(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
  'use strict'
  
  exports.byteLength = byteLength
  exports.toByteArray = toByteArray
  exports.fromByteArray = fromByteArray
  
  var lookup = []
  var revLookup = []
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array
  
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i]
    revLookup[code.charCodeAt(i)] = i
  }
  
  // Support decoding URL-safe base64 strings, as Node.js does.
  // See: https://en.wikipedia.org/wiki/Base64#URL_applications
  revLookup['-'.charCodeAt(0)] = 62
  revLookup['_'.charCodeAt(0)] = 63
  
  function getLens (b64) {
    var len = b64.length
  
    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4')
    }
  
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=')
    if (validLen === -1) validLen = len
  
    var placeHoldersLen = validLen === len
      ? 0
      : 4 - (validLen % 4)
  
    return [validLen, placeHoldersLen]
  }
  
  // base64 is 4/3 + up to two characters of the original data
  function byteLength (b64) {
    var lens = getLens(b64)
    var validLen = lens[0]
    var placeHoldersLen = lens[1]
    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
  }
  
  function _byteLength (b64, validLen, placeHoldersLen) {
    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
  }
  
  function toByteArray (b64) {
    var tmp
    var lens = getLens(b64)
    var validLen = lens[0]
    var placeHoldersLen = lens[1]
  
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))
  
    var curByte = 0
  
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0
      ? validLen - 4
      : validLen
  
    var i
    for (i = 0; i < len; i += 4) {
      tmp =
        (revLookup[b64.charCodeAt(i)] << 18) |
        (revLookup[b64.charCodeAt(i + 1)] << 12) |
        (revLookup[b64.charCodeAt(i + 2)] << 6) |
        revLookup[b64.charCodeAt(i + 3)]
      arr[curByte++] = (tmp >> 16) & 0xFF
      arr[curByte++] = (tmp >> 8) & 0xFF
      arr[curByte++] = tmp & 0xFF
    }
  
    if (placeHoldersLen === 2) {
      tmp =
        (revLookup[b64.charCodeAt(i)] << 2) |
        (revLookup[b64.charCodeAt(i + 1)] >> 4)
      arr[curByte++] = tmp & 0xFF
    }
  
    if (placeHoldersLen === 1) {
      tmp =
        (revLookup[b64.charCodeAt(i)] << 10) |
        (revLookup[b64.charCodeAt(i + 1)] << 4) |
        (revLookup[b64.charCodeAt(i + 2)] >> 2)
      arr[curByte++] = (tmp >> 8) & 0xFF
      arr[curByte++] = tmp & 0xFF
    }
  
    return arr
  }
  
  function tripletToBase64 (num) {
    return lookup[num >> 18 & 0x3F] +
      lookup[num >> 12 & 0x3F] +
      lookup[num >> 6 & 0x3F] +
      lookup[num & 0x3F]
  }
  
  function encodeChunk (uint8, start, end) {
    var tmp
    var output = []
    for (var i = start; i < end; i += 3) {
      tmp =
        ((uint8[i] << 16) & 0xFF0000) +
        ((uint8[i + 1] << 8) & 0xFF00) +
        (uint8[i + 2] & 0xFF)
      output.push(tripletToBase64(tmp))
    }
    return output.join('')
  }
  
  function fromByteArray (uint8) {
    var tmp
    var len = uint8.length
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    var parts = []
    var maxChunkLength = 16383 // must be multiple of 3
  
    // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(
        uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
      ))
    }
  
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
      tmp = uint8[len - 1]
      parts.push(
        lookup[tmp >> 2] +
        lookup[(tmp << 4) & 0x3F] +
        '=='
      )
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1]
      parts.push(
        lookup[tmp >> 10] +
        lookup[(tmp >> 4) & 0x3F] +
        lookup[(tmp << 2) & 0x3F] +
        '='
      )
    }
  
    return parts.join('')
  }
  
  },{}],2:[function(require,module,exports){
  
  },{}],3:[function(require,module,exports){
  (function (Buffer){
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /* eslint-disable no-proto */
  
  'use strict'
  
  var base64 = require('base64-js')
  var ieee754 = require('ieee754')
  var customInspectSymbol =
    (typeof Symbol === 'function' && typeof Symbol.for === 'function')
      ? Symbol.for('nodejs.util.inspect.custom')
      : null
  
  exports.Buffer = Buffer
  exports.SlowBuffer = SlowBuffer
  exports.INSPECT_MAX_BYTES = 50
  
  var K_MAX_LENGTH = 0x7fffffff
  exports.kMaxLength = K_MAX_LENGTH
  
  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Print warning and recommend using `buffer` v4.x which has an Object
   *               implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * We report that the browser does not support typed arrays if the are not subclassable
   * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
   * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
   * for __proto__ and has a buggy typed array implementation.
   */
  Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()
  
  if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
      typeof console.error === 'function') {
    console.error(
      'This browser lacks typed array (Uint8Array) support which is required by ' +
      '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
    )
  }
  
  function typedArraySupport () {
    // Can typed array instances can be augmented?
    try {
      var arr = new Uint8Array(1)
      var proto = { foo: function () { return 42 } }
      Object.setPrototypeOf(proto, Uint8Array.prototype)
      Object.setPrototypeOf(arr, proto)
      return arr.foo() === 42
    } catch (e) {
      return false
    }
  }
  
  Object.defineProperty(Buffer.prototype, 'parent', {
    enumerable: true,
    get: function () {
      if (!Buffer.isBuffer(this)) return undefined
      return this.buffer
    }
  })
  
  Object.defineProperty(Buffer.prototype, 'offset', {
    enumerable: true,
    get: function () {
      if (!Buffer.isBuffer(this)) return undefined
      return this.byteOffset
    }
  })
  
  function createBuffer (length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"')
    }
    // Return an augmented `Uint8Array` instance
    var buf = new Uint8Array(length)
    Object.setPrototypeOf(buf, Buffer.prototype)
    return buf
  }
  
  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */
  
  function Buffer (arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        )
      }
      return allocUnsafe(arg)
    }
    return from(arg, encodingOrOffset, length)
  }
  
  // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
  if (typeof Symbol !== 'undefined' && Symbol.species != null &&
      Buffer[Symbol.species] === Buffer) {
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true,
      enumerable: false,
      writable: false
    })
  }
  
  Buffer.poolSize = 8192 // not used by this implementation
  
  function from (value, encodingOrOffset, length) {
    if (typeof value === 'string') {
      return fromString(value, encodingOrOffset)
    }
  
    if (ArrayBuffer.isView(value)) {
      return fromArrayLike(value)
    }
  
    if (value == null) {
      throw new TypeError(
        'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
        'or Array-like Object. Received type ' + (typeof value)
      )
    }
  
    if (isInstance(value, ArrayBuffer) ||
        (value && isInstance(value.buffer, ArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length)
    }
  
    if (typeof SharedArrayBuffer !== 'undefined' &&
        (isInstance(value, SharedArrayBuffer) ||
        (value && isInstance(value.buffer, SharedArrayBuffer)))) {
      return fromArrayBuffer(value, encodingOrOffset, length)
    }
  
    if (typeof value === 'number') {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      )
    }
  
    var valueOf = value.valueOf && value.valueOf()
    if (valueOf != null && valueOf !== value) {
      return Buffer.from(valueOf, encodingOrOffset, length)
    }
  
    var b = fromObject(value)
    if (b) return b
  
    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
        typeof value[Symbol.toPrimitive] === 'function') {
      return Buffer.from(
        value[Symbol.toPrimitive]('string'), encodingOrOffset, length
      )
    }
  
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }
  
  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/
  Buffer.from = function (value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length)
  }
  
  // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
  // https://github.com/feross/buffer/pull/148
  Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
  Object.setPrototypeOf(Buffer, Uint8Array)
  
  function assertSize (size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be of type number')
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"')
    }
  }
  
  function alloc (size, fill, encoding) {
    assertSize(size)
    if (size <= 0) {
      return createBuffer(size)
    }
    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpretted as a start offset.
      return typeof encoding === 'string'
        ? createBuffer(size).fill(fill, encoding)
        : createBuffer(size).fill(fill)
    }
    return createBuffer(size)
  }
  
  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/
  Buffer.alloc = function (size, fill, encoding) {
    return alloc(size, fill, encoding)
  }
  
  function allocUnsafe (size) {
    assertSize(size)
    return createBuffer(size < 0 ? 0 : checked(size) | 0)
  }
  
  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */
  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(size)
  }
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */
  Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(size)
  }
  
  function fromString (string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8'
    }
  
    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  
    var length = byteLength(string, encoding) | 0
    var buf = createBuffer(length)
  
    var actual = buf.write(string, encoding)
  
    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      buf = buf.slice(0, actual)
    }
  
    return buf
  }
  
  function fromArrayLike (array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0
    var buf = createBuffer(length)
    for (var i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255
    }
    return buf
  }
  
  function fromArrayBuffer (array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds')
    }
  
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds')
    }
  
    var buf
    if (byteOffset === undefined && length === undefined) {
      buf = new Uint8Array(array)
    } else if (length === undefined) {
      buf = new Uint8Array(array, byteOffset)
    } else {
      buf = new Uint8Array(array, byteOffset, length)
    }
  
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype)
  
    return buf
  }
  
  function fromObject (obj) {
    if (Buffer.isBuffer(obj)) {
      var len = checked(obj.length) | 0
      var buf = createBuffer(len)
  
      if (buf.length === 0) {
        return buf
      }
  
      obj.copy(buf, 0, 0, len)
      return buf
    }
  
    if (obj.length !== undefined) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }
  
    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }
  
  function checked (length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                           'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
    }
    return length | 0
  }
  
  function SlowBuffer (length) {
    if (+length != length) { // eslint-disable-line eqeqeq
      length = 0
    }
    return Buffer.alloc(+length)
  }
  
  Buffer.isBuffer = function isBuffer (b) {
    return b != null && b._isBuffer === true &&
      b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
  }
  
  Buffer.compare = function compare (a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      )
    }
  
    if (a === b) return 0
  
    var x = a.length
    var y = b.length
  
    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i]
        y = b[i]
        break
      }
    }
  
    if (x < y) return -1
    if (y < x) return 1
    return 0
  }
  
  Buffer.isEncoding = function isEncoding (encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true
      default:
        return false
    }
  }
  
  Buffer.concat = function concat (list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
  
    if (list.length === 0) {
      return Buffer.alloc(0)
    }
  
    var i
    if (length === undefined) {
      length = 0
      for (i = 0; i < list.length; ++i) {
        length += list[i].length
      }
    }
  
    var buffer = Buffer.allocUnsafe(length)
    var pos = 0
    for (i = 0; i < list.length; ++i) {
      var buf = list[i]
      if (isInstance(buf, Uint8Array)) {
        buf = Buffer.from(buf)
      }
      if (!Buffer.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }
      buf.copy(buffer, pos)
      pos += buf.length
    }
    return buffer
  }
  
  function byteLength (string, encoding) {
    if (Buffer.isBuffer(string)) {
      return string.length
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength
    }
    if (typeof string !== 'string') {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
        'Received type ' + typeof string
      )
    }
  
    var len = string.length
    var mustMatch = (arguments.length > 2 && arguments[2] === true)
    if (!mustMatch && len === 0) return 0
  
    // Use a for loop to avoid recursion
    var loweredCase = false
    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len
        case 'utf8':
        case 'utf-8':
          return utf8ToBytes(string).length
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2
        case 'hex':
          return len >>> 1
        case 'base64':
          return base64ToBytes(string).length
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
          }
          encoding = ('' + encoding).toLowerCase()
          loweredCase = true
      }
    }
  }
  Buffer.byteLength = byteLength
  
  function slowToString (encoding, start, end) {
    var loweredCase = false
  
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
  
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) {
      start = 0
    }
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) {
      return ''
    }
  
    if (end === undefined || end > this.length) {
      end = this.length
    }
  
    if (end <= 0) {
      return ''
    }
  
    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0
    start >>>= 0
  
    if (end <= start) {
      return ''
    }
  
    if (!encoding) encoding = 'utf8'
  
    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end)
  
        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end)
  
        case 'ascii':
          return asciiSlice(this, start, end)
  
        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end)
  
        case 'base64':
          return base64Slice(this, start, end)
  
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end)
  
        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = (encoding + '').toLowerCase()
          loweredCase = true
      }
    }
  }
  
  // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
  // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
  // reliably in a browserify context because there could be multiple different
  // copies of the 'buffer' package in use. This method works even for Buffer
  // instances that were created from another copy of the `buffer` package.
  // See: https://github.com/feross/buffer/issues/154
  Buffer.prototype._isBuffer = true
  
  function swap (b, n, m) {
    var i = b[n]
    b[n] = b[m]
    b[m] = i
  }
  
  Buffer.prototype.swap16 = function swap16 () {
    var len = this.length
    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits')
    }
    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1)
    }
    return this
  }
  
  Buffer.prototype.swap32 = function swap32 () {
    var len = this.length
    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits')
    }
    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3)
      swap(this, i + 1, i + 2)
    }
    return this
  }
  
  Buffer.prototype.swap64 = function swap64 () {
    var len = this.length
    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits')
    }
    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7)
      swap(this, i + 1, i + 6)
      swap(this, i + 2, i + 5)
      swap(this, i + 3, i + 4)
    }
    return this
  }
  
  Buffer.prototype.toString = function toString () {
    var length = this.length
    if (length === 0) return ''
    if (arguments.length === 0) return utf8Slice(this, 0, length)
    return slowToString.apply(this, arguments)
  }
  
  Buffer.prototype.toLocaleString = Buffer.prototype.toString
  
  Buffer.prototype.equals = function equals (b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
    if (this === b) return true
    return Buffer.compare(this, b) === 0
  }
  
  Buffer.prototype.inspect = function inspect () {
    var str = ''
    var max = exports.INSPECT_MAX_BYTES
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
    if (this.length > max) str += ' ... '
    return '<Buffer ' + str + '>'
  }
  if (customInspectSymbol) {
    Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
  }
  
  Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer.from(target, target.offset, target.byteLength)
    }
    if (!Buffer.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. ' +
        'Received type ' + (typeof target)
      )
    }
  
    if (start === undefined) {
      start = 0
    }
    if (end === undefined) {
      end = target ? target.length : 0
    }
    if (thisStart === undefined) {
      thisStart = 0
    }
    if (thisEnd === undefined) {
      thisEnd = this.length
    }
  
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index')
    }
  
    if (thisStart >= thisEnd && start >= end) {
      return 0
    }
    if (thisStart >= thisEnd) {
      return -1
    }
    if (start >= end) {
      return 1
    }
  
    start >>>= 0
    end >>>= 0
    thisStart >>>= 0
    thisEnd >>>= 0
  
    if (this === target) return 0
  
    var x = thisEnd - thisStart
    var y = end - start
    var len = Math.min(x, y)
  
    var thisCopy = this.slice(thisStart, thisEnd)
    var targetCopy = target.slice(start, end)
  
    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i]
        y = targetCopy[i]
        break
      }
    }
  
    if (x < y) return -1
    if (y < x) return 1
    return 0
  }
  
  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf
  function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1
  
    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
      encoding = byteOffset
      byteOffset = 0
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000
    }
    byteOffset = +byteOffset // Coerce to Number.
    if (numberIsNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : (buffer.length - 1)
    }
  
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset
    if (byteOffset >= buffer.length) {
      if (dir) return -1
      else byteOffset = buffer.length - 1
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0
      else return -1
    }
  
    // Normalize val
    if (typeof val === 'string') {
      val = Buffer.from(val, encoding)
    }
  
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
    } else if (typeof val === 'number') {
      val = val & 0xFF // Search for a byte value [0-255]
      if (typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
        }
      }
      return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
    }
  
    throw new TypeError('val must be string, number or Buffer')
  }
  
  function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
    var indexSize = 1
    var arrLength = arr.length
    var valLength = val.length
  
    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase()
      if (encoding === 'ucs2' || encoding === 'ucs-2' ||
          encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1
        }
        indexSize = 2
        arrLength /= 2
        valLength /= 2
        byteOffset /= 2
      }
    }
  
    function read (buf, i) {
      if (indexSize === 1) {
        return buf[i]
      } else {
        return buf.readUInt16BE(i * indexSize)
      }
    }
  
    var i
    if (dir) {
      var foundIndex = -1
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
        } else {
          if (foundIndex !== -1) i -= i - foundIndex
          foundIndex = -1
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
      for (i = byteOffset; i >= 0; i--) {
        var found = true
        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false
            break
          }
        }
        if (found) return i
      }
    }
  
    return -1
  }
  
  Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1
  }
  
  Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
  }
  
  Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
  }
  
  function hexWrite (buf, string, offset, length) {
    offset = Number(offset) || 0
    var remaining = buf.length - offset
    if (!length) {
      length = remaining
    } else {
      length = Number(length)
      if (length > remaining) {
        length = remaining
      }
    }
  
    var strLen = string.length
  
    if (length > strLen / 2) {
      length = strLen / 2
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16)
      if (numberIsNaN(parsed)) return i
      buf[offset + i] = parsed
    }
    return i
  }
  
  function utf8Write (buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
  }
  
  function asciiWrite (buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length)
  }
  
  function latin1Write (buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length)
  }
  
  function base64Write (buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length)
  }
  
  function ucs2Write (buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  }
  
  Buffer.prototype.write = function write (string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8'
      length = this.length
      offset = 0
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset
      length = this.length
      offset = 0
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset >>> 0
      if (isFinite(length)) {
        length = length >>> 0
        if (encoding === undefined) encoding = 'utf8'
      } else {
        encoding = length
        length = undefined
      }
    } else {
      throw new Error(
        'Buffer.write(string, encoding, offset[, length]) is no longer supported'
      )
    }
  
    var remaining = this.length - offset
    if (length === undefined || length > remaining) length = remaining
  
    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds')
    }
  
    if (!encoding) encoding = 'utf8'
  
    var loweredCase = false
    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length)
  
        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length)
  
        case 'ascii':
          return asciiWrite(this, string, offset, length)
  
        case 'latin1':
        case 'binary':
          return latin1Write(this, string, offset, length)
  
        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length)
  
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length)
  
        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = ('' + encoding).toLowerCase()
          loweredCase = true
      }
    }
  }
  
  Buffer.prototype.toJSON = function toJSON () {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    }
  }
  
  function base64Slice (buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf)
    } else {
      return base64.fromByteArray(buf.slice(start, end))
    }
  }
  
  function utf8Slice (buf, start, end) {
    end = Math.min(buf.length, end)
    var res = []
  
    var i = start
    while (i < end) {
      var firstByte = buf[i]
      var codePoint = null
      var bytesPerSequence = (firstByte > 0xEF) ? 4
        : (firstByte > 0xDF) ? 3
          : (firstByte > 0xBF) ? 2
            : 1
  
      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint
  
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte
            }
            break
          case 2:
            secondByte = buf[i + 1]
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint
              }
            }
            break
          case 3:
            secondByte = buf[i + 1]
            thirdByte = buf[i + 2]
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint
              }
            }
            break
          case 4:
            secondByte = buf[i + 1]
            thirdByte = buf[i + 2]
            fourthByte = buf[i + 3]
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint
              }
            }
        }
      }
  
      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD
        bytesPerSequence = 1
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000
        res.push(codePoint >>> 10 & 0x3FF | 0xD800)
        codePoint = 0xDC00 | codePoint & 0x3FF
      }
  
      res.push(codePoint)
      i += bytesPerSequence
    }
  
    return decodeCodePointsArray(res)
  }
  
  // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety
  var MAX_ARGUMENTS_LENGTH = 0x1000
  
  function decodeCodePointsArray (codePoints) {
    var len = codePoints.length
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    }
  
    // Decode in chunks to avoid "call stack size exceeded".
    var res = ''
    var i = 0
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      )
    }
    return res
  }
  
  function asciiSlice (buf, start, end) {
    var ret = ''
    end = Math.min(buf.length, end)
  
    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F)
    }
    return ret
  }
  
  function latin1Slice (buf, start, end) {
    var ret = ''
    end = Math.min(buf.length, end)
  
    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i])
    }
    return ret
  }
  
  function hexSlice (buf, start, end) {
    var len = buf.length
  
    if (!start || start < 0) start = 0
    if (!end || end < 0 || end > len) end = len
  
    var out = ''
    for (var i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]]
    }
    return out
  }
  
  function utf16leSlice (buf, start, end) {
    var bytes = buf.slice(start, end)
    var res = ''
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
    }
    return res
  }
  
  Buffer.prototype.slice = function slice (start, end) {
    var len = this.length
    start = ~~start
    end = end === undefined ? len : ~~end
  
    if (start < 0) {
      start += len
      if (start < 0) start = 0
    } else if (start > len) {
      start = len
    }
  
    if (end < 0) {
      end += len
      if (end < 0) end = 0
    } else if (end > len) {
      end = len
    }
  
    if (end < start) end = start
  
    var newBuf = this.subarray(start, end)
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype)
  
    return newBuf
  }
  
  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */
  function checkOffset (offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
  }
  
  Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
    offset = offset >>> 0
    byteLength = byteLength >>> 0
    if (!noAssert) checkOffset(offset, byteLength, this.length)
  
    var val = this[offset]
    var mul = 1
    var i = 0
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul
    }
  
    return val
  }
  
  Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
    offset = offset >>> 0
    byteLength = byteLength >>> 0
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length)
    }
  
    var val = this[offset + --byteLength]
    var mul = 1
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul
    }
  
    return val
  }
  
  Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 1, this.length)
    return this[offset]
  }
  
  Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 2, this.length)
    return this[offset] | (this[offset + 1] << 8)
  }
  
  Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 2, this.length)
    return (this[offset] << 8) | this[offset + 1]
  }
  
  Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 4, this.length)
  
    return ((this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16)) +
        (this[offset + 3] * 0x1000000)
  }
  
  Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 4, this.length)
  
    return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
  }
  
  Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
    offset = offset >>> 0
    byteLength = byteLength >>> 0
    if (!noAssert) checkOffset(offset, byteLength, this.length)
  
    var val = this[offset]
    var mul = 1
    var i = 0
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul
    }
    mul *= 0x80
  
    if (val >= mul) val -= Math.pow(2, 8 * byteLength)
  
    return val
  }
  
  Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
    offset = offset >>> 0
    byteLength = byteLength >>> 0
    if (!noAssert) checkOffset(offset, byteLength, this.length)
  
    var i = byteLength
    var mul = 1
    var val = this[offset + --i]
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul
    }
    mul *= 0x80
  
    if (val >= mul) val -= Math.pow(2, 8 * byteLength)
  
    return val
  }
  
  Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 1, this.length)
    if (!(this[offset] & 0x80)) return (this[offset])
    return ((0xff - this[offset] + 1) * -1)
  }
  
  Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 2, this.length)
    var val = this[offset] | (this[offset + 1] << 8)
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  }
  
  Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 2, this.length)
    var val = this[offset + 1] | (this[offset] << 8)
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  }
  
  Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 4, this.length)
  
    return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
  }
  
  Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 4, this.length)
  
    return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
  }
  
  Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 4, this.length)
    return ieee754.read(this, offset, true, 23, 4)
  }
  
  Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 4, this.length)
    return ieee754.read(this, offset, false, 23, 4)
  }
  
  Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 8, this.length)
    return ieee754.read(this, offset, true, 52, 8)
  }
  
  Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
    offset = offset >>> 0
    if (!noAssert) checkOffset(offset, 8, this.length)
    return ieee754.read(this, offset, false, 52, 8)
  }
  
  function checkInt (buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
  }
  
  Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
    value = +value
    offset = offset >>> 0
    byteLength = byteLength >>> 0
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1
      checkInt(this, value, offset, byteLength, maxBytes, 0)
    }
  
    var mul = 1
    var i = 0
    this[offset] = value & 0xFF
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF
    }
  
    return offset + byteLength
  }
  
  Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
    value = +value
    offset = offset >>> 0
    byteLength = byteLength >>> 0
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1
      checkInt(this, value, offset, byteLength, maxBytes, 0)
    }
  
    var i = byteLength - 1
    var mul = 1
    this[offset + i] = value & 0xFF
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF
    }
  
    return offset + byteLength
  }
  
  Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
    this[offset] = (value & 0xff)
    return offset + 1
  }
  
  Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    return offset + 2
  }
  
  Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
    return offset + 2
  }
  
  Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
    return offset + 4
  }
  
  Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
    return offset + 4
  }
  
  Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) {
      var limit = Math.pow(2, (8 * byteLength) - 1)
  
      checkInt(this, value, offset, byteLength, limit - 1, -limit)
    }
  
    var i = 0
    var mul = 1
    var sub = 0
    this[offset] = value & 0xFF
    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
    }
  
    return offset + byteLength
  }
  
  Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) {
      var limit = Math.pow(2, (8 * byteLength) - 1)
  
      checkInt(this, value, offset, byteLength, limit - 1, -limit)
    }
  
    var i = byteLength - 1
    var mul = 1
    var sub = 0
    this[offset + i] = value & 0xFF
    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
    }
  
    return offset + byteLength
  }
  
  Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
    if (value < 0) value = 0xff + value + 1
    this[offset] = (value & 0xff)
    return offset + 1
  }
  
  Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    return offset + 2
  }
  
  Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
    return offset + 2
  }
  
  Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
    return offset + 4
  }
  
  Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
    if (value < 0) value = 0xffffffff + value + 1
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
    return offset + 4
  }
  
  function checkIEEE754 (buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
    if (offset < 0) throw new RangeError('Index out of range')
  }
  
  function writeFloat (buf, value, offset, littleEndian, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4)
    return offset + 4
  }
  
  Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert)
  }
  
  Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert)
  }
  
  function writeDouble (buf, value, offset, littleEndian, noAssert) {
    value = +value
    offset = offset >>> 0
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8)
    return offset + 8
  }
  
  Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert)
  }
  
  Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert)
  }
  
  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  Buffer.prototype.copy = function copy (target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
    if (!start) start = 0
    if (!end && end !== 0) end = this.length
    if (targetStart >= target.length) targetStart = target.length
    if (!targetStart) targetStart = 0
    if (end > 0 && end < start) end = start
  
    // Copy 0 bytes; we're done
    if (end === start) return 0
    if (target.length === 0 || this.length === 0) return 0
  
    // Fatal error conditions
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds')
    }
    if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
    if (end < 0) throw new RangeError('sourceEnd out of bounds')
  
    // Are we oob?
    if (end > this.length) end = this.length
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start
    }
  
    var len = end - start
  
    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
      // Use built-in when available, missing from IE11
      this.copyWithin(targetStart, start, end)
    } else if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (var i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start]
      }
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, end),
        targetStart
      )
    }
  
    return len
  }
  
  // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])
  Buffer.prototype.fill = function fill (val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start
        start = 0
        end = this.length
      } else if (typeof end === 'string') {
        encoding = end
        end = this.length
      }
      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string')
      }
      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding)
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0)
        if ((encoding === 'utf8' && code < 128) ||
            encoding === 'latin1') {
          // Fast path: If `val` fits into a single byte, use that numeric value.
          val = code
        }
      }
    } else if (typeof val === 'number') {
      val = val & 255
    } else if (typeof val === 'boolean') {
      val = Number(val)
    }
  
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index')
    }
  
    if (end <= start) {
      return this
    }
  
    start = start >>> 0
    end = end === undefined ? this.length : end >>> 0
  
    if (!val) val = 0
  
    var i
    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val
      }
    } else {
      var bytes = Buffer.isBuffer(val)
        ? val
        : Buffer.from(val, encoding)
      var len = bytes.length
      if (len === 0) {
        throw new TypeError('The value "' + val +
          '" is invalid for argument "value"')
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len]
      }
    }
  
    return this
  }
  
  // HELPER FUNCTIONS
  // ================
  
  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g
  
  function base64clean (str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split('=')[0]
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, '')
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return ''
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while (str.length % 4 !== 0) {
      str = str + '='
    }
    return str
  }
  
  function utf8ToBytes (string, units) {
    units = units || Infinity
    var codePoint
    var length = string.length
    var leadSurrogate = null
    var bytes = []
  
    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i)
  
      // is surrogate component
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
            continue
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
            continue
          }
  
          // valid lead
          leadSurrogate = codePoint
  
          continue
        }
  
        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          leadSurrogate = codePoint
          continue
        }
  
        // valid surrogate pair
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
      }
  
      leadSurrogate = null
  
      // encode utf8
      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break
        bytes.push(codePoint)
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break
        bytes.push(
          codePoint >> 0x6 | 0xC0,
          codePoint & 0x3F | 0x80
        )
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break
        bytes.push(
          codePoint >> 0xC | 0xE0,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        )
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break
        bytes.push(
          codePoint >> 0x12 | 0xF0,
          codePoint >> 0xC & 0x3F | 0x80,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        )
      } else {
        throw new Error('Invalid code point')
      }
    }
  
    return bytes
  }
  
  function asciiToBytes (str) {
    var byteArray = []
    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF)
    }
    return byteArray
  }
  
  function utf16leToBytes (str, units) {
    var c, hi, lo
    var byteArray = []
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break
  
      c = str.charCodeAt(i)
      hi = c >> 8
      lo = c % 256
      byteArray.push(lo)
      byteArray.push(hi)
    }
  
    return byteArray
  }
  
  function base64ToBytes (str) {
    return base64.toByteArray(base64clean(str))
  }
  
  function blitBuffer (src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if ((i + offset >= dst.length) || (i >= src.length)) break
      dst[i + offset] = src[i]
    }
    return i
  }
  
  // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
  // the `instanceof` check but they should be treated as of that type.
  // See: https://github.com/feross/buffer/issues/166
  function isInstance (obj, type) {
    return obj instanceof type ||
      (obj != null && obj.constructor != null && obj.constructor.name != null &&
        obj.constructor.name === type.name)
  }
  function numberIsNaN (obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
  }
  
  // Create lookup table for `toString('hex')`
  // See: https://github.com/feross/buffer/issues/219
  var hexSliceLookupTable = (function () {
    var alphabet = '0123456789abcdef'
    var table = new Array(256)
    for (var i = 0; i < 16; ++i) {
      var i16 = i * 16
      for (var j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet[i] + alphabet[j]
      }
    }
    return table
  })()
  
  }).call(this,require("buffer").Buffer)
  },{"base64-js":1,"buffer":3,"ieee754":6}],4:[function(require,module,exports){
  (function (Buffer){
  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.
  
  // NOTE: These type checking functions intentionally don't use `instanceof`
  // because it is fragile and can be easily faked with `Object.create()`.
  
  function isArray(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString(arg) === '[object Array]';
  }
  exports.isArray = isArray;
  
  function isBoolean(arg) {
    return typeof arg === 'boolean';
  }
  exports.isBoolean = isBoolean;
  
  function isNull(arg) {
    return arg === null;
  }
  exports.isNull = isNull;
  
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  exports.isNullOrUndefined = isNullOrUndefined;
  
  function isNumber(arg) {
    return typeof arg === 'number';
  }
  exports.isNumber = isNumber;
  
  function isString(arg) {
    return typeof arg === 'string';
  }
  exports.isString = isString;
  
  function isSymbol(arg) {
    return typeof arg === 'symbol';
  }
  exports.isSymbol = isSymbol;
  
  function isUndefined(arg) {
    return arg === void 0;
  }
  exports.isUndefined = isUndefined;
  
  function isRegExp(re) {
    return objectToString(re) === '[object RegExp]';
  }
  exports.isRegExp = isRegExp;
  
  function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
  }
  exports.isObject = isObject;
  
  function isDate(d) {
    return objectToString(d) === '[object Date]';
  }
  exports.isDate = isDate;
  
  function isError(e) {
    return (objectToString(e) === '[object Error]' || e instanceof Error);
  }
  exports.isError = isError;
  
  function isFunction(arg) {
    return typeof arg === 'function';
  }
  exports.isFunction = isFunction;
  
  function isPrimitive(arg) {
    return arg === null ||
           typeof arg === 'boolean' ||
           typeof arg === 'number' ||
           typeof arg === 'string' ||
           typeof arg === 'symbol' ||  // ES6 symbol
           typeof arg === 'undefined';
  }
  exports.isPrimitive = isPrimitive;
  
  exports.isBuffer = Buffer.isBuffer;
  
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
  
  }).call(this,{"isBuffer":require("../../is-buffer/index.js")})
  },{"../../is-buffer/index.js":8}],5:[function(require,module,exports){
  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.
  
  var objectCreate = Object.create || objectCreatePolyfill
  var objectKeys = Object.keys || objectKeysPolyfill
  var bind = Function.prototype.bind || functionBindPolyfill
  
  function EventEmitter() {
    if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
      this._events = objectCreate(null);
      this._eventsCount = 0;
    }
  
    this._maxListeners = this._maxListeners || undefined;
  }
  module.exports = EventEmitter;
  
  // Backwards-compat with node 0.10.x
  EventEmitter.EventEmitter = EventEmitter;
  
  EventEmitter.prototype._events = undefined;
  EventEmitter.prototype._maxListeners = undefined;
  
  // By default EventEmitters will print a warning if more than 10 listeners are
  // added to it. This is a useful default which helps finding memory leaks.
  var defaultMaxListeners = 10;
  
  var hasDefineProperty;
  try {
    var o = {};
    if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
    hasDefineProperty = o.x === 0;
  } catch (err) { hasDefineProperty = false }
  if (hasDefineProperty) {
    Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        // check whether the input is a positive number (whose value is zero or
        // greater and not a NaN).
        if (typeof arg !== 'number' || arg < 0 || arg !== arg)
          throw new TypeError('"defaultMaxListeners" must be a positive number');
        defaultMaxListeners = arg;
      }
    });
  } else {
    EventEmitter.defaultMaxListeners = defaultMaxListeners;
  }
  
  // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.
  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== 'number' || n < 0 || isNaN(n))
      throw new TypeError('"n" argument must be a positive number');
    this._maxListeners = n;
    return this;
  };
  
  function $getMaxListeners(that) {
    if (that._maxListeners === undefined)
      return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
  }
  
  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return $getMaxListeners(this);
  };
  
  // These standalone emit* functions are used to optimize calling of event
  // handlers for fast cases because emit() itself often has a variable number of
  // arguments and can be deoptimized because of that. These functions always have
  // the same number of arguments and thus do not get deoptimized, so the code
  // inside them can execute faster.
  function emitNone(handler, isFn, self) {
    if (isFn)
      handler.call(self);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].call(self);
    }
  }
  function emitOne(handler, isFn, self, arg1) {
    if (isFn)
      handler.call(self, arg1);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].call(self, arg1);
    }
  }
  function emitTwo(handler, isFn, self, arg1, arg2) {
    if (isFn)
      handler.call(self, arg1, arg2);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].call(self, arg1, arg2);
    }
  }
  function emitThree(handler, isFn, self, arg1, arg2, arg3) {
    if (isFn)
      handler.call(self, arg1, arg2, arg3);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].call(self, arg1, arg2, arg3);
    }
  }
  
  function emitMany(handler, isFn, self, args) {
    if (isFn)
      handler.apply(self, args);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].apply(self, args);
    }
  }
  
  EventEmitter.prototype.emit = function emit(type) {
    var er, handler, len, args, i, events;
    var doError = (type === 'error');
  
    events = this._events;
    if (events)
      doError = (doError && events.error == null);
    else if (!doError)
      return false;
  
    // If there is no 'error' event listener then throw.
    if (doError) {
      if (arguments.length > 1)
        er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Unhandled "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
      return false;
    }
  
    handler = events[type];
  
    if (!handler)
      return false;
  
    var isFn = typeof handler === 'function';
    len = arguments.length;
    switch (len) {
        // fast cases
      case 1:
        emitNone(handler, isFn, this);
        break;
      case 2:
        emitOne(handler, isFn, this, arguments[1]);
        break;
      case 3:
        emitTwo(handler, isFn, this, arguments[1], arguments[2]);
        break;
      case 4:
        emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
        break;
        // slower
      default:
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        emitMany(handler, isFn, this, args);
    }
  
    return true;
  };
  
  function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;
  
    if (typeof listener !== 'function')
      throw new TypeError('"listener" argument must be a function');
  
    events = target._events;
    if (!events) {
      events = target._events = objectCreate(null);
      target._eventsCount = 0;
    } else {
      // To avoid recursion in the case that type === "newListener"! Before
      // adding it to the listeners, first emit "newListener".
      if (events.newListener) {
        target.emit('newListener', type,
            listener.listener ? listener.listener : listener);
  
        // Re-assign `events` because a newListener handler could have caused the
        // this._events to be assigned to a new object
        events = target._events;
      }
      existing = events[type];
    }
  
    if (!existing) {
      // Optimize the case of one listener. Don't need the extra array object.
      existing = events[type] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === 'function') {
        // Adding the second element, need to change to array.
        existing = events[type] =
            prepend ? [listener, existing] : [existing, listener];
      } else {
        // If we've already got an array, just append.
        if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
      }
  
      // Check for listener leak
      if (!existing.warned) {
        m = $getMaxListeners(target);
        if (m && m > 0 && existing.length > m) {
          existing.warned = true;
          var w = new Error('Possible EventEmitter memory leak detected. ' +
              existing.length + ' "' + String(type) + '" listeners ' +
              'added. Use emitter.setMaxListeners() to ' +
              'increase limit.');
          w.name = 'MaxListenersExceededWarning';
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          if (typeof console === 'object' && console.warn) {
            console.warn('%s: %s', w.name, w.message);
          }
        }
      }
    }
  
    return target;
  }
  
  EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
  };
  
  EventEmitter.prototype.on = EventEmitter.prototype.addListener;
  
  EventEmitter.prototype.prependListener =
      function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };
  
  function onceWrapper() {
    if (!this.fired) {
      this.target.removeListener(this.type, this.wrapFn);
      this.fired = true;
      switch (arguments.length) {
        case 0:
          return this.listener.call(this.target);
        case 1:
          return this.listener.call(this.target, arguments[0]);
        case 2:
          return this.listener.call(this.target, arguments[0], arguments[1]);
        case 3:
          return this.listener.call(this.target, arguments[0], arguments[1],
              arguments[2]);
        default:
          var args = new Array(arguments.length);
          for (var i = 0; i < args.length; ++i)
            args[i] = arguments[i];
          this.listener.apply(this.target, args);
      }
    }
  }
  
  function _onceWrap(target, type, listener) {
    var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
    var wrapped = bind.call(onceWrapper, state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
  }
  
  EventEmitter.prototype.once = function once(type, listener) {
    if (typeof listener !== 'function')
      throw new TypeError('"listener" argument must be a function');
    this.on(type, _onceWrap(this, type, listener));
    return this;
  };
  
  EventEmitter.prototype.prependOnceListener =
      function prependOnceListener(type, listener) {
        if (typeof listener !== 'function')
          throw new TypeError('"listener" argument must be a function');
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };
  
  // Emits a 'removeListener' event if and only if the listener was removed.
  EventEmitter.prototype.removeListener =
      function removeListener(type, listener) {
        var list, events, position, i, originalListener;
  
        if (typeof listener !== 'function')
          throw new TypeError('"listener" argument must be a function');
  
        events = this._events;
        if (!events)
          return this;
  
        list = events[type];
        if (!list)
          return this;
  
        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else {
            delete events[type];
            if (events.removeListener)
              this.emit('removeListener', type, list.listener || listener);
          }
        } else if (typeof list !== 'function') {
          position = -1;
  
          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }
  
          if (position < 0)
            return this;
  
          if (position === 0)
            list.shift();
          else
            spliceOne(list, position);
  
          if (list.length === 1)
            events[type] = list[0];
  
          if (events.removeListener)
            this.emit('removeListener', type, originalListener || listener);
        }
  
        return this;
      };
  
  EventEmitter.prototype.removeAllListeners =
      function removeAllListeners(type) {
        var listeners, events, i;
  
        events = this._events;
        if (!events)
          return this;
  
        // not listening for removeListener, no need to emit
        if (!events.removeListener) {
          if (arguments.length === 0) {
            this._events = objectCreate(null);
            this._eventsCount = 0;
          } else if (events[type]) {
            if (--this._eventsCount === 0)
              this._events = objectCreate(null);
            else
              delete events[type];
          }
          return this;
        }
  
        // emit removeListener for all listeners on all events
        if (arguments.length === 0) {
          var keys = objectKeys(events);
          var key;
          for (i = 0; i < keys.length; ++i) {
            key = keys[i];
            if (key === 'removeListener') continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners('removeListener');
          this._events = objectCreate(null);
          this._eventsCount = 0;
          return this;
        }
  
        listeners = events[type];
  
        if (typeof listeners === 'function') {
          this.removeListener(type, listeners);
        } else if (listeners) {
          // LIFO order
          for (i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(type, listeners[i]);
          }
        }
  
        return this;
      };
  
  function _listeners(target, type, unwrap) {
    var events = target._events;
  
    if (!events)
      return [];
  
    var evlistener = events[type];
    if (!evlistener)
      return [];
  
    if (typeof evlistener === 'function')
      return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
  }
  
  EventEmitter.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
  };
  
  EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
  };
  
  EventEmitter.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === 'function') {
      return emitter.listenerCount(type);
    } else {
      return listenerCount.call(emitter, type);
    }
  };
  
  EventEmitter.prototype.listenerCount = listenerCount;
  function listenerCount(type) {
    var events = this._events;
  
    if (events) {
      var evlistener = events[type];
  
      if (typeof evlistener === 'function') {
        return 1;
      } else if (evlistener) {
        return evlistener.length;
      }
    }
  
    return 0;
  }
  
  EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
  };
  
  // About 1.5x faster than the two-arg version of Array#splice().
  function spliceOne(list, index) {
    for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
      list[i] = list[k];
    list.pop();
  }
  
  function arrayClone(arr, n) {
    var copy = new Array(n);
    for (var i = 0; i < n; ++i)
      copy[i] = arr[i];
    return copy;
  }
  
  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i = 0; i < ret.length; ++i) {
      ret[i] = arr[i].listener || arr[i];
    }
    return ret;
  }
  
  function objectCreatePolyfill(proto) {
    var F = function() {};
    F.prototype = proto;
    return new F;
  }
  function objectKeysPolyfill(obj) {
    var keys = [];
    for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
      keys.push(k);
    }
    return k;
  }
  function functionBindPolyfill(context) {
    var fn = this;
    return function () {
      return fn.apply(context, arguments);
    };
  }
  
  },{}],6:[function(require,module,exports){
  exports.read = function (buffer, offset, isLE, mLen, nBytes) {
    var e, m
    var eLen = (nBytes * 8) - mLen - 1
    var eMax = (1 << eLen) - 1
    var eBias = eMax >> 1
    var nBits = -7
    var i = isLE ? (nBytes - 1) : 0
    var d = isLE ? -1 : 1
    var s = buffer[offset + i]
  
    i += d
  
    e = s & ((1 << (-nBits)) - 1)
    s >>= (-nBits)
    nBits += eLen
    for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}
  
    m = e & ((1 << (-nBits)) - 1)
    e >>= (-nBits)
    nBits += mLen
    for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}
  
    if (e === 0) {
      e = 1 - eBias
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity)
    } else {
      m = m + Math.pow(2, mLen)
      e = e - eBias
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
  }
  
  exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c
    var eLen = (nBytes * 8) - mLen - 1
    var eMax = (1 << eLen) - 1
    var eBias = eMax >> 1
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
    var i = isLE ? 0 : (nBytes - 1)
    var d = isLE ? 1 : -1
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
  
    value = Math.abs(value)
  
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0
      e = eMax
    } else {
      e = Math.floor(Math.log(value) / Math.LN2)
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--
        c *= 2
      }
      if (e + eBias >= 1) {
        value += rt / c
      } else {
        value += rt * Math.pow(2, 1 - eBias)
      }
      if (value * c >= 2) {
        e++
        c /= 2
      }
  
      if (e + eBias >= eMax) {
        m = 0
        e = eMax
      } else if (e + eBias >= 1) {
        m = ((value * c) - 1) * Math.pow(2, mLen)
        e = e + eBias
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
        e = 0
      }
    }
  
    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
  
    e = (e << mLen) | m
    eLen += mLen
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
  
    buffer[offset + i - d] |= s * 128
  }
  
  },{}],7:[function(require,module,exports){
  if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        })
      }
    };
  } else {
    // old school shim for old browsers
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor
        var TempCtor = function () {}
        TempCtor.prototype = superCtor.prototype
        ctor.prototype = new TempCtor()
        ctor.prototype.constructor = ctor
      }
    }
  }
  
  },{}],8:[function(require,module,exports){
  /*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  
  // The _isBuffer check is for Safari 5-7 support, because it's missing
  // Object.prototype.constructor. Remove this eventually
  module.exports = function (obj) {
    return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
  }
  
  function isBuffer (obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
  }
  
  // For Node v0.10 support. Remove this eventually.
  function isSlowBuffer (obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
  }
  
  },{}],9:[function(require,module,exports){
  var toString = {}.toString;
  
  module.exports = Array.isArray || function (arr) {
    return toString.call(arr) == '[object Array]';
  };
  
  },{}],10:[function(require,module,exports){
  (function (process){
  'use strict';
  
  if (typeof process === 'undefined' ||
      !process.version ||
      process.version.indexOf('v0.') === 0 ||
      process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
    module.exports = { nextTick: nextTick };
  } else {
    module.exports = process
  }
  
  function nextTick(fn, arg1, arg2, arg3) {
    if (typeof fn !== 'function') {
      throw new TypeError('"callback" argument must be a function');
    }
    var len = arguments.length;
    var args, i;
    switch (len) {
    case 0:
    case 1:
      return process.nextTick(fn);
    case 2:
      return process.nextTick(function afterTickOne() {
        fn.call(null, arg1);
      });
    case 3:
      return process.nextTick(function afterTickTwo() {
        fn.call(null, arg1, arg2);
      });
    case 4:
      return process.nextTick(function afterTickThree() {
        fn.call(null, arg1, arg2, arg3);
      });
    default:
      args = new Array(len - 1);
      i = 0;
      while (i < args.length) {
        args[i++] = arguments[i];
      }
      return process.nextTick(function afterTick() {
        fn.apply(null, args);
      });
    }
  }
  
  
  }).call(this,require('_process'))
  },{"_process":11}],11:[function(require,module,exports){
  // shim for using process in browser
  var process = module.exports = {};
  
  // cached from whatever global is present so that test runners that stub it
  // don't break things.  But we need to wrap it in a try catch in case it is
  // wrapped in strict mode code which doesn't define any globals.  It's inside a
  // function because try/catches deoptimize in certain engines.
  
  var cachedSetTimeout;
  var cachedClearTimeout;
  
  function defaultSetTimout() {
      throw new Error('setTimeout has not been defined');
  }
  function defaultClearTimeout () {
      throw new Error('clearTimeout has not been defined');
  }
  (function () {
      try {
          if (typeof setTimeout === 'function') {
              cachedSetTimeout = setTimeout;
          } else {
              cachedSetTimeout = defaultSetTimout;
          }
      } catch (e) {
          cachedSetTimeout = defaultSetTimout;
      }
      try {
          if (typeof clearTimeout === 'function') {
              cachedClearTimeout = clearTimeout;
          } else {
              cachedClearTimeout = defaultClearTimeout;
          }
      } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
      }
  } ())
  function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
      }
      // if setTimeout wasn't available but was latter defined
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
      } catch(e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0);
          } catch(e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0);
          }
      }
  
  
  }
  function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
      }
      // if clearTimeout wasn't available but was latter defined
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
      } catch (e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker);
          } catch (e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker);
          }
      }
  
  
  
  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  
  function cleanUpNextTick() {
      if (!draining || !currentQueue) {
          return;
      }
      draining = false;
      if (currentQueue.length) {
          queue = currentQueue.concat(queue);
      } else {
          queueIndex = -1;
      }
      if (queue.length) {
          drainQueue();
      }
  }
  
  function drainQueue() {
      if (draining) {
          return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
  
      var len = queue.length;
      while(len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
              if (currentQueue) {
                  currentQueue[queueIndex].run();
              }
          }
          queueIndex = -1;
          len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
  }
  
  process.nextTick = function (fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
          }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
      }
  };
  
  // v8 likes predictible objects
  function Item(fun, array) {
      this.fun = fun;
      this.array = array;
  }
  Item.prototype.run = function () {
      this.fun.apply(null, this.array);
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = ''; // empty string to avoid regexp issues
  process.versions = {};
  
  function noop() {}
  
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.prependListener = noop;
  process.prependOnceListener = noop;
  
  process.listeners = function (name) { return [] }
  
  process.binding = function (name) {
      throw new Error('process.binding is not supported');
  };
  
  process.cwd = function () { return '/' };
  process.chdir = function (dir) {
      throw new Error('process.chdir is not supported');
  };
  process.umask = function() { return 0; };
  
  },{}],12:[function(require,module,exports){
  module.exports = require('./lib/_stream_duplex.js');
  
  },{"./lib/_stream_duplex.js":13}],13:[function(require,module,exports){
  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.
  
  // a duplex stream is just a stream that is both readable and writable.
  // Since JS doesn't have multiple prototypal inheritance, this class
  // prototypally inherits from Readable, and then parasitically from
  // Writable.
  
  'use strict';
  
  /*<replacement>*/
  
  var pna = require('process-nextick-args');
  /*</replacement>*/
  
  /*<replacement>*/
  var objectKeys = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) {
      keys.push(key);
    }return keys;
  };
  /*</replacement>*/
  
  module.exports = Duplex;
  
  /*<replacement>*/
  var util = Object.create(require('core-util-is'));
  util.inherits = require('inherits');
  /*</replacement>*/
  
  var Readable = require('./_stream_readable');
  var Writable = require('./_stream_writable');
  
  util.inherits(Duplex, Readable);
  
  {
    // avoid scope creep, the keys array can then be collected
    var keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method = keys[v];
      if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
  
    Readable.call(this, options);
    Writable.call(this, options);
  
    if (options && options.readable === false) this.readable = false;
  
    if (options && options.writable === false) this.writable = false;
  
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
  
    this.once('end', onend);
  }
  
  Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function () {
      return this._writableState.highWaterMark;
    }
  });
  
  // the no-half-open enforcer
  function onend() {
    // if we allow half-open state, or if the writable side ended,
    // then we're ok.
    if (this.allowHalfOpen || this._writableState.ended) return;
  
    // no more data can be written.
    // But allow more writes to happen in this tick.
    pna.nextTick(onEndNT, this);
  }
  
  function onEndNT(self) {
    self.end();
  }
  
  Object.defineProperty(Duplex.prototype, 'destroyed', {
    get: function () {
      if (this._readableState === undefined || this._writableState === undefined) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function (value) {
      // we ignore the value if the stream
      // has not been initialized yet
      if (this._readableState === undefined || this._writableState === undefined) {
        return;
      }
  
      // backward compatibility, the user is explicitly
      // managing destroyed
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  
  Duplex.prototype._destroy = function (err, cb) {
    this.push(null);
    this.end();
  
    pna.nextTick(cb, err);
  };
  },{"./_stream_readable":15,"./_stream_writable":17,"core-util-is":4,"inherits":7,"process-nextick-args":10}],14:[function(require,module,exports){
  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.
  
  // a passthrough stream.
  // basically just the most minimal sort of Transform stream.
  // Every written chunk gets output as-is.
  
  'use strict';
  
  module.exports = PassThrough;
  
  var Transform = require('./_stream_transform');
  
  /*<replacement>*/
  var util = Object.create(require('core-util-is'));
  util.inherits = require('inherits');
  /*</replacement>*/
  
  util.inherits(PassThrough, Transform);
  
  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
  
    Transform.call(this, options);
  }
  
  PassThrough.prototype._transform = function (chunk, encoding, cb) {
    cb(null, chunk);
  };
  },{"./_stream_transform":16,"core-util-is":4,"inherits":7}],15:[function(require,module,exports){
  (function (process,global){
  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.
  
  'use strict';
  
  /*<replacement>*/
  
  var pna = require('process-nextick-args');
  /*</replacement>*/
  
  module.exports = Readable;
  
  /*<replacement>*/
  var isArray = require('isarray');
  /*</replacement>*/
  
  /*<replacement>*/
  var Duplex;
  /*</replacement>*/
  
  Readable.ReadableState = ReadableState;
  
  /*<replacement>*/
  var EE = require('events').EventEmitter;
  
  var EElistenerCount = function (emitter, type) {
    return emitter.listeners(type).length;
  };
  /*</replacement>*/
  
  /*<replacement>*/
  var Stream = require('./internal/streams/stream');
  /*</replacement>*/
  
  /*<replacement>*/
  
  var Buffer = require('safe-buffer').Buffer;
  var OurUint8Array = global.Uint8Array || function () {};
  function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  
  /*</replacement>*/
  
  /*<replacement>*/
  var util = Object.create(require('core-util-is'));
  util.inherits = require('inherits');
  /*</replacement>*/
  
  /*<replacement>*/
  var debugUtil = require('util');
  var debug = void 0;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog('stream');
  } else {
    debug = function () {};
  }
  /*</replacement>*/
  
  var BufferList = require('./internal/streams/BufferList');
  var destroyImpl = require('./internal/streams/destroy');
  var StringDecoder;
  
  util.inherits(Readable, Stream);
  
  var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
  
  function prependListener(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);
  
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }
  
  function ReadableState(options, stream) {
    Duplex = Duplex || require('./_stream_duplex');
  
    options = options || {};
  
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.
    var isDuplex = stream instanceof Duplex;
  
    // object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away
    this.objectMode = !!options.objectMode;
  
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
  
    // the point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means "don't call _read preemptively ever"
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  
    if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;
  
    // cast to ints.
    this.highWaterMark = Math.floor(this.highWaterMark);
  
    // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift()
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
  
    // a flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    this.sync = true;
  
    // whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
  
    // has it been destroyed
    this.destroyed = false;
  
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || 'utf8';
  
    // the number of writers that are awaiting a drain event in .pipe()s
    this.awaitDrain = 0;
  
    // if true, a maybeReadMore has been scheduled
    this.readingMore = false;
  
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  
  function Readable(options) {
    Duplex = Duplex || require('./_stream_duplex');
  
    if (!(this instanceof Readable)) return new Readable(options);
  
    this._readableState = new ReadableState(options, this);
  
    // legacy
    this.readable = true;
  
    if (options) {
      if (typeof options.read === 'function') this._read = options.read;
  
      if (typeof options.destroy === 'function') this._destroy = options.destroy;
    }
  
    Stream.call(this);
  }
  
  Object.defineProperty(Readable.prototype, 'destroyed', {
    get: function () {
      if (this._readableState === undefined) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function (value) {
      // we ignore the value if the stream
      // has not been initialized yet
      if (!this._readableState) {
        return;
      }
  
      // backward compatibility, the user is explicitly
      // managing destroyed
      this._readableState.destroyed = value;
    }
  });
  
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function (err, cb) {
    this.push(null);
    cb(err);
  };
  
  // Manually shove something into the read() buffer.
  // This returns true if the highWaterMark has not been hit yet,
  // similar to how Writable.write() returns true if you should
  // write() some more.
  Readable.prototype.push = function (chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
  
    if (!state.objectMode) {
      if (typeof chunk === 'string') {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer.from(chunk, encoding);
          encoding = '';
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
  
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  
  // Unshift should *always* be something directly out of read()
  Readable.prototype.unshift = function (chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit('error', er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
  
        if (addToFront) {
          if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          stream.emit('error', new Error('stream.push() after EOF'));
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
      }
    }
  
    return needMoreData(state);
  }
  
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      stream.emit('data', chunk);
      stream.read(0);
    } else {
      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
  
      if (state.needReadable) emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
      er = new TypeError('Invalid non-string/buffer chunk');
    }
    return er;
  }
  
  // if it's past the high water mark, we can push in some more.
  // Also, if we have no data yet, we can stand some
  // more bytes.  This is to work around cases where hwm=0,
  // such as the repl.  Also, if the push() triggered a
  // readable event, and the user called read(largeNumber) such that
  // needReadable was set, then we ought to push more, so that another
  // 'readable' event will be triggered.
  function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  }
  
  Readable.prototype.isPaused = function () {
    return this._readableState.flowing === false;
  };
  
  // backwards compatibility.
  Readable.prototype.setEncoding = function (enc) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  
  // Don't raise the hwm > 8MB
  var MAX_HWM = 0x800000;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      // Get the next highest power of 2 to prevent increasing hwm excessively in
      // tiny amounts
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;
    if (n !== n) {
      // Only flow one buffer at a time
      if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
    }
    // If we're asking for more than the current hwm, then raise the hwm.
    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length) return n;
    // Don't have enough
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  
  // you can override either this method, or the async _read(n) below.
  Readable.prototype.read = function (n) {
    debug('read', n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
  
    if (n !== 0) state.emittedReadable = false;
  
    // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
      debug('read: emitReadable', state.length, state.ended);
      if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
      return null;
    }
  
    n = howMuchToRead(n, state);
  
    // if we've ended, and we're now clear, then finish it up.
    if (n === 0 && state.ended) {
      if (state.length === 0) endReadable(this);
      return null;
    }
  
    // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.
  
    // if we need a readable event, then we need to do some reading.
    var doRead = state.needReadable;
    debug('need readable', doRead);
  
    // if we currently have less than the highWaterMark, then also read some
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug('length less than watermark', doRead);
    }
  
    // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.
    if (state.ended || state.reading) {
      doRead = false;
      debug('reading or ended', doRead);
    } else if (doRead) {
      debug('do read');
      state.reading = true;
      state.sync = true;
      // if the length is currently zero, then we *need* a readable event.
      if (state.length === 0) state.needReadable = true;
      // call internal read method
      this._read(state.highWaterMark);
      state.sync = false;
      // If _read pushed data synchronously, then `reading` will be false,
      // and we need to re-evaluate how much data we can return to the user.
      if (!state.reading) n = howMuchToRead(nOrig, state);
    }
  
    var ret;
    if (n > 0) ret = fromList(n, state);else ret = null;
  
    if (ret === null) {
      state.needReadable = true;
      n = 0;
    } else {
      state.length -= n;
    }
  
    if (state.length === 0) {
      // If we have nothing in the buffer, then we want to know
      // as soon as we *do* get something into the buffer.
      if (!state.ended) state.needReadable = true;
  
      // If we tried to read() past the EOF, then emit end on the next tick.
      if (nOrig !== n && state.ended) endReadable(this);
    }
  
    if (ret !== null) this.emit('data', ret);
  
    return ret;
  };
  
  function onEofChunk(stream, state) {
    if (state.ended) return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
  
    // emit 'readable' now to make sure it gets picked up.
    emitReadable(stream);
  }
  
  // Don't emit readable right away in sync mode, because this can trigger
  // another read() call => stack overflow.  This way, it might trigger
  // a nextTick recursion warning, but that's not so bad.
  function emitReadable(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug('emitReadable', state.flowing);
      state.emittedReadable = true;
      if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
    }
  }
  
  function emitReadable_(stream) {
    debug('emit readable');
    stream.emit('readable');
    flow(stream);
  }
  
  // at this point, the user has presumably seen the 'readable' event,
  // and called read() to consume some data.  that may have triggered
  // in turn another _read(n) call, in which case reading = true if
  // it's in progress.
  // However, if we're not ended, or reading, and the length < hwm,
  // then go ahead and try to read some more preemptively.
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      pna.nextTick(maybeReadMore_, stream, state);
    }
  }
  
  function maybeReadMore_(stream, state) {
    var len = state.length;
    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
      debug('maybeReadMore read 0');
      stream.read(0);
      if (len === state.length)
        // didn't get any data, stop spinning.
        break;else len = state.length;
    }
    state.readingMore = false;
  }
  
  // abstract method.  to be overridden in specific implementation classes.
  // call cb(er, data) where data is <= n in length.
  // for virtual (non-string, non-buffer) streams, "length" is somewhat
  // arbitrary, and perhaps not very meaningful.
  Readable.prototype._read = function (n) {
    this.emit('error', new Error('_read() is not implemented'));
  };
  
  Readable.prototype.pipe = function (dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
  
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);
  
    dest.on('unpipe', onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug('onunpipe');
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
  
    function onend() {
      debug('onend');
      dest.end();
    }
  
    // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.
    var ondrain = pipeOnDrain(src);
    dest.on('drain', ondrain);
  
    var cleanedUp = false;
    function cleanup() {
      debug('cleanup');
      // cleanup event handlers once the pipe is broken
      dest.removeListener('close', onclose);
      dest.removeListener('finish', onfinish);
      dest.removeListener('drain', ondrain);
      dest.removeListener('error', onerror);
      dest.removeListener('unpipe', onunpipe);
      src.removeListener('end', onend);
      src.removeListener('end', unpipe);
      src.removeListener('data', ondata);
  
      cleanedUp = true;
  
      // if the reader is waiting for a drain event from this
      // specific writer, then it would cause it to never start
      // flowing again.
      // So, if this is awaiting a drain, then we just call it now.
      // If we don't know, then assume that we are waiting for one.
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
  
    // If the user pushes more data while we're writing to dest then we'll end up
    // in ondata again. However, we only want to increase awaitDrain once because
    // dest will only emit one 'drain' event for the multiple writes.
    // => Introduce a guard on increasing awaitDrain.
    var increasedAwaitDrain = false;
    src.on('data', ondata);
    function ondata(chunk) {
      debug('ondata');
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (false === ret && !increasedAwaitDrain) {
        // If the user unpiped during `dest.write()`, it is possible
        // to get stuck in a permanently paused state if that write
        // also returned false.
        // => Check whether `dest` is still a piping destination.
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug('false write response, pause', src._readableState.awaitDrain);
          src._readableState.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src.pause();
      }
    }
  
    // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.
    function onerror(er) {
      debug('onerror', er);
      unpipe();
      dest.removeListener('error', onerror);
      if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
    }
  
    // Make sure our error handler is attached before userland ones.
    prependListener(dest, 'error', onerror);
  
    // Both close and finish should trigger unpipe, but only once.
    function onclose() {
      dest.removeListener('finish', onfinish);
      unpipe();
    }
    dest.once('close', onclose);
    function onfinish() {
      debug('onfinish');
      dest.removeListener('close', onclose);
      unpipe();
    }
    dest.once('finish', onfinish);
  
    function unpipe() {
      debug('unpipe');
      src.unpipe(dest);
    }
  
    // tell the dest that it's being piped to
    dest.emit('pipe', src);
  
    // start the flow if it hasn't been started already.
    if (!state.flowing) {
      debug('pipe resume');
      src.resume();
    }
  
    return dest;
  };
  
  function pipeOnDrain(src) {
    return function () {
      var state = src._readableState;
      debug('pipeOnDrain', state.awaitDrain);
      if (state.awaitDrain) state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  
  Readable.prototype.unpipe = function (dest) {
    var state = this._readableState;
    var unpipeInfo = { hasUnpiped: false };
  
    // if we're not piping anywhere, then do nothing.
    if (state.pipesCount === 0) return this;
  
    // just one destination.  most common case.
    if (state.pipesCount === 1) {
      // passed in one, but it's not the right one.
      if (dest && dest !== state.pipes) return this;
  
      if (!dest) dest = state.pipes;
  
      // got a match.
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest) dest.emit('unpipe', this, unpipeInfo);
      return this;
    }
  
    // slow case. multiple pipe destinations.
  
    if (!dest) {
      // remove all.
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
  
      for (var i = 0; i < len; i++) {
        dests[i].emit('unpipe', this, unpipeInfo);
      }return this;
    }
  
    // try to find the right one.
    var index = indexOf(state.pipes, dest);
    if (index === -1) return this;
  
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];
  
    dest.emit('unpipe', this, unpipeInfo);
  
    return this;
  };
  
  // set up data events if they are asked for
  // Ensure readable listeners eventually get something
  Readable.prototype.on = function (ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
  
    if (ev === 'data') {
      // Start flowing on next tick if stream isn't explicitly paused
      if (this._readableState.flowing !== false) this.resume();
    } else if (ev === 'readable') {
      var state = this._readableState;
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.emittedReadable = false;
        if (!state.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state.length) {
          emitReadable(this);
        }
      }
    }
  
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  
  function nReadingNextTick(self) {
    debug('readable nexttick read 0');
    self.read(0);
  }
  
  // pause() and resume() are remnants of the legacy readable stream API
  // If the user uses them, then switch into old mode.
  Readable.prototype.resume = function () {
    var state = this._readableState;
    if (!state.flowing) {
      debug('resume');
      state.flowing = true;
      resume(this, state);
    }
    return this;
  };
  
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      pna.nextTick(resume_, stream, state);
    }
  }
  
  function resume_(stream, state) {
    if (!state.reading) {
      debug('resume read 0');
      stream.read(0);
    }
  
    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit('resume');
    flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
  }
  
  Readable.prototype.pause = function () {
    debug('call pause flowing=%j', this._readableState.flowing);
    if (false !== this._readableState.flowing) {
      debug('pause');
      this._readableState.flowing = false;
      this.emit('pause');
    }
    return this;
  };
  
  function flow(stream) {
    var state = stream._readableState;
    debug('flow', state.flowing);
    while (state.flowing && stream.read() !== null) {}
  }
  
  // wrap an old-style stream as the async data source.
  // This is *not* part of the readable stream interface.
  // It is an ugly unfortunate mess of history.
  Readable.prototype.wrap = function (stream) {
    var _this = this;
  
    var state = this._readableState;
    var paused = false;
  
    stream.on('end', function () {
      debug('wrapped end');
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
  
      _this.push(null);
    });
  
    stream.on('data', function (chunk) {
      debug('wrapped data');
      if (state.decoder) chunk = state.decoder.write(chunk);
  
      // don't skip over falsy values in objectMode
      if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
  
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
  
    // proxy all the other methods.
    // important when wrapping filters and duplexes.
    for (var i in stream) {
      if (this[i] === undefined && typeof stream[i] === 'function') {
        this[i] = function (method) {
          return function () {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }
  
    // proxy certain important events.
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
  
    // when we try to consume some more bytes, simply unpause the
    // underlying stream.
    this._read = function (n) {
      debug('wrapped _read', n);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
  
    return this;
  };
  
  Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function () {
      return this._readableState.highWaterMark;
    }
  });
  
  // exposed for testing purposes only.
  Readable._fromList = fromList;
  
  // Pluck off n bytes from an array of buffers.
  // Length is the combined lengths of all the buffers in the list.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.
  function fromList(n, state) {
    // nothing buffered
    if (state.length === 0) return null;
  
    var ret;
    if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
      // read it all, truncate the list
      if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      // read part of list
      ret = fromListPartial(n, state.buffer, state.decoder);
    }
  
    return ret;
  }
  
  // Extracts only enough buffered data to satisfy the amount requested.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      // slice is the same for buffers and strings
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      // first chunk is a perfect match
      ret = list.shift();
    } else {
      // result spans more than one buffer
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  
  // Copies a specified amount of characters from the list of buffered data
  // chunks.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length) ret += str;else ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next) list.head = p.next;else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  
  // Copies a specified amount of bytes from the list of buffered data chunks.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.
  function copyFromBuffer(n, list) {
    var ret = Buffer.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next) list.head = p.next;else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  
  function endReadable(stream) {
    var state = stream._readableState;
  
    // If we get here before consuming all the bytes, then that is a
    // bug in node.  Should never happen.
    if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
  
    if (!state.endEmitted) {
      state.ended = true;
      pna.nextTick(endReadableNT, state, stream);
    }
  }
  
  function endReadableNT(state, stream) {
    // Check that we didn't get one last unshift.
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit('end');
    }
  }
  
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }
    return -1;
  }
  }).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"./_stream_duplex":13,"./internal/streams/BufferList":18,"./internal/streams/destroy":19,"./internal/streams/stream":20,"_process":11,"core-util-is":4,"events":5,"inherits":7,"isarray":9,"process-nextick-args":10,"safe-buffer":21,"string_decoder/":22,"util":2}],16:[function(require,module,exports){
  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.
  
  // a transform stream is a readable/writable stream where you do
  // something with the data.  Sometimes it's called a "filter",
  // but that's not a great name for it, since that implies a thing where
  // some bits pass through, and others are simply ignored.  (That would
  // be a valid example of a transform, of course.)
  //
  // While the output is causally related to the input, it's not a
  // necessarily symmetric or synchronous transformation.  For example,
  // a zlib stream might take multiple plain-text writes(), and then
  // emit a single compressed chunk some time in the future.
  //
  // Here's how this works:
  //
  // The Transform stream has all the aspects of the readable and writable
  // stream classes.  When you write(chunk), that calls _write(chunk,cb)
  // internally, and returns false if there's a lot of pending writes
  // buffered up.  When you call read(), that calls _read(n) until
  // there's enough pending readable data buffered up.
  //
  // In a transform stream, the written data is placed in a buffer.  When
  // _read(n) is called, it transforms the queued up data, calling the
  // buffered _write cb's as it consumes chunks.  If consuming a single
  // written chunk would result in multiple output chunks, then the first
  // outputted bit calls the readcb, and subsequent chunks just go into
  // the read buffer, and will cause it to emit 'readable' if necessary.
  //
  // This way, back-pressure is actually determined by the reading side,
  // since _read has to be called to start processing a new chunk.  However,
  // a pathological inflate type of transform can cause excessive buffering
  // here.  For example, imagine a stream where every byte of input is
  // interpreted as an integer from 0-255, and then results in that many
  // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
  // 1kb of data being output.  In this case, you could write a very small
  // amount of input, and end up with a very large amount of output.  In
  // such a pathological inflating mechanism, there'd be no way to tell
  // the system to stop doing the transform.  A single 4MB write could
  // cause the system to run out of memory.
  //
  // However, even in such a pathological case, only a single written chunk
  // would be consumed, and then the rest would wait (un-transformed) until
  // the results of the previous transformed chunk were consumed.
  
  'use strict';
  
  module.exports = Transform;
  
  var Duplex = require('./_stream_duplex');
  
  /*<replacement>*/
  var util = Object.create(require('core-util-is'));
  util.inherits = require('inherits');
  /*</replacement>*/
  
  util.inherits(Transform, Duplex);
  
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
  
    var cb = ts.writecb;
  
    if (!cb) {
      return this.emit('error', new Error('write callback called multiple times'));
    }
  
    ts.writechunk = null;
    ts.writecb = null;
  
    if (data != null) // single equals check for both `null` and `undefined`
      this.push(data);
  
    cb(er);
  
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  
  function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
  
    Duplex.call(this, options);
  
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
  
    // start out asking for a readable event once data is transformed.
    this._readableState.needReadable = true;
  
    // we have implemented the _read method, and done the other things
    // that Readable wants before the first _read call, so unset the
    // sync guard flag.
    this._readableState.sync = false;
  
    if (options) {
      if (typeof options.transform === 'function') this._transform = options.transform;
  
      if (typeof options.flush === 'function') this._flush = options.flush;
    }
  
    // When the writable side finishes, then flush out anything remaining.
    this.on('prefinish', prefinish);
  }
  
  function prefinish() {
    var _this = this;
  
    if (typeof this._flush === 'function') {
      this._flush(function (er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  
  Transform.prototype.push = function (chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  
  // This is the part where you do stuff!
  // override this function in implementation classes.
  // 'chunk' is an input chunk.
  //
  // Call `push(newChunk)` to pass along transformed output
  // to the readable side.  You may call 'push' zero or more times.
  //
  // Call `cb(err)` when you are done with this chunk.  If you pass
  // an error, then that'll put the hurt on the whole operation.  If you
  // never call cb(), then you'll never get another chunk.
  Transform.prototype._transform = function (chunk, encoding, cb) {
    throw new Error('_transform() is not implemented');
  };
  
  Transform.prototype._write = function (chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };
  
  // Doesn't matter what the args are here.
  // _transform does all the work.
  // That we got here means that the readable side wants more data.
  Transform.prototype._read = function (n) {
    var ts = this._transformState;
  
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      // mark that we need a transform, so that any data that comes in
      // will get processed, now that we've asked for it.
      ts.needTransform = true;
    }
  };
  
  Transform.prototype._destroy = function (err, cb) {
    var _this2 = this;
  
    Duplex.prototype._destroy.call(this, err, function (err2) {
      cb(err2);
      _this2.emit('close');
    });
  };
  
  function done(stream, er, data) {
    if (er) return stream.emit('error', er);
  
    if (data != null) // single equals check for both `null` and `undefined`
      stream.push(data);
  
    // if there's nothing in the write buffer, then that means
    // that nothing more will ever be provided
    if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');
  
    if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');
  
    return stream.push(null);
  }
  },{"./_stream_duplex":13,"core-util-is":4,"inherits":7}],17:[function(require,module,exports){
  (function (process,global,setImmediate){
  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.
  
  // A bit simpler than readable streams.
  // Implement an async ._write(chunk, encoding, cb), and it'll handle all
  // the drain event emission and buffering.
  
  'use strict';
  
  /*<replacement>*/
  
  var pna = require('process-nextick-args');
  /*</replacement>*/
  
  module.exports = Writable;
  
  /* <replacement> */
  function WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
  }
  
  // It seems a linked list but it is not
  // there will be only 2 of these for each stream
  function CorkedRequest(state) {
    var _this = this;
  
    this.next = null;
    this.entry = null;
    this.finish = function () {
      onCorkedFinish(_this, state);
    };
  }
  /* </replacement> */
  
  /*<replacement>*/
  var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  /*</replacement>*/
  
  /*<replacement>*/
  var Duplex;
  /*</replacement>*/
  
  Writable.WritableState = WritableState;
  
  /*<replacement>*/
  var util = Object.create(require('core-util-is'));
  util.inherits = require('inherits');
  /*</replacement>*/
  
  /*<replacement>*/
  var internalUtil = {
    deprecate: require('util-deprecate')
  };
  /*</replacement>*/
  
  /*<replacement>*/
  var Stream = require('./internal/streams/stream');
  /*</replacement>*/
  
  /*<replacement>*/
  
  var Buffer = require('safe-buffer').Buffer;
  var OurUint8Array = global.Uint8Array || function () {};
  function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  
  /*</replacement>*/
  
  var destroyImpl = require('./internal/streams/destroy');
  
  util.inherits(Writable, Stream);
  
  function nop() {}
  
  function WritableState(options, stream) {
    Duplex = Duplex || require('./_stream_duplex');
  
    options = options || {};
  
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.
    var isDuplex = stream instanceof Duplex;
  
    // object stream flag to indicate whether or not this stream
    // contains buffers or objects.
    this.objectMode = !!options.objectMode;
  
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
  
    // the point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write()
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  
    if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;
  
    // cast to ints.
    this.highWaterMark = Math.floor(this.highWaterMark);
  
    // if _final has been called
    this.finalCalled = false;
  
    // drain event flag.
    this.needDrain = false;
    // at the start of calling end()
    this.ending = false;
    // when end() has been called, and returned
    this.ended = false;
    // when 'finish' is emitted
    this.finished = false;
  
    // has it been destroyed
    this.destroyed = false;
  
    // should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
  
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || 'utf8';
  
    // not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.
    this.length = 0;
  
    // a flag to see when we're in the middle of a write.
    this.writing = false;
  
    // when true all writes will be buffered until .uncork() call
    this.corked = 0;
  
    // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.
    this.sync = true;
  
    // a flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.
    this.bufferProcessing = false;
  
    // the callback that's passed to _write(chunk,cb)
    this.onwrite = function (er) {
      onwrite(stream, er);
    };
  
    // the callback that the user supplies to write(chunk,encoding,cb)
    this.writecb = null;
  
    // the amount that is being written when _write is called.
    this.writelen = 0;
  
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
  
    // number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted
    this.pendingcb = 0;
  
    // emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams
    this.prefinished = false;
  
    // True if the error was already emitted and should not be thrown again
    this.errorEmitted = false;
  
    // count buffered requests
    this.bufferedRequestCount = 0;
  
    // allocate the first CorkedRequest, there is always
    // one allocated and free to use, and we maintain at most two
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  
  (function () {
    try {
      Object.defineProperty(WritableState.prototype, 'buffer', {
        get: internalUtil.deprecate(function () {
          return this.getBuffer();
        }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
      });
    } catch (_) {}
  })();
  
  // Test _writableState for inheritance to account for Duplex streams,
  // whose prototype chain only points to Readable.
  var realHasInstance;
  if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function (object) {
        if (realHasInstance.call(this, object)) return true;
        if (this !== Writable) return false;
  
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function (object) {
      return object instanceof this;
    };
  }
  
  function Writable(options) {
    Duplex = Duplex || require('./_stream_duplex');
  
    // Writable ctor is applied to Duplexes, too.
    // `realHasInstance` is necessary because using plain `instanceof`
    // would return false, as no `_writableState` property is attached.
  
    // Trying to use the custom `instanceof` for Writable here will also break the
    // Node.js LazyTransform implementation, which has a non-trivial getter for
    // `_writableState` that would lead to infinite recursion.
    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
      return new Writable(options);
    }
  
    this._writableState = new WritableState(options, this);
  
    // legacy.
    this.writable = true;
  
    if (options) {
      if (typeof options.write === 'function') this._write = options.write;
  
      if (typeof options.writev === 'function') this._writev = options.writev;
  
      if (typeof options.destroy === 'function') this._destroy = options.destroy;
  
      if (typeof options.final === 'function') this._final = options.final;
    }
  
    Stream.call(this);
  }
  
  // Otherwise people can pipe Writable streams, which is just wrong.
  Writable.prototype.pipe = function () {
    this.emit('error', new Error('Cannot pipe, not readable'));
  };
  
  function writeAfterEnd(stream, cb) {
    var er = new Error('write after end');
    // TODO: defer error events consistently everywhere, not just the cb
    stream.emit('error', er);
    pna.nextTick(cb, er);
  }
  
  // Checks that a user-supplied chunk is valid, especially for the particular
  // mode the stream is in. Currently this means that `null` is never accepted
  // and undefined/non-string values are only allowed in object mode.
  function validChunk(stream, state, chunk, cb) {
    var valid = true;
    var er = false;
  
    if (chunk === null) {
      er = new TypeError('May not write null values to stream');
    } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
      er = new TypeError('Invalid non-string/buffer chunk');
    }
    if (er) {
      stream.emit('error', er);
      pna.nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  
  Writable.prototype.write = function (chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
  
    if (isBuf && !Buffer.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
  
    if (typeof encoding === 'function') {
      cb = encoding;
      encoding = null;
    }
  
    if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  
    if (typeof cb !== 'function') cb = nop;
  
    if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
  
    return ret;
  };
  
  Writable.prototype.cork = function () {
    var state = this._writableState;
  
    state.corked++;
  };
  
  Writable.prototype.uncork = function () {
    var state = this._writableState;
  
    if (state.corked) {
      state.corked--;
  
      if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
    }
  };
  
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === 'string') encoding = encoding.toLowerCase();
    if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
      chunk = Buffer.from(chunk, encoding);
    }
    return chunk;
  }
  
  Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function () {
      return this._writableState.highWaterMark;
    }
  });
  
  // if we're already writing something, then just put this
  // in the queue, and wait our turn.  Otherwise, call _write
  // If we return false, then we need a drain event, so set that flag.
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = 'buffer';
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
  
    state.length += len;
  
    var ret = state.length < state.highWaterMark;
    // we must ensure that previous needDrain will not be reset to false.
    if (!ret) state.needDrain = true;
  
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk: chunk,
        encoding: encoding,
        isBuf: isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
  
    return ret;
  }
  
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
  
    if (sync) {
      // defer the callback if we are being called synchronously
      // to avoid piling up things on the stack
      pna.nextTick(cb, er);
      // this can emit finish, and it will always happen
      // after error
      pna.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      stream.emit('error', er);
    } else {
      // the caller expect this to happen before if
      // it is async
      cb(er);
      stream._writableState.errorEmitted = true;
      stream.emit('error', er);
      // this can emit finish, but finish must
      // always follow error
      finishMaybe(stream, state);
    }
  }
  
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
  
    onwriteStateUpdate(state);
  
    if (er) onwriteError(stream, state, sync, er, cb);else {
      // Check if we're actually ready to finish, but don't emit yet
      var finished = needFinish(state);
  
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
  
      if (sync) {
        /*<replacement>*/
        asyncWrite(afterWrite, stream, state, finished, cb);
        /*</replacement>*/
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  
  function afterWrite(stream, state, finished, cb) {
    if (!finished) onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  
  // Must force callback to be called on nextTick, so that we don't
  // emit 'drain' before the write() consumer gets the 'false' return
  // value, and has a chance to attach a 'drain' listener.
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit('drain');
    }
  }
  
  // if there's something in the buffer waiting, then process it
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
  
    if (stream._writev && entry && entry.next) {
      // Fast case, write everything using _writev()
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
  
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
  
      doWrite(stream, state, true, state.length, buffer, '', holder.finish);
  
      // doWrite is almost always async, defer these to save a bit of time
      // as the hot path ends with doWrite
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      // Slow case, write chunks one-by-one
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
  
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        // if we didn't call the onwrite immediately, then
        // it means that we need to wait until it does.
        // also, that means that the chunk and cb are currently
        // being processed, so move the buffer counter past them.
        if (state.writing) {
          break;
        }
      }
  
      if (entry === null) state.lastBufferedRequest = null;
    }
  
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  
  Writable.prototype._write = function (chunk, encoding, cb) {
    cb(new Error('_write() is not implemented'));
  };
  
  Writable.prototype._writev = null;
  
  Writable.prototype.end = function (chunk, encoding, cb) {
    var state = this._writableState;
  
    if (typeof chunk === 'function') {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === 'function') {
      cb = encoding;
      encoding = null;
    }
  
    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
  
    // .end() fully uncorks
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
  
    // ignore unnecessary end() calls.
    if (!state.ending && !state.finished) endWritable(this, state, cb);
  };
  
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function (err) {
      state.pendingcb--;
      if (err) {
        stream.emit('error', err);
      }
      state.prefinished = true;
      stream.emit('prefinish');
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === 'function') {
        state.pendingcb++;
        state.finalCalled = true;
        pna.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit('prefinish');
      }
    }
  }
  
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit('finish');
      }
    }
    return need;
  }
  
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = corkReq;
    } else {
      state.corkedRequestsFree = corkReq;
    }
  }
  
  Object.defineProperty(Writable.prototype, 'destroyed', {
    get: function () {
      if (this._writableState === undefined) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function (value) {
      // we ignore the value if the stream
      // has not been initialized yet
      if (!this._writableState) {
        return;
      }
  
      // backward compatibility, the user is explicitly
      // managing destroyed
      this._writableState.destroyed = value;
    }
  });
  
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function (err, cb) {
    this.end();
    cb(err);
  };
  }).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)
  },{"./_stream_duplex":13,"./internal/streams/destroy":19,"./internal/streams/stream":20,"_process":11,"core-util-is":4,"inherits":7,"process-nextick-args":10,"safe-buffer":21,"timers":30,"util-deprecate":31}],18:[function(require,module,exports){
  'use strict';
  
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  
  var Buffer = require('safe-buffer').Buffer;
  var util = require('util');
  
  function copyBuffer(src, target, offset) {
    src.copy(target, offset);
  }
  
  module.exports = function () {
    function BufferList() {
      _classCallCheck(this, BufferList);
  
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
  
    BufferList.prototype.push = function push(v) {
      var entry = { data: v, next: null };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    };
  
    BufferList.prototype.unshift = function unshift(v) {
      var entry = { data: v, next: this.head };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    };
  
    BufferList.prototype.shift = function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    };
  
    BufferList.prototype.clear = function clear() {
      this.head = this.tail = null;
      this.length = 0;
    };
  
    BufferList.prototype.join = function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }return ret;
    };
  
    BufferList.prototype.concat = function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      if (this.length === 1) return this.head.data;
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };
  
    return BufferList;
  }();
  
  if (util && util.inspect && util.inspect.custom) {
    module.exports.prototype[util.inspect.custom] = function () {
      var obj = util.inspect({ length: this.length });
      return this.constructor.name + ' ' + obj;
    };
  }
  },{"safe-buffer":21,"util":2}],19:[function(require,module,exports){
  'use strict';
  
  /*<replacement>*/
  
  var pna = require('process-nextick-args');
  /*</replacement>*/
  
  // undocumented cb() API, needed for core, not for public API
  function destroy(err, cb) {
    var _this = this;
  
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
  
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
        pna.nextTick(emitErrorNT, this, err);
      }
      return this;
    }
  
    // we set destroyed to true before firing error callbacks in order
    // to make it re-entrance safe in case destroy() is called within callbacks
  
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
  
    // if this is a duplex stream mark the writable part as destroyed as well
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
  
    this._destroy(err || null, function (err) {
      if (!cb && err) {
        pna.nextTick(emitErrorNT, _this, err);
        if (_this._writableState) {
          _this._writableState.errorEmitted = true;
        }
      } else if (cb) {
        cb(err);
      }
    });
  
    return this;
  }
  
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
  
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  
  function emitErrorNT(self, err) {
    self.emit('error', err);
  }
  
  module.exports = {
    destroy: destroy,
    undestroy: undestroy
  };
  },{"process-nextick-args":10}],20:[function(require,module,exports){
  module.exports = require('events').EventEmitter;
  
  },{"events":5}],21:[function(require,module,exports){
  /* eslint-disable node/no-deprecated-api */
  var buffer = require('buffer')
  var Buffer = buffer.Buffer
  
  // alternative to using Object.keys for old browsers
  function copyProps (src, dst) {
    for (var key in src) {
      dst[key] = src[key]
    }
  }
  if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    module.exports = buffer
  } else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports)
    exports.Buffer = SafeBuffer
  }
  
  function SafeBuffer (arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length)
  }
  
  // Copy static methods from Buffer
  copyProps(Buffer, SafeBuffer)
  
  SafeBuffer.from = function (arg, encodingOrOffset, length) {
    if (typeof arg === 'number') {
      throw new TypeError('Argument must not be a number')
    }
    return Buffer(arg, encodingOrOffset, length)
  }
  
  SafeBuffer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number')
    }
    var buf = Buffer(size)
    if (fill !== undefined) {
      if (typeof encoding === 'string') {
        buf.fill(fill, encoding)
      } else {
        buf.fill(fill)
      }
    } else {
      buf.fill(0)
    }
    return buf
  }
  
  SafeBuffer.allocUnsafe = function (size) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number')
    }
    return Buffer(size)
  }
  
  SafeBuffer.allocUnsafeSlow = function (size) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number')
    }
    return buffer.SlowBuffer(size)
  }
  
  },{"buffer":3}],22:[function(require,module,exports){
  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.
  
  'use strict';
  
  /*<replacement>*/
  
  var Buffer = require('safe-buffer').Buffer;
  /*</replacement>*/
  
  var isEncoding = Buffer.isEncoding || function (encoding) {
    encoding = '' + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
        return true;
      default:
        return false;
    }
  };
  
  function _normalizeEncoding(enc) {
    if (!enc) return 'utf8';
    var retried;
    while (true) {
      switch (enc) {
        case 'utf8':
        case 'utf-8':
          return 'utf8';
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return 'utf16le';
        case 'latin1':
        case 'binary':
          return 'latin1';
        case 'base64':
        case 'ascii':
        case 'hex':
          return enc;
        default:
          if (retried) return; // undefined
          enc = ('' + enc).toLowerCase();
          retried = true;
      }
    }
  };
  
  // Do not cache `Buffer.isEncoding` when checking encoding names as some
  // modules monkey-patch it to support additional encodings
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
    return nenc || enc;
  }
  
  // StringDecoder provides an interface for efficiently splitting a series of
  // buffers into a series of JS strings without breaking apart multi-byte
  // characters.
  exports.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case 'utf16le':
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case 'utf8':
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case 'base64':
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer.allocUnsafe(nb);
  }
  
  StringDecoder.prototype.write = function (buf) {
    if (buf.length === 0) return '';
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === undefined) return '';
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || '';
  };
  
  StringDecoder.prototype.end = utf8End;
  
  // Returns only complete characters in a Buffer
  StringDecoder.prototype.text = utf8Text;
  
  // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
  StringDecoder.prototype.fillLast = function (buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  
  // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
  // continuation byte. If an invalid byte is detected, -2 is returned.
  function utf8CheckByte(byte) {
    if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
    return byte >> 6 === 0x02 ? -1 : -2;
  }
  
  // Checks at most 3 bytes at the end of a Buffer in order to detect an
  // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
  // needed to complete the UTF-8 character (if applicable) are returned.
  function utf8CheckIncomplete(self, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  
  // Validates as many continuation bytes for a multi-byte UTF-8 character as
  // needed or are available. If we see a non-continuation byte where we expect
  // one, we "replace" the validated continuation bytes we've seen so far with
  // a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
  // behavior. The continuation byte check is included three times in the case
  // where all of the continuation bytes for a character exist in the same buffer.
  // It is also done this way as a slight performance increase instead of using a
  // loop.
  function utf8CheckExtraBytes(self, buf, p) {
    if ((buf[0] & 0xC0) !== 0x80) {
      self.lastNeed = 0;
      return '\ufffd';
    }
    if (self.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 0xC0) !== 0x80) {
        self.lastNeed = 1;
        return '\ufffd';
      }
      if (self.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 0xC0) !== 0x80) {
          self.lastNeed = 2;
          return '\ufffd';
        }
      }
    }
  }
  
  // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  
  // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
  // partial character, the character's bytes are buffered until the required
  // number of bytes are available.
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString('utf8', i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString('utf8', i, end);
  }
  
  // For UTF-8, a replacement character is added when ending on a partial
  // character.
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) return r + '\ufffd';
    return r;
  }
  
  // UTF-16LE typically needs two bytes per character, but even if we have an even
  // number of bytes available, we need to check if we end on a leading/high
  // surrogate. In that case, we need to wait for the next two bytes in order to
  // decode the last character properly.
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString('utf16le', i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 0xD800 && c <= 0xDBFF) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString('utf16le', i, buf.length - 1);
  }
  
  // For UTF-16LE we do not explicitly append special replacement characters if we
  // end on a partial character, we simply let v8 handle that.
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString('utf16le', 0, end);
    }
    return r;
  }
  
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString('base64', i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString('base64', i, buf.length - n);
  }
  
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
    return r;
  }
  
  // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : '';
  }
  },{"safe-buffer":21}],23:[function(require,module,exports){
  module.exports = require('./readable').PassThrough
  
  },{"./readable":24}],24:[function(require,module,exports){
  exports = module.exports = require('./lib/_stream_readable.js');
  exports.Stream = exports;
  exports.Readable = exports;
  exports.Writable = require('./lib/_stream_writable.js');
  exports.Duplex = require('./lib/_stream_duplex.js');
  exports.Transform = require('./lib/_stream_transform.js');
  exports.PassThrough = require('./lib/_stream_passthrough.js');
  
  },{"./lib/_stream_duplex.js":13,"./lib/_stream_passthrough.js":14,"./lib/_stream_readable.js":15,"./lib/_stream_transform.js":16,"./lib/_stream_writable.js":17}],25:[function(require,module,exports){
  module.exports = require('./readable').Transform
  
  },{"./readable":24}],26:[function(require,module,exports){
  module.exports = require('./lib/_stream_writable.js');
  
  },{"./lib/_stream_writable.js":17}],27:[function(require,module,exports){
  /* eslint-disable node/no-deprecated-api */
  var buffer = require('buffer')
  var Buffer = buffer.Buffer
  
  // alternative to using Object.keys for old browsers
  function copyProps (src, dst) {
    for (var key in src) {
      dst[key] = src[key]
    }
  }
  if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    module.exports = buffer
  } else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports)
    exports.Buffer = SafeBuffer
  }
  
  function SafeBuffer (arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length)
  }
  
  SafeBuffer.prototype = Object.create(Buffer.prototype)
  
  // Copy static methods from Buffer
  copyProps(Buffer, SafeBuffer)
  
  SafeBuffer.from = function (arg, encodingOrOffset, length) {
    if (typeof arg === 'number') {
      throw new TypeError('Argument must not be a number')
    }
    return Buffer(arg, encodingOrOffset, length)
  }
  
  SafeBuffer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number')
    }
    var buf = Buffer(size)
    if (fill !== undefined) {
      if (typeof encoding === 'string') {
        buf.fill(fill, encoding)
      } else {
        buf.fill(fill)
      }
    } else {
      buf.fill(0)
    }
    return buf
  }
  
  SafeBuffer.allocUnsafe = function (size) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number')
    }
    return Buffer(size)
  }
  
  SafeBuffer.allocUnsafeSlow = function (size) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number')
    }
    return buffer.SlowBuffer(size)
  }
  
  },{"buffer":3}],28:[function(require,module,exports){
  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.
  
  module.exports = Stream;
  
  var EE = require('events').EventEmitter;
  var inherits = require('inherits');
  
  inherits(Stream, EE);
  Stream.Readable = require('readable-stream/readable.js');
  Stream.Writable = require('readable-stream/writable.js');
  Stream.Duplex = require('readable-stream/duplex.js');
  Stream.Transform = require('readable-stream/transform.js');
  Stream.PassThrough = require('readable-stream/passthrough.js');
  
  // Backwards-compat with node 0.4.x
  Stream.Stream = Stream;
  
  
  
  // old-style streams.  Note that the pipe method (the only relevant
  // part of this class) is overridden in the Readable class.
  
  function Stream() {
    EE.call(this);
  }
  
  Stream.prototype.pipe = function(dest, options) {
    var source = this;
  
    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }
  
    source.on('data', ondata);
  
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
  
    dest.on('drain', ondrain);
  
    // If the 'end' option is not supplied, dest.end() will be called when
    // source gets the 'end' or 'close' events.  Only dest.end() once.
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on('end', onend);
      source.on('close', onclose);
    }
  
    var didOnEnd = false;
    function onend() {
      if (didOnEnd) return;
      didOnEnd = true;
  
      dest.end();
    }
  
  
    function onclose() {
      if (didOnEnd) return;
      didOnEnd = true;
  
      if (typeof dest.destroy === 'function') dest.destroy();
    }
  
    // don't leave dangling pipes when there are errors.
    function onerror(er) {
      cleanup();
      if (EE.listenerCount(this, 'error') === 0) {
        throw er; // Unhandled stream error in pipe.
      }
    }
  
    source.on('error', onerror);
    dest.on('error', onerror);
  
    // remove all the event listeners that were added.
    function cleanup() {
      source.removeListener('data', ondata);
      dest.removeListener('drain', ondrain);
  
      source.removeListener('end', onend);
      source.removeListener('close', onclose);
  
      source.removeListener('error', onerror);
      dest.removeListener('error', onerror);
  
      source.removeListener('end', cleanup);
      source.removeListener('close', cleanup);
  
      dest.removeListener('close', cleanup);
    }
  
    source.on('end', cleanup);
    source.on('close', cleanup);
  
    dest.on('close', cleanup);
  
    dest.emit('pipe', source);
  
    // Allow for unix-like usage: A.pipe(B).pipe(C)
    return dest;
  };
  
  },{"events":5,"inherits":7,"readable-stream/duplex.js":12,"readable-stream/passthrough.js":23,"readable-stream/readable.js":24,"readable-stream/transform.js":25,"readable-stream/writable.js":26}],29:[function(require,module,exports){
  arguments[4][22][0].apply(exports,arguments)
  },{"dup":22,"safe-buffer":27}],30:[function(require,module,exports){
  (function (setImmediate,clearImmediate){
  var nextTick = require('process/browser.js').nextTick;
  var apply = Function.prototype.apply;
  var slice = Array.prototype.slice;
  var immediateIds = {};
  var nextImmediateId = 0;
  
  // DOM APIs, for completeness
  
  exports.setTimeout = function() {
    return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
  };
  exports.setInterval = function() {
    return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
  };
  exports.clearTimeout =
  exports.clearInterval = function(timeout) { timeout.close(); };
  
  function Timeout(id, clearFn) {
    this._id = id;
    this._clearFn = clearFn;
  }
  Timeout.prototype.unref = Timeout.prototype.ref = function() {};
  Timeout.prototype.close = function() {
    this._clearFn.call(window, this._id);
  };
  
  // Does not start the time, just sets up the members needed.
  exports.enroll = function(item, msecs) {
    clearTimeout(item._idleTimeoutId);
    item._idleTimeout = msecs;
  };
  
  exports.unenroll = function(item) {
    clearTimeout(item._idleTimeoutId);
    item._idleTimeout = -1;
  };
  
  exports._unrefActive = exports.active = function(item) {
    clearTimeout(item._idleTimeoutId);
  
    var msecs = item._idleTimeout;
    if (msecs >= 0) {
      item._idleTimeoutId = setTimeout(function onTimeout() {
        if (item._onTimeout)
          item._onTimeout();
      }, msecs);
    }
  };
  
  // That's not how node.js implements it but the exposed api is the same.
  exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
    var id = nextImmediateId++;
    var args = arguments.length < 2 ? false : slice.call(arguments, 1);
  
    immediateIds[id] = true;
  
    nextTick(function onNextTick() {
      if (immediateIds[id]) {
        // fn.call() is faster so we optimize for the common use-case
        // @see http://jsperf.com/call-apply-segu
        if (args) {
          fn.apply(null, args);
        } else {
          fn.call(null);
        }
        // Prevent ids from leaking
        exports.clearImmediate(id);
      }
    });
  
    return id;
  };
  
  exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
    delete immediateIds[id];
  };
  }).call(this,require("timers").setImmediate,require("timers").clearImmediate)
  },{"process/browser.js":11,"timers":30}],31:[function(require,module,exports){
  (function (global){
  
  /**
   * Module exports.
   */
  
  module.exports = deprecate;
  
  /**
   * Mark that a method should not be used.
   * Returns a modified function which warns once by default.
   *
   * If `localStorage.noDeprecation = true` is set, then it is a no-op.
   *
   * If `localStorage.throwDeprecation = true` is set, then deprecated functions
   * will throw an Error when invoked.
   *
   * If `localStorage.traceDeprecation = true` is set, then deprecated functions
   * will invoke `console.trace()` instead of `console.error()`.
   *
   * @param {Function} fn - the function to deprecate
   * @param {String} msg - the string to print to the console when `fn` is invoked
   * @returns {Function} a new "deprecated" version of `fn`
   * @api public
   */
  
  function deprecate (fn, msg) {
    if (config('noDeprecation')) {
      return fn;
    }
  
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (config('throwDeprecation')) {
          throw new Error(msg);
        } else if (config('traceDeprecation')) {
          console.trace(msg);
        } else {
          console.warn(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }
  
    return deprecated;
  }
  
  /**
   * Checks `localStorage` for boolean values for the given `name`.
   *
   * @param {String} name
   * @returns {Boolean}
   * @api private
   */
  
  function config (name) {
    // accessing global.localStorage can trigger a DOMException in sandboxed iframes
    try {
      if (!global.localStorage) return false;
    } catch (_) {
      return false;
    }
    var val = global.localStorage[name];
    if (null == val) return false;
    return String(val).toLowerCase() === 'true';
  }
  
  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{}],32:[function(require,module,exports){
  var blockstack = require('blockstack');
  
  const appConfig = new blockstack.AppConfig();
  const userSession = new blockstack.UserSession({ appConfig: appConfig });
  
  userSession.redirectToSignIn();
  },{"blockstack":60}],33:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const authConstants_1 = require("./authConstants");
  const utils_1 = require("../utils");
  /**
   * Configuration data for the current app.
   *
   * On browser platforms, creating an instance of this
   * class without any arguments will use
   * `window.location.origin` as the app domain.
   * On non-browser platforms, you need to
   * specify an app domain as the second argument.
   *
   */
  class AppConfig {
      /**
       * @param {Array<string>} scopes - permissions this app is requesting
       * @param {string} appDomain - the app domain
       * @param {string} redirectPath - path on app domain to redirect users to after authentication
       * @param {string} manifestPath - path relative to app domain of app's manifest file
       * @param {string} coreNode - override the default or user selected core node
       * @param {string} authenticatorURL - the web-based fall back authenticator
       * ([[DEFAULT_BLOCKSTACK_HOST]])
       */
      constructor(scopes = authConstants_1.DEFAULT_SCOPE.slice(), appDomain = utils_1.getGlobalObject('location', { returnEmptyObject: true }).origin, redirectPath = '', manifestPath = '/manifest.json', coreNode = null, authenticatorURL = authConstants_1.DEFAULT_BLOCKSTACK_HOST) {
          this.appDomain = appDomain;
          this.scopes = scopes;
          this.redirectPath = redirectPath;
          this.manifestPath = manifestPath;
          this.coreNode = coreNode;
          this.authenticatorURL = authenticatorURL;
      }
      /**
       * The location to which the authenticator should
       * redirect the user.
       * @returns {string} - URI
       */
      redirectURI() {
          return `${this.appDomain}${this.redirectPath}`;
      }
      /**
       * The location of the app's manifest file.
       * @returns {string} - URI
       */
      manifestURI() {
          return `${this.appDomain}${this.manifestPath}`;
      }
  }
  exports.AppConfig = AppConfig;
  
  },{"../utils":95,"./authConstants":35}],34:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const tslib_1 = require("tslib");
  const queryString = require("query-string");
  const jsontokens_1 = require("jsontokens");
  const authVerification_1 = require("./authVerification");
  const utils_1 = require("../utils");
  const fetchUtil_1 = require("../fetchUtil");
  const dids_1 = require("../dids");
  const errors_1 = require("../errors");
  const authMessages_1 = require("./authMessages");
  const authConstants_1 = require("./authConstants");
  const profileTokens_1 = require("../profiles/profileTokens");
  const userSession_1 = require("./userSession");
  const config_1 = require("../config");
  const logger_1 = require("../logger");
  const protocolEchoDetection_1 = require("./protocolEchoDetection");
  const protocolLaunch_1 = require("./protocolLaunch");
  const keys_1 = require("../keys");
  const DEFAULT_PROFILE = {
      '@type': 'Person',
      '@context': 'http://schema.org'
  };
  /**
   * @deprecated
   * #### v19 Use [[UserSession.isUserSignedIn]] instead.
   *
   * Check if a user is currently signed in.
   * @return {Boolean} `true` if the user is signed in, `false` if not.
   */
  function isUserSignedIn() {
      console.warn('DEPRECATION WARNING: The static isUserSignedIn() function will be deprecated in '
          + 'the next major release of blockstack.js. Create an instance of UserSession and call the '
          + 'instance method isUserSignedIn().');
      const userSession = new userSession_1.UserSession();
      return userSession.isUserSignedIn();
  }
  exports.isUserSignedIn = isUserSignedIn;
  /**
   *
   *
   * @deprecated
   * #### v19 Use [[UserSession.isUserSignedIn]] instead.
   *
   * Generates an authentication request and redirects the user to the Blockstack
   * browser to approve the sign in request.
   *
   * Please note that this requires that the web browser properly handles the
   * `blockstack:` URL protocol handler.
   *
   * Most applications should use this
   * method for sign in unless they require more fine grained control over how the
   * authentication request is generated. If your app falls into this category,
   * use `makeAuthRequest` and `redirectToSignInWithAuthRequest` to build your own sign in process.
   *
   * @param {String} [redirectURI=`${window.location.origin}/`]
   * The location to which the identity provider will redirect the user after
   * the user approves sign in.
   * @param  {String} [manifestURI=`${window.location.origin}/manifest.json`]
   * Location of the manifest file.
   * @param  {Array} [scopes=DEFAULT_SCOPE] Defaults to requesting write access to
   * this app's data store.
   * An array of strings indicating which permissions this app is requesting.
   * @return {void}
   */
  function redirectToSignIn(redirectURI, manifestURI, scopes) {
      console.warn('DEPRECATION WARNING: The static redirectToSignIn() function will be deprecated in the '
          + 'next major release of blockstack.js. Create an instance of UserSession and call the '
          + 'instance method redirectToSignIn().');
      const authRequest = authMessages_1.makeAuthRequest(null, redirectURI, manifestURI, scopes);
      return redirectToSignInWithAuthRequest(authRequest);
  }
  exports.redirectToSignIn = redirectToSignIn;
  /**
   * @deprecated
   * #### v19 Use [[UserSession.isSignInPending]] instead.
   *
   * Check if there is a authentication request that hasn't been handled.
   *
   * Also checks for a protocol echo reply (which if detected then the page
   * will be automatically redirected after this call).
   *
   * @return {Boolean} `true` if there is a pending sign in, otherwise `false`
   */
  function isSignInPending() {
      try {
          const isProtocolEcho = protocolEchoDetection_1.protocolEchoReplyDetection();
          if (isProtocolEcho) {
              logger_1.Logger.info('protocolEchoReply detected from isSignInPending call, the page is about to redirect.');
              return true;
          }
      }
      catch (error) {
          logger_1.Logger.error(`Error checking for protocol echo reply isSignInPending: ${error}`);
      }
      return !!getAuthResponseToken();
  }
  exports.isSignInPending = isSignInPending;
  /**
   * @deprecated
   * #### v19 Use [[UserSession.getAuthResponseToken]] instead.
   *
   * Retrieve the authentication token from the URL query
   * @return {String} the authentication token if it exists otherwise `null`
   */
  function getAuthResponseToken() {
      const search = utils_1.getGlobalObject('location', { throwIfUnavailable: true, usageDesc: 'getAuthResponseToken' }).search;
      const queryDict = queryString.parse(search);
      return queryDict.authResponse ? queryDict.authResponse : '';
  }
  exports.getAuthResponseToken = getAuthResponseToken;
  /**
   * @deprecated
   * #### v19 Use [[UserSession.loadUserData]] instead.
   *
   * Retrieves the user data object. The user's profile is stored in the key `profile`.
   * @return {Object} User data object.
  */
  function loadUserData() {
      console.warn('DEPRECATION WARNING: The static loadUserData() function will be deprecated in the '
          + 'next major release of blockstack.js. Create an instance of UserSession and call the '
          + 'instance method loadUserData().');
      const userSession = new userSession_1.UserSession();
      return userSession.loadUserData();
  }
  exports.loadUserData = loadUserData;
  /**
   * @deprecated
   * #### v19 Use [[UserSession.signUserOut]] instead.
   *
   * Sign the user out and optionally redirect to given location.
   * @param  redirectURL
   * Location to redirect user to after sign out.
   * Only used in environments with `window` available
   */
  function signUserOut(redirectURL, caller) {
      const userSession = caller || new userSession_1.UserSession();
      userSession.store.deleteSessionData();
      if (redirectURL) {
          utils_1.getGlobalObject('location', { throwIfUnavailable: true, usageDesc: 'signUserOut' }).href = redirectURL;
      }
  }
  exports.signUserOut = signUserOut;
  /**
   * @deprecated
   * #### v19 Use [[UserSession.redirectToSignInWithAuthRequest]] instead.
   *
   * Redirects the user to the Blockstack browser to approve the sign in request
   * given.
   *
   * The user is redirected to the `blockstackIDHost` if the `blockstack:`
   * protocol handler is not detected. Please note that the protocol handler detection
   * does not work on all browsers.
   * @param  {String} authRequest - the authentication request generated by `makeAuthRequest`
   * @param  {String} blockstackIDHost - the URL to redirect the user to if the blockstack
   *                                     protocol handler is not detected
   * @return {void}
   */
  function redirectToSignInWithAuthRequest(authRequest, blockstackIDHost = authConstants_1.DEFAULT_BLOCKSTACK_HOST) {
      authRequest = authRequest || authMessages_1.makeAuthRequest();
      const httpsURI = `${blockstackIDHost}?authRequest=${authRequest}`;
      const { navigator, location } = utils_1.getGlobalObjects(['navigator', 'location'], { throwIfUnavailable: true, usageDesc: 'redirectToSignInWithAuthRequest' });
      // If they're on a mobile OS, always redirect them to HTTPS site
      if (/Android|webOS|iPhone|iPad|iPod|Opera Mini/i.test(navigator.userAgent)) {
          logger_1.Logger.info('detected mobile OS, sending to https');
          location.href = httpsURI;
          return;
      }
      function successCallback() {
          logger_1.Logger.info('protocol handler detected');
          // The detection function should open the link for us
      }
      function failCallback() {
          logger_1.Logger.warn('protocol handler not detected');
          location.href = httpsURI;
      }
      protocolLaunch_1.launchCustomProtocol(authRequest, successCallback, failCallback);
  }
  exports.redirectToSignInWithAuthRequest = redirectToSignInWithAuthRequest;
  /**
   * @deprecated
   * #### v19 Use [[UserSession.handlePendingSignIn]] instead.
   *
   * Try to process any pending sign in request by returning a `Promise` that resolves
   * to the user data object if the sign in succeeds.
   *
   * @param {String} nameLookupURL - the endpoint against which to verify public
   * keys match claimed username
   * @param {String} authResponseToken - the signed authentication response token
   * @param {String} transitKey - the transit private key that corresponds to the transit public key
   * that was provided in the authentication request
   * @return {Promise} that resolves to the user data object if successful and rejects
   * if handling the sign in request fails or there was no pending sign in request.
   */
  function handlePendingSignIn(nameLookupURL = '', authResponseToken = getAuthResponseToken(), transitKey, caller) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          try {
              const isProtocolEcho = protocolEchoDetection_1.protocolEchoReplyDetection();
              if (isProtocolEcho) {
                  const msg = 'handlePendingSignIn called while protocolEchoReply was detected, and '
                      + 'the page is about to redirect. This function will resolve with an error after '
                      + 'several seconds, if the page was not redirected for some reason.';
                  logger_1.Logger.info(msg);
                  return new Promise((_resolve, reject) => {
                      setTimeout(() => {
                          logger_1.Logger.error('Page should have redirected by now. handlePendingSignIn will now throw.');
                          reject(msg);
                      }, 3000);
                  });
              }
          }
          catch (error) {
              logger_1.Logger.error(`Error checking for protocol echo reply handlePendingSignIn: ${error}`);
          }
          if (!caller) {
              caller = new userSession_1.UserSession();
          }
          const sessionData = caller.store.getSessionData();
          if (sessionData.userData) {
              throw new errors_1.LoginFailedError('Existing user session found.');
          }
          if (!transitKey) {
              transitKey = caller.store.getSessionData().transitKey;
          }
          if (!nameLookupURL) {
              let coreNode = caller.appConfig && caller.appConfig.coreNode;
              if (!coreNode) {
                  coreNode = config_1.config.network.blockstackAPIUrl;
              }
              const tokenPayload = jsontokens_1.decodeToken(authResponseToken).payload;
              if (typeof tokenPayload === 'string') {
                  throw new Error('Unexpected token payload type of string');
              }
              if (utils_1.isLaterVersion(tokenPayload.version, '1.3.0')
                  && tokenPayload.blockstackAPIUrl !== null && tokenPayload.blockstackAPIUrl !== undefined) {
                  // override globally
                  logger_1.Logger.info(`Overriding ${config_1.config.network.blockstackAPIUrl} `
                      + `with ${tokenPayload.blockstackAPIUrl}`);
                  // TODO: this config is never saved so the user node preference 
                  // is not respected in later sessions..
                  config_1.config.network.blockstackAPIUrl = tokenPayload.blockstackAPIUrl;
                  coreNode = tokenPayload.blockstackAPIUrl;
              }
              nameLookupURL = `${coreNode}${authConstants_1.NAME_LOOKUP_PATH}`;
          }
          const isValid = yield authVerification_1.verifyAuthResponse(authResponseToken, nameLookupURL);
          if (!isValid) {
              throw new errors_1.LoginFailedError('Invalid authentication response.');
          }
          const tokenPayload = jsontokens_1.decodeToken(authResponseToken).payload;
          if (typeof tokenPayload === 'string') {
              throw new Error('Unexpected token payload type of string');
          }
          // TODO: real version handling
          let appPrivateKey = tokenPayload.private_key;
          let coreSessionToken = tokenPayload.core_token;
          if (utils_1.isLaterVersion(tokenPayload.version, '1.1.0')) {
              if (transitKey !== undefined && transitKey != null) {
                  if (tokenPayload.private_key !== undefined && tokenPayload.private_key !== null) {
                      try {
                          appPrivateKey = yield authMessages_1.decryptPrivateKey(transitKey, tokenPayload.private_key);
                      }
                      catch (e) {
                          logger_1.Logger.warn('Failed decryption of appPrivateKey, will try to use as given');
                          try {
                              keys_1.hexStringToECPair(tokenPayload.private_key);
                          }
                          catch (ecPairError) {
                              throw new errors_1.LoginFailedError('Failed decrypting appPrivateKey. Usually means'
                                  + ' that the transit key has changed during login.');
                          }
                      }
                  }
                  if (coreSessionToken !== undefined && coreSessionToken !== null) {
                      try {
                          coreSessionToken = yield authMessages_1.decryptPrivateKey(transitKey, coreSessionToken);
                      }
                      catch (e) {
                          logger_1.Logger.info('Failed decryption of coreSessionToken, will try to use as given');
                      }
                  }
              }
              else {
                  throw new errors_1.LoginFailedError('Authenticating with protocol > 1.1.0 requires transit'
                      + ' key, and none found.');
              }
          }
          let hubUrl = authConstants_1.BLOCKSTACK_DEFAULT_GAIA_HUB_URL;
          let gaiaAssociationToken;
          if (utils_1.isLaterVersion(tokenPayload.version, '1.2.0')
              && tokenPayload.hubUrl !== null && tokenPayload.hubUrl !== undefined) {
              hubUrl = tokenPayload.hubUrl;
          }
          if (utils_1.isLaterVersion(tokenPayload.version, '1.3.0')
              && tokenPayload.associationToken !== null && tokenPayload.associationToken !== undefined) {
              gaiaAssociationToken = tokenPayload.associationToken;
          }
          const userData = {
              username: tokenPayload.username,
              profile: tokenPayload.profile,
              email: tokenPayload.email,
              decentralizedID: tokenPayload.iss,
              identityAddress: dids_1.getAddressFromDID(tokenPayload.iss),
              appPrivateKey,
              coreSessionToken,
              authResponseToken,
              hubUrl,
              coreNode: tokenPayload.blockstackAPIUrl,
              gaiaAssociationToken
          };
          const profileURL = tokenPayload.profile_url;
          if (!userData.profile && profileURL) {
              const response = yield fetchUtil_1.fetchPrivate(profileURL);
              if (!response.ok) { // return blank profile if we fail to fetch
                  userData.profile = Object.assign({}, DEFAULT_PROFILE);
              }
              else {
                  const responseText = yield response.text();
                  const wrappedProfile = JSON.parse(responseText);
                  const profile = profileTokens_1.extractProfile(wrappedProfile[0].token);
                  userData.profile = profile;
              }
          }
          else {
              userData.profile = tokenPayload.profile;
          }
          sessionData.userData = userData;
          caller.store.setSessionData(sessionData);
          return userData;
      });
  }
  exports.handlePendingSignIn = handlePendingSignIn;
  
  },{"../config":46,"../dids":47,"../errors":58,"../fetchUtil":59,"../keys":61,"../logger":62,"../profiles/profileTokens":81,"../utils":95,"./authConstants":35,"./authMessages":36,"./authVerification":39,"./protocolEchoDetection":41,"./protocolLaunch":42,"./userSession":45,"jsontokens":237,"query-string":250,"tslib":268}],35:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  /**
  * @ignore
  */
  exports.BLOCKSTACK_HANDLER = 'blockstack';
  /**
  * @ignore
  */
  exports.BLOCKSTACK_STORAGE_LABEL = 'blockstack';
  /**
  * This constant is used in the [[redirectToSignInWithAuthRequest]]
  */
  exports.DEFAULT_BLOCKSTACK_HOST = 'https://browser.blockstack.org/auth';
  /**
  * @ignore
  */
  exports.DEFAULT_SCOPE = ["store_write" /* store_write */];
  /**
  * @ignore
  */
  exports.BLOCKSTACK_APP_PRIVATE_KEY_LABEL = 'blockstack-transit-private-key';
  /**
  * @ignore
  */
  exports.BLOCKSTACK_DEFAULT_GAIA_HUB_URL = 'https://hub.blockstack.org';
  /**
  * @ignore
  */
  exports.DEFAULT_CORE_NODE = 'https://core.blockstack.org';
  /**
  * @ignore
  */
  exports.NAME_LOOKUP_PATH = '/v1/names';
  /**
  * @ignore
  */
  exports.LOCALSTORAGE_SESSION_KEY = 'blockstack-session';
  
  },{}],36:[function(require,module,exports){
  (function (Buffer){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const tslib_1 = require("tslib");
  // eslint-disable-next-line import/no-unassigned-import
  require("cross-fetch/polyfill");
  const jsontokens_1 = require("jsontokens");
  const keys_1 = require("../keys");
  const utils_1 = require("../utils");
  const dids_1 = require("../dids");
  const ec_1 = require("../encryption/ec");
  const logger_1 = require("../logger");
  const authConstants_1 = require("./authConstants");
  const userSession_1 = require("./userSession");
  const VERSION = '1.3.1';
  /**
   * Generates a ECDSA keypair to
   * use as the ephemeral app transit private key
   * @param {SessionData} session - session object in which key will be stored
   * @return {String} the hex encoded private key
   * @private
   * @ignore
   */
  function generateTransitKey() {
      const transitKey = keys_1.makeECPrivateKey();
      return transitKey;
  }
  exports.generateTransitKey = generateTransitKey;
  /**
   * Generates an authentication request that can be sent to the Blockstack
   * browser for the user to approve sign in. This authentication request can
   * then be used for sign in by passing it to the `redirectToSignInWithAuthRequest`
   * method.
   *
   * *Note: This method should only be used if you want to roll your own authentication
   * flow. Typically you'd use `redirectToSignIn` which takes care of this
   * under the hood.*
   *
   * @param  {String} transitPrivateKey - hex encoded transit private key
   * @param {String} redirectURI - location to redirect user to after sign in approval
   * @param {String} manifestURI - location of this app's manifest file
   * @param {Array<String>} scopes - the permissions this app is requesting
   * @param {String} appDomain - the origin of this app
   * @param {Number} expiresAt - the time at which this request is no longer valid
   * @param {Object} extraParams - Any extra parameters you'd like to pass to the authenticator.
   * Use this to pass options that aren't part of the Blockstack auth spec, but might be supported
   * by special authenticators.
   * @return {String} the authentication request
   */
  function makeAuthRequest(transitPrivateKey, redirectURI, manifestURI, scopes = authConstants_1.DEFAULT_SCOPE.slice(), appDomain, expiresAt = utils_1.nextMonth().getTime(), extraParams = {}) {
      if (!transitPrivateKey) {
          transitPrivateKey = new userSession_1.UserSession().generateAndStoreTransitKey();
      }
      const getWindowOrigin = (paramName) => {
          const location = utils_1.getGlobalObject('location', {
              throwIfUnavailable: true,
              usageDesc: `makeAuthRequest([${paramName}=undefined])`
          });
          return location.origin;
      };
      if (!redirectURI) {
          redirectURI = `${getWindowOrigin('redirectURI')}/`;
      }
      if (!manifestURI) {
          manifestURI = `${getWindowOrigin('manifestURI')}/manifest.json`;
      }
      if (!appDomain) {
          appDomain = getWindowOrigin('appDomain');
      }
      /* Create the payload */
      const payload = Object.assign({}, extraParams, {
          jti: utils_1.makeUUID4(),
          iat: Math.floor(new Date().getTime() / 1000),
          exp: Math.floor(expiresAt / 1000),
          iss: null,
          public_keys: [],
          domain_name: appDomain,
          manifest_uri: manifestURI,
          redirect_uri: redirectURI,
          version: VERSION,
          do_not_include_profile: true,
          supports_hub_url: true,
          scopes
      });
      logger_1.Logger.info(`blockstack.js: generating v${VERSION} auth request`);
      /* Convert the private key to a public key to an issuer */
      const publicKey = jsontokens_1.SECP256K1Client.derivePublicKey(transitPrivateKey);
      payload.public_keys = [publicKey];
      const address = keys_1.publicKeyToAddress(publicKey);
      payload.iss = dids_1.makeDIDFromAddress(address);
      /* Sign and return the token */
      const tokenSigner = new jsontokens_1.TokenSigner('ES256k', transitPrivateKey);
      const token = tokenSigner.sign(payload);
      return token;
  }
  exports.makeAuthRequest = makeAuthRequest;
  /**
   * Encrypts the private key for decryption by the given
   * public key.
   * @param  {String} publicKey  [description]
   * @param  {String} privateKey [description]
   * @return {String} hex encoded ciphertext
   * @private
   * @ignore
   */
  function encryptPrivateKey(publicKey, privateKey) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const encryptedObj = yield ec_1.encryptECIES(publicKey, Buffer.from(privateKey), true);
          const encryptedJSON = JSON.stringify(encryptedObj);
          return Buffer.from(encryptedJSON).toString('hex');
      });
  }
  exports.encryptPrivateKey = encryptPrivateKey;
  /**
   * Decrypts the hex encrypted private key
   * @param  {String} privateKey  the private key corresponding to the public
   * key for which the ciphertext was encrypted
   * @param  {String} hexedEncrypted the ciphertext
   * @return {String}  the decrypted private key
   * @throws {Error} if unable to decrypt
   *
   * @private
   * @ignore
   */
  function decryptPrivateKey(privateKey, hexedEncrypted) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const unhexedString = Buffer.from(hexedEncrypted, 'hex').toString();
          const encryptedObj = JSON.parse(unhexedString);
          const decrypted = yield ec_1.decryptECIES(privateKey, encryptedObj);
          if (typeof decrypted !== 'string') {
              throw new Error('Unable to correctly decrypt private key');
          }
          else {
              return decrypted;
          }
      });
  }
  exports.decryptPrivateKey = decryptPrivateKey;
  /**
   * Generates a signed authentication response token for an app. This
   * token is sent back to apps which use contents to access the
   * resources and data requested by the app.
   *
   * @param  {String} privateKey the identity key of the Blockstack ID generating
   * the authentication response
   * @param  {Object} profile the profile object for the Blockstack ID
   * @param  {String} username the username of the Blockstack ID if any, otherwise `null`
   * @param  {AuthMetadata} metadata an object containing metadata sent as part of the authentication
   * response including `email` if requested and available and a URL to the profile
   * @param  {String} coreToken core session token when responding to a legacy auth request
   * or `null` for current direct to gaia authentication requests
   * @param  {String} appPrivateKey the application private key. This private key is
   * unique and specific for every Blockstack ID and application combination.
   * @param  {Number} expiresAt an integer in the same format as
   * `new Date().getTime()`, milliseconds since the Unix epoch
   * @param {String} transitPublicKey the public key provide by the app
   * in its authentication request with which secrets will be encrypted
   * @param {String} hubUrl URL to the write path of the user's Gaia hub
   * @param {String} blockstackAPIUrl URL to the API endpoint to use
   * @param {String} associationToken JWT that binds the app key to the identity key
   * @return {String} signed and encoded authentication response token
   * @private
   * @ignore
   */
  function makeAuthResponse(privateKey, profile = {}, username = null, metadata, coreToken = null, appPrivateKey = null, expiresAt = utils_1.nextMonth().getTime(), transitPublicKey = null, hubUrl = null, blockstackAPIUrl = null, associationToken = null) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          /* Convert the private key to a public key to an issuer */
          const publicKey = jsontokens_1.SECP256K1Client.derivePublicKey(privateKey);
          const address = keys_1.publicKeyToAddress(publicKey);
          /* See if we should encrypt with the transit key */
          let privateKeyPayload = appPrivateKey;
          let coreTokenPayload = coreToken;
          let additionalProperties = {};
          if (appPrivateKey !== undefined && appPrivateKey !== null) {
              logger_1.Logger.info(`blockstack.js: generating v${VERSION} auth response`);
              if (transitPublicKey !== undefined && transitPublicKey !== null) {
                  privateKeyPayload = yield encryptPrivateKey(transitPublicKey, appPrivateKey);
                  if (coreToken !== undefined && coreToken !== null) {
                      coreTokenPayload = yield encryptPrivateKey(transitPublicKey, coreToken);
                  }
              }
              additionalProperties = {
                  email: metadata.email ? metadata.email : null,
                  profile_url: metadata.profileUrl ? metadata.profileUrl : null,
                  hubUrl,
                  blockstackAPIUrl,
                  associationToken,
                  version: VERSION
              };
          }
          else {
              logger_1.Logger.info('blockstack.js: generating legacy auth response');
          }
          /* Create the payload */
          const payload = Object.assign({}, {
              jti: utils_1.makeUUID4(),
              iat: Math.floor(new Date().getTime() / 1000),
              exp: Math.floor(expiresAt / 1000),
              iss: dids_1.makeDIDFromAddress(address),
              private_key: privateKeyPayload,
              public_keys: [publicKey],
              profile,
              username,
              core_token: coreTokenPayload
          }, additionalProperties);
          /* Sign and return the token */
          const tokenSigner = new jsontokens_1.TokenSigner('ES256k', privateKey);
          return tokenSigner.sign(payload);
      });
  }
  exports.makeAuthResponse = makeAuthResponse;
  
  }).call(this,require("buffer").Buffer)
  },{"../dids":47,"../encryption/ec":51,"../keys":61,"../logger":62,"../utils":95,"./authConstants":35,"./userSession":45,"buffer":3,"cross-fetch/polyfill":197,"jsontokens":237,"tslib":268}],37:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const tslib_1 = require("tslib");
  const queryString = require("query-string");
  const jsontokens_1 = require("jsontokens");
  const utils_1 = require("../utils");
  const fetchUtil_1 = require("../fetchUtil");
  const logger_1 = require("../logger");
  /**
   * Retrieves the authentication request from the query string
   * @return {String|null} the authentication request or `null` if
   * the query string parameter `authRequest` is not found
   * @private
   * @ignore
   */
  function getAuthRequestFromURL() {
      const location = utils_1.getGlobalObject('location', { throwIfUnavailable: true, usageDesc: 'getAuthRequestFromURL' });
      const queryDict = queryString.parse(location.search);
      if (queryDict.authRequest) {
          return queryDict.authRequest.split(`${utils_1.BLOCKSTACK_HANDLER}:`).join('');
      }
      else {
          return null;
      }
  }
  exports.getAuthRequestFromURL = getAuthRequestFromURL;
  /**
   * Fetches the contents of the manifest file specified in the authentication request
   *
   * @param  {String} authRequest encoded and signed authentication request
   * @return {Promise<Object|String>} Returns a `Promise` that resolves to the JSON
   * object manifest file unless there's an error in which case rejects with an error
   * message.
   * @private
   * @ignore
   */
  function fetchAppManifest(authRequest) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!authRequest) {
              throw new Error('Invalid auth request');
          }
          const payload = jsontokens_1.decodeToken(authRequest).payload;
          if (typeof payload === 'string') {
              throw new Error('Unexpected token payload type of string');
          }
          const manifestURI = payload.manifest_uri;
          try {
              logger_1.Logger.debug(`Fetching manifest from ${manifestURI}`);
              const response = yield fetchUtil_1.fetchPrivate(manifestURI);
              const responseText = yield response.text();
              const responseJSON = JSON.parse(responseText);
              return Object.assign(Object.assign({}, responseJSON), { manifestURI });
          }
          catch (error) {
              console.log(error);
              throw new Error('Could not fetch manifest.json');
          }
      });
  }
  exports.fetchAppManifest = fetchAppManifest;
  /**
   * Redirect the user's browser to the app using the `redirect_uri`
   * specified in the authentication request, passing the authentication
   * response token as a query parameter.
   *
   * @param {String} authRequest  encoded and signed authentication request token
   * @param {String} authResponse encoded and signed authentication response token
   * @return {void}
   * @throws {Error} if there is no redirect uri
   * @private
   * @ignore
   */
  function redirectUserToApp(authRequest, authResponse) {
      const payload = jsontokens_1.decodeToken(authRequest).payload;
      if (typeof payload === 'string') {
          throw new Error('Unexpected token payload type of string');
      }
      let redirectURI = payload.redirect_uri;
      logger_1.Logger.debug(redirectURI);
      if (redirectURI) {
          redirectURI = utils_1.updateQueryStringParameter(redirectURI, 'authResponse', authResponse);
      }
      else {
          throw new Error('Invalid redirect URI');
      }
      const location = utils_1.getGlobalObject('location', { throwIfUnavailable: true, usageDesc: 'redirectUserToApp' });
      location.href = redirectURI;
  }
  exports.redirectUserToApp = redirectUserToApp;
  
  },{"../fetchUtil":59,"../logger":62,"../utils":95,"jsontokens":237,"query-string":250,"tslib":268}],38:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const jsontokens_1 = require("jsontokens");
  const fetchUtil_1 = require("../fetchUtil");
  /**
   * Create an authentication token to be sent to the Core API server
   * in order to generate a Core session JWT.
   *
   * @param {String} appDomain  The unique application identifier (e.g. foo.app, www.foo.com, etc).
   * @param {Array} appMethods  The list of API methods this application will need.
   * @param {String} appPrivateKey  The application-specific private key
   * @param {String|null} blockchainID  This is the blockchain ID of the requester
   * @param {String} thisDevice Identifier of the current device
   *
   * @return {String} a JWT signed by the app's private key
   * @deprecated
   * @private
   * @ignore
   */
  function makeCoreSessionRequest(appDomain, appMethods, appPrivateKey, blockchainID = null, thisDevice = null) {
      if (thisDevice === null) {
          thisDevice = '.default';
      }
      const appPublicKey = jsontokens_1.SECP256K1Client.derivePublicKey(appPrivateKey);
      const appPublicKeys = [{
              public_key: appPublicKey,
              device_id: thisDevice
          }];
      const authBody = {
          version: 1,
          blockchain_id: blockchainID,
          app_private_key: appPrivateKey,
          app_domain: appDomain,
          methods: appMethods,
          app_public_keys: appPublicKeys,
          device_id: thisDevice
      };
      // make token
      const tokenSigner = new jsontokens_1.TokenSigner('ES256k', appPrivateKey);
      const token = tokenSigner.sign(authBody);
      return token;
  }
  exports.makeCoreSessionRequest = makeCoreSessionRequest;
  /**
   * Send Core a request for a session token.
   *
   * @param {String} coreHost host name of the core node
   * @param {Number} corePort port number of the core node
   * @param {String} coreAuthRequest  a signed JWT encoding the authentication request
   * @param {String} apiPassword the API password for Core
   *
   * @return {Promise} the resolves to a JWT signed with the Core API server's private key
   * that authorizes the bearer to carry out the requested operations and rejects
   * with an error message otherwise
   * @deprecated
   * @private
   * @ignore
   */
  function sendCoreSessionRequest(coreHost, corePort, coreAuthRequest, apiPassword) {
      return Promise.resolve().then(() => {
          if (!apiPassword) {
              throw new Error('Missing API password');
          }
      })
          .then(() => {
          const options = {
              headers: {
                  Authorization: `bearer ${apiPassword}`
              }
          };
          const url = `http://${coreHost}:${corePort}/v1/auth?authRequest=${coreAuthRequest}`;
          return fetchUtil_1.fetchPrivate(url, options);
      })
          .then((response) => {
          if (!response.ok) {
              throw new Error('HTTP status not OK');
          }
          return response.text();
      })
          .then((responseText) => {
          const responseJson = JSON.parse(responseText);
          const token = responseJson.token;
          if (!token) {
              throw new Error('Failed to get Core session token');
          }
          return token;
      })
          .catch((error) => {
          console.error(error);
          throw new Error('Invalid Core response: not JSON');
      });
  }
  exports.sendCoreSessionRequest = sendCoreSessionRequest;
  /**
   * Get a core session token.  Generate an auth request, sign it, send it to Core,
   * and get back a session token.
   *
   * @param {String} coreHost Core API server's hostname
   * @param {Number} corePort Core API server's port number
   * @param {String} apiPassword core api password
   * @param  {String} appPrivateKey Application's private key
   * @param  {String} blockchainId blockchain ID of the user signing in.
   * `null` if user has no blockchain ID
   * @param {String} authRequest authentication request token
   * @param {String} deviceId identifier for the current device
   *
   * @return {Promise} a Promise that resolves to a Core session token or rejects
   * with an error message.
   * @deprecated
   * @private
   * @ignore
   */
  function getCoreSession(coreHost, corePort, apiPassword, appPrivateKey, blockchainId = null, authRequest = null, deviceId = '0') {
      if (!authRequest) {
          return Promise.reject('No authRequest provided');
      }
      try {
          const authRequestObject = jsontokens_1.decodeToken(authRequest);
          if (!authRequestObject) {
              return Promise.reject('Invalid authRequest in URL query string');
          }
          if (!authRequestObject.payload) {
              return Promise.reject('Invalid authRequest in URL query string');
          }
          const payload = authRequestObject.payload;
          if (typeof payload === 'string') {
              throw new Error('Unexpected token payload type of string');
          }
          const appDomain = payload.domain_name;
          if (!appDomain) {
              return Promise.reject('No domain_name in authRequest');
          }
          const appMethods = payload.scopes;
          const coreAuthRequest = makeCoreSessionRequest(appDomain, appMethods, appPrivateKey, blockchainId, deviceId);
          return sendCoreSessionRequest(coreHost, corePort, coreAuthRequest, apiPassword);
      }
      catch (e) {
          console.error(e.stack);
          return Promise.reject('Failed to parse authRequest in URL');
      }
  }
  exports.getCoreSession = getCoreSession;
  
  },{"../fetchUtil":59,"jsontokens":237}],39:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const tslib_1 = require("tslib");
  const jsontokens_1 = require("jsontokens");
  const dids_1 = require("../dids");
  const keys_1 = require("../keys");
  const utils_1 = require("../utils");
  const fetchUtil_1 = require("../fetchUtil");
  const authProvider_1 = require("./authProvider");
  /**
   * Checks if the ES256k signature on passed `token` match the claimed public key
   * in the payload key `public_keys`.
   *
   * @param  {String} token encoded and signed authentication token
   * @return {Boolean} Returns `true` if the signature matches the claimed public key
   * @throws {Error} if `token` contains multiple public keys
   * @private
   * @ignore
   */
  function doSignaturesMatchPublicKeys(token) {
      const payload = jsontokens_1.decodeToken(token).payload;
      if (typeof payload === 'string') {
          throw new Error('Unexpected token payload type of string');
      }
      const publicKeys = payload.public_keys;
      if (publicKeys.length === 1) {
          const publicKey = publicKeys[0];
          try {
              const tokenVerifier = new jsontokens_1.TokenVerifier('ES256k', publicKey);
              const signatureVerified = tokenVerifier.verify(token);
              if (signatureVerified) {
                  return true;
              }
              else {
                  return false;
              }
          }
          catch (e) {
              return false;
          }
      }
      else {
          throw new Error('Multiple public keys are not supported');
      }
  }
  exports.doSignaturesMatchPublicKeys = doSignaturesMatchPublicKeys;
  /**
   * Makes sure that the identity address portion of
   * the decentralized identifier passed in the issuer `iss`
   * key of the token matches the public key
   *
   * @param  {String} token encoded and signed authentication token
   * @return {Boolean} if the identity address and public keys match
   * @throws {Error} if ` token` has multiple public keys
   * @private
   * @ignore
   */
  function doPublicKeysMatchIssuer(token) {
      const payload = jsontokens_1.decodeToken(token).payload;
      if (typeof payload === 'string') {
          throw new Error('Unexpected token payload type of string');
      }
      const publicKeys = payload.public_keys;
      const addressFromIssuer = dids_1.getAddressFromDID(payload.iss);
      if (publicKeys.length === 1) {
          const addressFromPublicKeys = keys_1.publicKeyToAddress(publicKeys[0]);
          if (addressFromPublicKeys === addressFromIssuer) {
              return true;
          }
      }
      else {
          throw new Error('Multiple public keys are not supported');
      }
      return false;
  }
  exports.doPublicKeysMatchIssuer = doPublicKeysMatchIssuer;
  /**
   * Looks up the identity address that owns the claimed username
   * in `token` using the lookup endpoint provided in `nameLookupURL`
   * to determine if the username is owned by the identity address
   * that matches the claimed public key
   *
   * @param  {String} token  encoded and signed authentication token
   * @param  {String} nameLookupURL a URL to the name lookup endpoint of the Blockstack Core API
   * @return {Promise<Boolean>} returns a `Promise` that resolves to
   * `true` if the username is owned by the public key, otherwise the
   * `Promise` resolves to `false`
   * @private
   * @ignore
   */
  function doPublicKeysMatchUsername(token, nameLookupURL) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          try {
              const payload = jsontokens_1.decodeToken(token).payload;
              if (typeof payload === 'string') {
                  throw new Error('Unexpected token payload type of string');
              }
              if (!payload.username) {
                  return true;
              }
              if (payload.username === null) {
                  return true;
              }
              if (nameLookupURL === null) {
                  return false;
              }
              const username = payload.username;
              const url = `${nameLookupURL.replace(/\/$/, '')}/${username}`;
              const response = yield fetchUtil_1.fetchPrivate(url);
              const responseText = yield response.text();
              const responseJSON = JSON.parse(responseText);
              if (responseJSON.hasOwnProperty('address')) {
                  const nameOwningAddress = responseJSON.address;
                  const addressFromIssuer = dids_1.getAddressFromDID(payload.iss);
                  if (nameOwningAddress === addressFromIssuer) {
                      return true;
                  }
                  else {
                      return false;
                  }
              }
              else {
                  return false;
              }
          }
          catch (error) {
              console.log(error);
              console.log('Error checking `doPublicKeysMatchUsername`');
              return false;
          }
      });
  }
  exports.doPublicKeysMatchUsername = doPublicKeysMatchUsername;
  /**
   * Checks if the if the token issuance time and date is after the
   * current time and date.
   *
   * @param  {String}  token encoded and signed authentication token
   * @return {Boolean} `true` if the token was issued after the current time,
   * otherwise returns `false`
   * @private
   * @ignore
   */
  function isIssuanceDateValid(token) {
      const payload = jsontokens_1.decodeToken(token).payload;
      if (typeof payload === 'string') {
          throw new Error('Unexpected token payload type of string');
      }
      if (payload.iat) {
          if (typeof payload.iat !== 'number') {
              return false;
          }
          const issuedAt = new Date(payload.iat * 1000); // JWT times are in seconds
          if (new Date().getTime() < issuedAt.getTime()) {
              return false;
          }
          else {
              return true;
          }
      }
      else {
          return true;
      }
  }
  exports.isIssuanceDateValid = isIssuanceDateValid;
  /**
   * Checks if the expiration date of the `token` is before the current time
   * @param  {String}  token encoded and signed authentication token
   * @return {Boolean} `true` if the `token` has not yet expired, `false`
   * if the `token` has expired
   *
   * @private
   * @ignore
   */
  function isExpirationDateValid(token) {
      const payload = jsontokens_1.decodeToken(token).payload;
      if (typeof payload === 'string') {
          throw new Error('Unexpected token payload type of string');
      }
      if (payload.exp) {
          if (typeof payload.exp !== 'number') {
              return false;
          }
          const expiresAt = new Date(payload.exp * 1000); // JWT times are in seconds
          if (new Date().getTime() > expiresAt.getTime()) {
              return false;
          }
          else {
              return true;
          }
      }
      else {
          return true;
      }
  }
  exports.isExpirationDateValid = isExpirationDateValid;
  /**
   * Makes sure the `manifest_uri` is a same origin absolute URL.
   * @param  {String}  token encoded and signed authentication token
   * @return {Boolean} `true` if valid, otherwise `false`
   * @private
   * @ignore
   */
  function isManifestUriValid(token) {
      const payload = jsontokens_1.decodeToken(token).payload;
      if (typeof payload === 'string') {
          throw new Error('Unexpected token payload type of string');
      }
      return utils_1.isSameOriginAbsoluteUrl(payload.domain_name, payload.manifest_uri);
  }
  exports.isManifestUriValid = isManifestUriValid;
  /**
   * Makes sure the `redirect_uri` is a same origin absolute URL.
   * @param  {String}  token encoded and signed authentication token
   * @return {Boolean} `true` if valid, otherwise `false`
   * @private
   * @ignore
   */
  function isRedirectUriValid(token) {
      const payload = jsontokens_1.decodeToken(token).payload;
      if (typeof payload === 'string') {
          throw new Error('Unexpected token payload type of string');
      }
      return utils_1.isSameOriginAbsoluteUrl(payload.domain_name, payload.redirect_uri);
  }
  exports.isRedirectUriValid = isRedirectUriValid;
  /**
   * Verify authentication request is valid. This function performs a number
   * of checks on the authentication request token:
   * * Checks that `token` has a valid issuance date & is not expired
   * * Checks that `token` has a valid signature that matches the public key it claims
   * * Checks that both the manifest and redirect URLs are absolute and conform to
   * the same origin policy
   *
   * @param  {String} token encoded and signed authentication request token
   * @return {Promise} that resolves to true if the auth request
   *  is valid and false if it does not. It rejects with a String if the
   *  token is not signed
   * @private
   * @ignore
   */
  function verifyAuthRequest(token) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (jsontokens_1.decodeToken(token).header.alg === 'none') {
              throw new Error('Token must be signed in order to be verified');
          }
          const values = yield Promise.all([
              isExpirationDateValid(token),
              isIssuanceDateValid(token),
              doSignaturesMatchPublicKeys(token),
              doPublicKeysMatchIssuer(token),
              isManifestUriValid(token),
              isRedirectUriValid(token)
          ]);
          return values.every(val => val);
      });
  }
  exports.verifyAuthRequest = verifyAuthRequest;
  /**
   * Verify the authentication request is valid and
   * fetch the app manifest file if valid. Otherwise, reject the promise.
   * @param  {String} token encoded and signed authentication request token
   * @return {Promise} that resolves to the app manifest file in JSON format
   * or rejects if the auth request or app manifest file is invalid
   * @private
   * @ignore
   */
  function verifyAuthRequestAndLoadManifest(token) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const valid = yield verifyAuthRequest(token);
          if (!valid) {
              throw new Error('Token is an invalid auth request');
          }
          return authProvider_1.fetchAppManifest(token);
      });
  }
  exports.verifyAuthRequestAndLoadManifest = verifyAuthRequestAndLoadManifest;
  /**
   * Verify the authentication response is valid
   * @param {String} token the authentication response token
   * @param {String} nameLookupURL the url use to verify owner of a username
   * @return {Promise} that resolves to true if auth response
   * is valid and false if it does not
   * @private
   * @ignore
   */
  function verifyAuthResponse(token, nameLookupURL) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const values = yield Promise.all([
              isExpirationDateValid(token),
              isIssuanceDateValid(token),
              doSignaturesMatchPublicKeys(token),
              doPublicKeysMatchIssuer(token),
              doPublicKeysMatchUsername(token, nameLookupURL)
          ]);
          return values.every(val => val);
      });
  }
  exports.verifyAuthResponse = verifyAuthResponse;
  
  },{"../dids":47,"../fetchUtil":59,"../keys":61,"../utils":95,"./authProvider":37,"jsontokens":237,"tslib":268}],40:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  var appConfig_1 = require("./appConfig");
  exports.AppConfig = appConfig_1.AppConfig;
  var authMessages_1 = require("./authMessages");
  exports.makeAuthResponse = authMessages_1.makeAuthResponse;
  var authProvider_1 = require("./authProvider");
  exports.getAuthRequestFromURL = authProvider_1.getAuthRequestFromURL;
  exports.fetchAppManifest = authProvider_1.fetchAppManifest;
  exports.redirectUserToApp = authProvider_1.redirectUserToApp;
  var authSession_1 = require("./authSession");
  exports.makeCoreSessionRequest = authSession_1.makeCoreSessionRequest;
  exports.sendCoreSessionRequest = authSession_1.sendCoreSessionRequest;
  exports.getCoreSession = authSession_1.getCoreSession;
  var authVerification_1 = require("./authVerification");
  exports.verifyAuthRequest = authVerification_1.verifyAuthRequest;
  exports.verifyAuthResponse = authVerification_1.verifyAuthResponse;
  exports.isExpirationDateValid = authVerification_1.isExpirationDateValid;
  exports.isIssuanceDateValid = authVerification_1.isIssuanceDateValid;
  exports.doPublicKeysMatchUsername = authVerification_1.doPublicKeysMatchUsername;
  exports.doPublicKeysMatchIssuer = authVerification_1.doPublicKeysMatchIssuer;
  exports.doSignaturesMatchPublicKeys = authVerification_1.doSignaturesMatchPublicKeys;
  exports.isManifestUriValid = authVerification_1.isManifestUriValid;
  exports.isRedirectUriValid = authVerification_1.isRedirectUriValid;
  exports.verifyAuthRequestAndLoadManifest = authVerification_1.verifyAuthRequestAndLoadManifest;
  var authApp_1 = require("./authApp");
  exports.isUserSignedIn = authApp_1.isUserSignedIn;
  exports.redirectToSignIn = authApp_1.redirectToSignIn;
  exports.redirectToSignInWithAuthRequest = authApp_1.redirectToSignInWithAuthRequest;
  exports.isSignInPending = authApp_1.isSignInPending;
  exports.handlePendingSignIn = authApp_1.handlePendingSignIn;
  exports.loadUserData = authApp_1.loadUserData;
  exports.signUserOut = authApp_1.signUserOut;
  var authMessages_2 = require("./authMessages");
  exports.makeAuthRequest = authMessages_2.makeAuthRequest;
  
  },{"./appConfig":33,"./authApp":34,"./authMessages":36,"./authProvider":37,"./authSession":38,"./authVerification":39}],41:[function(require,module,exports){
  "use strict";
  /**
   * This logic is in a separate file with no dependencies so that it can be
   * loaded and executed as soon as possible to fulfill the purpose of the protocol
   * detection technique. The effectiveness of this is obviously subject to how web
   * apps bundle/consume the blockstack.js lib.
   */
  Object.defineProperty(exports, "__esModule", { value: true });
  const GLOBAL_DETECTION_CACHE_KEY = '_blockstackDidCheckEchoReply';
  const ECHO_REPLY_PARAM = 'echoReply';
  const AUTH_CONTINUATION_PARAM = 'authContinuation';
  function getQueryStringParams(query) {
      if (!query) {
          return {};
      }
      // Trim a starting `?` character if exists
      const trimmed = /^[?#]/.test(query) ? query.slice(1) : query;
      return trimmed
          .split('&')
          .reduce((params, param) => {
          const [key, value] = param.split('=');
          params[key] = value ? decodeURIComponent(value.replace(/\+/g, ' ')) : '';
          return params;
      }, {});
  }
  /**
   * Checks if the current window location URL contains an 'echoReply' parameter
   * which indicates that this page was only opened to signal back to the originating
   * tab that the protocol handler is installed.
   * If found, then localStorage events are used to notify the other tab,
   * and this page is redirected back to the Blockstack authenticator URL.
   * This function caches its result and will not trigger multiple redirects when
   * invoked multiple times.
   * @returns True if detected and the page will be automatically redirected.
   * @hidden
   */
  function protocolEchoReplyDetection() {
      // Check that the `window` APIs exist
      let globalScope;
      if (typeof self !== 'undefined') {
          globalScope = self;
      }
      else if (typeof window !== 'undefined') {
          globalScope = window;
      }
      else {
          // Exit detection function - we are not running in a browser environment.
          return false;
      }
      if (!globalScope.location || !globalScope.localStorage) {
          // Exit detection function - we are not running in a browser environment.
          return false;
      }
      // Avoid performing the check twice and triggered multiple redirect timers.
      const existingDetection = globalScope[GLOBAL_DETECTION_CACHE_KEY];
      if (typeof existingDetection === 'boolean') {
          return existingDetection;
      }
      const searchParams = getQueryStringParams(globalScope.location.search);
      const echoReplyParam = searchParams[ECHO_REPLY_PARAM];
      if (echoReplyParam) {
          globalScope[GLOBAL_DETECTION_CACHE_KEY] = true;
          // Use localStorage to notify originated tab that protocol handler is available and working.
          const echoReplyKey = `echo-reply-${echoReplyParam}`;
          // Set the echo-reply result in localStorage for the other window to see.
          globalScope.localStorage.setItem(echoReplyKey, 'success');
          // Redirect back to the localhost auth url, as opposed to another protocol launch.
          // This will re-use the same tab rather than creating another useless one.
          globalScope.setTimeout(() => {
              const authContinuationParam = searchParams[AUTH_CONTINUATION_PARAM];
              globalScope.location.href = authContinuationParam;
          }, 10);
          return true;
      }
      return false;
  }
  exports.protocolEchoReplyDetection = protocolEchoReplyDetection;
  
  },{}],42:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const utils_1 = require("../utils");
  const logger_1 = require("../logger");
  /**
   * Detects if the native auth-browser is installed and is successfully
   * launched via a custom protocol URI.
   * @param {String} authRequest
   * The encoded authRequest to be used as a query param in the custom URI.
   * @param {String} successCallback
   * The callback that is invoked when the protocol handler was detected.
   * @param {String} failCallback
   * The callback that is invoked when the protocol handler was not detected.
   * @return {void}
   */
  function launchCustomProtocol(authRequest, successCallback, failCallback) {
      // Create a unique ID used for this protocol detection attempt.
      const echoReplyID = Math.random().toString(36).substr(2, 9);
      const echoReplyKeyPrefix = 'echo-reply-';
      const echoReplyKey = `${echoReplyKeyPrefix}${echoReplyID}`;
      const { localStorage, document, setTimeout, clearTimeout, addEventListener, removeEventListener } = utils_1.getGlobalObjects(['localStorage', 'document', 'setTimeout', 'clearTimeout', 'addEventListener', 'removeEventListener'], { throwIfUnavailable: true, usageDesc: 'detectProtocolLaunch' });
      // Use localStorage as a reliable cross-window communication method.
      // Create the storage entry to signal a protocol detection attempt for the
      // next browser window to check.
      localStorage.setItem(echoReplyKey, Date.now().toString());
      const cleanUpLocalStorage = () => {
          try {
              localStorage.removeItem(echoReplyKey);
              // Also clear out any stale echo-reply keys older than 1 hour.
              for (let i = 0; i < localStorage.length; i++) {
                  const storageKey = localStorage.key(i);
                  if (storageKey && storageKey.startsWith(echoReplyKeyPrefix)) {
                      const storageValue = localStorage.getItem(storageKey);
                      if (storageValue === 'success' || (Date.now() - parseInt(storageValue, 10)) > 3600000) {
                          localStorage.removeItem(storageKey);
                      }
                  }
              }
          }
          catch (err) {
              logger_1.Logger.error('Exception cleaning up echo-reply entries in localStorage');
              logger_1.Logger.error(err);
          }
      };
      const detectionTimeout = 1000;
      let redirectToWebAuthTimer = 0;
      const cancelWebAuthRedirectTimer = () => {
          if (redirectToWebAuthTimer) {
              clearTimeout(redirectToWebAuthTimer);
              redirectToWebAuthTimer = 0;
          }
      };
      const startWebAuthRedirectTimer = (timeout = detectionTimeout) => {
          cancelWebAuthRedirectTimer();
          redirectToWebAuthTimer = setTimeout(() => {
              if (redirectToWebAuthTimer) {
                  cancelWebAuthRedirectTimer();
                  let nextFunc;
                  if (localStorage.getItem(echoReplyKey) === 'success') {
                      logger_1.Logger.info('Protocol echo reply detected.');
                      nextFunc = successCallback;
                  }
                  else {
                      logger_1.Logger.info('Protocol handler not detected.');
                      nextFunc = failCallback;
                  }
                  failCallback = () => { };
                  successCallback = () => { };
                  cleanUpLocalStorage();
                  // Briefly wait since localStorage changes can 
                  // sometimes be ignored when immediately redirected.
                  setTimeout(() => nextFunc(), 100);
              }
          }, timeout);
      };
      startWebAuthRedirectTimer();
      const inputPromptTracker = document.createElement('input');
      inputPromptTracker.type = 'text';
      // Setting display:none on an element prevents them from being focused/blurred.
      // So we hide using 0 width/height/opacity, and set position:fixed so that the
      // page does not scroll when the element is focused. 
      const hiddenCssStyle = 'all: initial; position: fixed; top: 0; height: 0; width: 0; opacity: 0;';
      inputPromptTracker.style.cssText = hiddenCssStyle;
      // If the the focus of a page element is immediately changed then this likely indicates 
      // the protocol handler is installed, and the browser is prompting the user if they want 
      // to open the application. 
      const inputBlurredFunc = () => {
          // Use a timeout of 100ms to ignore instant toggles between blur and focus.
          // Browsers often perform an instant blur & focus when the protocol handler is working
          // but not showing any browser prompts, so we want to ignore those instances.
          let isRefocused = false;
          inputPromptTracker.addEventListener('focus', () => { isRefocused = true; }, { once: true, capture: true });
          setTimeout(() => {
              if (redirectToWebAuthTimer && !isRefocused) {
                  logger_1.Logger.info('Detected possible browser prompt for opening the protocol handler app.');
                  clearTimeout(redirectToWebAuthTimer);
                  inputPromptTracker.addEventListener('focus', () => {
                      if (redirectToWebAuthTimer) {
                          logger_1.Logger.info('Possible browser prompt closed, restarting auth redirect timeout.');
                          startWebAuthRedirectTimer();
                      }
                  }, { once: true, capture: true });
              }
          }, 100);
      };
      inputPromptTracker.addEventListener('blur', inputBlurredFunc, { once: true, capture: true });
      setTimeout(() => inputPromptTracker.removeEventListener('blur', inputBlurredFunc), 200);
      document.body.appendChild(inputPromptTracker);
      inputPromptTracker.focus();
      // Detect if document.visibility is immediately changed which is a strong 
      // indication that the protocol handler is working. We don't know for sure and 
      // can't predict future browser changes, so only increase the redirect timeout.
      // This reduces the probability of a false-negative (where local auth works, but 
      // the original page was redirect to web auth because something took too long),
      const pageVisibilityChanged = () => {
          if (document.hidden && redirectToWebAuthTimer) {
              logger_1.Logger.info('Detected immediate page visibility change (protocol handler probably working).');
              startWebAuthRedirectTimer(3000);
          }
      };
      document.addEventListener('visibilitychange', pageVisibilityChanged, { once: true, capture: true });
      setTimeout(() => document.removeEventListener('visibilitychange', pageVisibilityChanged), 500);
      // Listen for the custom protocol echo reply via localStorage update event.
      addEventListener('storage', function replyEventListener(event) {
          if (event.key === echoReplyKey && localStorage.getItem(echoReplyKey) === 'success') {
              // Custom protocol worked, cancel the web auth redirect timer.
              cancelWebAuthRedirectTimer();
              inputPromptTracker.removeEventListener('blur', inputBlurredFunc);
              logger_1.Logger.info('Protocol echo reply detected from localStorage event.');
              // Clean up event listener and localStorage.
              removeEventListener('storage', replyEventListener);
              const nextFunc = successCallback;
              successCallback = () => { };
              failCallback = () => { };
              cleanUpLocalStorage();
              // Briefly wait since localStorage changes can sometimes 
              // be ignored when immediately redirected.
              setTimeout(() => nextFunc(), 100);
          }
      }, false);
      // Use iframe technique for launching the protocol URI rather than setting `window.location`.
      // This method prevents browsers like Safari, Opera, Firefox from showing error prompts
      // about unknown protocol handler when app is not installed, and avoids an empty
      // browser tab when the app is installed. 
      logger_1.Logger.info('Attempting protocol launch via iframe injection.');
      const locationSrc = `${utils_1.BLOCKSTACK_HANDLER}:${authRequest}&echo=${echoReplyID}`;
      const iframe = document.createElement('iframe');
      const iframeStyle = 'all: initial; display: none; position: fixed; top: 0; height: 0; width: 0; opacity: 0;';
      iframe.style.cssText = iframeStyle;
      iframe.src = locationSrc;
      document.body.appendChild(iframe);
  }
  exports.launchCustomProtocol = launchCustomProtocol;
  
  },{"../logger":62,"../utils":95}],43:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const errors_1 = require("../errors");
  const SESSION_VERSION = '1.0.0';
  /**
   * @ignore
   */
  class SessionData {
      constructor(options) {
          this.version = SESSION_VERSION;
          this.userData = options.userData;
          this.transitKey = options.transitKey;
      }
      getGaiaHubConfig() {
          return this.userData && this.userData.gaiaHubConfig;
      }
      setGaiaHubConfig(config) {
          this.userData.gaiaHubConfig = config;
      }
      static fromJSON(json) {
          if (json.version !== SESSION_VERSION) {
              throw new errors_1.InvalidStateError(`JSON data version ${json.version} not supported by SessionData`);
          }
          const options = {
              coreNode: json.coreNode,
              userData: json.userData,
              transitKey: json.transitKey
          };
          return new SessionData(options);
      }
      toString() {
          return JSON.stringify(this);
      }
  }
  exports.SessionData = SessionData;
  
  },{"../errors":58}],44:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const sessionData_1 = require("./sessionData");
  // import { BLOCKSTACK_GAIA_HUB_LABEL } from '../storage/hub'
  const authConstants_1 = require("./authConstants");
  const errors_1 = require("../errors");
  // import { Logger } from '../logger'
  /**
   * An abstract class representing the SessionDataStore interface.
  
   */
  class SessionDataStore {
      constructor(sessionOptions) {
          if (sessionOptions) {
              const newSessionData = new sessionData_1.SessionData(sessionOptions);
              this.setSessionData(newSessionData);
          }
      }
      getSessionData() {
          throw new Error('Abstract class');
      }
      /* eslint-disable */
      setSessionData(session) {
          throw new Error('Abstract class');
      }
      deleteSessionData() {
          throw new Error('Abstract class');
      }
  }
  exports.SessionDataStore = SessionDataStore;
  /**
   * Stores session data in the instance of this class.
   * @ignore
   */
  class InstanceDataStore extends SessionDataStore {
      constructor(sessionOptions) {
          super(sessionOptions);
          if (!this.sessionData) {
              this.setSessionData(new sessionData_1.SessionData({}));
          }
      }
      getSessionData() {
          if (!this.sessionData) {
              throw new errors_1.NoSessionDataError('No session data was found.');
          }
          return this.sessionData;
      }
      setSessionData(session) {
          this.sessionData = session;
          return true;
      }
      deleteSessionData() {
          this.setSessionData(new sessionData_1.SessionData({}));
          return true;
      }
  }
  exports.InstanceDataStore = InstanceDataStore;
  /**
   * Stores session data in browser a localStorage entry.
   * @ignore
   */
  class LocalStorageStore extends SessionDataStore {
      constructor(sessionOptions) {
          super(sessionOptions);
          if (sessionOptions
              && sessionOptions.storeOptions
              && sessionOptions.storeOptions.localStorageKey
              && (typeof sessionOptions.storeOptions.localStorageKey === 'string')) {
              this.key = sessionOptions.storeOptions.localStorageKey;
          }
          else {
              this.key = authConstants_1.LOCALSTORAGE_SESSION_KEY;
          }
          const data = localStorage.getItem(this.key);
          if (!data) {
              const sessionData = new sessionData_1.SessionData({});
              this.setSessionData(sessionData);
          }
      }
      getSessionData() {
          const data = localStorage.getItem(this.key);
          if (!data) {
              throw new errors_1.NoSessionDataError('No session data was found in localStorage');
          }
          const dataJSON = JSON.parse(data);
          return sessionData_1.SessionData.fromJSON(dataJSON);
      }
      setSessionData(session) {
          localStorage.setItem(this.key, session.toString());
          return true;
      }
      deleteSessionData() {
          localStorage.removeItem(this.key);
          this.setSessionData(new sessionData_1.SessionData({}));
          return true;
      }
  }
  exports.LocalStorageStore = LocalStorageStore;
  
  },{"../errors":58,"./authConstants":35,"./sessionData":43}],45:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const tslib_1 = require("tslib");
  const appConfig_1 = require("./appConfig");
  const sessionStore_1 = require("./sessionStore");
  const authApp = require("./authApp");
  const authMessages = require("./authMessages");
  const storage = require("../storage");
  const utils_1 = require("../utils");
  const errors_1 = require("../errors");
  const logger_1 = require("../logger");
  const hub_1 = require("../storage/hub");
  const authConstants_1 = require("./authConstants");
  /**
   *
   * Represents an instance of a signed in user for a particular app.
   *
   * A signed in user has access to two major pieces of information
   * about the user, the user's private key for that app and the location
   * of the user's gaia storage bucket for the app.
   *
   * A user can be signed in either directly through the interactive
   * sign in process or by directly providing the app private key.
   *
  
   *
   */
  class UserSession {
      /**
       * Creates a UserSession object
       *
       * @param options
       */
      constructor(options) {
          let runningInBrowser = true;
          if (typeof window === 'undefined' && typeof self === 'undefined') {
              logger_1.Logger.debug('UserSession: not running in browser');
              runningInBrowser = false;
          }
          if (options && options.appConfig) {
              this.appConfig = options.appConfig;
          }
          else if (runningInBrowser) {
              this.appConfig = new appConfig_1.AppConfig();
          }
          else {
              throw new errors_1.MissingParameterError('You need to specify options.appConfig');
          }
          if (options && options.sessionStore) {
              this.store = options.sessionStore;
          }
          else if (runningInBrowser) {
              if (options) {
                  this.store = new sessionStore_1.LocalStorageStore(options.sessionOptions);
              }
              else {
                  this.store = new sessionStore_1.LocalStorageStore();
              }
          }
          else if (options) {
              this.store = new sessionStore_1.InstanceDataStore(options.sessionOptions);
          }
          else {
              this.store = new sessionStore_1.InstanceDataStore();
          }
      }
      /**
       * Generates an authentication request and redirects the user to the Blockstack
       * browser to approve the sign in request.
       *
       * Please note that this requires that the web browser properly handles the
       * `blockstack:` URL protocol handler.
       *
       * Most applications should use this
       * method for sign in unless they require more fine grained control over how the
       * authentication request is generated. If your app falls into this category,
       * use [[generateAndStoreTransitKey]], [[makeAuthRequest]],
       * and [[redirectToSignInWithAuthRequest]] to build your own sign in process.
       *
       * @param redirectURI Location of your application.
       * @param manifestURI Location of the manifest.json file
       * @param scopes Permissions requested by the application. Possible values are
       *  `store_write` (default) or `publish_data`.
       *
       * @returns {void}
       */
      redirectToSignIn(redirectURI, manifestURI, scopes) {
          const transitKey = this.generateAndStoreTransitKey();
          const authRequest = this.makeAuthRequest(transitKey, redirectURI, manifestURI, scopes);
          const authenticatorURL = this.appConfig && this.appConfig.authenticatorURL;
          return authApp.redirectToSignInWithAuthRequest(authRequest, authenticatorURL);
      }
      /**
       * Redirects the user to the Blockstack browser to approve the sign in request.
       * To construct a request see the [[makeAuthRequest]] function.
       *
       * The user is redirected to the authenticator URL specified in the `AppConfig`
       * if the `blockstack:` protocol handler is not detected.
       * Please note that the protocol handler detection does not work on all browsers.
       *
       * @param authRequest A request string built by the [[makeAuthRequest]] function
       * @param blockstackIDHost The ID of the Blockstack Browser application.
       *
       */
      redirectToSignInWithAuthRequest(authRequest, blockstackIDHost) {
          authRequest = authRequest || this.makeAuthRequest();
          const authenticatorURL = blockstackIDHost
              || (this.appConfig && this.appConfig.authenticatorURL);
          return authApp.redirectToSignInWithAuthRequest(authRequest, authenticatorURL);
      }
      /**
       * Generates an authentication request that can be sent to the Blockstack
       * browser for the user to approve sign in. This authentication request can
       * then be used for sign in by passing it to the [[redirectToSignInWithAuthRequest]]
       * method.
       *
       * *Note*: This method should only be used if you want to use a customized authentication
       * flow. Typically, you'd use [[redirectToSignIn]] which is the default sign in method.
       *
       * @param transitKey A HEX encoded transit private key.
       * @param redirectURI Location to redirect the user to after sign in approval.
       * @param manifestURI Location of this app's manifest file.
       * @param scopes The permissions this app is requesting. The default is `store_write`.
       * @param appDomain The origin of the app.
       * @param expiresAt The time at which this request is no longer valid.
       * @param extraParams Any extra parameters to pass to the authenticator. Use this to
       * pass options that aren't part of the Blockstack authentication specification,
       * but might be supported by special authenticators.
       *
       * @returns {String} the authentication request
       */
      makeAuthRequest(transitKey, redirectURI, manifestURI, scopes, appDomain, expiresAt = utils_1.nextHour().getTime(), extraParams = {}) {
          const appConfig = this.appConfig;
          if (!appConfig) {
              throw new errors_1.InvalidStateError('Missing AppConfig');
          }
          transitKey = transitKey || this.generateAndStoreTransitKey();
          redirectURI = redirectURI || appConfig.redirectURI();
          manifestURI = manifestURI || appConfig.manifestURI();
          scopes = scopes || appConfig.scopes;
          appDomain = appDomain || appConfig.appDomain;
          return authMessages.makeAuthRequest(transitKey, redirectURI, manifestURI, scopes, appDomain, expiresAt, extraParams);
      }
      /**
       * Generates a ECDSA keypair to
       * use as the ephemeral app transit private key
       * and store in the session.
       *
       * @returns {String} the hex encoded private key
       *
       */
      generateAndStoreTransitKey() {
          const sessionData = this.store.getSessionData();
          const transitKey = authMessages.generateTransitKey();
          sessionData.transitKey = transitKey;
          this.store.setSessionData(sessionData);
          return transitKey;
      }
      /**
       * Retrieve the authentication token from the URL query.
       *
       * @returns {String} the authentication token if it exists otherwise `null`
       */
      getAuthResponseToken() {
          return authApp.getAuthResponseToken();
      }
      /**
       * Check if there is a authentication request that hasn't been handled.
       *
       * @returns{Boolean} `true` if there is a pending sign in, otherwise `false`
       */
      isSignInPending() {
          return authApp.isSignInPending();
      }
      /**
       * Check if a user is currently signed in.
       *
       * @returns {Boolean} `true` if the user is signed in, `false` if not.
       */
      isUserSignedIn() {
          return !!this.store.getSessionData().userData;
      }
      /**
       * Try to process any pending sign in request by returning a `Promise` that resolves
       * to the user data object if the sign in succeeds.
       *
       * @param {String} authResponseToken - the signed authentication response token
       * @returns {Promise} that resolves to the user data object if successful and rejects
       * if handling the sign in request fails or there was no pending sign in request.
       */
      handlePendingSignIn(authResponseToken = this.getAuthResponseToken()) {
          const transitKey = this.store.getSessionData().transitKey;
          return authApp.handlePendingSignIn(undefined, authResponseToken, transitKey, this);
      }
      /**
       * Retrieves the user data object. The user's profile is stored in the key [[Profile]].
       *
       * @returns {Object} User data object.
       */
      loadUserData() {
          const userData = this.store.getSessionData().userData;
          if (!userData) {
              throw new errors_1.InvalidStateError('No user data found. Did the user sign in?');
          }
          return userData;
      }
      /**
       * Sign the user out and optionally redirect to given location.
       * @param  redirectURL Location to redirect user to after sign out.
       * Only used in environments with `window` available
       */
      signUserOut(redirectURL) {
          authApp.signUserOut(redirectURL, this);
      }
      /**
       * Encrypts the data provided with the app public key.
       * @param {String|Buffer} content  the data to encrypt
       * @param {String} options.publicKey the hex string of the ECDSA public
       * key to use for encryption. If not provided, will use user's appPrivateKey.
       *
       * @returns {String} Stringified ciphertext object
       */
      encryptContent(content, options) {
          return storage.encryptContent(content, options, this);
      }
      /**
       * Decrypts data encrypted with `encryptContent` with the
       * transit private key.
       * @param {String|Buffer} content - encrypted content.
       * @param {String} options.privateKey - The hex string of the ECDSA private
       * key to use for decryption. If not provided, will use user's appPrivateKey.
       * @returns {String|Buffer} decrypted content.
       */
      decryptContent(content, options) {
          return storage.decryptContent(content, options, this);
      }
      /**
       * Stores the data provided in the app's data store to to the file specified.
       * @param {String} path - the path to store the data in
       * @param {String|Buffer} content - the data to store in the file
       * @param options a [[PutFileOptions]] object
       *
       * @returns {Promise} that resolves if the operation succeed and rejects
       * if it failed
       */
      putFile(path, content, options) {
          return storage.putFile(path, content, options, this);
      }
      /**
       * Retrieves the specified file from the app's data store.
       *
       * @param {String} path - the path to the file to read
       * @param {Object} options a [[GetFileOptions]] object
       *
       * @returns {Promise} that resolves to the raw data in the file
       * or rejects with an error
       */
      getFile(path, options) {
          return storage.getFile(path, options, this);
      }
      /**
       * Get the URL for reading a file from an app's data store.
       *
       * @param {String} path - the path to the file to read
       *
       * @returns {Promise<string>} that resolves to the URL or rejects with an error
       */
      getFileUrl(path, options) {
          return storage.getFileUrl(path, options, this);
      }
      /**
       * List the set of files in this application's Gaia storage bucket.
       *
       * @param {function} callback - a callback to invoke on each named file that
       * returns `true` to continue the listing operation or `false` to end it
       *
       * @returns {Promise} that resolves to the number of files listed
       */
      listFiles(callback) {
          return storage.listFiles(callback, this);
      }
      /**
       * Deletes the specified file from the app's data store.
       * @param path - The path to the file to delete.
       * @param options - Optional options object.
       * @param options.wasSigned - Set to true if the file was originally signed
       * in order for the corresponding signature file to also be deleted.
       * @returns Resolves when the file has been removed or rejects with an error.
       */
      deleteFile(path, options) {
          return storage.deleteFile(path, options, this);
      }
      /**
       *  @ignore
       */
      getOrSetLocalGaiaHubConnection() {
          const sessionData = this.store.getSessionData();
          const userData = sessionData.userData;
          if (!userData) {
              throw new errors_1.InvalidStateError('Missing userData');
          }
          const hubConfig = userData.gaiaHubConfig;
          if (hubConfig) {
              return Promise.resolve(hubConfig);
          }
          return this.setLocalGaiaHubConnection();
      }
      /**
       * These two functions are app-specific connections to gaia hub,
       *   they read the user data object for information on setting up
       *   a hub connection, and store the hub config to localstorage
       * @private
       * @returns {Promise} that resolves to the new gaia hub connection
       */
      setLocalGaiaHubConnection() {
          return tslib_1.__awaiter(this, void 0, void 0, function* () {
              const userData = this.loadUserData();
              if (!userData) {
                  throw new errors_1.InvalidStateError('Missing userData');
              }
              if (!userData.hubUrl) {
                  userData.hubUrl = authConstants_1.BLOCKSTACK_DEFAULT_GAIA_HUB_URL;
              }
              const gaiaConfig = yield hub_1.connectToGaiaHub(userData.hubUrl, userData.appPrivateKey, userData.gaiaAssociationToken);
              userData.gaiaHubConfig = gaiaConfig;
              const sessionData = this.store.getSessionData();
              sessionData.userData.gaiaHubConfig = gaiaConfig;
              this.store.setSessionData(sessionData);
              return gaiaConfig;
          });
      }
  }
  exports.UserSession = UserSession;
  
  },{"../errors":58,"../logger":62,"../storage":94,"../storage/hub":93,"../utils":95,"./appConfig":33,"./authApp":34,"./authConstants":35,"./authMessages":36,"./sessionStore":44,"tslib":268}],46:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const network_1 = require("./network");
  /**
  * @ignore
  */
  const config = {
      network: network_1.network.defaults.MAINNET_DEFAULT,
      logLevel: 'debug'
  };
  exports.config = config;
  
  },{"./network":63}],47:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const errors_1 = require("./errors");
  /**
  * @ignore
  */
  function makeDIDFromAddress(address) {
      return `did:btc-addr:${address}`;
  }
  exports.makeDIDFromAddress = makeDIDFromAddress;
  /**
  * @ignore
  */
  function makeDIDFromPublicKey(publicKey) {
      return `did:ecdsa-pub:${publicKey}`;
  }
  exports.makeDIDFromPublicKey = makeDIDFromPublicKey;
  /**
  * @ignore
  */
  function getDIDType(decentralizedID) {
      const didParts = decentralizedID.split(':');
      if (didParts.length !== 3) {
          throw new errors_1.InvalidDIDError('Decentralized IDs must have 3 parts');
      }
      if (didParts[0].toLowerCase() !== 'did') {
          throw new errors_1.InvalidDIDError('Decentralized IDs must start with "did"');
      }
      return didParts[1].toLowerCase();
  }
  exports.getDIDType = getDIDType;
  /**
  * @ignore
  */
  function getAddressFromDID(decentralizedID) {
      const didType = getDIDType(decentralizedID);
      if (didType === 'btc-addr') {
          return decentralizedID.split(':')[2];
      }
      else {
          return null;
      }
  }
  exports.getAddressFromDID = getAddressFromDID;
  /*
  export function getPublicKeyOrAddressFromDID(decentralizedID) {
    const didParts = decentralizedID.split(':')
  
    if (didParts.length !== 3) {
      throw new InvalidDIDError('Decentralized IDs must have 3 parts')
    }
  
    if (didParts[0].toLowerCase() !== 'did') {
      throw new InvalidDIDError('Decentralized IDs must start with "did"')
    }
  
    if (didParts[1].toLowerCase() === 'ecdsa-pub') {
      return didParts[2]
    } else if (didParts[1].toLowerCase() === 'btc-addr') {
      return didParts[2]
    } else {
      throw new InvalidDIDError('Decentralized ID format not supported')
    }
  }
  */
  
  },{"./errors":58}],48:[function(require,module,exports){
  (function (Buffer){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const tslib_1 = require("tslib");
  const cryptoUtils_1 = require("./cryptoUtils");
  class NodeCryptoAesCipher {
      constructor(createCipher, createDecipher) {
          this.createCipher = createCipher;
          this.createDecipher = createDecipher;
      }
      encrypt(algorithm, key, iv, data) {
          return tslib_1.__awaiter(this, void 0, void 0, function* () {
              if (algorithm !== 'aes-128-cbc' && algorithm !== 'aes-256-cbc') {
                  throw new Error(`Unsupported cipher algorithm "${algorithm}"`);
              }
              const cipher = this.createCipher(algorithm, key, iv);
              const result = Buffer.concat([cipher.update(data), cipher.final()]);
              return Promise.resolve(result);
          });
      }
      decrypt(algorithm, key, iv, data) {
          return tslib_1.__awaiter(this, void 0, void 0, function* () {
              if (algorithm !== 'aes-128-cbc' && algorithm !== 'aes-256-cbc') {
                  throw new Error(`Unsupported cipher algorithm "${algorithm}"`);
              }
              const cipher = this.createDecipher(algorithm, key, iv);
              const result = Buffer.concat([cipher.update(data), cipher.final()]);
              return Promise.resolve(result);
          });
      }
  }
  exports.NodeCryptoAesCipher = NodeCryptoAesCipher;
  class WebCryptoAesCipher {
      constructor(subtleCrypto) {
          this.subtleCrypto = subtleCrypto;
      }
      encrypt(algorithm, key, iv, data) {
          return tslib_1.__awaiter(this, void 0, void 0, function* () {
              let algo;
              let length;
              if (algorithm === 'aes-128-cbc') {
                  algo = 'AES-CBC';
                  length = 128;
              }
              else if (algorithm === 'aes-256-cbc') {
                  algo = 'AES-CBC';
                  length = 256;
              }
              else {
                  throw new Error(`Unsupported cipher algorithm "${algorithm}"`);
              }
              const cryptoKey = yield this.subtleCrypto.importKey('raw', key, { name: algo, length }, false, ['encrypt']);
              const result = yield this.subtleCrypto.encrypt({ name: algo, iv }, cryptoKey, data);
              return Buffer.from(result);
          });
      }
      decrypt(algorithm, key, iv, data) {
          return tslib_1.__awaiter(this, void 0, void 0, function* () {
              let algo;
              let length;
              if (algorithm === 'aes-128-cbc') {
                  algo = 'AES-CBC';
                  length = 128;
              }
              else if (algorithm === 'aes-256-cbc') {
                  algo = 'AES-CBC';
                  length = 256;
              }
              else {
                  throw new Error(`Unsupported cipher algorithm "${algorithm}"`);
              }
              const cryptoKey = yield this.subtleCrypto.importKey('raw', key, { name: algo, length }, false, ['decrypt']);
              const result = yield this.subtleCrypto.decrypt({ name: algo, iv }, cryptoKey, data);
              return Buffer.from(result);
          });
      }
  }
  exports.WebCryptoAesCipher = WebCryptoAesCipher;
  function createCipher() {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const cryptoLib = yield cryptoUtils_1.getCryptoLib();
          if (cryptoLib.name === 'subtleCrypto') {
              return new WebCryptoAesCipher(cryptoLib.lib);
          }
          else {
              return new NodeCryptoAesCipher(cryptoLib.lib.createCipheriv, cryptoLib.lib.createDecipheriv);
          }
      });
  }
  exports.createCipher = createCipher;
  
  }).call(this,require("buffer").Buffer)
  },{"./cryptoUtils":50,"buffer":3,"tslib":268}],49:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const randombytes = require("randombytes");
  exports.randomBytes = randombytes;
  
  },{"randombytes":251}],50:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const tslib_1 = require("tslib");
  function isSubtleCryptoAvailable() {
      return typeof crypto !== 'undefined' && typeof crypto.subtle !== 'undefined';
  }
  exports.isSubtleCryptoAvailable = isSubtleCryptoAvailable;
  function isNodeCryptoAvailable(withFeature) {
      try {
          const resolvedResult = require.resolve('crypto');
          if (!resolvedResult) {
              return false;
          }
          // eslint-disable-next-line import/no-nodejs-modules,no-restricted-modules,global-require
          const cryptoModule = require('crypto');
          if (!cryptoModule) {
              return false;
          }
          if (withFeature) {
              const features = withFeature(cryptoModule);
              return features;
          }
          return true;
      }
      catch (error) {
          return false;
      }
  }
  exports.isNodeCryptoAvailable = isNodeCryptoAvailable;
  exports.NO_CRYPTO_LIB = 'Crypto lib not found. Either the WebCrypto "crypto.subtle" or Node.js "crypto" module must be available.';
  // Make async for future version which may lazy load.
  // eslint-disable-next-line @typescript-eslint/require-await
  function getCryptoLib() {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (isSubtleCryptoAvailable()) {
              return {
                  lib: crypto.subtle,
                  name: 'subtleCrypto'
              };
          }
          else {
              try {
                  // eslint-disable-next-line max-len
                  // eslint-disable-next-line import/no-nodejs-modules,no-restricted-modules,global-require,@typescript-eslint/no-var-requires
                  const nodeCrypto = require('crypto');
                  return {
                      lib: nodeCrypto,
                      name: 'nodeCrypto'
                  };
              }
              catch (error) {
                  throw new Error(exports.NO_CRYPTO_LIB);
              }
          }
      });
  }
  exports.getCryptoLib = getCryptoLib;
  
  },{"crypto":2,"tslib":268}],51:[function(require,module,exports){
  (function (Buffer){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const tslib_1 = require("tslib");
  const elliptic_1 = require("elliptic");
  const cryptoRandom_1 = require("./cryptoRandom");
  const errors_1 = require("../errors");
  const keys_1 = require("../keys");
  const sha2Hash_1 = require("./sha2Hash");
  const hmacSha256_1 = require("./hmacSha256");
  const aesCipher_1 = require("./aesCipher");
  const utils_1 = require("../utils");
  const ecurve = new elliptic_1.ec('secp256k1');
  /**
  * @ignore
  */
  function aes256CbcEncrypt(iv, key, plaintext) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const cipher = yield aesCipher_1.createCipher();
          const result = yield cipher.encrypt('aes-256-cbc', key, iv, plaintext);
          return result;
      });
  }
  exports.aes256CbcEncrypt = aes256CbcEncrypt;
  /**
  * @ignore
  */
  function aes256CbcDecrypt(iv, key, ciphertext) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const cipher = yield aesCipher_1.createCipher();
          const result = yield cipher.decrypt('aes-256-cbc', key, iv, ciphertext);
          return result;
      });
  }
  /**
  * @ignore
  */
  function hmacSha256(key, content) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const hmacSha256 = yield hmacSha256_1.createHmacSha256();
          return hmacSha256.digest(key, content);
      });
  }
  /**
  * @ignore
  */
  function equalConstTime(b1, b2) {
      if (b1.length !== b2.length) {
          return false;
      }
      let res = 0;
      for (let i = 0; i < b1.length; i++) {
          res |= b1[i] ^ b2[i]; // jshint ignore:line
      }
      return res === 0;
  }
  /**
  * @ignore
  */
  function sharedSecretToKeys(sharedSecret) {
      // generate mac and encryption key from shared secret
      const hashedSecret = sha2Hash_1.hashSha512Sync(sharedSecret);
      return {
          encryptionKey: hashedSecret.slice(0, 32),
          hmacKey: hashedSecret.slice(32)
      };
  }
  /**
   * Hex encodes a 32-byte BN.js instance.
   * The result string is zero padded and always 64 characters in length.
   * @ignore
   */
  function getHexFromBN(bnInput) {
      const hexOut = bnInput.toString('hex', 64);
      if (hexOut.length === 64) {
          return hexOut;
      }
      else if (hexOut.length < 64) {
          // pad with leading zeros
          // the padStart function would require node 9
          const padding = '0'.repeat(64 - hexOut.length);
          return `${padding}${hexOut}`;
      }
      else {
          throw new Error('Generated a > 32-byte BN for encryption. Failing.');
      }
  }
  exports.getHexFromBN = getHexFromBN;
  /**
   * Returns a big-endian encoded 32-byte BN.js instance.
   * The result Buffer is zero padded and always 32 bytes in length.
   * @ignore
   */
  function getBufferFromBN(bnInput) {
      const result = bnInput.toArrayLike(Buffer, 'be', 32);
      if (result.byteLength !== 32) {
          throw new Error('Generated a 32-byte BN for encryption. Failing.');
      }
      return result;
  }
  exports.getBufferFromBN = getBufferFromBN;
  /**
   * Get details about the JSON envelope size overhead for ciphertext payloads.
   * @ignore
   */
  function getCipherObjectWrapper(opts) {
      // Placeholder structure of the ciphertext payload, used to determine the 
      // stringified JSON overhead length. 
      const shell = {
          iv: '',
          ephemeralPK: '',
          mac: '',
          cipherText: '',
          wasString: !!opts.wasString,
      };
      if (opts.cipherTextEncoding === 'base64') {
          shell.cipherTextEncoding = 'base64';
      }
      // Hex encoded 16 byte buffer.
      const ivLength = 32;
      // Hex encoded, compressed EC pubkey of 33 bytes.
      const ephemeralPKLength = 66;
      // Hex encoded 32 byte hmac-sha256.
      const macLength = 64;
      return {
          payloadValuesLength: ivLength + ephemeralPKLength + macLength,
          payloadShell: JSON.stringify(shell)
      };
  }
  exports.getCipherObjectWrapper = getCipherObjectWrapper;
  /**
   * Get details about the JSON envelope size overhead for signed ciphertext payloads.
   * @param payloadShell - The JSON stringified empty `CipherObject`
   * @ignore
   */
  function getSignedCipherObjectWrapper(payloadShell) {
      // Placeholder structure of the signed ciphertext payload, used to determine the 
      // stringified JSON overhead length. 
      const shell = {
          signature: '',
          publicKey: '',
          cipherText: payloadShell
      };
      // Hex encoded DER signature, up to 72 byte length. 
      const signatureLength = 144;
      // Hex encoded 33 byte public key.
      const publicKeyLength = 66;
      return {
          signedPayloadValuesLength: signatureLength + publicKeyLength,
          signedPayloadShell: JSON.stringify(shell)
      };
  }
  exports.getSignedCipherObjectWrapper = getSignedCipherObjectWrapper;
  /**
   * Fast function that determines the final ASCII string byte length of the
   * JSON stringified ECIES encrypted payload.
   * @ignore
   */
  function eciesGetJsonStringLength(opts) {
      const { payloadShell, payloadValuesLength } = getCipherObjectWrapper(opts);
      // Calculate the AES output length given the input length. 
      const cipherTextLength = utils_1.getAesCbcOutputLength(opts.contentLength);
      // Get the encoded string length of the cipherText. 
      let encodedCipherTextLength;
      if (!opts.cipherTextEncoding || opts.cipherTextEncoding === 'hex') {
          encodedCipherTextLength = (cipherTextLength * 2);
      }
      else if (opts.cipherTextEncoding === 'base64') {
          encodedCipherTextLength = utils_1.getBase64OutputLength(cipherTextLength);
      }
      else {
          throw new Error(`Unexpected cipherTextEncoding "${opts.cipherTextEncoding}"`);
      }
      if (!opts.sign) {
          // Add the length of the JSON envelope, ciphertext length, and length of const values.
          return payloadShell.length
              + payloadValuesLength
              + encodedCipherTextLength;
      }
      else {
          // Get the signed version of the JSON envelope
          const { signedPayloadShell, signedPayloadValuesLength } = getSignedCipherObjectWrapper(payloadShell);
          // Add length of the JSON envelope, ciphertext length, and length of the const values. 
          return signedPayloadShell.length
              + signedPayloadValuesLength
              + payloadValuesLength
              + encodedCipherTextLength;
      }
  }
  exports.eciesGetJsonStringLength = eciesGetJsonStringLength;
  /**
   * Encrypt content to elliptic curve publicKey using ECIES
   * @param publicKey - secp256k1 public key hex string
   * @param content - content to encrypt
   * @return Object containing:
   *  iv (initialization vector, hex encoding),
   *  cipherText (cipher text either hex or base64 encoded),
   *  mac (message authentication code, hex encoded),
   *  ephemeral public key (hex encoded),
   *  wasString (boolean indicating with or not to return a buffer or string on decrypt)
   * @private
   * @ignore
   */
  function encryptECIES(publicKey, content, wasString, cipherTextEncoding) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const ecPK = ecurve.keyFromPublic(publicKey, 'hex').getPublic();
          const ephemeralSK = ecurve.genKeyPair();
          const ephemeralPK = Buffer.from(ephemeralSK.getPublic().encodeCompressed());
          const sharedSecret = ephemeralSK.derive(ecPK);
          const sharedSecretBuffer = getBufferFromBN(sharedSecret);
          const sharedKeys = sharedSecretToKeys(sharedSecretBuffer);
          const initializationVector = cryptoRandom_1.randomBytes(16);
          const cipherText = yield aes256CbcEncrypt(initializationVector, sharedKeys.encryptionKey, content);
          const macData = Buffer.concat([initializationVector,
              ephemeralPK,
              cipherText]);
          const mac = yield hmacSha256(sharedKeys.hmacKey, macData);
          let cipherTextString;
          if (!cipherTextEncoding || cipherTextEncoding === 'hex') {
              cipherTextString = cipherText.toString('hex');
          }
          else if (cipherTextEncoding === 'base64') {
              cipherTextString = cipherText.toString('base64');
          }
          else {
              throw new Error(`Unexpected cipherTextEncoding "${cipherTextEncoding}"`);
          }
          const result = {
              iv: initializationVector.toString('hex'),
              ephemeralPK: ephemeralPK.toString('hex'),
              cipherText: cipherTextString,
              mac: mac.toString('hex'),
              wasString: !!wasString
          };
          if (cipherTextEncoding && cipherTextEncoding !== 'hex') {
              result.cipherTextEncoding = cipherTextEncoding;
          }
          return result;
      });
  }
  exports.encryptECIES = encryptECIES;
  /**
   * Decrypt content encrypted using ECIES
   * @param {String} privateKey - secp256k1 private key hex string
   * @param {Object} cipherObject - object to decrypt, should contain:
   *  iv (initialization vector), cipherText (cipher text),
   *  mac (message authentication code), ephemeralPublicKey
   *  wasString (boolean indicating with or not to return a buffer or string on decrypt)
   * @return {Buffer} plaintext
   * @throws {FailedDecryptionError} if unable to decrypt
   * @private
   * @ignore
   */
  function decryptECIES(privateKey, cipherObject) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const ecSK = ecurve.keyFromPrivate(privateKey, 'hex');
          let ephemeralPK = null;
          try {
              ephemeralPK = ecurve.keyFromPublic(cipherObject.ephemeralPK, 'hex').getPublic();
          }
          catch (error) {
              throw new errors_1.FailedDecryptionError('Unable to get public key from cipher object. '
                  + 'You might be trying to decrypt an unencrypted object.');
          }
          const sharedSecret = ecSK.derive(ephemeralPK);
          const sharedSecretBuffer = getBufferFromBN(sharedSecret);
          const sharedKeys = sharedSecretToKeys(sharedSecretBuffer);
          const ivBuffer = Buffer.from(cipherObject.iv, 'hex');
          let cipherTextBuffer;
          if (!cipherObject.cipherTextEncoding || cipherObject.cipherTextEncoding === 'hex') {
              cipherTextBuffer = Buffer.from(cipherObject.cipherText, 'hex');
          }
          else if (cipherObject.cipherTextEncoding === 'base64') {
              cipherTextBuffer = Buffer.from(cipherObject.cipherText, 'base64');
          }
          else {
              throw new Error(`Unexpected cipherTextEncoding "${cipherObject.cipherText}"`);
          }
          const macData = Buffer.concat([ivBuffer,
              Buffer.from(ephemeralPK.encodeCompressed()),
              cipherTextBuffer]);
          const actualMac = yield hmacSha256(sharedKeys.hmacKey, macData);
          const expectedMac = Buffer.from(cipherObject.mac, 'hex');
          if (!equalConstTime(expectedMac, actualMac)) {
              throw new errors_1.FailedDecryptionError('Decryption failed: failure in MAC check');
          }
          const plainText = yield aes256CbcDecrypt(ivBuffer, sharedKeys.encryptionKey, cipherTextBuffer);
          if (cipherObject.wasString) {
              return plainText.toString();
          }
          else {
              return plainText;
          }
      });
  }
  exports.decryptECIES = decryptECIES;
  /**
   * Sign content using ECDSA
   *
   * @param {String} privateKey - secp256k1 private key hex string
   * @param {Object} content - content to sign
   * @return {Object} contains:
   * signature - Hex encoded DER signature
   * public key - Hex encoded private string taken from privateKey
   * @private
   * @ignore
   */
  function signECDSA(privateKey, content) {
      const contentBuffer = content instanceof Buffer ? content : Buffer.from(content);
      const ecPrivate = ecurve.keyFromPrivate(privateKey, 'hex');
      const publicKey = keys_1.getPublicKeyFromPrivate(privateKey);
      const contentHash = sha2Hash_1.hashSha256Sync(contentBuffer);
      const signature = ecPrivate.sign(contentHash);
      const signatureString = signature.toDER('hex');
      return {
          signature: signatureString,
          publicKey
      };
  }
  exports.signECDSA = signECDSA;
  /**
  * @ignore
  */
  function getBuffer(content) {
      if (content instanceof Buffer)
          return content;
      else if (content instanceof ArrayBuffer)
          return Buffer.from(content);
      else
          return Buffer.from(content);
  }
  /**
   * Verify content using ECDSA
   * @param {String | Buffer} content - Content to verify was signed
   * @param {String} publicKey - secp256k1 private key hex string
   * @param {String} signature - Hex encoded DER signature
   * @return {Boolean} returns true when signature matches publickey + content, false if not
   * @private
   * @ignore
   */
  function verifyECDSA(content, publicKey, signature) {
      const contentBuffer = getBuffer(content);
      const ecPublic = ecurve.keyFromPublic(publicKey, 'hex');
      const contentHash = sha2Hash_1.hashSha256Sync(contentBuffer);
      return ecPublic.verify(contentHash, signature);
  }
  exports.verifyECDSA = verifyECDSA;
  
  }).call(this,require("buffer").Buffer)
  },{"../errors":58,"../keys":61,"../utils":95,"./aesCipher":48,"./cryptoRandom":49,"./hmacSha256":53,"./sha2Hash":56,"buffer":3,"elliptic":201,"tslib":268}],52:[function(require,module,exports){
  (function (Buffer){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const ripemd160_min_1 = require("ripemd160-min");
  const cryptoUtils_1 = require("./cryptoUtils");
  class Ripemd160PolyfillDigest {
      digest(data) {
          const instance = new ripemd160_min_1.default();
          instance.update(data);
          const hash = instance.digest();
          if (Array.isArray(hash)) {
              return Buffer.from(hash);
          }
          else {
              return Buffer.from(hash.buffer);
          }
      }
  }
  exports.Ripemd160PolyfillDigest = Ripemd160PolyfillDigest;
  class NodeCryptoRipemd160Digest {
      constructor(nodeCryptoCreateHash) {
          this.nodeCryptoCreateHash = nodeCryptoCreateHash;
      }
      digest(data) {
          try {
              return this.nodeCryptoCreateHash('rmd160').update(data).digest();
          }
          catch (error) {
              try {
                  return this.nodeCryptoCreateHash('ripemd160').update(data).digest();
              }
              catch (_err) {
                  console.log(error);
                  console.log('Node.js `crypto.createHash` exists but failing to digest for ripemd160, falling back to js implementation');
                  const polyfill = new Ripemd160PolyfillDigest();
                  return polyfill.digest(data);
              }
          }
      }
  }
  exports.NodeCryptoRipemd160Digest = NodeCryptoRipemd160Digest;
  function createHashRipemd160() {
      const nodeCryptoCreateHash = cryptoUtils_1.isNodeCryptoAvailable(nodeCrypto => {
          if (typeof nodeCrypto.createHash === 'function') {
              return nodeCrypto.createHash;
          }
          return false;
      });
      if (nodeCryptoCreateHash) {
          return new NodeCryptoRipemd160Digest(nodeCryptoCreateHash);
      }
      else {
          return new Ripemd160PolyfillDigest();
      }
  }
  exports.createHashRipemd160 = createHashRipemd160;
  function hashRipemd160(data) {
      const hash = createHashRipemd160();
      return hash.digest(data);
  }
  exports.hashRipemd160 = hashRipemd160;
  
  }).call(this,require("buffer").Buffer)
  },{"./cryptoUtils":50,"buffer":3,"ripemd160-min":252}],53:[function(require,module,exports){
  (function (Buffer){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const tslib_1 = require("tslib");
  const cryptoUtils_1 = require("./cryptoUtils");
  class NodeCryptoHmacSha256 {
      constructor(createHmac) {
          this.createHmac = createHmac;
      }
      digest(key, data) {
          return tslib_1.__awaiter(this, void 0, void 0, function* () {
              const result = this.createHmac('sha256', key)
                  .update(data)
                  .digest();
              return Promise.resolve(result);
          });
      }
  }
  exports.NodeCryptoHmacSha256 = NodeCryptoHmacSha256;
  class WebCryptoHmacSha256 {
      constructor(subtleCrypto) {
          this.subtleCrypto = subtleCrypto;
      }
      digest(key, data) {
          return tslib_1.__awaiter(this, void 0, void 0, function* () {
              const cryptoKey = yield this.subtleCrypto.importKey('raw', key, { name: 'HMAC', hash: 'SHA-256' }, true, ['sign']);
              const sig = yield this.subtleCrypto.sign(
              // The `hash` is only specified for non-compliant browsers like Edge. 
              { name: 'HMAC', hash: 'SHA-256' }, cryptoKey, data);
              return Buffer.from(sig);
          });
      }
  }
  exports.WebCryptoHmacSha256 = WebCryptoHmacSha256;
  function createHmacSha256() {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const cryptoLib = yield cryptoUtils_1.getCryptoLib();
          if (cryptoLib.name === 'subtleCrypto') {
              return new WebCryptoHmacSha256(cryptoLib.lib);
          }
          else {
              return new NodeCryptoHmacSha256(cryptoLib.lib.createHmac);
          }
      });
  }
  exports.createHmacSha256 = createHmacSha256;
  
  }).call(this,require("buffer").Buffer)
  },{"./cryptoUtils":50,"buffer":3,"tslib":268}],54:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  var ec_1 = require("./ec");
  exports.encryptECIES = ec_1.encryptECIES;
  exports.decryptECIES = ec_1.decryptECIES;
  exports.signECDSA = ec_1.signECDSA;
  exports.verifyECDSA = ec_1.verifyECDSA;
  exports.getHexFromBN = ec_1.getHexFromBN;
  var wallet_1 = require("./wallet");
  exports.encryptMnemonic = wallet_1.encryptMnemonic;
  exports.decryptMnemonic = wallet_1.decryptMnemonic;
  
  },{"./ec":51,"./wallet":57}],55:[function(require,module,exports){
  (function (Buffer){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const tslib_1 = require("tslib");
  const cryptoUtils_1 = require("./cryptoUtils");
  class NodeCryptoPbkdf2 {
      constructor(nodePbkdf2) {
          this.nodePbkdf2 = nodePbkdf2;
      }
      derive(password, salt, iterations, keyLength, digest) {
          return tslib_1.__awaiter(this, void 0, void 0, function* () {
              if (digest !== 'sha512' && digest !== 'sha256') {
                  throw new Error(`Unsupported digest "${digest}" for Pbkdf2`);
              }
              return new Promise((resolve, reject) => {
                  this.nodePbkdf2(password, salt, iterations, keyLength, digest, (error, result) => {
                      if (error) {
                          reject(error);
                      }
                      resolve(result);
                  });
              });
          });
      }
  }
  exports.NodeCryptoPbkdf2 = NodeCryptoPbkdf2;
  class WebCryptoPbkdf2 {
      constructor(subtleCrypto) {
          this.subtleCrypto = subtleCrypto;
      }
      derive(password, salt, iterations, keyLength, digest) {
          return tslib_1.__awaiter(this, void 0, void 0, function* () {
              let algo;
              if (digest === 'sha256') {
                  algo = 'SHA-256';
              }
              else if (digest === 'sha512') {
                  algo = 'SHA-512';
              }
              else {
                  throw new Error(`Unsupported Pbkdf2 digest algorithm "${digest}"`);
              }
              let result;
              const passwordBytes = Buffer.from(password, 'utf8');
              try {
                  const key = yield this.subtleCrypto.importKey('raw', passwordBytes, 'PBKDF2', false, ['deriveBits']);
                  result = yield this.subtleCrypto.deriveBits({
                      name: 'PBKDF2', salt, iterations, hash: { name: algo }
                  }, key, keyLength * 8);
              }
              catch (error) {
                  // Browser appears to support WebCrypto but missing pbkdf2 support.
                  const partialWebCrypto = new WebCryptoPartialPbkdf2(this.subtleCrypto);
                  return partialWebCrypto.derive(password, salt, iterations, keyLength, digest);
              }
              return Buffer.from(result);
          });
      }
  }
  exports.WebCryptoPbkdf2 = WebCryptoPbkdf2;
  class WebCryptoPartialPbkdf2 {
      constructor(subtleCrypto) {
          this.subtleCrypto = subtleCrypto;
      }
      derive(password, salt, iterations, keyLength, digest) {
          return tslib_1.__awaiter(this, void 0, void 0, function* () {
              if (digest !== 'sha512' && digest !== 'sha256') {
                  throw new Error(`Unsupported digest "${digest}" for Pbkdf2`);
              }
              const key = Buffer.from(password, 'utf8');
              const algo = digest === 'sha512' ? 'SHA-512' : 'SHA-256';
              const algoOpts = { name: 'HMAC', hash: algo };
              const hmacDigest = (key, data) => this.subtleCrypto
                  .importKey('raw', key, algoOpts, true, ['sign'])
                  .then(cryptoKey => this.subtleCrypto.sign(algoOpts, cryptoKey, data))
                  .then(result => new Uint8Array(result));
              const DK = new Uint8Array(keyLength);
              const saltLength = salt.length;
              const block1 = new Uint8Array(saltLength + 4);
              block1.set(salt);
              let destPos = 0;
              const hLen = digest === 'sha512' ? 64 : 32;
              const l = Math.ceil(keyLength / hLen);
              function writeUInt32BE(data, value, offset) {
                  value = +value;
                  offset >>>= 0;
                  data[offset] = (value >>> 24);
                  data[offset + 1] = (value >>> 16);
                  data[offset + 2] = (value >>> 8);
                  data[offset + 3] = (value & 0xff);
                  return offset + 4;
              }
              for (let i = 1; i <= l; i++) {
                  writeUInt32BE(block1, i, saltLength);
                  // eslint-disable-next-line no-await-in-loop
                  const T = yield hmacDigest(key, block1);
                  let U = T;
                  for (let j = 1; j < iterations; j++) {
                      // eslint-disable-next-line no-await-in-loop
                      U = yield hmacDigest(key, U);
                      for (let k = 0; k < hLen; k++) {
                          T[k] ^= U[k];
                      }
                  }
                  DK.set(T.subarray(0, DK.byteLength - destPos), destPos);
                  destPos += hLen;
              }
              return Buffer.from(DK.buffer);
          });
      }
  }
  exports.WebCryptoPartialPbkdf2 = WebCryptoPartialPbkdf2;
  function createPbkdf2() {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const cryptoLib = yield cryptoUtils_1.getCryptoLib();
          if (cryptoLib.name === 'subtleCrypto') {
              return new WebCryptoPbkdf2(cryptoLib.lib);
          }
          else {
              return new NodeCryptoPbkdf2(cryptoLib.lib.pbkdf2);
          }
      });
  }
  exports.createPbkdf2 = createPbkdf2;
  
  }).call(this,require("buffer").Buffer)
  },{"./cryptoUtils":50,"buffer":3,"tslib":268}],56:[function(require,module,exports){
  (function (Buffer){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const tslib_1 = require("tslib");
  const sha_js_1 = require("sha.js");
  const cryptoUtils_1 = require("./cryptoUtils");
  class NodeCryptoSha2Hash {
      constructor(createHash) {
          this.createHash = createHash;
      }
      digest(data, algorithm = 'sha256') {
          return tslib_1.__awaiter(this, void 0, void 0, function* () {
              try {
                  const result = this.createHash(algorithm)
                      .update(data)
                      .digest();
                  return Promise.resolve(result);
              }
              catch (error) {
                  console.log(error);
                  console.log(`Error performing ${algorithm} digest with Node.js 'crypto.createHash', falling back to JS implementation.`);
                  return Promise.resolve(algorithm === 'sha256' ? hashSha256Sync(data) : hashSha512Sync(data));
              }
          });
      }
  }
  exports.NodeCryptoSha2Hash = NodeCryptoSha2Hash;
  class WebCryptoSha2Hash {
      constructor(subtleCrypto) {
          this.subtleCrypto = subtleCrypto;
      }
      digest(data, algorithm = 'sha256') {
          return tslib_1.__awaiter(this, void 0, void 0, function* () {
              let algo;
              if (algorithm === 'sha256') {
                  algo = 'SHA-256';
              }
              else if (algorithm === 'sha512') {
                  algo = 'SHA-512';
              }
              else {
                  throw new Error(`Unsupported hash algorithm ${algorithm}`);
              }
              try {
                  const hash = yield this.subtleCrypto.digest(algo, data);
                  return Buffer.from(hash);
              }
              catch (error) {
                  console.log(error);
                  console.log(`Error performing ${algorithm} digest with WebCrypto, falling back to JS implementation.`);
                  return Promise.resolve(algorithm === 'sha256' ? hashSha256Sync(data) : hashSha512Sync(data));
              }
          });
      }
  }
  exports.WebCryptoSha2Hash = WebCryptoSha2Hash;
  function createSha2Hash() {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const cryptoLib = yield cryptoUtils_1.getCryptoLib();
          if (cryptoLib.name === 'subtleCrypto') {
              return new WebCryptoSha2Hash(cryptoLib.lib);
          }
          else {
              return new NodeCryptoSha2Hash(cryptoLib.lib.createHash);
          }
      });
  }
  exports.createSha2Hash = createSha2Hash;
  function hashSha256Sync(data) {
      const hash = new sha_js_1.sha256();
      hash.update(data);
      return hash.digest();
  }
  exports.hashSha256Sync = hashSha256Sync;
  function hashSha512Sync(data) {
      const hash = new sha_js_1.sha512();
      hash.update(data);
      return hash.digest();
  }
  exports.hashSha512Sync = hashSha512Sync;
  
  }).call(this,require("buffer").Buffer)
  },{"./cryptoUtils":50,"buffer":3,"sha.js":257,"tslib":268}],57:[function(require,module,exports){
  (function (Buffer){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const tslib_1 = require("tslib");
  const bip39_1 = require("bip39");
  const cryptoRandom_1 = require("./cryptoRandom");
  const sha2Hash_1 = require("./sha2Hash");
  const hmacSha256_1 = require("./hmacSha256");
  const aesCipher_1 = require("./aesCipher");
  const pbkdf2_1 = require("./pbkdf2");
  /**
   * Encrypt a raw mnemonic phrase to be password protected
   * @param {string} phrase - Raw mnemonic phrase
   * @param {string} password - Password to encrypt mnemonic with
   * @return {Promise<Buffer>} The encrypted phrase
   * @private
   * @ignore
   * */
  function encryptMnemonic(phrase, password, opts) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          // hex encoded mnemonic string
          let mnemonicEntropy;
          try {
              // must be bip39 mnemonic
              mnemonicEntropy = bip39_1.mnemonicToEntropy(phrase);
          }
          catch (error) {
              console.error('Invalid mnemonic phrase provided');
              console.error(error);
              throw new Error('Not a valid bip39 mnemonic');
          }
          // normalize plaintext to fixed length byte string
          const plaintextNormalized = Buffer.from(mnemonicEntropy, 'hex');
          // AES-128-CBC with SHA256 HMAC
          const pbkdf2 = yield pbkdf2_1.createPbkdf2();
          let salt;
          if (opts && opts.getRandomBytes) {
              salt = opts.getRandomBytes(16);
          }
          else {
              salt = cryptoRandom_1.randomBytes(16);
          }
          const keysAndIV = yield pbkdf2.derive(password, salt, 100000, 48, 'sha512');
          const encKey = keysAndIV.slice(0, 16);
          const macKey = keysAndIV.slice(16, 32);
          const iv = keysAndIV.slice(32, 48);
          const cipher = yield aesCipher_1.createCipher();
          const cipherText = yield cipher.encrypt('aes-128-cbc', encKey, iv, plaintextNormalized);
          const hmacPayload = Buffer.concat([salt, cipherText]);
          const hmacSha256 = yield hmacSha256_1.createHmacSha256();
          const hmacDigest = yield hmacSha256.digest(macKey, hmacPayload);
          const payload = Buffer.concat([salt, hmacDigest, cipherText]);
          return payload;
      });
  }
  exports.encryptMnemonic = encryptMnemonic;
  // Used to distinguish bad password during decrypt vs invalid format
  class PasswordError extends Error {
  }
  /**
  * @ignore
  */
  function decryptMnemonicBuffer(dataBuffer, password) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const salt = dataBuffer.slice(0, 16);
          const hmacSig = dataBuffer.slice(16, 48); // 32 bytes
          const cipherText = dataBuffer.slice(48);
          const hmacPayload = Buffer.concat([salt, cipherText]);
          const pbkdf2 = yield pbkdf2_1.createPbkdf2();
          const keysAndIV = yield pbkdf2.derive(password, salt, 100000, 48, 'sha512');
          const encKey = keysAndIV.slice(0, 16);
          const macKey = keysAndIV.slice(16, 32);
          const iv = keysAndIV.slice(32, 48);
          const decipher = yield aesCipher_1.createCipher();
          const decryptedResult = yield decipher.decrypt('aes-128-cbc', encKey, iv, cipherText);
          const hmacSha256 = yield hmacSha256_1.createHmacSha256();
          const hmacDigest = yield hmacSha256.digest(macKey, hmacPayload);
          // hash both hmacSig and hmacDigest so string comparison time
          // is uncorrelated to the ciphertext
          const sha2Hash = yield sha2Hash_1.createSha2Hash();
          const hmacSigHash = yield sha2Hash.digest(hmacSig);
          const hmacDigestHash = yield sha2Hash.digest(hmacDigest);
          if (!hmacSigHash.equals(hmacDigestHash)) {
              // not authentic
              throw new PasswordError('Wrong password (HMAC mismatch)');
          }
          let mnemonic;
          try {
              mnemonic = bip39_1.entropyToMnemonic(decryptedResult);
          }
          catch (error) {
              console.error('Error thrown by `entropyToMnemonic`');
              console.error(error);
              throw new PasswordError('Wrong password (invalid plaintext)');
          }
          if (!bip39_1.validateMnemonic(mnemonic)) {
              throw new PasswordError('Wrong password (invalid plaintext)');
          }
          return mnemonic;
      });
  }
  /**
   * Decrypt legacy triplesec keys
   * @param {Buffer} dataBuffer - The encrypted key
   * @param {String} password - Password for data
   * @return {Promise<Buffer>} Decrypted seed
   * @private
   * @ignore
   */
  function decryptLegacy(dataBuffer, password, triplesecDecrypt) {
      return new Promise((resolve, reject) => {
          if (!triplesecDecrypt) {
              reject(new Error('The `triplesec.decrypt` function must be provided'));
          }
          triplesecDecrypt({
              key: Buffer.from(password),
              data: dataBuffer
          }, (err, plaintextBuffer) => {
              if (!err) {
                  resolve(plaintextBuffer);
              }
              else {
                  reject(err);
              }
          });
      });
  }
  /**
   * Decrypt an encrypted mnemonic phrase with a password.
   * Legacy triplesec encrypted payloads are also supported.
   * @param data - Buffer or hex-encoded string of the encrypted mnemonic
   * @param password - Password for data
   * @return the raw mnemonic phrase
   * @private
   * @ignore
   */
  function decryptMnemonic(data, password, triplesecDecrypt) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const dataBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'hex');
          try {
              return yield decryptMnemonicBuffer(dataBuffer, password);
          }
          catch (err) {
              // If it was a password error, don't even bother with legacy
              if (err instanceof PasswordError) {
                  throw err;
              }
              const data = yield decryptLegacy(dataBuffer, password, triplesecDecrypt);
              return data.toString();
          }
      });
  }
  exports.decryptMnemonic = decryptMnemonic;
  
  }).call(this,require("buffer").Buffer)
  },{"./aesCipher":48,"./cryptoRandom":49,"./hmacSha256":53,"./pbkdf2":55,"./sha2Hash":56,"bip39":130,"buffer":3,"tslib":268}],58:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  /**
  * @ignore
  */
  exports.ERROR_CODES = {
      MISSING_PARAMETER: 'missing_parameter',
      REMOTE_SERVICE_ERROR: 'remote_service_error',
      INVALID_STATE: 'invalid_state',
      NO_SESSION_DATA: 'no_session_data',
      DOES_NOT_EXIST: 'does_not_exist',
      FAILED_DECRYPTION_ERROR: 'failed_decryption_error',
      INVALID_DID_ERROR: 'invalid_did_error',
      NOT_ENOUGH_FUNDS_ERROR: 'not_enough_error',
      INVALID_AMOUNT_ERROR: 'invalid_amount_error',
      LOGIN_FAILED_ERROR: 'login_failed',
      SIGNATURE_VERIFICATION_ERROR: 'signature_verification_failure',
      CONFLICT_ERROR: 'conflict_error',
      NOT_ENOUGH_PROOF_ERROR: 'not_enough_proof_error',
      BAD_PATH_ERROR: 'bad_path_error',
      VALIDATION_ERROR: 'validation_error',
      PAYLOAD_TOO_LARGE_ERROR: 'payload_too_large_error',
      PRECONDITION_FAILED_ERROR: 'precondition_failed_error',
      UNKNOWN: 'unknown'
  };
  Object.freeze(exports.ERROR_CODES);
  /**
  * @ignore
  */
  class BlockstackError extends Error {
      constructor(error) {
          super();
          let message = error.message;
          let bugDetails = `Error Code: ${error.code}`;
          let stack = this.stack;
          if (!stack) {
              try {
                  throw new Error();
              }
              catch (e) {
                  stack = e.stack;
              }
          }
          else {
              bugDetails += `Stack Trace:\n${stack}`;
          }
          message += `\nIf you believe this exception is caused by a bug in blockstack.js,
        please file a bug report: https://github.com/blockstack/blockstack.js/issues\n\n${bugDetails}`;
          this.message = message;
          this.code = error.code;
          this.parameter = error.parameter ? error.parameter : null;
      }
      toString() {
          return `${super.toString()}
      code: ${this.code} param: ${this.parameter ? this.parameter : 'n/a'}`;
      }
  }
  exports.BlockstackError = BlockstackError;
  /**
  * @ignore
  */
  class InvalidParameterError extends BlockstackError {
      constructor(parameter, message = '') {
          super({ code: exports.ERROR_CODES.MISSING_PARAMETER, message, parameter: '' });
          this.name = 'MissingParametersError';
      }
  }
  exports.InvalidParameterError = InvalidParameterError;
  /**
  * @ignore
  */
  class MissingParameterError extends BlockstackError {
      constructor(parameter, message = '') {
          super({ code: exports.ERROR_CODES.MISSING_PARAMETER, message, parameter });
          this.name = 'MissingParametersError';
      }
  }
  exports.MissingParameterError = MissingParameterError;
  /**
  * @ignore
  */
  class RemoteServiceError extends BlockstackError {
      constructor(response, message = '') {
          super({ code: exports.ERROR_CODES.REMOTE_SERVICE_ERROR, message });
          this.response = response;
      }
  }
  exports.RemoteServiceError = RemoteServiceError;
  /**
  * @ignore
  */
  class InvalidDIDError extends BlockstackError {
      constructor(message = '') {
          super({ code: exports.ERROR_CODES.INVALID_DID_ERROR, message });
          this.name = 'InvalidDIDError';
      }
  }
  exports.InvalidDIDError = InvalidDIDError;
  /**
  * @ignore
  */
  class NotEnoughFundsError extends BlockstackError {
      constructor(leftToFund) {
          const message = `Not enough UTXOs to fund. Left to fund: ${leftToFund}`;
          super({ code: exports.ERROR_CODES.NOT_ENOUGH_FUNDS_ERROR, message });
          this.leftToFund = leftToFund;
          this.name = 'NotEnoughFundsError';
          this.message = message;
      }
  }
  exports.NotEnoughFundsError = NotEnoughFundsError;
  /**
  * @ignore
  */
  class InvalidAmountError extends BlockstackError {
      constructor(fees, specifiedAmount) {
          const message = `Not enough coin to fund fees transaction fees. Fees would be ${fees},`
              + ` specified spend is  ${specifiedAmount}`;
          super({ code: exports.ERROR_CODES.INVALID_AMOUNT_ERROR, message });
          this.specifiedAmount = specifiedAmount;
          this.fees = fees;
          this.name = 'InvalidAmountError';
          this.message = message;
      }
  }
  exports.InvalidAmountError = InvalidAmountError;
  /**
  * @ignore
  */
  class LoginFailedError extends BlockstackError {
      constructor(reason) {
          const message = `Failed to login: ${reason}`;
          super({ code: exports.ERROR_CODES.LOGIN_FAILED_ERROR, message });
          this.message = message;
          this.name = 'LoginFailedError';
      }
  }
  exports.LoginFailedError = LoginFailedError;
  /**
  * @ignore
  */
  class SignatureVerificationError extends BlockstackError {
      constructor(reason) {
          const message = `Failed to verify signature: ${reason}`;
          super({ code: exports.ERROR_CODES.SIGNATURE_VERIFICATION_ERROR, message });
          this.message = message;
          this.name = 'SignatureVerificationError';
      }
  }
  exports.SignatureVerificationError = SignatureVerificationError;
  /**
  * @ignore
  */
  class FailedDecryptionError extends BlockstackError {
      constructor(message = 'Unable to decrypt cipher object.') {
          super({ code: exports.ERROR_CODES.FAILED_DECRYPTION_ERROR, message });
          this.message = message;
          this.name = 'FailedDecryptionError';
      }
  }
  exports.FailedDecryptionError = FailedDecryptionError;
  /**
  * @ignore
  */
  class InvalidStateError extends BlockstackError {
      constructor(message) {
          super({ code: exports.ERROR_CODES.INVALID_STATE, message });
          this.message = message;
          this.name = 'InvalidStateError';
      }
  }
  exports.InvalidStateError = InvalidStateError;
  /**
  * @ignore
  */
  class NoSessionDataError extends BlockstackError {
      constructor(message) {
          super({ code: exports.ERROR_CODES.INVALID_STATE, message });
          this.message = message;
          this.name = 'NoSessionDataError';
      }
  }
  exports.NoSessionDataError = NoSessionDataError;
  /**
  * @ignore
  */
  class GaiaHubError extends BlockstackError {
      constructor(error, response) {
          super(error);
          if (response) {
              this.hubError = {
                  statusCode: response.status,
                  statusText: response.statusText
              };
              if (typeof response.body === 'string') {
                  this.hubError.message = response.body;
              }
              else if (typeof response.body === 'object') {
                  Object.assign(this.hubError, response.body);
              }
          }
      }
  }
  exports.GaiaHubError = GaiaHubError;
  /**
  * @ignore
  */
  class DoesNotExist extends GaiaHubError {
      constructor(message, response) {
          super({ message, code: exports.ERROR_CODES.DOES_NOT_EXIST }, response);
          this.name = 'DoesNotExist';
      }
  }
  exports.DoesNotExist = DoesNotExist;
  /**
  * @ignore
  */
  class ConflictError extends GaiaHubError {
      constructor(message, response) {
          super({ message, code: exports.ERROR_CODES.CONFLICT_ERROR }, response);
          this.name = 'ConflictError';
      }
  }
  exports.ConflictError = ConflictError;
  /**
  * @ignore
  */
  class NotEnoughProofError extends GaiaHubError {
      constructor(message, response) {
          super({ message, code: exports.ERROR_CODES.NOT_ENOUGH_PROOF_ERROR }, response);
          this.name = 'NotEnoughProofError';
      }
  }
  exports.NotEnoughProofError = NotEnoughProofError;
  /**
  * @ignore
  */
  class BadPathError extends GaiaHubError {
      constructor(message, response) {
          super({ message, code: exports.ERROR_CODES.BAD_PATH_ERROR }, response);
          this.name = 'BadPathError';
      }
  }
  exports.BadPathError = BadPathError;
  /**
  * @ignore
  */
  class ValidationError extends GaiaHubError {
      constructor(message, response) {
          super({ message, code: exports.ERROR_CODES.VALIDATION_ERROR }, response);
          this.name = 'ValidationError';
      }
  }
  exports.ValidationError = ValidationError;
  /**
   * @ignore
   */
  class PayloadTooLargeError extends GaiaHubError {
      constructor(message, response, maxUploadByteSize) {
          super({ message, code: exports.ERROR_CODES.PAYLOAD_TOO_LARGE_ERROR }, response);
          this.name = 'PayloadTooLargeError';
          this.maxUploadByteSize = maxUploadByteSize;
      }
  }
  exports.PayloadTooLargeError = PayloadTooLargeError;
  /**
   * @ignore
   */
  class PreconditionFailedError extends GaiaHubError {
      constructor(message, response) {
          super({ message, code: exports.ERROR_CODES.PRECONDITION_FAILED_ERROR }, response);
          this.name = 'PreconditionFailedError';
      }
  }
  exports.PreconditionFailedError = PreconditionFailedError;
  
  },{}],59:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const tslib_1 = require("tslib");
  // eslint-disable-next-line import/no-unassigned-import
  require("cross-fetch/polyfill");
  /** @ignore */
  function fetchPrivate(input, init) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const defaultFetchOpts = {
              referrer: 'no-referrer',
              referrerPolicy: 'no-referrer'
          };
          const fetchOpts = Object.assign(defaultFetchOpts, init);
          // eslint-disable-next-line no-restricted-globals
          const fetchResult = yield fetch(input, fetchOpts);
          return fetchResult;
      });
  }
  exports.fetchPrivate = fetchPrivate;
  
  },{"cross-fetch/polyfill":197,"tslib":268}],60:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const tslib_1 = require("tslib");
  const publicExports = require("./public");
  exports.default = publicExports;
  tslib_1.__exportStar(require("./public"), exports);
  
  },{"./public":92,"tslib":268}],61:[function(require,module,exports){
  (function (Buffer){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const bitcoinjs_lib_1 = require("bitcoinjs-lib");
  const cryptoRandom_1 = require("./encryption/cryptoRandom");
  const sha2Hash_1 = require("./encryption/sha2Hash");
  const hashRipemd160_1 = require("./encryption/hashRipemd160");
  const config_1 = require("./config");
  /**
   *
   * @param numberOfBytes
   *
   * @ignore
   */
  function getEntropy(arg) {
      if (!arg) {
          arg = 32;
      }
      return cryptoRandom_1.randomBytes(arg);
  }
  exports.getEntropy = getEntropy;
  /**
  * @ignore
  */
  function makeECPrivateKey() {
      const keyPair = bitcoinjs_lib_1.ECPair.makeRandom({ rng: getEntropy });
      return keyPair.privateKey.toString('hex');
  }
  exports.makeECPrivateKey = makeECPrivateKey;
  /**
  * @ignore
  */
  function publicKeyToAddress(publicKey) {
      const publicKeyBuffer = Buffer.isBuffer(publicKey) ? publicKey : Buffer.from(publicKey, 'hex');
      const publicKeyHash160 = hashRipemd160_1.hashRipemd160(sha2Hash_1.hashSha256Sync(publicKeyBuffer));
      const result = bitcoinjs_lib_1.address.toBase58Check(publicKeyHash160, bitcoinjs_lib_1.networks.bitcoin.pubKeyHash);
      return result;
  }
  exports.publicKeyToAddress = publicKeyToAddress;
  /**
  * @ignore
  */
  function getPublicKeyFromPrivate(privateKey) {
      const privateKeyBuffer = Buffer.isBuffer(privateKey) ? privateKey : Buffer.from(privateKey, 'hex');
      const keyPair = bitcoinjs_lib_1.ECPair.fromPrivateKey(privateKeyBuffer);
      return keyPair.publicKey.toString('hex');
  }
  exports.getPublicKeyFromPrivate = getPublicKeyFromPrivate;
  /**
   * Time
   * @private
   * @ignore
   */
  function hexStringToECPair(skHex) {
      const ecPairOptions = {
          network: config_1.config.network.layer1,
          compressed: true
      };
      if (skHex.length === 66) {
          if (skHex.slice(64) !== '01') {
              throw new Error('Improperly formatted private-key hex string. 66-length hex usually '
                  + 'indicates compressed key, but last byte must be == 1');
          }
          return bitcoinjs_lib_1.ECPair.fromPrivateKey(Buffer.from(skHex.slice(0, 64), 'hex'), ecPairOptions);
      }
      else if (skHex.length === 64) {
          ecPairOptions.compressed = false;
          return bitcoinjs_lib_1.ECPair.fromPrivateKey(Buffer.from(skHex, 'hex'), ecPairOptions);
      }
      else {
          throw new Error('Improperly formatted private-key hex string: length should be 64 or 66.');
      }
  }
  exports.hexStringToECPair = hexStringToECPair;
  /**
   *
   * @ignore
   */
  function ecPairToHexString(secretKey) {
      const ecPointHex = secretKey.privateKey.toString('hex');
      if (secretKey.compressed) {
          return `${ecPointHex}01`;
      }
      else {
          return ecPointHex;
      }
  }
  exports.ecPairToHexString = ecPairToHexString;
  /**
   * Creates a bitcoin address string from an ECPair
   * @private
   * @ignore
   */
  function ecPairToAddress(keyPair) {
      const sha256 = sha2Hash_1.hashSha256Sync(keyPair.publicKey);
      const hash160 = hashRipemd160_1.hashRipemd160(sha256);
      return bitcoinjs_lib_1.address.toBase58Check(hash160, keyPair.network.pubKeyHash);
  }
  exports.ecPairToAddress = ecPairToAddress;
  
  }).call(this,require("buffer").Buffer)
  },{"./config":46,"./encryption/cryptoRandom":49,"./encryption/hashRipemd160":52,"./encryption/sha2Hash":56,"bitcoinjs-lib":148,"buffer":3}],62:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const config_1 = require("./config");
  const levels = ['debug', 'info', 'warn', 'error', 'none'];
  const levelToInt = {};
  const intToLevel = {};
  for (let index = 0; index < levels.length; index++) {
      const level = levels[index];
      levelToInt[level] = index;
      intToLevel[index] = level;
  }
  /**
   * @ignore
   */
  class Logger {
      static error(message) {
          if (!this.shouldLog('error'))
              return;
          console.error(this.logMessage('error', message));
      }
      static warn(message) {
          if (!this.shouldLog('warn'))
              return;
          console.warn(this.logMessage('warn', message));
      }
      static info(message) {
          if (!this.shouldLog('info'))
              return;
          console.log(this.logMessage('info', message));
      }
      static debug(message) {
          if (!this.shouldLog('debug'))
              return;
          console.log(this.logMessage('debug', message));
      }
      static logMessage(level, message) {
          return `[${level.toUpperCase()}] ${message}`;
      }
      static shouldLog(level) {
          const currentLevel = levelToInt[config_1.config.logLevel];
          return currentLevel <= levelToInt[level];
      }
  }
  exports.Logger = Logger;
  
  },{"./config":46}],63:[function(require,module,exports){
  (function (Buffer){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const tslib_1 = require("tslib");
  const bitcoinjs_lib_1 = require("bitcoinjs-lib");
  const FormData = require("form-data");
  const BN = require("bn.js");
  const errors_1 = require("./errors");
  const logger_1 = require("./logger");
  const config_1 = require("./config");
  const fetchUtil_1 = require("./fetchUtil");
  const sha2Hash_1 = require("./encryption/sha2Hash");
  const hashRipemd160_1 = require("./encryption/hashRipemd160");
  const SATOSHIS_PER_BTC = 1e8;
  const TX_BROADCAST_SERVICE_ZONE_FILE_ENDPOINT = 'zone-file';
  const TX_BROADCAST_SERVICE_REGISTRATION_ENDPOINT = 'registration';
  const TX_BROADCAST_SERVICE_TX_ENDPOINT = 'transaction';
  /**
   * @private
   * @ignore
   */
  class BitcoinNetwork {
      broadcastTransaction(transaction) {
          return Promise.reject(new Error(`Not implemented, broadcastTransaction(${transaction})`));
      }
      getBlockHeight() {
          return Promise.reject(new Error('Not implemented, getBlockHeight()'));
      }
      getTransactionInfo(txid) {
          return Promise.reject(new Error(`Not implemented, getTransactionInfo(${txid})`));
      }
      getNetworkedUTXOs(address) {
          return Promise.reject(new Error(`Not implemented, getNetworkedUTXOs(${address})`));
      }
  }
  exports.BitcoinNetwork = BitcoinNetwork;
  /**
   * Use the methods in class to build third-party wallets or in DApps that register names.
   */
  class BlockstackNetwork {
      constructor(apiUrl, broadcastServiceUrl, bitcoinAPI, network = bitcoinjs_lib_1.networks.bitcoin) {
          this.blockstackAPIUrl = apiUrl;
          this.broadcastServiceUrl = broadcastServiceUrl;
          this.layer1 = network;
          this.btc = bitcoinAPI;
          this.DUST_MINIMUM = 5500;
          this.includeUtxoMap = {};
          this.excludeUtxoSet = [];
          this.MAGIC_BYTES = 'id';
      }
      /**
       * @ignore
       */
      coerceAddress(address) {
          const { hash, version } = bitcoinjs_lib_1.address.fromBase58Check(address);
          const scriptHashes = [bitcoinjs_lib_1.networks.bitcoin.scriptHash,
              bitcoinjs_lib_1.networks.testnet.scriptHash];
          const pubKeyHashes = [bitcoinjs_lib_1.networks.bitcoin.pubKeyHash,
              bitcoinjs_lib_1.networks.testnet.pubKeyHash];
          let coercedVersion;
          if (scriptHashes.indexOf(version) >= 0) {
              coercedVersion = this.layer1.scriptHash;
          }
          else if (pubKeyHashes.indexOf(version) >= 0) {
              coercedVersion = this.layer1.pubKeyHash;
          }
          else {
              throw new Error(`Unrecognized address version number ${version} in ${address}`);
          }
          return bitcoinjs_lib_1.address.toBase58Check(hash, coercedVersion);
      }
      /**
       * This is intended for use in third-party wallets or in DApps that register names.
       */
      getDefaultBurnAddress() {
          return this.coerceAddress('1111111111111111111114oLvT2');
      }
      /**
       * Get the price of a name via the legacy /v1/prices API endpoint. This is
       * intended for use in third-party wallets or in DApps that register names.
       * @param fullyQualifiedName the name to query
       * @return a promise to an Object with { units: String, amount: BigInteger }
       * @private
       */
      getNamePriceV1(fullyQualifiedName) {
          // legacy code path
          return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/prices/names/${fullyQualifiedName}`)
              .then((resp) => {
              if (!resp.ok) {
                  throw new Error(`Failed to query name price for ${fullyQualifiedName}`);
              }
              return resp;
          })
              .then(resp => resp.json())
              .then(resp => resp.name_price)
              .then((namePrice) => {
              if (!namePrice || !namePrice.satoshis) {
                  throw new Error(`Failed to get price for ${fullyQualifiedName}. Does the namespace exist?`);
              }
              if (namePrice.satoshis < this.DUST_MINIMUM) {
                  namePrice.satoshis = this.DUST_MINIMUM;
              }
              const result = {
                  units: 'BTC',
                  amount: new BN(String(namePrice.satoshis))
              };
              return result;
          });
      }
      /**
       * Get the price of a namespace via the legacy /v1/prices API endpoint. This is intended for
       * use in third-party wallets or in DApps that register names.
       * @param namespaceID the namespace to query
       * @return a promise to an Object with { units: String, amount: BigInteger }
       * @private
       */
      getNamespacePriceV1(namespaceID) {
          // legacy code path
          return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/prices/namespaces/${namespaceID}`)
              .then((resp) => {
              if (!resp.ok) {
                  throw new Error(`Failed to query name price for ${namespaceID}`);
              }
              return resp;
          })
              .then(resp => resp.json())
              .then((namespacePrice) => {
              if (!namespacePrice || !namespacePrice.satoshis) {
                  throw new Error(`Failed to get price for ${namespaceID}`);
              }
              if (namespacePrice.satoshis < this.DUST_MINIMUM) {
                  namespacePrice.satoshis = this.DUST_MINIMUM;
              }
              const result = {
                  units: 'BTC',
                  amount: new BN(String(namespacePrice.satoshis))
              };
              return result;
          });
      }
      /**
       * Get the price of a name via the /v2/prices API endpoint. This is intended
       * for use in third-party wallets or in DApps that register names.
       * @param fullyQualifiedName the name to query
       * @return a promise to an Object with { units: String, amount: BigInteger }
       * @private
       */
      getNamePriceV2(fullyQualifiedName) {
          return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v2/prices/names/${fullyQualifiedName}`)
              .then((resp) => {
              if (resp.status !== 200) {
                  // old core node 
                  throw new Error('The upstream node does not handle the /v2/ price namespace');
              }
              return resp;
          })
              .then(resp => resp.json())
              .then(resp => resp.name_price)
              .then((namePrice) => {
              if (!namePrice) {
                  throw new Error(`Failed to get price for ${fullyQualifiedName}. Does the namespace exist?`);
              }
              const result = {
                  units: namePrice.units,
                  amount: new BN(namePrice.amount)
              };
              if (namePrice.units === 'BTC') {
                  // must be at least dust-minimum
                  const dustMin = new BN(String(this.DUST_MINIMUM));
                  if (result.amount.ucmp(dustMin) < 0) {
                      result.amount = dustMin;
                  }
              }
              return result;
          });
      }
      /**
       * Get the price of a namespace via the /v2/prices API endpoint.
       * This is intended for use in third-party wallets or in DApps that register names.
       * @param namespaceID the namespace to query
       * @return a promise to an Object with { units: String, amount: BigInteger }
       * @private
       */
      getNamespacePriceV2(namespaceID) {
          return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v2/prices/namespaces/${namespaceID}`)
              .then((resp) => {
              if (resp.status !== 200) {
                  // old core node 
                  throw new Error('The upstream node does not handle the /v2/ price namespace');
              }
              return resp;
          })
              .then(resp => resp.json())
              .then((namespacePrice) => {
              if (!namespacePrice) {
                  throw new Error(`Failed to get price for ${namespaceID}`);
              }
              const result = {
                  units: namespacePrice.units,
                  amount: new BN(namespacePrice.amount)
              };
              if (namespacePrice.units === 'BTC') {
                  // must be at least dust-minimum
                  const dustMin = new BN(String(this.DUST_MINIMUM));
                  if (result.amount.ucmp(dustMin) < 0) {
                      result.amount = dustMin;
                  }
              }
              return result;
          });
      }
      /**
       * Get the price of a name. This is intended for
       * use in third-party wallets or in DApps that register names.
       * This is intended for use in third-party wallets or in DApps that register names.
       * @param fullyQualifiedName the name to query
       * @return a promise to an Object with { units: String, amount: BigInteger }, where
       *   .units encodes the cryptocurrency units to pay (e.g. BTC, STACKS), and
       *   .amount encodes the number of units, in the smallest denominiated amount
       *   (e.g. if .units is BTC, .amount will be satoshis; if .units is STACKS,
       *   .amount will be microStacks)
       */
      getNamePrice(fullyQualifiedName) {
          // handle v1 or v2 
          return Promise.resolve().then(() => this.getNamePriceV2(fullyQualifiedName))
              .catch(() => this.getNamePriceV1(fullyQualifiedName));
      }
      /**
       * Get the price of a namespace. This is intended for use in third-party
       * wallets or in DApps that register names.
       * @param namespaceID the namespace to query
       * @return a promise to an Object with { units: String, amount: BigInteger }, where
       *   .units encodes the cryptocurrency units to pay (e.g. BTC, STACKS), and
       *   .amount encodes the number of units, in the smallest denominiated amount
       *   (e.g. if .units is BTC, .amount will be satoshis; if .units is STACKS,
       *   .amount will be microStacks)
       */
      getNamespacePrice(namespaceID) {
          // handle v1 or v2 
          return Promise.resolve().then(() => this.getNamespacePriceV2(namespaceID))
              .catch(() => this.getNamespacePriceV1(namespaceID));
      }
      /**
       * How many blocks can pass between a name expiring and the name being able to be
       * re-registered by a different owner. This is intended for
       * use in third-party wallets or in DApps that register names.
       * @param fullyQualifiedName unused
       * @return a promise to the number of blocks
       */
      getGracePeriod(_fullyQualifiedName) {
          return Promise.resolve(5000);
      }
      /**
       * Get the names -- both on-chain and off-chain -- owned by an address. This is intended for
       * use in third-party wallets or in DApps that register names.
       * @param address the blockchain address (the hash of the owner public key)
       * @return a promise that resolves to a list of names (Strings)
       */
      getNamesOwned(address) {
          const networkAddress = this.coerceAddress(address);
          return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/addresses/bitcoin/${networkAddress}`)
              .then(resp => resp.json())
              .then(obj => obj.names);
      }
      /**
       * Get the blockchain address to which a name's registration fee must be sent
       * (the address will depend on the namespace in which it is registered.)
       *
       * This is intended for use in third-party wallets or in DApps that register names.
       * @param namespace the namespace ID
       * @return a promise that resolves to an address (String)
       */
      getNamespaceBurnAddress(namespace) {
          return Promise.all([
              fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/namespaces/${namespace}`),
              this.getBlockHeight()
          ])
              .then(([resp, blockHeight]) => {
              if (resp.status === 404) {
                  throw new Error(`No such namespace '${namespace}'`);
              }
              else {
                  return Promise.all([resp.json(), blockHeight]);
              }
          })
              .then(([namespaceInfo, blockHeight]) => {
              let address = this.getDefaultBurnAddress();
              if (namespaceInfo.version === 2) {
                  // pay-to-namespace-creator if this namespace is less than 1 year old
                  if (namespaceInfo.reveal_block + 52595 >= blockHeight) {
                      address = namespaceInfo.address;
                  }
              }
              return address;
          })
              .then(address => this.coerceAddress(address));
      }
      /**
       * Get WHOIS-like information for a name, including the address that owns it,
       * the block at which it expires, and the zone file anchored to it (if available).
       *
       * This is intended for use in third-party wallets or in DApps that register names.
       * @param fullyQualifiedName the name to query.  Can be on-chain of off-chain.
       * @return a promise that resolves to the WHOIS-like information
       */
      getNameInfo(fullyQualifiedName) {
          logger_1.Logger.debug(this.blockstackAPIUrl);
          const nameLookupURL = `${this.blockstackAPIUrl}/v1/names/${fullyQualifiedName}`;
          return fetchUtil_1.fetchPrivate(nameLookupURL)
              .then((resp) => {
              if (resp.status === 404) {
                  throw new Error('Name not found');
              }
              else if (resp.status !== 200) {
                  throw new Error(`Bad response status: ${resp.status}`);
              }
              else {
                  return resp.json();
              }
          })
              .then((nameInfo) => {
              logger_1.Logger.debug(`nameInfo: ${JSON.stringify(nameInfo)}`);
              // the returned address _should_ be in the correct network ---
              //  blockstackd gets into trouble because it tries to coerce back to mainnet
              //  and the regtest transaction generation libraries want to use testnet addresses
              if (nameInfo.address) {
                  return Object.assign({}, nameInfo, { address: this.coerceAddress(nameInfo.address) });
              }
              else {
                  return nameInfo;
              }
          });
      }
      /**
       * Get the pricing parameters and creation history of a namespace. This is intended for
       * use in third-party wallets or in DApps that register names.
       * @param namespaceID the namespace to query
       * @return a promise that resolves to the namespace information.
       */
      getNamespaceInfo(namespaceID) {
          return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/namespaces/${namespaceID}`)
              .then((resp) => {
              if (resp.status === 404) {
                  throw new Error('Namespace not found');
              }
              else if (resp.status !== 200) {
                  throw new Error(`Bad response status: ${resp.status}`);
              }
              else {
                  return resp.json();
              }
          })
              .then((namespaceInfo) => {
              // the returned address _should_ be in the correct network ---
              //  blockstackd gets into trouble because it tries to coerce back to mainnet
              //  and the regtest transaction generation libraries want to use testnet addresses
              if (namespaceInfo.address && namespaceInfo.recipient_address) {
                  return Object.assign({}, namespaceInfo, {
                      address: this.coerceAddress(namespaceInfo.address),
                      recipient_address: this.coerceAddress(namespaceInfo.recipient_address)
                  });
              }
              else {
                  return namespaceInfo;
              }
          });
      }
      /**
       * Get a zone file, given its hash.  Throws an exception if the zone file
       * obtained does not match the hash.
       *
       * This is intended for use in third-party wallets or in DApps that register names.
       *
       * @param zonefileHash the ripemd160(sha256) hash of the zone file
       * @return a promise that resolves to the zone file's text
       */
      getZonefile(zonefileHash) {
          return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/zonefiles/${zonefileHash}`)
              .then((resp) => {
              if (resp.status === 200) {
                  return resp.text()
                      .then((body) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                      const sha2Hash = yield sha2Hash_1.createSha2Hash();
                      const sha256 = yield sha2Hash.digest(Buffer.from(body));
                      const h = hashRipemd160_1.hashRipemd160(sha256).toString('hex');
                      if (h !== zonefileHash) {
                          throw new Error(`Zone file contents hash to ${h}, not ${zonefileHash}`);
                      }
                      return body;
                  }));
              }
              else {
                  throw new Error(`Bad response status: ${resp.status}`);
              }
          });
      }
      /**
       * Get the status of an account for a particular token holding.  This includes its total number of
       * expenditures and credits, lockup times, last `txid`, and so on.
       *
       * This is intended for use in third-party wallets or in DApps that register names.
       * @param address the account
       * @param tokenType the token type to query
       * @return a promise that resolves to an object representing the state of the account
       *   for this token
       */
      getAccountStatus(address, tokenType) {
          return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/accounts/${address}/${tokenType}/status`)
              .then((resp) => {
              if (resp.status === 404) {
                  throw new Error('Account not found');
              }
              else if (resp.status !== 200) {
                  throw new Error(`Bad response status: ${resp.status}`);
              }
              else {
                  return resp.json();
              }
          }).then((accountStatus) => {
              // coerce all addresses, and convert credit/debit to biginteger
              const formattedStatus = Object.assign({}, accountStatus, {
                  address: this.coerceAddress(accountStatus.address),
                  debit_value: new BN(String(accountStatus.debit_value)),
                  credit_value: new BN(String(accountStatus.credit_value))
              });
              return formattedStatus;
          });
      }
      /**
       * Get a page of an account's transaction history. This is intended for use in
       * third-party wallets or in DApps that register names.
       * @param address the account's address
       * @param page the page number.  Page 0 is the most recent transactions
       * @return a promise that resolves to an Array of Objects, where each Object encodes
       *   states of the account at various block heights (e.g. prior balances, txids, etc)
       */
      getAccountHistoryPage(address, page) {
          const url = `${this.blockstackAPIUrl}/v1/accounts/${address}/history?page=${page}`;
          return fetchUtil_1.fetchPrivate(url)
              .then((resp) => {
              if (resp.status === 404) {
                  throw new Error('Account not found');
              }
              else if (resp.status !== 200) {
                  throw new Error(`Bad response status: ${resp.status}`);
              }
              else {
                  return resp.json();
              }
          })
              .then((historyList) => {
              if (historyList.error) {
                  throw new Error(`Unable to get account history page: ${historyList.error}`);
              }
              // coerse all addresses and convert to bigint
              return historyList.map((histEntry) => {
                  histEntry.address = this.coerceAddress(histEntry.address);
                  histEntry.debit_value = new BN(String(histEntry.debit_value));
                  histEntry.credit_value = new BN(String(histEntry.credit_value));
                  return histEntry;
              });
          });
      }
      /**
       * Get the state(s) of an account at a particular block height.  This includes the state of the
       * account beginning with this block's transactions, as well as all of the states the account
       * passed through when this block was processed (if any).
       *
       * This is intended for use in third-party wallets or in DApps that register names.
       * @param address the account's address
       * @param blockHeight the block to query
       * @return a promise that resolves to an Array of Objects, where each Object encodes
       *   states of the account at this block.
       */
      getAccountAt(address, blockHeight) {
          const url = `${this.blockstackAPIUrl}/v1/accounts/${address}/history/${blockHeight}`;
          return fetchUtil_1.fetchPrivate(url)
              .then((resp) => {
              if (resp.status === 404) {
                  throw new Error('Account not found');
              }
              else if (resp.status !== 200) {
                  throw new Error(`Bad response status: ${resp.status}`);
              }
              else {
                  return resp.json();
              }
          })
              .then((historyList) => {
              if (historyList.error) {
                  throw new Error(`Unable to get historic account state: ${historyList.error}`);
              }
              // coerce all addresses 
              return historyList.map((histEntry) => {
                  histEntry.address = this.coerceAddress(histEntry.address);
                  histEntry.debit_value = new BN(String(histEntry.debit_value));
                  histEntry.credit_value = new BN(String(histEntry.credit_value));
                  return histEntry;
              });
          });
      }
      /**
       * Get the set of token types that this account owns. This is intended for use
       * in third-party wallets or in DApps that register names.
       * @param address the account's address
       * @return a promise that resolves to an Array of Strings, where each item encodes the
       *   type of token this account holds (excluding the underlying blockchain's tokens)
       */
      getAccountTokens(address) {
          return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/accounts/${address}/tokens`)
              .then((resp) => {
              if (resp.status === 404) {
                  throw new Error('Account not found');
              }
              else if (resp.status !== 200) {
                  throw new Error(`Bad response status: ${resp.status}`);
              }
              else {
                  return resp.json();
              }
          })
              .then((tokenList) => {
              if (tokenList.error) {
                  throw new Error(`Unable to get token list: ${tokenList.error}`);
              }
              return tokenList;
          });
      }
      /**
       * Get the number of tokens owned by an account.  If the account does not exist or has no
       * tokens of this type, then 0 will be returned.
       *
       * This is intended for use in third-party wallets or in DApps that register names.
       * @param address the account's address
       * @param tokenType the type of token to query.
       * @return a promise that resolves to a BigInteger that encodes the number of tokens
       *   held by this account.
       */
      getAccountBalance(address, tokenType) {
          return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/accounts/${address}/${tokenType}/balance`)
              .then((resp) => {
              if (resp.status === 404) {
                  // talking to an older blockstack core node without the accounts API
                  return Promise.resolve().then(() => new BN('0'));
              }
              else if (resp.status !== 200) {
                  throw new Error(`Bad response status: ${resp.status}`);
              }
              else {
                  return resp.json();
              }
          })
              .then((tokenBalance) => {
              if (tokenBalance.error) {
                  throw new Error(`Unable to get account balance: ${tokenBalance.error}`);
              }
              let balance = '0';
              if (tokenBalance && tokenBalance.balance) {
                  balance = tokenBalance.balance;
              }
              return new BN(balance);
          });
      }
      /**
       * Performs a POST request to the given URL. This is intended for
       * use in third-party wallets or in DApps that register names.
       * @param endpoint  the name of
       * @param body [description]
       * @return Returns a `Promise` that resolves to the object requested.
       * In the event of an error, it rejects with:
       * * a `RemoteServiceError` if there is a problem
       * with the transaction broadcast service
       * * `MissingParameterError` if you call the function without a required
       * parameter
       *
       * @private
       */
      broadcastServiceFetchHelper(endpoint, body) {
          const requestHeaders = {
              Accept: 'application/json',
              'Content-Type': 'application/json'
          };
          const options = {
              method: 'POST',
              headers: requestHeaders,
              body: JSON.stringify(body)
          };
          const url = `${this.broadcastServiceUrl}/v1/broadcast/${endpoint}`;
          return fetchUtil_1.fetchPrivate(url, options)
              .then((response) => {
              if (response.ok) {
                  return response.json();
              }
              else {
                  throw new errors_1.RemoteServiceError(response);
              }
          });
      }
      /**
       * Broadcasts a signed bitcoin transaction to the network optionally waiting to broadcast the
       * transaction until a second transaction has a certain number of confirmations.
       *
       * This is intended for use in third-party wallets or in DApps that register names.
       *
       * @param transaction the hex-encoded transaction to broadcast
       * @param transactionToWatch the hex transaction id of the transaction to watch for
       * the specified number of confirmations before broadcasting the `transaction`
       * @param confirmations the number of confirmations `transactionToWatch` must have
       * before broadcasting `transaction`.
       * @return Returns a Promise that resolves to an object with a
       * `transaction_hash` key containing the transaction hash of the broadcasted transaction.
       *
       * In the event of an error, it rejects with:
       * * a `RemoteServiceError` if there is a problem
       *   with the transaction broadcast service
       * * `MissingParameterError` if you call the function without a required
       *   parameter
       * @private
       */
      broadcastTransaction(transaction, transactionToWatch = null, confirmations = 6) {
          if (!transaction) {
              const error = new errors_1.MissingParameterError('transaction');
              return Promise.reject(error);
          }
          if (!confirmations && confirmations !== 0) {
              const error = new errors_1.MissingParameterError('confirmations');
              return Promise.reject(error);
          }
          if (transactionToWatch === null) {
              return this.btc.broadcastTransaction(transaction);
          }
          else {
              /*
               * POST /v1/broadcast/transaction
               * Request body:
               * JSON.stringify({
               *  transaction,
               *  transactionToWatch,
               *  confirmations
               * })
               */
              const endpoint = TX_BROADCAST_SERVICE_TX_ENDPOINT;
              const requestBody = {
                  transaction,
                  transactionToWatch,
                  confirmations
              };
              return this.broadcastServiceFetchHelper(endpoint, requestBody);
          }
      }
      /**
       * Broadcasts a zone file to the Atlas network via the transaction broadcast service.
       * This is intended for use in third-party wallets or in DApps that register names.
       *
       * @param zoneFile the zone file to be broadcast to the Atlas network
       * @param transactionToWatch the hex transaction id of the transaction
       * to watch for confirmation before broadcasting the zone file to the Atlas network
       * @return Returns a Promise that resolves to an object with a
       * `transaction_hash` key containing the transaction hash of the broadcasted transaction.
       *
       * In the event of an error, it rejects with:
       * * a `RemoteServiceError` if there is a problem
       *   with the transaction broadcast service
       * * `MissingParameterError` if you call the function without a required
       *   parameter
       * @private
       */
      broadcastZoneFile(zoneFile, transactionToWatch = null) {
          if (!zoneFile) {
              return Promise.reject(new errors_1.MissingParameterError('zoneFile'));
          }
          // TODO: validate zonefile
          if (transactionToWatch) {
              // broadcast via transaction broadcast service
              /*
               * POST /v1/broadcast/zone-file
               * Request body:
               * JSON.stringify({
               *  zoneFile,
               *  transactionToWatch
               * })
               */
              const requestBody = {
                  zoneFile,
                  transactionToWatch
              };
              const endpoint = TX_BROADCAST_SERVICE_ZONE_FILE_ENDPOINT;
              return this.broadcastServiceFetchHelper(endpoint, requestBody);
          }
          else {
              // broadcast via core endpoint
              // zone file is two words but core's api treats it as one word 'zonefile'
              const requestBody = { zonefile: zoneFile };
              return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/zonefile/`, {
                  method: 'POST',
                  body: JSON.stringify(requestBody),
                  headers: {
                      'Content-Type': 'application/json'
                  }
              })
                  .then((resp) => {
                  const json = resp.json();
                  return json
                      .then((respObj) => {
                      if (respObj.hasOwnProperty('error')) {
                          throw new errors_1.RemoteServiceError(resp);
                      }
                      return respObj.servers;
                  });
              });
          }
      }
      /**
       * Sends the preorder and registration transactions and zone file
       * for a Blockstack name registration along with the to the transaction
       *  broadcast service.
       *
       * The transaction broadcast:
       *
       * * immediately broadcasts the preorder transaction
       * * broadcasts the register transactions after the preorder transaction
       * has an appropriate number of confirmations
       * * broadcasts the zone file to the Atlas network after the register transaction
       * has an appropriate number of confirmations
       *
       * This is intended for use in third-party wallets or in DApps that register names.
       *
       * @param preorderTransaction the hex-encoded, signed preorder transaction generated
       * using the `makePreorder` function
       * @param registerTransaction the hex-encoded, signed register transaction generated
       * using the `makeRegister` function
       * @param zoneFile the zone file to be broadcast to the Atlas network
       * @return Returns a Promise that resolves to an object with a
       * `transaction_hash` key containing the transaction hash of the broadcasted transaction.
       *
       * In the event of an error, it rejects with:
       * * a `RemoteServiceError` if there is a problem
       *   with the transaction broadcast service
       * * `MissingParameterError` if you call the function without a required
       *   parameter
       * @private
       */
      broadcastNameRegistration(preorderTransaction, registerTransaction, zoneFile) {
          /*
             * POST /v1/broadcast/registration
             * Request body:
             * JSON.stringify({
             * preorderTransaction,
             * registerTransaction,
             * zoneFile
             * })
             */
          if (!preorderTransaction) {
              const error = new errors_1.MissingParameterError('preorderTransaction');
              return Promise.reject(error);
          }
          if (!registerTransaction) {
              const error = new errors_1.MissingParameterError('registerTransaction');
              return Promise.reject(error);
          }
          if (!zoneFile) {
              const error = new errors_1.MissingParameterError('zoneFile');
              return Promise.reject(error);
          }
          const requestBody = {
              preorderTransaction,
              registerTransaction,
              zoneFile
          };
          const endpoint = TX_BROADCAST_SERVICE_REGISTRATION_ENDPOINT;
          return this.broadcastServiceFetchHelper(endpoint, requestBody);
      }
      /**
       * @ignore
       */
      getFeeRate() {
          return fetchUtil_1.fetchPrivate('https://bitcoinfees.earn.com/api/v1/fees/recommended')
              .then(resp => resp.json())
              .then(rates => Math.floor(rates.fastestFee));
      }
      /**
       * @ignore
       */
      countDustOutputs() {
          throw new Error('Not implemented.');
      }
      /**
       * @ignore
       */
      getUTXOs(address) {
          return this.getNetworkedUTXOs(address)
              .then((networkedUTXOs) => {
              let returnSet = networkedUTXOs.concat();
              if (this.includeUtxoMap.hasOwnProperty(address)) {
                  returnSet = networkedUTXOs.concat(this.includeUtxoMap[address]);
              }
              // aaron: I am *well* aware this is O(n)*O(m) runtime
              //    however, clients should clear the exclude set periodically
              const excludeSet = this.excludeUtxoSet;
              returnSet = returnSet.filter((utxo) => {
                  const inExcludeSet = excludeSet.reduce((inSet, utxoToCheck) => inSet || (utxoToCheck.tx_hash === utxo.tx_hash
                      && utxoToCheck.tx_output_n === utxo.tx_output_n), false);
                  return !inExcludeSet;
              });
              return returnSet;
          });
      }
      /**
       * This will modify the network's utxo set to include UTXOs
       *  from the given transaction and exclude UTXOs *spent* in
       *  that transaction.
       *
       * This is intended for use in third-party wallets or in DApps that register names.
       * @param txHex - the hex-encoded transaction to use
       * @return no return value, this modifies the UTXO config state
       * @private
       * @ignore
       */
      modifyUTXOSetFrom(txHex) {
          const tx = bitcoinjs_lib_1.Transaction.fromHex(txHex);
          const excludeSet = this.excludeUtxoSet.concat();
          tx.ins.forEach((utxoUsed) => {
              const reverseHash = Buffer.from(utxoUsed.hash);
              reverseHash.reverse();
              excludeSet.push({
                  tx_hash: reverseHash.toString('hex'),
                  tx_output_n: utxoUsed.index
              });
          });
          this.excludeUtxoSet = excludeSet;
          const txHash = Buffer.from(tx.getHash().reverse()).toString('hex');
          tx.outs.forEach((utxoCreated, txOutputN) => {
              const isNullData = function isNullData(script) {
                  try {
                      bitcoinjs_lib_1.payments.embed({ output: script }, { validate: true });
                      return true;
                  }
                  catch (_) {
                      return false;
                  }
              };
              if (isNullData(utxoCreated.script)) {
                  return;
              }
              const address = bitcoinjs_lib_1.address.fromOutputScript(utxoCreated.script, this.layer1);
              let includeSet = [];
              if (this.includeUtxoMap.hasOwnProperty(address)) {
                  includeSet = includeSet.concat(this.includeUtxoMap[address]);
              }
              includeSet.push({
                  tx_hash: txHash,
                  confirmations: 0,
                  value: utxoCreated.value,
                  tx_output_n: txOutputN
              });
              this.includeUtxoMap[address] = includeSet;
          });
      }
      /**
       * @ignore
       */
      resetUTXOs(address) {
          delete this.includeUtxoMap[address];
          this.excludeUtxoSet = [];
      }
      /**
       * @ignore
       */
      getConsensusHash() {
          return fetchUtil_1.fetchPrivate(`${this.blockstackAPIUrl}/v1/blockchains/bitcoin/consensus`)
              .then(resp => resp.json())
              .then(x => x.consensus_hash);
      }
      getTransactionInfo(txHash) {
          return this.btc.getTransactionInfo(txHash);
      }
      /**
       * @ignore
       */
      getBlockHeight() {
          return this.btc.getBlockHeight();
      }
      getNetworkedUTXOs(address) {
          return this.btc.getNetworkedUTXOs(address);
      }
  }
  exports.BlockstackNetwork = BlockstackNetwork;
  /**
   * @ignore
   */
  class LocalRegtest extends BlockstackNetwork {
      constructor(apiUrl, broadcastServiceUrl, bitcoinAPI) {
          super(apiUrl, broadcastServiceUrl, bitcoinAPI, bitcoinjs_lib_1.networks.testnet);
      }
      getFeeRate() {
          return Promise.resolve(Math.floor(0.00001000 * SATOSHIS_PER_BTC));
      }
  }
  exports.LocalRegtest = LocalRegtest;
  /**
   * @ignore
   */
  class BitcoindAPI extends BitcoinNetwork {
      constructor(bitcoindUrl, bitcoindCredentials) {
          super();
          this.bitcoindUrl = bitcoindUrl;
          this.bitcoindCredentials = bitcoindCredentials;
          this.importedBefore = {};
      }
      broadcastTransaction(transaction) {
          const jsonRPC = {
              jsonrpc: '1.0',
              method: 'sendrawtransaction',
              params: [transaction]
          };
          const authString = Buffer.from(`${this.bitcoindCredentials.username}:${this.bitcoindCredentials.password}`)
              .toString('base64');
          const headers = { Authorization: `Basic ${authString}` };
          return fetchUtil_1.fetchPrivate(this.bitcoindUrl, {
              method: 'POST',
              body: JSON.stringify(jsonRPC),
              headers
          })
              .then(resp => resp.json())
              .then(respObj => respObj.result);
      }
      getBlockHeight() {
          const jsonRPC = {
              jsonrpc: '1.0',
              method: 'getblockcount'
          };
          const authString = Buffer.from(`${this.bitcoindCredentials.username}:${this.bitcoindCredentials.password}`)
              .toString('base64');
          const headers = { Authorization: `Basic ${authString}` };
          return fetchUtil_1.fetchPrivate(this.bitcoindUrl, {
              method: 'POST',
              body: JSON.stringify(jsonRPC),
              headers
          })
              .then(resp => resp.json())
              .then(respObj => respObj.result);
      }
      getTransactionInfo(txHash) {
          const jsonRPC = {
              jsonrpc: '1.0',
              method: 'gettransaction',
              params: [txHash]
          };
          const authString = Buffer.from(`${this.bitcoindCredentials.username}:${this.bitcoindCredentials.password}`)
              .toString('base64');
          const headers = { Authorization: `Basic ${authString}` };
          return fetchUtil_1.fetchPrivate(this.bitcoindUrl, {
              method: 'POST',
              body: JSON.stringify(jsonRPC),
              headers
          })
              .then(resp => resp.json())
              .then(respObj => respObj.result)
              .then(txInfo => txInfo.blockhash)
              .then((blockhash) => {
              const jsonRPCBlock = {
                  jsonrpc: '1.0',
                  method: 'getblockheader',
                  params: [blockhash]
              };
              headers.Authorization = `Basic ${authString}`;
              return fetchUtil_1.fetchPrivate(this.bitcoindUrl, {
                  method: 'POST',
                  body: JSON.stringify(jsonRPCBlock),
                  headers
              });
          })
              .then(resp => resp.json())
              .then((respObj) => {
              if (!respObj || !respObj.result) {
                  // unconfirmed 
                  throw new Error('Unconfirmed transaction');
              }
              else {
                  return { block_height: respObj.result.height };
              }
          });
      }
      getNetworkedUTXOs(address) {
          const jsonRPCImport = {
              jsonrpc: '1.0',
              method: 'importaddress',
              params: [address]
          };
          const jsonRPCUnspent = {
              jsonrpc: '1.0',
              method: 'listunspent',
              params: [0, 9999999, [address]]
          };
          const authString = Buffer.from(`${this.bitcoindCredentials.username}:${this.bitcoindCredentials.password}`)
              .toString('base64');
          const headers = { Authorization: `Basic ${authString}` };
          const importPromise = (this.importedBefore[address])
              ? Promise.resolve()
              : fetchUtil_1.fetchPrivate(this.bitcoindUrl, {
                  method: 'POST',
                  body: JSON.stringify(jsonRPCImport),
                  headers
              })
                  .then(() => { this.importedBefore[address] = true; });
          return importPromise
              .then(() => fetchUtil_1.fetchPrivate(this.bitcoindUrl, {
              method: 'POST',
              body: JSON.stringify(jsonRPCUnspent),
              headers
          }))
              .then(resp => resp.json())
              .then(x => x.result)
              .then(utxos => utxos.map((x) => ({
              value: Math.round(x.amount * SATOSHIS_PER_BTC),
              confirmations: x.confirmations,
              tx_hash: x.txid,
              tx_output_n: x.vout
          })));
      }
  }
  exports.BitcoindAPI = BitcoindAPI;
  /**
   * @ignore
   */
  class InsightClient extends BitcoinNetwork {
      constructor(insightUrl = 'https://utxo.technofractal.com/') {
          super();
          this.apiUrl = insightUrl;
      }
      broadcastTransaction(transaction) {
          const jsonData = { rawtx: transaction };
          return fetchUtil_1.fetchPrivate(`${this.apiUrl}/tx/send`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(jsonData)
          })
              .then(resp => resp.json());
      }
      getBlockHeight() {
          return fetchUtil_1.fetchPrivate(`${this.apiUrl}/status`)
              .then(resp => resp.json())
              .then(status => status.blocks);
      }
      getTransactionInfo(txHash) {
          return fetchUtil_1.fetchPrivate(`${this.apiUrl}/tx/${txHash}`)
              .then(resp => resp.json())
              .then((transactionInfo) => {
              if (transactionInfo.error) {
                  throw new Error(`Error finding transaction: ${transactionInfo.error}`);
              }
              return fetchUtil_1.fetchPrivate(`${this.apiUrl}/block/${transactionInfo.blockHash}`);
          })
              .then(resp => resp.json())
              .then(blockInfo => ({ block_height: blockInfo.height }));
      }
      getNetworkedUTXOs(address) {
          return fetchUtil_1.fetchPrivate(`${this.apiUrl}/addr/${address}/utxo`)
              .then(resp => resp.json())
              .then(utxos => utxos.map((x) => ({
              value: x.satoshis,
              confirmations: x.confirmations,
              tx_hash: x.txid,
              tx_output_n: x.vout
          })));
      }
  }
  exports.InsightClient = InsightClient;
  /**
   * @ignore
   */
  class BlockchainInfoApi extends BitcoinNetwork {
      constructor(blockchainInfoUrl = 'https://blockchain.info') {
          super();
          this.utxoProviderUrl = blockchainInfoUrl;
      }
      getBlockHeight() {
          return fetchUtil_1.fetchPrivate(`${this.utxoProviderUrl}/latestblock?cors=true`)
              .then(resp => resp.json())
              .then(blockObj => blockObj.height);
      }
      getNetworkedUTXOs(address) {
          return fetchUtil_1.fetchPrivate(`${this.utxoProviderUrl}/unspent?format=json&active=${address}&cors=true`)
              .then((resp) => {
              if (resp.status === 500) {
                  logger_1.Logger.debug('UTXO provider 500 usually means no UTXOs: returning []');
                  return {
                      unspent_outputs: []
                  };
              }
              else {
                  return resp.json();
              }
          })
              .then(utxoJSON => utxoJSON.unspent_outputs)
              .then(utxoList => utxoList.map((utxo) => {
              const utxoOut = {
                  value: utxo.value,
                  tx_output_n: utxo.tx_output_n,
                  confirmations: utxo.confirmations,
                  tx_hash: utxo.tx_hash_big_endian
              };
              return utxoOut;
          }));
      }
      getTransactionInfo(txHash) {
          return fetchUtil_1.fetchPrivate(`${this.utxoProviderUrl}/rawtx/${txHash}?cors=true`)
              .then((resp) => {
              if (resp.status === 200) {
                  return resp.json();
              }
              else {
                  throw new Error(`Could not lookup transaction info for '${txHash}'. Server error.`);
              }
          })
              .then(respObj => ({ block_height: respObj.block_height }));
      }
      broadcastTransaction(transaction) {
          const form = new FormData();
          form.append('tx', transaction);
          return fetchUtil_1.fetchPrivate(`${this.utxoProviderUrl}/pushtx?cors=true`, {
              method: 'POST',
              body: form
          })
              .then((resp) => {
              const text = resp.text();
              return text
                  .then((respText) => {
                  if (respText.toLowerCase().indexOf('transaction submitted') >= 0) {
                      const txHash = Buffer.from(bitcoinjs_lib_1.Transaction.fromHex(transaction)
                          .getHash()
                          .reverse()).toString('hex'); // big_endian
                      return txHash;
                  }
                  else {
                      throw new errors_1.RemoteServiceError(resp, `Broadcast transaction failed with message: ${respText}`);
                  }
              });
          });
      }
  }
  exports.BlockchainInfoApi = BlockchainInfoApi;
  /**
  * @ignore
  */
  const LOCAL_REGTEST = new LocalRegtest('http://localhost:16268', 'http://localhost:16269', new BitcoindAPI('http://localhost:18332/', { username: 'blockstack', password: 'blockstacksystem' }));
  /**
  * Instance of [[BlockstackNetwork]] set to the default endpoints.
  */
  exports.MAINNET_DEFAULT = new BlockstackNetwork('https://core.blockstack.org', 'https://broadcast.blockstack.org', new BlockchainInfoApi());
  /**
   * Get WHOIS-like information for a name, including the address that owns it,
   * the block at which it expires, and the zone file anchored to it (if available).
   * This is intended for use in third-party wallets or in DApps that register names.
   * @param fullyQualifiedName the name to query.  Can be on-chain of off-chain.
   * @return a promise that resolves to the WHOIS-like information
   */
  function getNameInfo(fullyQualifiedName) {
      return config_1.config.network.getNameInfo(fullyQualifiedName);
  }
  exports.getNameInfo = getNameInfo;
  /**
  * @ignore
  */
  exports.network = {
      BlockstackNetwork,
      LocalRegtest,
      BlockchainInfoApi,
      BitcoindAPI,
      InsightClient,
      defaults: { LOCAL_REGTEST, MAINNET_DEFAULT: exports.MAINNET_DEFAULT }
  };
  
  }).call(this,require("buffer").Buffer)
  },{"./config":46,"./encryption/hashRipemd160":52,"./encryption/sha2Hash":56,"./errors":58,"./fetchUtil":59,"./logger":62,"bitcoinjs-lib":148,"bn.js":187,"buffer":3,"form-data":217,"tslib":268}],64:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const tslib_1 = require("tslib");
  var skeletons_1 = require("./skeletons");
  exports.makePreorderSkeleton = skeletons_1.makePreorderSkeleton;
  var txbuild_1 = require("./txbuild");
  exports.transactions = txbuild_1.transactions;
  tslib_1.__exportStar(require("./utils"), exports);
  tslib_1.__exportStar(require("./signers"), exports);
  var safety_1 = require("./safety");
  exports.safety = safety_1.safety;
  
  },{"./safety":65,"./signers":66,"./skeletons":67,"./txbuild":68,"./utils":69,"tslib":268}],65:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const config_1 = require("../config");
  /**
  * @ignore
  */
  function isNameValid(fullyQualifiedName = '') {
      const NAME_PART_RULE = /^[a-z0-9\-_+]+$/;
      const LENGTH_MAX_NAME = 37;
      if (!fullyQualifiedName
          || fullyQualifiedName.length > LENGTH_MAX_NAME) {
          return Promise.resolve(false);
      }
      const nameParts = fullyQualifiedName.split('.');
      if (nameParts.length !== 2) {
          return Promise.resolve(false);
      }
      return Promise.resolve(nameParts.reduce((agg, namePart) => {
          if (!agg) {
              return false;
          }
          else {
              return NAME_PART_RULE.test(namePart);
          }
      }, true));
  }
  /**
  * @ignore
  */
  function isNamespaceValid(namespaceID) {
      const NAMESPACE_RULE = /^[a-z0-9\-_]{1,19}$/;
      return Promise.resolve(namespaceID.match(NAMESPACE_RULE) !== null);
  }
  /**
  * @ignore
  */
  function isNameAvailable(fullyQualifiedName) {
      return config_1.config.network.getNameInfo(fullyQualifiedName)
          .then(() => false)
          .catch((e) => {
          if (e.message === 'Name not found') {
              return true;
          }
          else {
              throw e;
          }
      });
  }
  /**
  * @ignore
  */
  function isNamespaceAvailable(namespaceID) {
      return config_1.config.network.getNamespaceInfo(namespaceID)
          .then(() => false)
          .catch((e) => {
          if (e.message === 'Namespace not found') {
              return true;
          }
          else {
              throw e;
          }
      });
  }
  /**
  * @ignore
  */
  function ownsName(fullyQualifiedName, ownerAddress) {
      return config_1.config.network.getNameInfo(fullyQualifiedName)
          .then(nameInfo => nameInfo.address === ownerAddress)
          .catch((e) => {
          if (e.message === 'Name not found') {
              return false;
          }
          else {
              throw e;
          }
      });
  }
  /**
  * @ignore
  */
  function revealedNamespace(namespaceID, revealAddress) {
      return config_1.config.network.getNamespaceInfo(namespaceID)
          .then(namespaceInfo => namespaceInfo.recipient_address === revealAddress)
          .catch((e) => {
          if (e.message === 'Namespace not found') {
              return false;
          }
          else {
              throw e;
          }
      });
  }
  /**
  * @ignore
  */
  function namespaceIsReady(namespaceID) {
      return config_1.config.network.getNamespaceInfo(namespaceID)
          .then(namespaceInfo => namespaceInfo.ready)
          .catch((e) => {
          if (e.message === 'Namespace not found') {
              return false;
          }
          else {
              throw e;
          }
      });
  }
  /**
  * @ignore
  */
  function namespaceIsRevealed(namespaceID) {
      return config_1.config.network.getNamespaceInfo(namespaceID)
          .then(namespaceInfo => !namespaceInfo.ready)
          .catch((e) => {
          if (e.message === 'Namespace not found') {
              return false;
          }
          else {
              throw e;
          }
      });
  }
  /**
  * @ignore
  */
  function isInGracePeriod(fullyQualifiedName) {
      const network = config_1.config.network;
      return Promise.all([network.getNameInfo(fullyQualifiedName),
          network.getBlockHeight(),
          network.getGracePeriod(fullyQualifiedName)])
          .then(([nameInfo, blockHeight, gracePeriod]) => {
          const expiresAt = nameInfo.expire_block;
          return (blockHeight >= expiresAt) && (blockHeight < (gracePeriod + expiresAt));
      })
          .catch((e) => {
          if (e.message === 'Name not found') {
              return false;
          }
          else {
              throw e;
          }
      });
  }
  /**
  * @ignore
  */
  function addressCanReceiveName(address) {
      return config_1.config.network.getNamesOwned(address)
          .then(names => (Promise.all(names.map(name => isNameValid(name)))
          .then(validNames => validNames.filter(nameValid => nameValid).length < 25)));
  }
  /**
  * @ignore
  */
  function isAccountSpendable(address, tokenType, blockHeight) {
      return config_1.config.network.getAccountStatus(address, tokenType)
          .then(accountStatus => accountStatus.transfer_send_block_id >= blockHeight);
  }
  /**
  * @ignore
  */
  exports.safety = {
      addressCanReceiveName,
      isInGracePeriod,
      ownsName,
      isNameAvailable,
      isNameValid,
      isNamespaceValid,
      isNamespaceAvailable,
      revealedNamespace,
      namespaceIsReady,
      namespaceIsRevealed,
      isAccountSpendable
  };
  
  },{"../config":46}],66:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const keys_1 = require("../keys");
  /**
   * Class representing a transaction signer for pubkeyhash addresses
   * (a.k.a. single-sig addresses)
   * @private
   * @ignore
   */
  class PubkeyHashSigner {
      constructor(ecPair) {
          this.ecPair = ecPair;
      }
      static fromHexString(keyHex) {
          return new PubkeyHashSigner(keys_1.hexStringToECPair(keyHex));
      }
      signerVersion() {
          return 1;
      }
      getAddress() {
          return Promise.resolve()
              .then(() => keys_1.ecPairToAddress(this.ecPair));
      }
      signTransaction(transaction, inputIndex) {
          return Promise.resolve()
              .then(() => {
              transaction.sign(inputIndex, this.ecPair);
          });
      }
  }
  exports.PubkeyHashSigner = PubkeyHashSigner;
  
  },{"../keys":61}],67:[function(require,module,exports){
  (function (Buffer){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const bitcoinjs_lib_1 = require("bitcoinjs-lib");
  const BN = require("bn.js");
  const utils_1 = require("./utils");
  const config_1 = require("../config");
  // todo : add name length / character verification
  /**
  * @ignore
  */
  class BlockstackNamespace {
      constructor(namespaceID) {
          if (namespaceID.length > 19) {
              throw new Error('Namespace ID too long (19 chars max)');
          }
          if (!namespaceID.match('[0123456789abcdefghijklmnopqrstuvwxyz_-]+')) {
              throw new Error('Namespace ID can only use characters 0123456789abcdefghijklmnopqrstuvwxyz-_');
          }
          this.namespaceID = namespaceID;
          this.version = -1;
          this.lifetime = -1;
          this.coeff = -1;
          this.base = -1;
          this.buckets = [-1];
          this.nonalphaDiscount = -1;
          this.noVowelDiscount = -1;
      }
      check() {
          try {
              this.setVersion(this.version);
              this.setLifetime(this.lifetime);
              this.setCoeff(this.coeff);
              this.setBase(this.base);
              this.setBuckets(this.buckets);
              this.setNonalphaDiscount(this.nonalphaDiscount);
              this.setNoVowelDiscount(this.noVowelDiscount);
              return true;
          }
          catch (e) {
              return false;
          }
      }
      setVersion(version) {
          if (version < 0 || version > Math.pow(2, 16) - 1) {
              throw new Error('Invalid version: must be a 16-bit number');
          }
          this.version = version;
      }
      setLifetime(lifetime) {
          if (lifetime < 0 || lifetime > Math.pow(2, 32) - 1) {
              throw new Error('Invalid lifetime: must be a 32-bit number');
          }
          this.lifetime = lifetime;
      }
      setCoeff(coeff) {
          if (coeff < 0 || coeff > 255) {
              throw new Error('Invalid coeff: must be an 8-bit number');
          }
          this.coeff = coeff;
      }
      setBase(base) {
          if (base < 0 || base > 255) {
              throw new Error('Invalid base: must be an 8-bit number');
          }
          this.base = base;
      }
      setBuckets(buckets) {
          if (buckets.length !== 16) {
              throw new Error('Invalid buckets: must have 16 entries');
          }
          for (let i = 0; i < buckets.length; i++) {
              if (buckets[i] < 0 || buckets[i] > 15) {
                  throw new Error('Invalid buckets: must be 4-bit numbers');
              }
          }
          this.buckets = buckets.slice(0);
      }
      setNonalphaDiscount(nonalphaDiscount) {
          if (nonalphaDiscount <= 0 || nonalphaDiscount > 15) {
              throw new Error('Invalid nonalphaDiscount: must be a positive 4-bit number');
          }
          this.nonalphaDiscount = nonalphaDiscount;
      }
      setNoVowelDiscount(noVowelDiscount) {
          if (noVowelDiscount <= 0 || noVowelDiscount > 15) {
              throw new Error('Invalid noVowelDiscount: must be a positive 4-bit number');
          }
          this.noVowelDiscount = noVowelDiscount;
      }
      toHexPayload() {
          const lifeHex = `00000000${this.lifetime.toString(16)}`.slice(-8);
          const coeffHex = `00${this.coeff.toString(16)}`.slice(-2);
          const baseHex = `00${this.base.toString(16)}`.slice(-2);
          const bucketHex = this.buckets.map(b => b.toString(16)).reduce((b1, b2) => b1 + b2, '');
          const discountHex = this.nonalphaDiscount.toString(16) + this.noVowelDiscount.toString(16);
          const versionHex = `0000${this.version.toString(16)}`.slice(-4);
          const namespaceIDHex = Buffer.from(this.namespaceID).toString('hex');
          return lifeHex + coeffHex + baseHex + bucketHex + discountHex + versionHex + namespaceIDHex;
      }
  }
  exports.BlockstackNamespace = BlockstackNamespace;
  /**
  * @ignore
  */
  function asAmountV2(amount) {
      // convert an AmountType v1 or v2 to an AmountTypeV2.
      // the "units" of a v1 amount type are always 'BTC'
      if (typeof amount === 'number') {
          return { units: 'BTC', amount: new BN(String(amount)) };
      }
      else {
          return { units: amount.units, amount: amount.amount };
      }
  }
  /**
  * @ignore
  */
  function makeTXbuilder() {
      const txb = new bitcoinjs_lib_1.TransactionBuilder(config_1.config.network.layer1);
      txb.setVersion(1);
      return txb;
  }
  /**
  * @ignore
  */
  function opEncode(opcode) {
      // NOTE: must *always* a 3-character string
      const res = `${config_1.config.network.MAGIC_BYTES}${opcode}`;
      if (res.length !== 3) {
          throw new Error('Runtime error: invalid MAGIC_BYTES');
      }
      return res;
  }
  /**
  * @ignore
  */
  function makePreorderSkeleton(fullyQualifiedName, consensusHash, preorderAddress, burnAddress, burn, registerAddress = null) {
      // Returns a preorder tx skeleton.
      //   with 3 outputs : 1. the Blockstack Preorder OP_RETURN data
      //                    2. the Preorder's change address (5500 satoshi minimum)
      //                    3. the BURN
      //
      // 0     2  3                                     23             39          47            66
      // |-----|--|--------------------------------------|--------------|-----------|-------------|
      // magic op  hash160(fqn,scriptPubkey,registerAddr) consensus hash token burn  token type
      //                                                                 (optional)   (optional)
      //
      // output 0: name preorder code
      // output 1: preorder address
      // output 2: burn address
      //
      // Returns an unsigned serialized transaction.
      const burnAmount = asAmountV2(burn);
      const network = config_1.config.network;
      const nameBuff = Buffer.from(utils_1.decodeB40(fullyQualifiedName), 'hex'); // base40
      const scriptPublicKey = bitcoinjs_lib_1.address.toOutputScript(preorderAddress, network.layer1);
      const dataBuffers = [nameBuff, scriptPublicKey];
      if (!!registerAddress) {
          const registerBuff = Buffer.from(registerAddress, 'ascii');
          dataBuffers.push(registerBuff);
      }
      const dataBuff = Buffer.concat(dataBuffers);
      const hashed = utils_1.hash160(dataBuff);
      const opReturnBufferLen = burnAmount.units === 'BTC' ? 39 : 66;
      const opReturnBuffer = Buffer.alloc(opReturnBufferLen);
      opReturnBuffer.write(opEncode('?'), 0, 3, 'ascii');
      hashed.copy(opReturnBuffer, 3);
      opReturnBuffer.write(consensusHash, 23, 16, 'hex');
      if (burnAmount.units !== 'BTC') {
          const burnHex = burnAmount.amount.toString(16, 2);
          if (burnHex.length > 16) {
              // exceeds 2**64; can't fit
              throw new Error(`Cannot preorder '${fullyQualifiedName}': cannot fit price into 8 bytes`);
          }
          const paddedBurnHex = `0000000000000000${burnHex}`.slice(-16);
          opReturnBuffer.write(paddedBurnHex, 39, 8, 'hex');
          opReturnBuffer.write(burnAmount.units, 47, burnAmount.units.length, 'ascii');
      }
      const nullOutput = bitcoinjs_lib_1.payments.embed({ data: [opReturnBuffer] }).output;
      const tx = makeTXbuilder();
      tx.addOutput(nullOutput, 0);
      tx.addOutput(preorderAddress, utils_1.DUST_MINIMUM);
      if (burnAmount.units === 'BTC') {
          const btcBurnAmount = burnAmount.amount.toNumber();
          tx.addOutput(burnAddress, btcBurnAmount);
      }
      else {
          tx.addOutput(burnAddress, utils_1.DUST_MINIMUM);
      }
      return tx.buildIncomplete();
  }
  exports.makePreorderSkeleton = makePreorderSkeleton;
  /**
  * @ignore
  */
  function makeRegisterSkeleton(fullyQualifiedName, ownerAddress, valueHash = null, burnTokenAmountHex = null) {
      // Returns a register tx skeleton.
      //   with 2 outputs : 1. The register OP_RETURN
      //                    2. The owner address (can be different from REGISTER address on renewals)
      // You MUST make the first input a UTXO from the current OWNER *or* the
      //   funder of the PREORDER
      // in the case of a renewal, this would need to be modified to include a change address
      //  as output (3) before the burn output (4)
      /*
        Formats
    
        No zonefile hash, and pay with BTC:
    
        0    2  3                                  39
        |----|--|----------------------------------|
        magic op   name.ns_id (up to 37 bytes)
    
    
        With zonefile hash, and pay with BTC:
    
        0    2  3                                  39                  59
        |----|--|----------------------------------|-------------------|
        magic op   name.ns_id (37 bytes, 0-padded)     zone file hash
    
        output 0: name registration code
        output 1: owner address
      */
      let payload;
      if (!!burnTokenAmountHex && !valueHash) {
          // empty value hash
          valueHash = '0000000000000000000000000000000000000000';
      }
      if (!!valueHash) {
          if (valueHash.length !== 40) {
              throw new Error('Value hash length incorrect. Expecting 20-bytes, hex-encoded');
          }
          if (!!burnTokenAmountHex) {
              if (burnTokenAmountHex.length !== 16) {
                  throw new Error('Burn field length incorrect.  Expecting 8-bytes, hex-encoded');
              }
          }
          const payloadLen = burnTokenAmountHex ? 65 : 57;
          payload = Buffer.alloc(payloadLen, 0);
          payload.write(fullyQualifiedName, 0, 37, 'ascii');
          payload.write(valueHash, 37, 20, 'hex');
          if (!!burnTokenAmountHex) {
              payload.write(burnTokenAmountHex, 57, 8, 'hex');
          }
      }
      else {
          payload = Buffer.from(fullyQualifiedName, 'ascii');
      }
      const opReturnBuffer = Buffer.concat([Buffer.from(opEncode(':'), 'ascii'), payload]);
      const nullOutput = bitcoinjs_lib_1.payments.embed({ data: [opReturnBuffer] }).output;
      const tx = makeTXbuilder();
      tx.addOutput(nullOutput, 0);
      tx.addOutput(ownerAddress, utils_1.DUST_MINIMUM);
      return tx.buildIncomplete();
  }
  exports.makeRegisterSkeleton = makeRegisterSkeleton;
  /**
  * @ignore
  */
  function makeRenewalSkeleton(fullyQualifiedName, nextOwnerAddress, lastOwnerAddress, burnAddress, burn, valueHash = null) {
      /*
        Formats
    
        No zonefile hash, and pay with BTC:
    
        0    2  3                                  39
        |----|--|----------------------------------|
        magic op   name.ns_id (up to 37 bytes)
    
    
        With zonefile hash, and pay with BTC:
    
        0    2  3                                  39                  59
        |----|--|----------------------------------|-------------------|
        magic op   name.ns_id (37 bytes, 0-padded)     zone file hash
    
    
       With renewal payment in a token:
       (for register, tokens burned is not included)
       (for renew, tokens burned is the number of tokens to burn)
    
       0    2  3                                  39                  59                            67
       |----|--|----------------------------------|-------------------|------------------------------|
       magic op   name.ns_id (37 bytes, 0-padded)     zone file hash    tokens burned (big-endian)
    
       output 0: renewal code
       output 1: new owner address
       output 2: current owner address
       output 3: burn address
      */
      const burnAmount = asAmountV2(burn);
      const network = config_1.config.network;
      const burnTokenAmount = burnAmount.units === 'BTC' ? null : burnAmount.amount;
      const burnBTCAmount = burnAmount.units === 'BTC'
          ? burnAmount.amount.toNumber() : utils_1.DUST_MINIMUM;
      let burnTokenHex = null;
      if (!!burnTokenAmount) {
          const burnHex = burnTokenAmount.toString(16, 2);
          if (burnHex.length > 16) {
              // exceeds 2**64; can't fit 
              throw new Error(`Cannot renew '${fullyQualifiedName}': cannot fit price into 8 bytes`);
          }
          burnTokenHex = `0000000000000000${burnHex}`.slice(-16);
      }
      const registerTX = makeRegisterSkeleton(fullyQualifiedName, nextOwnerAddress, valueHash, burnTokenHex);
      const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(registerTX, network.layer1);
      txB.addOutput(lastOwnerAddress, utils_1.DUST_MINIMUM);
      txB.addOutput(burnAddress, burnBTCAmount);
      return txB.buildIncomplete();
  }
  exports.makeRenewalSkeleton = makeRenewalSkeleton;
  /**
  * @ignore
  */
  function makeTransferSkeleton(fullyQualifiedName, consensusHash, newOwner, keepZonefile = false) {
      // Returns a transfer tx skeleton.
      //   with 2 outputs : 1. the Blockstack Transfer OP_RETURN data
      //                    2. the new owner with a DUST_MINIMUM value (5500 satoshi)
      //
      // You MUST make the first input a UTXO from the current OWNER
      //
      // Returns an unsigned serialized transaction.
      /*
        Format
    
        0     2  3    4                   20              36
        |-----|--|----|-------------------|---------------|
        magic op keep  hash128(name.ns_id) consensus hash
                 data?
    
        output 0: transfer code
        output 1: new owner
      */
      const opRet = Buffer.alloc(36);
      let keepChar = '~';
      if (keepZonefile) {
          keepChar = '>';
      }
      opRet.write(opEncode('>'), 0, 3, 'ascii');
      opRet.write(keepChar, 3, 1, 'ascii');
      const hashed = utils_1.hash128(Buffer.from(fullyQualifiedName, 'ascii'));
      hashed.copy(opRet, 4);
      opRet.write(consensusHash, 20, 16, 'hex');
      const opRetPayload = bitcoinjs_lib_1.payments.embed({ data: [opRet] }).output;
      const tx = makeTXbuilder();
      tx.addOutput(opRetPayload, 0);
      tx.addOutput(newOwner, utils_1.DUST_MINIMUM);
      return tx.buildIncomplete();
  }
  exports.makeTransferSkeleton = makeTransferSkeleton;
  /**
  * @ignore
  */
  function makeUpdateSkeleton(fullyQualifiedName, consensusHash, valueHash) {
      // Returns an update tx skeleton.
      //   with 1 output : 1. the Blockstack update OP_RETURN
      //
      // You MUST make the first input a UTXO from the current OWNER
      //
      // Returns an unsigned serialized transaction.
      //
      // output 0: the revoke code
      /*
        Format:
    
        0     2  3                                   19                      39
        |-----|--|-----------------------------------|-----------------------|
        magic op  hash128(name.ns_id,consensus hash) hash160(data)
    
        output 0: update code
      */
      const opRet = Buffer.alloc(39);
      const nameBuff = Buffer.from(fullyQualifiedName, 'ascii');
      const consensusBuff = Buffer.from(consensusHash, 'ascii');
      const hashedName = utils_1.hash128(Buffer.concat([nameBuff, consensusBuff]));
      opRet.write(opEncode('+'), 0, 3, 'ascii');
      hashedName.copy(opRet, 3);
      opRet.write(valueHash, 19, 20, 'hex');
      const opRetPayload = bitcoinjs_lib_1.payments.embed({ data: [opRet] }).output;
      const tx = makeTXbuilder();
      tx.addOutput(opRetPayload, 0);
      return tx.buildIncomplete();
  }
  exports.makeUpdateSkeleton = makeUpdateSkeleton;
  /**
  * @ignore
  */
  function makeRevokeSkeleton(fullyQualifiedName) {
      // Returns a revoke tx skeleton
      //    with 1 output: 1. the Blockstack revoke OP_RETURN
      //
      // You MUST make the first input a UTXO from the current OWNER
      //
      // Returns an unsigned serialized transaction
      /*
       Format:
    
       0    2  3                             39
       |----|--|-----------------------------|
       magic op   name.ns_id (37 bytes)
    
       output 0: the revoke code
      */
      const opRet = Buffer.alloc(3);
      const nameBuff = Buffer.from(fullyQualifiedName, 'ascii');
      opRet.write(opEncode('~'), 0, 3, 'ascii');
      const opReturnBuffer = Buffer.concat([opRet, nameBuff]);
      const nullOutput = bitcoinjs_lib_1.payments.embed({ data: [opReturnBuffer] }).output;
      const tx = makeTXbuilder();
      tx.addOutput(nullOutput, 0);
      return tx.buildIncomplete();
  }
  exports.makeRevokeSkeleton = makeRevokeSkeleton;
  /**
  * @ignore
  */
  function makeNamespacePreorderSkeleton(namespaceID, consensusHash, preorderAddress, registerAddress, burn) {
      // Returns a namespace preorder tx skeleton.
      // Returns an unsigned serialized transaction.
      /*
       Formats:
    
       Without STACKS:
    
       0     2   3                                      23               39
       |-----|---|--------------------------------------|----------------|
       magic op  hash(ns_id,script_pubkey,reveal_addr)   consensus hash
    
    
       with STACKs:
    
       0     2   3                                      23               39                         47
       |-----|---|--------------------------------------|----------------|--------------------------|
       magic op  hash(ns_id,script_pubkey,reveal_addr)   consensus hash    token fee (big-endian)
    
       output 0: namespace preorder code
       output 1: change address
       otuput 2: burn address
      */
      const burnAmount = asAmountV2(burn);
      if (burnAmount.units !== 'BTC' && burnAmount.units !== 'STACKS') {
          throw new Error(`Invalid burnUnits ${burnAmount.units}`);
      }
      const network = config_1.config.network;
      const burnAddress = network.getDefaultBurnAddress();
      const namespaceIDBuff = Buffer.from(utils_1.decodeB40(namespaceID), 'hex'); // base40
      const scriptPublicKey = bitcoinjs_lib_1.address.toOutputScript(preorderAddress, network.layer1);
      const registerBuff = Buffer.from(registerAddress, 'ascii');
      const dataBuffers = [namespaceIDBuff, scriptPublicKey, registerBuff];
      const dataBuff = Buffer.concat(dataBuffers);
      const hashed = utils_1.hash160(dataBuff);
      let btcBurnAmount = utils_1.DUST_MINIMUM;
      let opReturnBufferLen = 39;
      if (burnAmount.units === 'STACKS') {
          opReturnBufferLen = 47;
      }
      else {
          btcBurnAmount = burnAmount.amount.toNumber();
      }
      const opReturnBuffer = Buffer.alloc(opReturnBufferLen);
      opReturnBuffer.write(opEncode('*'), 0, 3, 'ascii');
      hashed.copy(opReturnBuffer, 3);
      opReturnBuffer.write(consensusHash, 23, 16, 'hex');
      if (burnAmount.units === 'STACKS') {
          const burnHex = burnAmount.amount.toString(16, 2);
          const paddedBurnHex = `0000000000000000${burnHex}`.slice(-16);
          opReturnBuffer.write(paddedBurnHex, 39, 8, 'hex');
      }
      const nullOutput = bitcoinjs_lib_1.payments.embed({ data: [opReturnBuffer] }).output;
      const tx = makeTXbuilder();
      tx.addOutput(nullOutput, 0);
      tx.addOutput(preorderAddress, utils_1.DUST_MINIMUM);
      tx.addOutput(burnAddress, btcBurnAmount);
      return tx.buildIncomplete();
  }
  exports.makeNamespacePreorderSkeleton = makeNamespacePreorderSkeleton;
  /**
  * @ignore
  */
  function makeNamespaceRevealSkeleton(namespace, revealAddress) {
      /*
       Format:
    
       0     2   3    7     8     9    10   11   12   13   14    15    16    17       18      20     39
       |-----|---|----|-----|-----|----|----|----|----|----|-----|-----|-----|--------|-------|-------|
       magic  op  life coeff. base 1-2  3-4  5-6  7-8  9-10 11-12 13-14 15-16 nonalpha version  ns ID
                                                      bucket exponents        no-vowel
                                                                              discounts
       
       output 0: namespace reveal code
       output 1: reveal address
      */
      const hexPayload = namespace.toHexPayload();
      const opReturnBuffer = Buffer.alloc(3 + hexPayload.length / 2);
      opReturnBuffer.write(opEncode('&'), 0, 3, 'ascii');
      opReturnBuffer.write(hexPayload, 3, hexPayload.length / 2, 'hex');
      const nullOutput = bitcoinjs_lib_1.payments.embed({ data: [opReturnBuffer] }).output;
      const tx = makeTXbuilder();
      tx.addOutput(nullOutput, 0);
      tx.addOutput(revealAddress, utils_1.DUST_MINIMUM);
      return tx.buildIncomplete();
  }
  exports.makeNamespaceRevealSkeleton = makeNamespaceRevealSkeleton;
  /**
  * @ignore
  */
  function makeNamespaceReadySkeleton(namespaceID) {
      /*
       Format:
    
       0     2  3  4           23
       |-----|--|--|------------|
       magic op  .  ns_id
    
       output 0: namespace ready code
       */
      const opReturnBuffer = Buffer.alloc(3 + namespaceID.length + 1);
      opReturnBuffer.write(opEncode('!'), 0, 3, 'ascii');
      opReturnBuffer.write(`.${namespaceID}`, 3, namespaceID.length + 1, 'ascii');
      const nullOutput = bitcoinjs_lib_1.payments.embed({ data: [opReturnBuffer] }).output;
      const tx = makeTXbuilder();
      tx.addOutput(nullOutput, 0);
      return tx.buildIncomplete();
  }
  exports.makeNamespaceReadySkeleton = makeNamespaceReadySkeleton;
  // type bitcoin.payments.p2data bitcoin.payments.embed
  /**
  * @ignore
  */
  function makeNameImportSkeleton(name, recipientAddr, zonefileHash) {
      /*
       Format:
    
        0    2  3                             39
        |----|--|-----------------------------|
        magic op   name.ns_id (37 bytes)
    
       Output 0: the OP_RETURN
       Output 1: the recipient
       Output 2: the zonefile hash
     */
      if (zonefileHash.length !== 40) {
          throw new Error('Invalid zonefile hash: must be 20 bytes hex-encoded');
      }
      const network = config_1.config.network;
      const opReturnBuffer = Buffer.alloc(3 + name.length);
      opReturnBuffer.write(opEncode(';'), 0, 3, 'ascii');
      opReturnBuffer.write(name, 3, name.length, 'ascii');
      const nullOutput = bitcoinjs_lib_1.payments.embed({ data: [opReturnBuffer] }).output;
      const tx = makeTXbuilder();
      const zonefileHashB58 = bitcoinjs_lib_1.address.toBase58Check(Buffer.from(zonefileHash, 'hex'), network.layer1.pubKeyHash);
      tx.addOutput(nullOutput, 0);
      tx.addOutput(recipientAddr, utils_1.DUST_MINIMUM);
      tx.addOutput(zonefileHashB58, utils_1.DUST_MINIMUM);
      return tx.buildIncomplete();
  }
  exports.makeNameImportSkeleton = makeNameImportSkeleton;
  /**
  * @ignore
  */
  function makeAnnounceSkeleton(messageHash) {
      /*
        Format:
    
        0    2  3                             23
        |----|--|-----------------------------|
        magic op   message hash (160-bit)
    
        output 0: the OP_RETURN
      */
      if (messageHash.length !== 40) {
          throw new Error('Invalid message hash: must be 20 bytes hex-encoded');
      }
      const opReturnBuffer = Buffer.alloc(3 + messageHash.length / 2);
      opReturnBuffer.write(opEncode('#'), 0, 3, 'ascii');
      opReturnBuffer.write(messageHash, 3, messageHash.length / 2, 'hex');
      const nullOutput = bitcoinjs_lib_1.payments.embed({ data: [opReturnBuffer] }).output;
      const tx = makeTXbuilder();
      tx.addOutput(nullOutput, 0);
      return tx.buildIncomplete();
  }
  exports.makeAnnounceSkeleton = makeAnnounceSkeleton;
  /**
  * @ignore
  */
  function makeTokenTransferSkeleton(recipientAddress, consensusHash, tokenType, tokenAmount, scratchArea) {
      /*
       Format:
    
        0     2  3              19         38          46                        80
        |-----|--|--------------|----------|-----------|-------------------------|
        magic op  consensus_hash token_type amount (BE) scratch area
                                 (ns_id)
    
        output 0: token transfer code
        output 1: recipient address
      */
      if (scratchArea.length > 34) {
          throw new Error('Invalid scratch area: must be no more than 34 bytes');
      }
      const opReturnBuffer = Buffer.alloc(46 + scratchArea.length);
      const tokenTypeHex = Buffer.from(tokenType).toString('hex');
      const tokenTypeHexPadded = `00000000000000000000000000000000000000${tokenTypeHex}`.slice(-38);
      const tokenValueHex = tokenAmount.toString(16, 2);
      if (tokenValueHex.length > 16) {
          // exceeds 2**64; can't fit
          throw new Error(`Cannot send tokens: cannot fit ${tokenAmount.toString()} into 8 bytes`);
      }
      const tokenValueHexPadded = `0000000000000000${tokenValueHex}`.slice(-16);
      opReturnBuffer.write(opEncode('$'), 0, 3, 'ascii');
      opReturnBuffer.write(consensusHash, 3, consensusHash.length / 2, 'hex');
      opReturnBuffer.write(tokenTypeHexPadded, 19, tokenTypeHexPadded.length / 2, 'hex');
      opReturnBuffer.write(tokenValueHexPadded, 38, tokenValueHexPadded.length / 2, 'hex');
      opReturnBuffer.write(scratchArea, 46, scratchArea.length, 'ascii');
      const nullOutput = bitcoinjs_lib_1.payments.embed({ data: [opReturnBuffer] }).output;
      const tx = makeTXbuilder();
      tx.addOutput(nullOutput, 0);
      tx.addOutput(recipientAddress, utils_1.DUST_MINIMUM);
      return tx.buildIncomplete();
  }
  exports.makeTokenTransferSkeleton = makeTokenTransferSkeleton;
  
  }).call(this,require("buffer").Buffer)
  },{"../config":46,"./utils":69,"bitcoinjs-lib":148,"bn.js":187,"buffer":3}],68:[function(require,module,exports){
  (function (Buffer){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const tslib_1 = require("tslib");
  const bitcoinjs_lib_1 = require("bitcoinjs-lib");
  const utils_1 = require("./utils");
  const skeletons_1 = require("./skeletons");
  const config_1 = require("../config");
  const errors_1 = require("../errors");
  const signers_1 = require("./signers");
  const dummyConsensusHash = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
  const dummyZonefileHash = 'ffffffffffffffffffffffffffffffffffffffff';
  /**
  * @ignore
  */
  function addOwnerInput(utxos, ownerAddress, txB, addChangeOut = true) {
      // add an owner UTXO and a change out.
      if (utxos.length <= 0) {
          throw new Error('Owner has no UTXOs for UPDATE.');
      }
      utxos.sort((a, b) => a.value - b.value);
      const ownerUTXO = utxos[0];
      const ownerInput = txB.addInput(ownerUTXO.tx_hash, ownerUTXO.tx_output_n);
      if (addChangeOut) {
          txB.addOutput(ownerAddress, ownerUTXO.value);
      }
      return { index: ownerInput, value: ownerUTXO.value };
  }
  /**
  * @ignore
  */
  function fundTransaction(txB, paymentAddress, utxos, feeRate, inAmounts, changeIndex = null) {
      // change index for the payer.
      if (changeIndex === null) {
          changeIndex = txB.addOutput(paymentAddress, utils_1.DUST_MINIMUM);
      }
      // fund the transaction fee.
      const txFee = utils_1.estimateTXBytes(txB, 0, 0) * feeRate;
      const outAmounts = utils_1.sumOutputValues(txB);
      const change = utils_1.addUTXOsToFund(txB, utxos, txFee + outAmounts - inAmounts, feeRate);
      const txInner = utils_1.getTransactionInsideBuilder(txB);
      const txOut = txInner.outs[changeIndex];
      txOut.value += change;
      return txB;
  }
  /**
  * @ignore
  */
  function returnTransactionHex(txB, buildIncomplete = false) {
      if (buildIncomplete) {
          return txB.buildIncomplete().toHex();
      }
      else {
          return txB.build().toHex();
      }
  }
  /**
  * @ignore
  */
  function getTransactionSigner(input) {
      if (typeof input === 'string') {
          return signers_1.PubkeyHashSigner.fromHexString(input);
      }
      else {
          return input;
      }
  }
  /**
   * Estimates cost of a preorder transaction for a domain name.
   * @param {String} fullyQualifiedName - the name to preorder
   * @param {String} destinationAddress - the address to receive the name (this
   *    must be passed as the 'registrationAddress' in the register transaction)
   * @param {String} paymentAddress - the address funding the preorder
   * @param {Number} paymentUtxos - the number of UTXOs we expect will be required
   *    from the payment address.
   * @returns {Promise} - a promise which resolves to the satoshi cost to fund
   *    the preorder. This includes a 5500 satoshi dust output for the preorder.
   *    Even though this is a change output, the payer must supply enough funds
   *    to generate this output, so we include it in the cost.
   * @private
   */
  function estimatePreorder(fullyQualifiedName, destinationAddress, paymentAddress, paymentUtxos = 1) {
      const network = config_1.config.network;
      const preorderPromise = network.getNamePrice(fullyQualifiedName)
          .then(namePrice => skeletons_1.makePreorderSkeleton(fullyQualifiedName, dummyConsensusHash, paymentAddress, network.getDefaultBurnAddress(), namePrice, destinationAddress));
      return Promise.all([network.getFeeRate(), preorderPromise])
          .then(([feeRate, preorderTX]) => {
          const outputsValue = utils_1.sumOutputValues(preorderTX);
          const txFee = feeRate * utils_1.estimateTXBytes(preorderTX, paymentUtxos, 0);
          return txFee + outputsValue;
      });
  }
  /**
   * Estimates cost of a register transaction for a domain name.
   * @param {String} fullyQualifiedName - the name to register
   * @param {String} registerAddress - the address to receive the name
   * @param {String} paymentAddress - the address funding the register
   * @param {Boolean} includingZonefile - whether or not we will broadcast
   *    a zonefile hash as part  of the register
   * @param {Number} paymentUtxos - the number of UTXOs we expect will be required
   *    from the payment address.
   * @returns {Promise} - a promise which resolves to the satoshi cost to fund
   *    the register.
   * @private
   */
  function estimateRegister(fullyQualifiedName, registerAddress, paymentAddress, includingZonefile = false, paymentUtxos = 1) {
      const network = config_1.config.network;
      let valueHash;
      if (includingZonefile) {
          valueHash = dummyZonefileHash;
      }
      const registerTX = skeletons_1.makeRegisterSkeleton(fullyQualifiedName, registerAddress, valueHash);
      return network.getFeeRate()
          .then((feeRate) => {
          const outputsValue = utils_1.sumOutputValues(registerTX);
          // 1 additional output for payer change
          const txFee = feeRate * utils_1.estimateTXBytes(registerTX, paymentUtxos, 1);
          return txFee + outputsValue;
      });
  }
  /**
   * Estimates cost of an update transaction for a domain name.
   * @param {String} fullyQualifiedName - the name to update
   * @param {String} ownerAddress - the owner of the name
   * @param {String} paymentAddress - the address funding the update
   * @param {Number} paymentUtxos - the number of UTXOs we expect will be required
   *    from the payment address.
   * @returns {Promise} - a promise which resolves to the satoshi cost to fund
   *    the update.
   * @private
   */
  function estimateUpdate(fullyQualifiedName, ownerAddress, paymentAddress, paymentUtxos = 1) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const network = config_1.config.network;
          const updateTX = skeletons_1.makeUpdateSkeleton(fullyQualifiedName, dummyConsensusHash, dummyZonefileHash);
          const feeRate = yield network.getFeeRate();
          const outputsValue = utils_1.sumOutputValues(updateTX);
          // 1 additional input for the owner
          // 2 additional outputs for owner / payer change
          const txFee = feeRate * utils_1.estimateTXBytes(updateTX, 1 + paymentUtxos, 2);
          return txFee + outputsValue;
      });
  }
  /**
   * Estimates cost of an transfer transaction for a domain name.
   * @param {String} fullyQualifiedName - the name to transfer
   * @param {String} destinationAddress - the next owner of the name
   * @param {String} ownerAddress - the current owner of the name
   * @param {String} paymentAddress - the address funding the transfer
   * @param {Number} paymentUtxos - the number of UTXOs we expect will be required
   *    from the payment address.
   * @returns {Promise} - a promise which resolves to the satoshi cost to fund
   *    the transfer.
   * @private
   */
  function estimateTransfer(fullyQualifiedName, destinationAddress, ownerAddress, paymentAddress, paymentUtxos = 1) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const network = config_1.config.network;
          const transferTX = skeletons_1.makeTransferSkeleton(fullyQualifiedName, dummyConsensusHash, destinationAddress);
          const feeRate = yield network.getFeeRate();
          const outputsValue = utils_1.sumOutputValues(transferTX);
          // 1 additional input for the owner
          // 2 additional outputs for owner / payer change
          const txFee = feeRate * utils_1.estimateTXBytes(transferTX, 1 + paymentUtxos, 2);
          return txFee + outputsValue;
      });
  }
  /**
   * Estimates cost of an transfer transaction for a domain name.
   * @param {String} fullyQualifiedName - the name to renew
   * @param {String} destinationAddress - the next owner of the name
   * @param {String} ownerAddress - the current owner of the name
   * @param {String} paymentAddress - the address funding the transfer
   * @param {Boolean} includingZonefile - whether or not we will broadcast a zonefile hash
        in the renewal operation
   * @param {Number} paymentUtxos - the number of UTXOs we expect will be required
   *    from the payment address.
   * @returns {Promise} - a promise which resolves to the satoshi cost to fund
   *    the transfer.
   * @private
   */
  function estimateRenewal(fullyQualifiedName, destinationAddress, ownerAddress, paymentAddress, includingZonefile = false, paymentUtxos = 1) {
      const network = config_1.config.network;
      let valueHash;
      if (includingZonefile) {
          valueHash = dummyZonefileHash;
      }
      const renewalPromise = network.getNamePrice(fullyQualifiedName)
          .then(namePrice => skeletons_1.makeRenewalSkeleton(fullyQualifiedName, destinationAddress, ownerAddress, network.getDefaultBurnAddress(), namePrice, valueHash));
      return Promise.all([network.getFeeRate(), renewalPromise])
          .then(([feeRate, renewalTX]) => {
          const outputsValue = utils_1.sumOutputValues(renewalTX);
          // 1 additional input for the owner
          // and renewal skeleton includes all outputs for owner change, but not for payer change.
          const txFee = feeRate * utils_1.estimateTXBytes(renewalTX, 1 + paymentUtxos, 1);
          return txFee + outputsValue - 5500; // don't count the dust change for old owner.
      });
  }
  /**
   * Estimates cost of a revoke transaction for a domain name.
   * @param {String} fullyQualifiedName - the name to revoke
   * @param {String} ownerAddress - the current owner of the name
   * @param {String} paymentAddress  the address funding the revoke
   * @param {Number} paymentUtxos - the number of UTXOs we expect will be required
   *    from the payment address.
   * @returns {Promise} - a promise which resolves to the satoshi cost to fund the
   *    revoke.
   * @private
   */
  function estimateRevoke(fullyQualifiedName, ownerAddress, paymentAddress, paymentUtxos = 1) {
      const network = config_1.config.network;
      const revokeTX = skeletons_1.makeRevokeSkeleton(fullyQualifiedName);
      return Promise.all([network.getFeeRate()])
          .then(([feeRate]) => {
          const outputsValue = utils_1.sumOutputValues(revokeTX);
          // 1 additional input for owner
          // 1 additional output for payer change
          const txFee = feeRate * utils_1.estimateTXBytes(revokeTX, 1 + paymentUtxos, 2);
          return txFee + outputsValue;
      });
  }
  /**
   * Estimates cost of a namespace preorder transaction for a namespace
   * @param {String} namespaceID - the namespace to preorder
   * @param {String} revealAddress - the address to receive the namespace (this
   *    must be passed as the 'revealAddress' in the namespace-reveal transaction)
   * @param {String} paymentAddress - the address funding the preorder
   * @param {Number} paymentUtxos - the number of UTXOs we expect will be required
   *    from the payment address.
   * @returns {Promise} - a promise which resolves to the satoshi cost to fund
   *    the preorder. This includes a 5500 satoshi dust output for the preorder.
   *    Even though this is a change output, the payer must supply enough funds
   *    to generate this output, so we include it in the cost.
   * @private
   */
  function estimateNamespacePreorder(namespaceID, revealAddress, paymentAddress, paymentUtxos = 1) {
      const network = config_1.config.network;
      const preorderPromise = network.getNamespacePrice(namespaceID)
          .then(namespacePrice => skeletons_1.makeNamespacePreorderSkeleton(namespaceID, dummyConsensusHash, paymentAddress, revealAddress, namespacePrice));
      return Promise.all([network.getFeeRate(), preorderPromise])
          .then(([feeRate, preorderTX]) => {
          const outputsValue = utils_1.sumOutputValues(preorderTX);
          const txFee = feeRate * utils_1.estimateTXBytes(preorderTX, paymentUtxos, 0);
          return txFee + outputsValue;
      });
  }
  /**
   * Estimates cost of a namesapce reveal transaction for a namespace
   * @param {BlockstackNamespace} namespace - the namespace to reveal
   * @param {String} revealAddress - the address to receive the namespace
   *    (this must have been passed as 'revealAddress' to a prior namespace
   *    preorder)
   * @param {String} paymentAddress - the address that pays for this transaction
   * @param {Number} paymentUtxos - the number of UTXOs we expect will be required
   *    from the payment address
   * @returns {Promise} - a promise which resolves to the satoshi cost to
   *    fund the reveal.  This includes a 5500 satoshi dust output for the
   *    preorder.  Even though this is a change output, the payer must have
   *    enough funds to generate this output, so we include it in the cost.
   * @private
   */
  function estimateNamespaceReveal(namespace, revealAddress, paymentAddress, paymentUtxos = 1) {
      const network = config_1.config.network;
      const revealTX = skeletons_1.makeNamespaceRevealSkeleton(namespace, revealAddress);
      return network.getFeeRate()
          .then((feeRate) => {
          const outputsValue = utils_1.sumOutputValues(revealTX);
          // 1 additional output for payer change
          const txFee = feeRate * utils_1.estimateTXBytes(revealTX, paymentUtxos, 1);
          return txFee + outputsValue;
      });
  }
  /**
   * Estimates the cost of a namespace-ready transaction for a namespace
   * @param {String} namespaceID - the namespace to ready
   * @param {Number} revealUtxos - the number of UTXOs we expect will
   *  be required from the reveal address
   * @returns {Promise} - a promise which resolves to the satoshi cost to
   *  fund this namespacey-ready transaction.
   * @private
   */
  function estimateNamespaceReady(namespaceID, revealUtxos = 1) {
      const network = config_1.config.network;
      const readyTX = skeletons_1.makeNamespaceReadySkeleton(namespaceID);
      return network.getFeeRate()
          .then((feeRate) => {
          const outputsValue = utils_1.sumOutputValues(readyTX);
          const txFee = feeRate * utils_1.estimateTXBytes(readyTX, revealUtxos, 1);
          return txFee + outputsValue;
      });
  }
  /**
   * Estimates the cost of a name-import transaction
   * @param {String} name - the fully-qualified name
   * @param {String} recipientAddr - the recipient
   * @param {String} zonefileHash - the zone file hash
   * @param {Number} importUtxos - the number of UTXOs we expect will
   *  be required from the importer address
   * @returns {Promise} - a promise which resolves to the satoshi cost
   *  to fund this name-import transaction
   * @private
   */
  function estimateNameImport(name, recipientAddr, zonefileHash, importUtxos = 1) {
      const network = config_1.config.network;
      const importTX = skeletons_1.makeNameImportSkeleton(name, recipientAddr, zonefileHash);
      return network.getFeeRate()
          .then((feeRate) => {
          const outputsValue = utils_1.sumOutputValues(importTX);
          const txFee = feeRate * utils_1.estimateTXBytes(importTX, importUtxos, 1);
          return txFee + outputsValue;
      });
  }
  /**
   * Estimates the cost of an announce transaction
   * @param {String} messageHash - the hash of the message
   * @param {Number} senderUtxos - the number of utxos we expect will
   *  be required from the importer address
   * @returns {Promise} - a promise which resolves to the satoshi cost
   *  to fund this announce transaction
   * @private
   */
  function estimateAnnounce(messageHash, senderUtxos = 1) {
      const network = config_1.config.network;
      const announceTX = skeletons_1.makeAnnounceSkeleton(messageHash);
      return network.getFeeRate()
          .then((feeRate) => {
          const outputsValue = utils_1.sumOutputValues(announceTX);
          const txFee = feeRate * utils_1.estimateTXBytes(announceTX, senderUtxos, 1);
          return txFee + outputsValue;
      });
  }
  /**
   * Estimates the cost of a token-transfer transaction
   * @param {String} recipientAddress - the recipient of the tokens
   * @param {String} tokenType - the type of token to spend
   * @param {Object} tokenAmount - a 64-bit unsigned BigInteger encoding the number of tokens
   *   to spend
   * @param {String} scratchArea - an arbitrary string to store with the transaction
   * @param {Number} senderUtxos - the number of utxos we expect will
   *  be required from the importer address
   * @param {Number} additionalOutputs - the number of outputs we expect to add beyond
   *  just the recipient output (default = 1, if the token owner is also the bitcoin funder)
   * @returns {Promise} - a promise which resolves to the satoshi cost to
   *  fund this token-transfer transaction
   * @private
   */
  function estimateTokenTransfer(recipientAddress, tokenType, tokenAmount, scratchArea, senderUtxos = 1, additionalOutputs = 1) {
      const network = config_1.config.network;
      const tokenTransferTX = skeletons_1.makeTokenTransferSkeleton(recipientAddress, dummyConsensusHash, tokenType, tokenAmount, scratchArea);
      return network.getFeeRate()
          .then((feeRate) => {
          const outputsValue = utils_1.sumOutputValues(tokenTransferTX);
          const txFee = feeRate * utils_1.estimateTXBytes(tokenTransferTX, senderUtxos, additionalOutputs);
          return txFee + outputsValue;
      });
  }
  /**
   * Generates a preorder transaction for a domain name.
   * @param {String} fullyQualifiedName - the name to pre-order
   * @param {String} destinationAddress - the address to receive the name (this
   *    must be passed as the 'registrationAddress' in the register transaction)
   * @param {String | TransactionSigner} paymentKeyIn - a hex string of
   *    the private key used to fund the transaction or a transaction signer object
   * @param {boolean} buildIncomplete - optional boolean, defaults to false,
   * indicating whether the function should attempt to return an unsigned (or not fully signed)
   * transaction. Useful for passing around a TX for multi-sig input signing.
   * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
   *    this function *does not* perform the requisite safety checks -- please see
   *    the safety module for those.
   * @private
   */
  function makePreorder(fullyQualifiedName, destinationAddress, paymentKeyIn, buildIncomplete = false) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const network = config_1.config.network;
          const namespace = fullyQualifiedName.split('.').pop();
          const paymentKey = getTransactionSigner(paymentKeyIn);
          const preorderAddress = yield paymentKey.getAddress();
          const preorderPromise = Promise.all([network.getConsensusHash(),
              network.getNamePrice(fullyQualifiedName),
              network.getNamespaceBurnAddress(namespace)])
              .then(([consensusHash, namePrice, burnAddress]) => skeletons_1.makePreorderSkeleton(fullyQualifiedName, consensusHash, preorderAddress, burnAddress, namePrice, destinationAddress));
          return Promise.all([network.getUTXOs(preorderAddress), network.getFeeRate(), preorderPromise])
              .then(([utxos, feeRate, preorderSkeleton]) => {
              const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(preorderSkeleton, network.layer1);
              txB.setVersion(1);
              const changeIndex = 1; // preorder skeleton always creates a change output at index = 1
              const signingTxB = fundTransaction(txB, preorderAddress, utxos, feeRate, 0, changeIndex);
              return utils_1.signInputs(signingTxB, paymentKey);
          })
              .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));
      });
  }
  /**
   * Generates an update transaction for a domain name.
   * @param {String} fullyQualifiedName - the name to update
   * @param {String | TransactionSigner} ownerKeyIn - a hex string of the
   *    owner key, or a transaction signer object. This will provide one
   *    UTXO input, and also recieve a dust output.
   * @param {String | TransactionSigner} paymentKeyIn - a hex string, or a
   *    transaction signer object, of the private key used to fund the
   *    transaction's txfees
   * @param {String} zonefile - the zonefile data to update (this will be hashed
   *    to include in the transaction), the zonefile itself must be published
   *    after the UPDATE propagates.
   * @param {String} valueHash - if given, this is the hash to store (instead of
   *    zonefile).  zonefile will be ignored if this is given.
   * @param {boolean} buildIncomplete - optional boolean, defaults to false,
   *    indicating whether the function should attempt to return an unsigned (or not fully signed)
   *    transaction. Useful for passing around a TX for multi-sig input signing.
   * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
   *    this function *does not* perform the requisite safety checks -- please see
   *    the safety module for those.
   * @private
   */
  function makeUpdate(fullyQualifiedName, ownerKeyIn, paymentKeyIn, zonefile, valueHash = '', buildIncomplete = false) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const network = config_1.config.network;
          if (!valueHash && !zonefile) {
              return Promise.reject(new Error('Need zonefile or valueHash arguments'));
          }
          if (valueHash.length === 0) {
              if (!zonefile) {
                  return Promise.reject(new Error('Need zonefile or valueHash arguments'));
              }
              valueHash = utils_1.hash160(Buffer.from(zonefile)).toString('hex');
          }
          else if (valueHash.length !== 40) {
              return Promise.reject(new Error(`Invalid valueHash ${valueHash}`));
          }
          const paymentKey = getTransactionSigner(paymentKeyIn);
          const ownerKey = getTransactionSigner(ownerKeyIn);
          return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()])
              .then(([ownerAddress, paymentAddress]) => {
              const txPromise = network.getConsensusHash()
                  .then(consensusHash => skeletons_1.makeUpdateSkeleton(fullyQualifiedName, consensusHash, valueHash))
                  .then((updateTX) => {
                  const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(updateTX, network.layer1);
                  txB.setVersion(1);
                  return txB;
              });
              return Promise.all([txPromise, network.getUTXOs(paymentAddress),
                  network.getUTXOs(ownerAddress), network.getFeeRate()])
                  .then(([txB, payerUtxos, ownerUtxos, feeRate]) => {
                  const ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB);
                  const signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);
                  return utils_1.signInputs(signingTxB, paymentKey, [{ index: ownerInput.index, signer: ownerKey }]);
              });
          })
              .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));
      });
  }
  /**
   * Generates a register transaction for a domain name.
   * @param {String} fullyQualifiedName - the name to register
   * @param {String} registerAddress - the address to receive the name (this
   *    must have been passed as the 'destinationAddress' in the preorder transaction)
   *    this address will receive a dust UTXO
   * @param {String | TransactionSigner} paymentKeyIn - a hex string of
   *    the private key (or a TransactionSigner object) used to fund the
   *    transaction (this *must* be the same as the payment address used
   *    to fund the preorder)
   * @param {String} zonefile - the zonefile data to include (this will be hashed
   *    to include in the transaction), the zonefile itself must be published
   *    after the UPDATE propagates.
   * @param {String} valueHash - the hash of the zone file data to include.
   *    It will be used instead of zonefile, if given
   * @param {boolean} buildIncomplete - optional boolean, defaults to false,
   *    indicating whether the function should attempt to return an unsigned (or not fully signed)
   *    transaction. Useful for passing around a TX for multi-sig input signing.
   * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
   *    this function *does not* perform the requisite safety checks -- please see
   *    the safety module for those.
   * @private
   */
  function makeRegister(fullyQualifiedName, registerAddress, paymentKeyIn, zonefile = null, valueHash = null, buildIncomplete = false) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const network = config_1.config.network;
          if (!valueHash && !!zonefile) {
              valueHash = utils_1.hash160(Buffer.from(zonefile)).toString('hex');
          }
          else if (!!valueHash && valueHash.length !== 40) {
              return Promise.reject(new Error(`Invalid zonefile hash ${valueHash}`));
          }
          const registerSkeleton = skeletons_1.makeRegisterSkeleton(fullyQualifiedName, registerAddress, valueHash);
          const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(registerSkeleton, network.layer1);
          txB.setVersion(1);
          const paymentKey = getTransactionSigner(paymentKeyIn);
          const paymentAddress = yield paymentKey.getAddress();
          return Promise.all([network.getUTXOs(paymentAddress), network.getFeeRate()])
              .then(([utxos, feeRate]) => {
              const signingTxB = fundTransaction(txB, paymentAddress, utxos, feeRate, 0);
              return utils_1.signInputs(signingTxB, paymentKey);
          })
              .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));
      });
  }
  /**
   * Generates a transfer transaction for a domain name.
   * @param {String} fullyQualifiedName - the name to transfer
   * @param {String} destinationAddress - the address to receive the name.
   *    this address will receive a dust UTXO
   * @param {String | TransactionSigner} ownerKeyIn - a hex string of
   *    the current owner's private key (or a TransactionSigner object)
   * @param {String | TransactionSigner} paymentKeyIn - a hex string of
   *    the private key used to fund the transaction (or a
   *    TransactionSigner object)
   * @param {Boolean} keepZonefile - if true, then preserve the name's zone file
   * @param {boolean} buildIncomplete - optional boolean, defaults to false,
   *   indicating whether the function should attempt to return an unsigned (or not fully signed)
   *   transaction. Useful for passing around a TX for multi-sig input signing.
   * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
   *    this function *does not* perform the requisite safety checks -- please see
   *    the safety module for those.
   * @private
   */
  function makeTransfer(fullyQualifiedName, destinationAddress, ownerKeyIn, paymentKeyIn, keepZonefile = false, buildIncomplete = false) {
      const network = config_1.config.network;
      const paymentKey = getTransactionSigner(paymentKeyIn);
      const ownerKey = getTransactionSigner(ownerKeyIn);
      return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()])
          .then(([ownerAddress, paymentAddress]) => {
          const txPromise = network.getConsensusHash()
              .then(consensusHash => skeletons_1.makeTransferSkeleton(fullyQualifiedName, consensusHash, destinationAddress, keepZonefile))
              .then((transferTX) => {
              const txB = bitcoinjs_lib_1.TransactionBuilder
                  .fromTransaction(transferTX, network.layer1);
              txB.setVersion(1);
              return txB;
          });
          return Promise.all([txPromise, network.getUTXOs(paymentAddress),
              network.getUTXOs(ownerAddress), network.getFeeRate()])
              .then(([txB, payerUtxos, ownerUtxos, feeRate]) => {
              const ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB);
              const signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);
              return utils_1.signInputs(signingTxB, paymentKey, [{ index: ownerInput.index, signer: ownerKey }]);
          });
      })
          .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));
  }
  /**
   * Generates a revoke transaction for a domain name.
   * @param {String} fullyQualifiedName - the name to revoke
   * @param {String | TransactionSigner} ownerKeyIn - a hex string of
   *    the current owner's private key (or a TransactionSigner object)
   * @param {String | TransactionSigner} paymentKeyIn - a hex string of
   *    the private key used to fund the transaction (or a
   *    TransactionSigner object)
   * @param {boolean} buildIncomplete - optional boolean, defaults to false,
   *    indicating whether the function should attempt to return an unsigned (or not fully signed)
   *    transaction. Useful for passing around a TX for multi-sig input signing.
   * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
   *    this function *does not* perform the requisite safety checks -- please see
   *    the safety module for those.
   * @private
   */
  function makeRevoke(fullyQualifiedName, ownerKeyIn, paymentKeyIn, buildIncomplete = false) {
      const network = config_1.config.network;
      const paymentKey = getTransactionSigner(paymentKeyIn);
      const ownerKey = getTransactionSigner(ownerKeyIn);
      return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()])
          .then(([ownerAddress, paymentAddress]) => {
          const revokeTX = skeletons_1.makeRevokeSkeleton(fullyQualifiedName);
          const txPromise = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(revokeTX, network.layer1);
          txPromise.setVersion(1);
          return Promise.all([txPromise, network.getUTXOs(paymentAddress),
              network.getUTXOs(ownerAddress), network.getFeeRate()])
              .then(([txB, payerUtxos, ownerUtxos, feeRate]) => {
              const ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB);
              const signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);
              return utils_1.signInputs(signingTxB, paymentKey, [{ index: ownerInput.index, signer: ownerKey }]);
          });
      })
          .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));
  }
  /**
   * Generates a renewal transaction for a domain name.
   * @param {String} fullyQualifiedName - the name to transfer
   * @param {String} destinationAddress - the address to receive the name after renewal
   *    this address will receive a dust UTXO
   * @param {String | TransactionSigner} ownerKeyIn - a hex string of
   *    the current owner's private key (or a TransactionSigner object)
   * @param {String | TransactionSigner} paymentKeyIn - a hex string of
   *    the private key used to fund the renewal (or a TransactionSigner
   *    object)
   * @param {String} zonefile - the zonefile data to include, if given (this will be hashed
   *    to include in the transaction), the zonefile itself must be published
   *    after the RENEWAL propagates.
   * @param {String} valueHash - the raw zone file hash to include (this will be used
   *    instead of zonefile, if given).
   * @param {boolean} buildIncomplete - optional boolean, defaults to false,
   *    indicating whether the function should attempt to return an unsigned (or not fully signed)
   *    transaction. Useful for passing around a TX for multi-sig input signing.
   * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
   *    this function *does not* perform the requisite safety checks -- please see
   *    the safety module for those.
   * @private
   */
  function makeRenewal(fullyQualifiedName, destinationAddress, ownerKeyIn, paymentKeyIn, zonefile = null, valueHash = null, buildIncomplete = false) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const network = config_1.config.network;
          if (!valueHash && !!zonefile) {
              valueHash = utils_1.hash160(Buffer.from(zonefile)).toString('hex');
          }
          const namespace = fullyQualifiedName.split('.').pop();
          const paymentKey = getTransactionSigner(paymentKeyIn);
          const ownerKey = getTransactionSigner(ownerKeyIn);
          return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()])
              .then(([ownerAddress, paymentAddress]) => {
              const txPromise = Promise.all([network.getNamePrice(fullyQualifiedName),
                  network.getNamespaceBurnAddress(namespace)])
                  .then(([namePrice, burnAddress]) => skeletons_1.makeRenewalSkeleton(fullyQualifiedName, destinationAddress, ownerAddress, burnAddress, namePrice, valueHash))
                  .then((tx) => {
                  const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(tx, network.layer1);
                  txB.setVersion(1);
                  return txB;
              });
              return Promise.all([txPromise, network.getUTXOs(paymentAddress),
                  network.getUTXOs(ownerAddress), network.getFeeRate()])
                  .then(([txB, payerUtxos, ownerUtxos, feeRate]) => {
                  const ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB, false);
                  const txInner = utils_1.getTransactionInsideBuilder(txB);
                  const ownerOutput = txInner.outs[2];
                  const ownerOutputAddr = bitcoinjs_lib_1.address.fromOutputScript(ownerOutput.script, network.layer1);
                  if (ownerOutputAddr !== ownerAddress) {
                      return Promise.reject(new Error(`Original owner ${ownerAddress} should have an output at `
                          + `index 2 in transaction was ${ownerOutputAddr}`));
                  }
                  ownerOutput.value = ownerInput.value;
                  const signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);
                  return utils_1.signInputs(signingTxB, paymentKey, [{ index: ownerInput.index, signer: ownerKey }]);
              });
          })
              .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));
      });
  }
  /**
   * Generates a namespace preorder transaction for a namespace
   * @param {String} namespaceID - the namespace to pre-order
   * @param {String} revealAddress - the address to receive the namespace (this
   *    must be passed as the 'revealAddress' in the namespace-reveal transaction)
   * @param {String | TransactionSigner} paymentKeyIn - a hex string of
   *    the private key used to fund the transaction (or a
   *    TransactionSigner object)
   * @param {boolean} buildIncomplete - optional boolean, defaults to false,
   *    indicating whether the function should attempt to return an unsigned (or not fully signed)
   *    transaction. Useful for passing around a TX for multi-sig input signing.
   * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
   *    this function *does not* perform the requisite safety checks -- please see
   *    the safety module for those.
   * @private
   *
   * @ignore
   */
  function makeNamespacePreorder(namespaceID, revealAddress, paymentKeyIn, buildIncomplete = false) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const network = config_1.config.network;
          const paymentKey = getTransactionSigner(paymentKeyIn);
          const preorderAddress = yield paymentKey.getAddress();
          const preorderPromise = Promise.all([network.getConsensusHash(),
              network.getNamespacePrice(namespaceID)])
              .then(([consensusHash, namespacePrice]) => skeletons_1.makeNamespacePreorderSkeleton(namespaceID, consensusHash, preorderAddress, revealAddress, namespacePrice));
          return Promise.all([network.getUTXOs(preorderAddress), network.getFeeRate(), preorderPromise])
              .then(([utxos, feeRate, preorderSkeleton]) => {
              const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(preorderSkeleton, network.layer1);
              txB.setVersion(1);
              const changeIndex = 1; // preorder skeleton always creates a change output at index = 1
              const signingTxB = fundTransaction(txB, preorderAddress, utxos, feeRate, 0, changeIndex);
              return utils_1.signInputs(signingTxB, paymentKey);
          })
              .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));
      });
  }
  /**
   * Generates a namespace reveal transaction for a namespace
   * @param {BlockstackNamespace} namespace - the namespace to reveal
   * @param {String} revealAddress - the address to receive the namespace (this
   *   must be passed as the 'revealAddress' in the namespace-reveal transaction)
   * @param {String | TransactionSigner} paymentKeyIn - a hex string (or
   *   a TransactionSigner object) of the private key used to fund the
   *   transaction
   * @param {boolean} buildIncomplete - optional boolean, defaults to false,
   *   indicating whether the function should attempt to return an unsigned (or not fully signed)
   *   transaction. Useful for passing around a TX for multi-sig input signing.
   * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
   *   this function *does not* perform the requisite safety checks -- please see
   *   the safety module for those.
   * @private
   */
  function makeNamespaceReveal(namespace, revealAddress, paymentKeyIn, buildIncomplete = false) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const network = config_1.config.network;
          if (!namespace.check()) {
              return Promise.reject(new Error('Invalid namespace'));
          }
          const namespaceRevealTX = skeletons_1.makeNamespaceRevealSkeleton(namespace, revealAddress);
          const paymentKey = getTransactionSigner(paymentKeyIn);
          const preorderAddress = yield paymentKey.getAddress();
          return Promise.all([network.getUTXOs(preorderAddress), network.getFeeRate()])
              .then(([utxos, feeRate]) => {
              const txB = bitcoinjs_lib_1.TransactionBuilder
                  .fromTransaction(namespaceRevealTX, network.layer1);
              txB.setVersion(1);
              const signingTxB = fundTransaction(txB, preorderAddress, utxos, feeRate, 0);
              return utils_1.signInputs(signingTxB, paymentKey);
          })
              .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));
      });
  }
  /**
   * Generates a namespace ready transaction for a namespace
   * @param {String} namespaceID - the namespace to launch
   * @param {String | TransactionSigner} revealKeyIn - the private key
   *  of the 'revealAddress' used to reveal the namespace
   * @param {boolean} buildIncomplete - optional boolean, defaults to false,
   *  indicating whether the function should attempt to return an unsigned (or not fully signed)
   *  transaction. Useful for passing around a TX for multi-sig input signing.
   * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
   *  this function *does not* perform the requisite safety checks -- please see
   *  the safety module for those.
   * @private
   */
  function makeNamespaceReady(namespaceID, revealKeyIn, buildIncomplete = false) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const network = config_1.config.network;
          const namespaceReadyTX = skeletons_1.makeNamespaceReadySkeleton(namespaceID);
          const revealKey = getTransactionSigner(revealKeyIn);
          const revealAddress = yield revealKey.getAddress();
          return Promise.all([network.getUTXOs(revealAddress), network.getFeeRate()])
              .then(([utxos, feeRate]) => {
              const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(namespaceReadyTX, network.layer1);
              txB.setVersion(1);
              const signingTxB = fundTransaction(txB, revealAddress, utxos, feeRate, 0);
              return utils_1.signInputs(signingTxB, revealKey);
          })
              .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));
      });
  }
  /**
   * Generates a name import transaction for a namespace
   * @param {String} name - the name to import
   * @param {String} recipientAddr - the address to receive the name
   * @param {String} zonefileHash - the hash of the zonefile to give this name
   * @param {String | TransactionSigner} importerKeyIn - the private key
   * that pays for the import
   * @param {boolean} buildIncomplete - optional boolean, defaults to false,
   * indicating whether the function should attempt to return an unsigned (or not fully signed)
   * transaction. Useful for passing around a TX for multi-sig input signing.
   * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
   * this function does not perform the requisite safety checks -- please see
   * the safety module for those.
   * @private
   */
  function makeNameImport(name, recipientAddr, zonefileHash, importerKeyIn, buildIncomplete = false) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const network = config_1.config.network;
          const nameImportTX = skeletons_1.makeNameImportSkeleton(name, recipientAddr, zonefileHash);
          const importerKey = getTransactionSigner(importerKeyIn);
          const importerAddress = yield importerKey.getAddress();
          return Promise.all([network.getUTXOs(importerAddress), network.getFeeRate()])
              .then(([utxos, feeRate]) => {
              const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(nameImportTX, network.layer1);
              const signingTxB = fundTransaction(txB, importerAddress, utxos, feeRate, 0);
              return utils_1.signInputs(signingTxB, importerKey);
          })
              .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));
      });
  }
  /**
   * Generates an announce transaction
   * @param {String} messageHash - the hash of the message to send.  Should be
   *  an already-announced zone file hash
   * @param {String | TransactionSigner} senderKeyIn - the private key
   *  that pays for the transaction.  Should be the key that owns the
   *  name that the message recipients subscribe to
   * @param {boolean} buildIncomplete - optional boolean, defaults to false,
   * indicating whether the function should attempt to return an unsigned (or not fully signed)
   * transaction. Useful for passing around a TX for multi-sig input signing.
   * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
   * this function does not perform the requisite safety checks -- please see the
   * safety module for those.
   * @private
   */
  function makeAnnounce(messageHash, senderKeyIn, buildIncomplete = false) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const network = config_1.config.network;
          const announceTX = skeletons_1.makeAnnounceSkeleton(messageHash);
          const senderKey = getTransactionSigner(senderKeyIn);
          const senderAddress = yield senderKey.getAddress();
          return Promise.all([network.getUTXOs(senderAddress), network.getFeeRate()])
              .then(([utxos, feeRate]) => {
              const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(announceTX, network.layer1);
              const signingTxB = fundTransaction(txB, senderAddress, utxos, feeRate, 0);
              return utils_1.signInputs(signingTxB, senderKey);
          })
              .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));
      });
  }
  /**
   * Generates a token-transfer transaction
   * @param {String} recipientAddress - the address to receive the tokens
   * @param {String} tokenType - the type of tokens to send
   * @param {Object} tokenAmount - the BigInteger encoding of an unsigned 64-bit number of
   *  tokens to send
   * @param {String} scratchArea - an arbitrary string to include with the transaction
   * @param {String | TransactionSigner} senderKeyIn - the hex-encoded private key to send
   *   the tokens
   * @param {String | TransactionSigner} btcFunderKeyIn - the hex-encoded private key to fund
   *   the bitcoin fees for the transaction. Optional -- if not passed, will attempt to
   *   fund with sender key.
   * @param {boolean} buildIncomplete - optional boolean, defaults to false,
   *   indicating whether the function should attempt to return an unsigned (or not fully signed)
   *   transaction. Useful for passing around a TX for multi-sig input signing.
   * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
   * This function does not perform the requisite safety checks -- please see the
   * safety module for those.
   * @private
   */
  function makeTokenTransfer(recipientAddress, tokenType, tokenAmount, scratchArea, senderKeyIn, btcFunderKeyIn, buildIncomplete = false) {
      const network = config_1.config.network;
      const separateFunder = !!btcFunderKeyIn;
      const senderKey = getTransactionSigner(senderKeyIn);
      const btcKey = btcFunderKeyIn ? getTransactionSigner(btcFunderKeyIn) : senderKey;
      const txPromise = network.getConsensusHash()
          .then(consensusHash => skeletons_1.makeTokenTransferSkeleton(recipientAddress, consensusHash, tokenType, tokenAmount, scratchArea));
      return Promise.all([senderKey.getAddress(), btcKey.getAddress()])
          .then(([senderAddress, btcAddress]) => {
          const btcUTXOsPromise = separateFunder
              ? network.getUTXOs(btcAddress) : Promise.resolve([]);
          return Promise.all([
              network.getUTXOs(senderAddress),
              btcUTXOsPromise,
              network.getFeeRate(),
              txPromise
          ]).then(([senderUTXOs, btcUTXOs, feeRate, tokenTransferTX]) => {
              const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(tokenTransferTX, network.layer1);
              if (separateFunder) {
                  const payerInput = addOwnerInput(senderUTXOs, senderAddress, txB);
                  const signingTxB = fundTransaction(txB, btcAddress, btcUTXOs, feeRate, payerInput.value);
                  return utils_1.signInputs(signingTxB, btcKey, [{ index: payerInput.index, signer: senderKey }]);
              }
              else {
                  const signingTxB = fundTransaction(txB, senderAddress, senderUTXOs, feeRate, 0);
                  return utils_1.signInputs(signingTxB, senderKey);
              }
          });
      })
          .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));
  }
  /**
   * Generates a bitcoin spend to a specified address. This will fund up to `amount`
   *   of satoshis from the payer's UTXOs. It will generate a change output if and only
   *   if the amount of leftover change is *greater* than the additional fees associated
   *   with the extra output. If the requested amount is not enough to fund the transaction's
   *   associated fees, then this will reject with a InvalidAmountError
   *
   * UTXOs are selected largest to smallest, and UTXOs which cannot fund the fees associated
   *   with their own input will not be included.
   *
   * If you specify an amount > the total balance of the payer address, then this will
   *   generate a maximum spend transaction
   *
   * @param {String} destinationAddress - the address to receive the bitcoin payment
   * @param {String | TransactionSigner} paymentKeyIn - the private key
   *    used to fund the bitcoin spend
   * @param {number} amount - the amount in satoshis for the payment address to
   *    spend in this transaction
   * @param {boolean} buildIncomplete - optional boolean, defaults to false,
   * indicating whether the function should attempt to return an unsigned (or not fully signed)
   * transaction. Useful for passing around a TX for multi-sig input signing.
   * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
   * @private
   */
  function makeBitcoinSpend(destinationAddress, paymentKeyIn, amount, buildIncomplete = false) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (amount <= 0) {
              return Promise.reject(new errors_1.InvalidParameterError('amount', 'amount must be greater than zero'));
          }
          const network = config_1.config.network;
          const paymentKey = getTransactionSigner(paymentKeyIn);
          const paymentAddress = yield paymentKey.getAddress();
          return Promise.all([network.getUTXOs(paymentAddress), network.getFeeRate()])
              .then(([utxos, feeRate]) => {
              const txB = new bitcoinjs_lib_1.TransactionBuilder(network.layer1);
              txB.setVersion(1);
              const destinationIndex = txB.addOutput(destinationAddress, 0);
              // will add utxos up to _amount_ and return the amount of leftover _change_
              let change;
              try {
                  change = utils_1.addUTXOsToFund(txB, utxos, amount, feeRate, false);
              }
              catch (err) {
                  if (err.name === 'NotEnoughFundsError') {
                      // actual amount funded = amount requested - remainder
                      amount -= err.leftToFund;
                      change = 0;
                  }
                  else {
                      throw err;
                  }
              }
              let feesToPay = feeRate * utils_1.estimateTXBytes(txB, 0, 0);
              const feeForChange = feeRate * (utils_1.estimateTXBytes(txB, 0, 1)) - feesToPay;
              // it's worthwhile to add a change output
              if (change > feeForChange) {
                  feesToPay += feeForChange;
                  txB.addOutput(paymentAddress, change);
              }
              // now let's compute how much output is leftover once we pay the fees.
              const outputAmount = amount - feesToPay;
              if (outputAmount < utils_1.DUST_MINIMUM) {
                  throw new errors_1.InvalidAmountError(feesToPay, amount);
              }
              // we need to manually set the output values now
              const txInner = utils_1.getTransactionInsideBuilder(txB);
              const txOut = txInner.outs[destinationIndex];
              txOut.value = outputAmount;
              // ready to sign.
              return utils_1.signInputs(txB, paymentKey);
          })
              .then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));
      });
  }
  exports.transactions = {
      makeRenewal,
      makeUpdate,
      makePreorder,
      makeRegister,
      makeTransfer,
      makeRevoke,
      makeNamespacePreorder,
      makeNamespaceReveal,
      makeNamespaceReady,
      makeBitcoinSpend,
      makeNameImport,
      makeAnnounce,
      makeTokenTransfer,
      BlockstackNamespace: skeletons_1.BlockstackNamespace,
      estimatePreorder,
      estimateRegister,
      estimateTransfer,
      estimateUpdate,
      estimateRenewal,
      estimateRevoke,
      estimateNamespacePreorder,
      estimateNamespaceReveal,
      estimateNamespaceReady,
      estimateNameImport,
      estimateAnnounce,
      estimateTokenTransfer
  };
  
  }).call(this,require("buffer").Buffer)
  },{"../config":46,"../errors":58,"./signers":66,"./skeletons":67,"./utils":69,"bitcoinjs-lib":148,"buffer":3,"tslib":268}],69:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const bitcoinjs_lib_1 = require("bitcoinjs-lib");
  const BN = require("bn.js");
  const errors_1 = require("../errors");
  const sha2Hash_1 = require("../encryption/sha2Hash");
  const hashRipemd160_1 = require("../encryption/hashRipemd160");
  /**
   *
   * @ignore
   */
  exports.DUST_MINIMUM = 5500;
  /**
   * Creates a RIPEMD160(SHA256(input)) hash.
   * @ignore
   */
  function hash160(buff) {
      const sha256 = sha2Hash_1.hashSha256Sync(buff);
      return hashRipemd160_1.hashRipemd160(sha256);
  }
  exports.hash160 = hash160;
  /**
   * Creates a SHA256 hash, truncated to 128 bits.
   * @ignore
   */
  function hash128(buff) {
      const sha256 = sha2Hash_1.hashSha256Sync(buff);
      return sha256.slice(0, 16);
  }
  exports.hash128 = hash128;
  // COPIED FROM coinselect, because 1 byte matters sometimes.
  // baseline estimates, used to improve performance
  const TX_EMPTY_SIZE = 4 + 1 + 1 + 4;
  const TX_INPUT_BASE = 32 + 4 + 1 + 4;
  const TX_INPUT_PUBKEYHASH = 107;
  const TX_OUTPUT_BASE = 8 + 1;
  const TX_OUTPUT_PUBKEYHASH = 25;
  function inputBytes(input) {
      if (input && input.script && input.script.length > 0) {
          return TX_INPUT_BASE + input.script.length;
      }
      else {
          return TX_INPUT_BASE + TX_INPUT_PUBKEYHASH;
      }
  }
  function outputBytes(output) {
      if (output && output.script && output.script.length > 0) {
          return TX_OUTPUT_BASE + output.script.length;
      }
      else {
          return TX_OUTPUT_BASE + TX_OUTPUT_PUBKEYHASH;
      }
  }
  function transactionBytes(inputs, outputs) {
      return TX_EMPTY_SIZE
          + inputs.reduce((a, x) => (a + inputBytes(x)), 0)
          + outputs.reduce((a, x) => (a + outputBytes(x)), 0);
  }
  /**
   *
   * @ignore
   */
  function getTransactionInsideBuilder(txBuilder) {
      return txBuilder.__TX;
  }
  exports.getTransactionInsideBuilder = getTransactionInsideBuilder;
  function getTransaction(txIn) {
      if (txIn instanceof bitcoinjs_lib_1.Transaction) {
          return txIn;
      }
      return getTransactionInsideBuilder(txIn);
  }
  //
  /**
   *
   * @ignore
   */
  function estimateTXBytes(txIn, additionalInputs, additionalOutputs) {
      const innerTx = getTransaction(txIn);
      const dummyInputs = new Array(additionalInputs);
      dummyInputs.fill(null);
      const dummyOutputs = new Array(additionalOutputs);
      dummyOutputs.fill(null);
      const inputs = [].concat(innerTx.ins, dummyInputs);
      const outputs = [].concat(innerTx.outs, dummyOutputs);
      return transactionBytes(inputs, outputs);
  }
  exports.estimateTXBytes = estimateTXBytes;
  /**
   *
   * @ignore
   */
  function sumOutputValues(txIn) {
      const innerTx = getTransaction(txIn);
      return innerTx.outs.reduce((agg, x) => agg + x.value, 0);
  }
  exports.sumOutputValues = sumOutputValues;
  /**
   *
   * @ignore
   */
  function decodeB40(input) {
      // treat input as a base40 integer, and output a hex encoding
      // of that integer.
      //
      //   for each digit of the string, find its location in `characters`
      //    to get the value of the digit, then multiply by 40^(-index in input)
      // e.g.,
      // the 'right-most' character has value: (digit-value) * 40^0
      //  the next character has value: (digit-value) * 40^1
      //
      // hence, we reverse the characters first, and use the index
      //  to compute the value of each digit, then sum
      const characters = '0123456789abcdefghijklmnopqrstuvwxyz-_.+';
      const base = new BN(40);
      const inputDigits = input.split('').reverse();
      const digitValues = inputDigits.map(((character, exponent) => new BN(characters.indexOf(character))
          .mul(base.pow(new BN(exponent)))));
      const sum = digitValues.reduce((agg, cur) => agg.add(cur), new BN(0));
      return sum.toString(16, 2);
  }
  exports.decodeB40 = decodeB40;
  /**
   * Adds UTXOs to fund a transaction
   * @param {TransactionBuilder} txBuilderIn - a transaction builder object to add the inputs to. this
   *    object is _always_ mutated. If not enough UTXOs exist to fund, the tx builder object
   *    will still contain as many inputs as could be found.
   * @param {Array<{value: number, tx_hash: string, tx_output_n}>} utxos - the utxo set for the
   *    payer's address.
   * @param {number} amountToFund - the amount of satoshis to fund in the transaction. the payer's
   *    utxos will be included to fund up to this amount of *output* and the corresponding *fees*
   *    for those additional inputs
   * @param {number} feeRate - the satoshis/byte fee rate to use for fee calculation
   * @param {boolean} fundNewFees - if true, this function will fund `amountToFund` and any new fees
   *    associated with including the new inputs.
   *    if false, this function will fund _at most_ `amountToFund`
   * @returns {number} - the amount of leftover change (in satoshis)
   * @private
   * @ignore
   */
  function addUTXOsToFund(txBuilderIn, utxos, amountToFund, feeRate, fundNewFees = true) {
      if (utxos.length === 0) {
          throw new errors_1.NotEnoughFundsError(amountToFund);
      }
      // how much are we increasing fees by adding an input ?
      const newFees = feeRate * (estimateTXBytes(txBuilderIn, 1, 0)
          - estimateTXBytes(txBuilderIn, 0, 0));
      let utxoThreshhold = amountToFund;
      if (fundNewFees) {
          utxoThreshhold += newFees;
      }
      const goodUtxos = utxos.filter(utxo => utxo.value >= utxoThreshhold);
      if (goodUtxos.length > 0) {
          goodUtxos.sort((a, b) => a.value - b.value);
          const selected = goodUtxos[0];
          let change = selected.value - amountToFund;
          if (fundNewFees) {
              change -= newFees;
          }
          txBuilderIn.addInput(selected.tx_hash, selected.tx_output_n);
          return change;
      }
      else {
          utxos.sort((a, b) => b.value - a.value);
          const largest = utxos[0];
          if (newFees >= largest.value) {
              throw new errors_1.NotEnoughFundsError(amountToFund);
          }
          txBuilderIn.addInput(largest.tx_hash, largest.tx_output_n);
          let remainToFund = amountToFund - largest.value;
          if (fundNewFees) {
              remainToFund += newFees;
          }
          return addUTXOsToFund(txBuilderIn, utxos.slice(1), remainToFund, feeRate, fundNewFees);
      }
  }
  exports.addUTXOsToFund = addUTXOsToFund;
  function signInputs(txB, defaultSigner, otherSigners) {
      const txInner = getTransactionInsideBuilder(txB);
      const signerArray = txInner.ins.map(() => defaultSigner);
      if (otherSigners) {
          otherSigners.forEach((signerPair) => {
              signerArray[signerPair.index] = signerPair.signer;
          });
      }
      let signingPromise = Promise.resolve();
      for (let i = 0; i < txInner.ins.length; i++) {
          signingPromise = signingPromise.then(() => signerArray[i].signTransaction(txB, i));
      }
      return signingPromise.then(() => txB);
  }
  exports.signInputs = signInputs;
  
  },{"../encryption/hashRipemd160":52,"../encryption/sha2Hash":56,"../errors":58,"bitcoinjs-lib":148,"bn.js":187}],70:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  var profile_1 = require("./profile");
  exports.Profile = profile_1.Profile;
  var profileSchemas_1 = require("./profileSchemas");
  exports.Person = profileSchemas_1.Person;
  exports.Organization = profileSchemas_1.Organization;
  exports.CreativeWork = profileSchemas_1.CreativeWork;
  exports.resolveZoneFileToPerson = profileSchemas_1.resolveZoneFileToPerson;
  var profileTokens_1 = require("./profileTokens");
  exports.signProfileToken = profileTokens_1.signProfileToken;
  exports.wrapProfileToken = profileTokens_1.wrapProfileToken;
  exports.verifyProfileToken = profileTokens_1.verifyProfileToken;
  exports.extractProfile = profileTokens_1.extractProfile;
  var profileProofs_1 = require("./profileProofs");
  exports.validateProofs = profileProofs_1.validateProofs;
  var serviceUtils_1 = require("./services/serviceUtils");
  exports.containsValidProofStatement = serviceUtils_1.containsValidProofStatement;
  exports.containsValidAddressProofStatement = serviceUtils_1.containsValidAddressProofStatement;
  var profileZoneFiles_1 = require("./profileZoneFiles");
  exports.makeProfileZoneFile = profileZoneFiles_1.makeProfileZoneFile;
  exports.getTokenFileUrl = profileZoneFiles_1.getTokenFileUrl;
  exports.resolveZoneFileToProfile = profileZoneFiles_1.resolveZoneFileToProfile;
  var profileLookup_1 = require("./profileLookup");
  exports.lookupProfile = profileLookup_1.lookupProfile;
  
  },{"./profile":71,"./profileLookup":72,"./profileProofs":73,"./profileSchemas":75,"./profileTokens":81,"./profileZoneFiles":82,"./services/serviceUtils":90}],71:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const tslib_1 = require("tslib");
  // @ts-ignore: Could not find a declaration file for module
  const inspector = require("schema-inspector");
  const profileTokens_1 = require("./profileTokens");
  const profileProofs_1 = require("./profileProofs");
  const profileZoneFiles_1 = require("./profileZoneFiles");
  const schemaDefinition = {
      type: 'object',
      properties: {
          '@context': { type: 'string', optional: true },
          '@type': { type: 'string' }
      }
  };
  /**
   * Represents a user profile
   *
   */
  class Profile {
      constructor(profile = {}) {
          this._profile = Object.assign({}, {
              '@context': 'http://schema.org/'
          }, profile);
      }
      toJSON() {
          return Object.assign({}, this._profile);
      }
      toToken(privateKey) {
          return profileTokens_1.signProfileToken(this.toJSON(), privateKey);
      }
      static validateSchema(profile, strict = false) {
          schemaDefinition.strict = strict;
          return inspector.validate(schemaDefinition, profile);
      }
      static fromToken(token, publicKeyOrAddress = null) {
          const profile = profileTokens_1.extractProfile(token, publicKeyOrAddress);
          return new Profile(profile);
      }
      static makeZoneFile(domainName, tokenFileURL) {
          return profileZoneFiles_1.makeProfileZoneFile(domainName, tokenFileURL);
      }
      static validateProofs(domainName, cheerio) {
          return tslib_1.__awaiter(this, void 0, void 0, function* () {
              return profileProofs_1.validateProofs(new Profile().toJSON(), domainName, cheerio);
          });
      }
  }
  exports.Profile = Profile;
  
  },{"./profileProofs":73,"./profileTokens":81,"./profileZoneFiles":82,"schema-inspector":254,"tslib":268}],72:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const profileZoneFiles_1 = require("./profileZoneFiles");
  const config_1 = require("../config");
  const fetchUtil_1 = require("../fetchUtil");
  /**
   * Look up a user profile by blockstack ID
   *
   * @param {string} username - The Blockstack ID of the profile to look up
   * @param {string} [zoneFileLookupURL=null] - The URL
   * to use for zonefile lookup. If falsey, lookupProfile will use the
   * blockstack.js [[getNameInfo]] function.
   * @returns {Promise} that resolves to a profile object
   */
  function lookupProfile(username, zoneFileLookupURL) {
      if (!username) {
          return Promise.reject();
      }
      let lookupPromise;
      if (zoneFileLookupURL) {
          const url = `${zoneFileLookupURL.replace(/\/$/, '')}/${username}`;
          lookupPromise = fetchUtil_1.fetchPrivate(url)
              .then(response => response.json());
      }
      else {
          lookupPromise = config_1.config.network.getNameInfo(username);
      }
      return lookupPromise
          .then((responseJSON) => {
          if (responseJSON.hasOwnProperty('zonefile')
              && responseJSON.hasOwnProperty('address')) {
              return profileZoneFiles_1.resolveZoneFileToProfile(responseJSON.zonefile, responseJSON.address);
          }
          else {
              throw new Error('Invalid zonefile lookup response: did not contain `address`'
                  + ' or `zonefile` field');
          }
      });
  }
  exports.lookupProfile = lookupProfile;
  
  },{"../config":46,"../fetchUtil":59,"./profileZoneFiles":82}],73:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const services_1 = require("./services");
  /**
   * Validates the social proofs in a user's profile. Currently supports validation of
   * Facebook, Twitter, GitHub, Instagram, LinkedIn and HackerNews accounts.
   *
   * @param {Object} profile The JSON of the profile to be validated
   * @param {string} ownerAddress The owner bitcoin address to be validated
   * @param {string} [name=null] The Blockstack name to be validated
   * @returns {Promise} that resolves to an array of validated proof objects
   */
  function validateProofs(profile, ownerAddress, cheerio, name = null) {
      if (!profile) {
          throw new Error('Profile must not be null');
      }
      let accounts = [];
      const proofsToValidate = [];
      if (profile.hasOwnProperty('account')) {
          accounts = profile.account;
      }
      else {
          return Promise.resolve([]);
      }
      accounts.forEach((account) => {
          // skip if proof service is not supported
          if (account.hasOwnProperty('service')
              && !services_1.profileServices.hasOwnProperty(account.service)) {
              return;
          }
          if (!(account.hasOwnProperty('proofType')
              && account.proofType === 'http'
              && account.hasOwnProperty('proofUrl'))) {
              return;
          }
          const proof = {
              service: account.service,
              proof_url: account.proof_url || account.proofUrl,
              identifier: account.identifier,
              valid: false
          };
          proofsToValidate.push(services_1.profileServices[account.service]
              .validateProof(proof, ownerAddress, cheerio, name));
      });
      return Promise.all(proofsToValidate);
  }
  exports.validateProofs = validateProofs;
  
  },{"./services":86}],74:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  // @ts-ignore: Could not find a declaration file for module
  const schema_inspector_1 = require("schema-inspector");
  const profileTokens_1 = require("../profileTokens");
  const profile_1 = require("../profile");
  const schemaDefinition = {
      type: 'object',
      properties: {
          '@context': { type: 'string', optional: true },
          '@type': { type: 'string' },
          '@id': { type: 'string', optional: true }
      }
  };
  /**
   * @ignore
   */
  class CreativeWork extends profile_1.Profile {
      constructor(profile = {}) {
          super(profile);
          this._profile = Object.assign({}, {
              '@type': 'CreativeWork'
          }, this._profile);
      }
      /**
       *
       * @ignore
       */
      static validateSchema(profile, strict = false) {
          schemaDefinition.strict = strict;
          return schema_inspector_1.default.validate(schemaDefinition, profile);
      }
      /**
       * @ignore
       */
      static fromToken(token, publicKeyOrAddress = null) {
          const profile = profileTokens_1.extractProfile(token, publicKeyOrAddress);
          return new CreativeWork(profile);
      }
  }
  exports.CreativeWork = CreativeWork;
  
  },{"../profile":71,"../profileTokens":81,"schema-inspector":254}],75:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  var person_1 = require("./person");
  exports.Person = person_1.Person;
  var organization_1 = require("./organization");
  exports.Organization = organization_1.Organization;
  var creativework_1 = require("./creativework");
  exports.CreativeWork = creativework_1.CreativeWork;
  var personLegacy_1 = require("./personLegacy");
  exports.getPersonFromLegacyFormat = personLegacy_1.getPersonFromLegacyFormat;
  var personZoneFiles_1 = require("./personZoneFiles");
  exports.resolveZoneFileToPerson = personZoneFiles_1.resolveZoneFileToPerson;
  
  },{"./creativework":74,"./organization":76,"./person":77,"./personLegacy":78,"./personZoneFiles":80}],76:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  // TODO: replace with 'ajv' - its already a dependency and it is maintained
  // @ts-ignore: Could not find a declaration file for module
  const schema_inspector_1 = require("schema-inspector");
  const profileTokens_1 = require("../profileTokens");
  const profile_1 = require("../profile");
  const schemaDefinition = {
      type: 'object',
      properties: {
          '@context': { type: 'string', optional: true },
          '@type': { type: 'string' },
          '@id': { type: 'string', optional: true }
      }
  };
  /**
   * @ignore
   */
  class Organization extends profile_1.Profile {
      constructor(profile = {}) {
          super(profile);
          this._profile = Object.assign({}, {
              '@type': 'Organization'
          }, this._profile);
      }
      static validateSchema(profile, strict = false) {
          schemaDefinition.strict = strict;
          return schema_inspector_1.default.validate(schemaDefinition, profile);
      }
      static fromToken(token, publicKeyOrAddress = null) {
          const profile = profileTokens_1.extractProfile(token, publicKeyOrAddress);
          return new Organization(profile);
      }
  }
  exports.Organization = Organization;
  
  },{"../profile":71,"../profileTokens":81,"schema-inspector":254}],77:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  // @ts-ignore: Could not find a declaration file for module
  const inspector = require("schema-inspector");
  const profile_1 = require("../profile");
  const profileTokens_1 = require("../profileTokens");
  const personLegacy_1 = require("./personLegacy");
  const personUtils_1 = require("./personUtils");
  const schemaDefinition = {
      type: 'object',
      strict: false,
      properties: {
          '@context': { type: 'string', optional: true },
          '@type': { type: 'string' },
          '@id': { type: 'string', optional: true },
          name: { type: 'string', optional: true },
          givenName: { type: 'string', optional: true },
          familyName: { type: 'string', optional: true },
          description: { type: 'string', optional: true },
          image: {
              type: 'array',
              optional: true,
              items: {
                  type: 'object',
                  properties: {
                      '@type': { type: 'string' },
                      name: { type: 'string', optional: true },
                      contentUrl: { type: 'string', optional: true }
                  }
              }
          },
          website: {
              type: 'array',
              optional: true,
              items: {
                  type: 'object',
                  properties: {
                      '@type': { type: 'string' },
                      url: { type: 'string', optional: true }
                  }
              }
          },
          account: {
              type: 'array',
              optional: true,
              items: {
                  type: 'object',
                  properties: {
                      '@type': { type: 'string' },
                      service: { type: 'string', optional: true },
                      identifier: { type: 'string', optional: true },
                      proofType: { type: 'string', optional: true },
                      proofUrl: { type: 'string', optional: true },
                      proofMessage: { type: 'string', optional: true },
                      proofSignature: { type: 'string', optional: true }
                  }
              }
          },
          worksFor: {
              type: 'array',
              optional: true,
              items: {
                  type: 'object',
                  properties: {
                      '@type': { type: 'string' },
                      '@id': { type: 'string', optional: true }
                  }
              }
          },
          knows: {
              type: 'array',
              optional: true,
              items: {
                  type: 'object',
                  properties: {
                      '@type': { type: 'string' },
                      '@id': { type: 'string', optional: true }
                  }
              }
          },
          address: {
              type: 'object',
              optional: true,
              properties: {
                  '@type': { type: 'string' },
                  streetAddress: { type: 'string', optional: true },
                  addressLocality: { type: 'string', optional: true },
                  postalCode: { type: 'string', optional: true },
                  addressCountry: { type: 'string', optional: true }
              }
          },
          birthDate: { type: 'string', optional: true },
          taxID: { type: 'string', optional: true }
      }
  };
  /**
   * @ignore
   */
  class Person extends profile_1.Profile {
      constructor(profile = {}) {
          super(profile);
          this._profile = Object.assign({}, {
              '@type': 'Person'
          }, this._profile);
      }
      static validateSchema(profile, strict = false) {
          schemaDefinition.strict = strict;
          return inspector.validate(schemaDefinition, profile);
      }
      static fromToken(token, publicKeyOrAddress = null) {
          const profile = profileTokens_1.extractProfile(token, publicKeyOrAddress);
          return new Person(profile);
      }
      static fromLegacyFormat(legacyProfile) {
          const profile = personLegacy_1.getPersonFromLegacyFormat(legacyProfile);
          return new Person(profile);
      }
      toJSON() {
          return {
              profile: this.profile(),
              name: this.name(),
              givenName: this.givenName(),
              familyName: this.familyName(),
              description: this.description(),
              avatarUrl: this.avatarUrl(),
              verifiedAccounts: this.verifiedAccounts(),
              address: this.address(),
              birthDate: this.birthDate(),
              connections: this.connections(),
              organizations: this.organizations()
          };
      }
      profile() {
          return Object.assign({}, this._profile);
      }
      name() {
          return personUtils_1.getName(this.profile());
      }
      givenName() {
          return personUtils_1.getGivenName(this.profile());
      }
      familyName() {
          return personUtils_1.getFamilyName(this.profile());
      }
      description() {
          return personUtils_1.getDescription(this.profile());
      }
      avatarUrl() {
          return personUtils_1.getAvatarUrl(this.profile());
      }
      verifiedAccounts(verifications) {
          return personUtils_1.getVerifiedAccounts(this.profile(), verifications);
      }
      address() {
          return personUtils_1.getAddress(this.profile());
      }
      birthDate() {
          return personUtils_1.getBirthDate(this.profile());
      }
      connections() {
          return personUtils_1.getConnections(this.profile());
      }
      organizations() {
          return personUtils_1.getOrganizations(this.profile());
      }
  }
  exports.Person = Person;
  
  },{"../profile":71,"../profileTokens":81,"./personLegacy":78,"./personUtils":79,"schema-inspector":254}],78:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  /**
   *
   * @param serviceName
   * @param data
   *
   * @ignore
   */
  function formatAccount(serviceName, data) {
      let proofUrl;
      if (data.proof && data.proof.url) {
          proofUrl = data.proof.url;
      }
      return {
          '@type': 'Account',
          service: serviceName,
          identifier: data.username,
          proofType: 'http',
          proofUrl
      };
  }
  /**
   *
   * @param profile
   *
   * @ignore
   */
  function getPersonFromLegacyFormat(profile) {
      const profileData = {
          '@type': 'Person'
      };
      if (profile) {
          if (profile.name && profile.name.formatted) {
              profileData.name = profile.name.formatted;
          }
          if (profile.bio) {
              profileData.description = profile.bio;
          }
          if (profile.location && profile.location.formatted) {
              profileData.address = {
                  '@type': 'PostalAddress',
                  addressLocality: profile.location.formatted
              };
          }
          const images = [];
          if (profile.avatar && profile.avatar.url) {
              images.push({
                  '@type': 'ImageObject',
                  name: 'avatar',
                  contentUrl: profile.avatar.url
              });
          }
          if (profile.cover && profile.cover.url) {
              images.push({
                  '@type': 'ImageObject',
                  name: 'cover',
                  contentUrl: profile.cover.url
              });
          }
          if (images.length) {
              profileData.image = images;
          }
          if (profile.website) {
              profileData.website = [{
                      '@type': 'WebSite',
                      url: profile.website
                  }];
          }
          const accounts = [];
          if (profile.bitcoin && profile.bitcoin.address) {
              accounts.push({
                  '@type': 'Account',
                  role: 'payment',
                  service: 'bitcoin',
                  identifier: profile.bitcoin.address
              });
          }
          if (profile.twitter && profile.twitter.username) {
              accounts.push(formatAccount('twitter', profile.twitter));
          }
          if (profile.facebook && profile.facebook.username) {
              accounts.push(formatAccount('facebook', profile.facebook));
          }
          if (profile.github && profile.github.username) {
              accounts.push(formatAccount('github', profile.github));
          }
          if (profile.auth) {
              if (profile.auth.length > 0) {
                  if (profile.auth[0] && profile.auth[0].publicKeychain) {
                      accounts.push({
                          '@type': 'Account',
                          role: 'key',
                          service: 'bip32',
                          identifier: profile.auth[0].publicKeychain
                      });
                  }
              }
          }
          if (profile.pgp && profile.pgp.url) {
              accounts.push({
                  '@type': 'Account',
                  role: 'key',
                  service: 'pgp',
                  identifier: profile.pgp.fingerprint,
                  contentUrl: profile.pgp.url
              });
          }
          profileData.account = accounts;
      }
      return profileData;
  }
  exports.getPersonFromLegacyFormat = getPersonFromLegacyFormat;
  
  },{}],79:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  function getName(profile) {
      if (!profile) {
          return null;
      }
      let name = null;
      if (profile.name) {
          name = profile.name;
      }
      else if (profile.givenName || profile.familyName) {
          name = '';
          if (profile.givenName) {
              name = profile.givenName;
          }
          if (profile.familyName) {
              name += ` ${profile.familyName}`;
          }
      }
      return name;
  }
  exports.getName = getName;
  /**
   *
   * @ignore
   */
  function getGivenName(profile) {
      if (!profile) {
          return null;
      }
      let givenName = null;
      if (profile.givenName) {
          givenName = profile.givenName;
      }
      else if (profile.name) {
          const nameParts = profile.name.split(' ');
          givenName = nameParts.slice(0, -1).join(' ');
      }
      return givenName;
  }
  exports.getGivenName = getGivenName;
  /**
   *
   * @ignore
   */
  function getFamilyName(profile) {
      if (!profile) {
          return null;
      }
      let familyName = null;
      if (profile.familyName) {
          familyName = profile.familyName;
      }
      else if (profile.name) {
          const nameParts = profile.name.split(' ');
          familyName = nameParts.pop();
      }
      return familyName;
  }
  exports.getFamilyName = getFamilyName;
  /**
   *
   * @ignore
   */
  function getDescription(profile) {
      if (!profile) {
          return null;
      }
      let description = null;
      if (profile.description) {
          description = profile.description;
      }
      return description;
  }
  exports.getDescription = getDescription;
  /**
   *
   * @ignore
   */
  function getAvatarUrl(profile) {
      if (!profile) {
          return null;
      }
      let avatarContentUrl = null;
      if (profile.image) {
          profile.image.map((image) => {
              if (image.name === 'avatar') {
                  avatarContentUrl = image.contentUrl;
                  return avatarContentUrl;
              }
              else {
                  return null;
              }
          });
      }
      return avatarContentUrl;
  }
  exports.getAvatarUrl = getAvatarUrl;
  /**
   *
   * @ignore
   */
  function getVerifiedAccounts(profile, verifications) {
      if (!profile) {
          return null;
      }
      const filteredAccounts = [];
      if (profile.hasOwnProperty('account') && verifications) {
          profile.account.map((account) => {
              let accountIsValid = false;
              let proofUrl = null;
              verifications.map((verification) => {
                  if (verification.hasOwnProperty('proof_url')) {
                      verification.proofUrl = verification.proof_url;
                  }
                  if (verification.valid
                      && verification.service === account.service
                      && verification.identifier === account.identifier
                      && verification.proofUrl) {
                      accountIsValid = true;
                      proofUrl = verification.proofUrl;
                      return true;
                  }
                  else {
                      return false;
                  }
              });
              if (accountIsValid) {
                  account.proofUrl = proofUrl;
                  filteredAccounts.push(account);
                  return account;
              }
              else {
                  return null;
              }
          });
      }
      return filteredAccounts;
  }
  exports.getVerifiedAccounts = getVerifiedAccounts;
  /**
   *
   * @ignore
   */
  function getOrganizations(profile) {
      if (!profile) {
          return null;
      }
      const organizations = [];
      if (profile.hasOwnProperty('worksFor')) {
          return profile.worksFor;
      }
      return organizations;
  }
  exports.getOrganizations = getOrganizations;
  /**
   *
   * @ignore
   */
  function getConnections(profile) {
      if (!profile) {
          return null;
      }
      let connections = [];
      if (profile.hasOwnProperty('knows')) {
          connections = profile.knows;
      }
      return connections;
  }
  exports.getConnections = getConnections;
  /**
   *
   * @ignore
   */
  function getAddress(profile) {
      if (!profile) {
          return null;
      }
      let addressString = null;
      if (profile.hasOwnProperty('address')) {
          const addressParts = [];
          if (profile.address.hasOwnProperty('streetAddress')) {
              addressParts.push(profile.address.streetAddress);
          }
          if (profile.address.hasOwnProperty('addressLocality')) {
              addressParts.push(profile.address.addressLocality);
          }
          if (profile.address.hasOwnProperty('postalCode')) {
              addressParts.push(profile.address.postalCode);
          }
          if (profile.address.hasOwnProperty('addressCountry')) {
              addressParts.push(profile.address.addressCountry);
          }
          if (addressParts.length) {
              addressString = addressParts.join(', ');
          }
      }
      return addressString;
  }
  exports.getAddress = getAddress;
  /**
   *
   * @ignore
   */
  function getBirthDate(profile) {
      if (!profile) {
          return null;
      }
      const monthNames = [
          'January', 'February', 'March', 'April', 'May', 'June',
          'July', 'August', 'September', 'October', 'November', 'December'
      ];
      let birthDateString = null;
      if (profile.hasOwnProperty('birthDate')) {
          const date = new Date(profile.birthDate);
          birthDateString = `${monthNames[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;
      }
      return birthDateString;
  }
  exports.getBirthDate = getBirthDate;
  
  },{}],80:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  // @ts-ignore: Could not find a declaration file for module
  const zone_file_1 = require("zone-file");
  const person_1 = require("./person");
  const profileZoneFiles_1 = require("../profileZoneFiles");
  const profileTokens_1 = require("../profileTokens");
  const fetchUtil_1 = require("../../fetchUtil");
  /**
   *
   * @param zoneFile
   * @param publicKeyOrAddress
   * @param callback
   *
   * @ignore
   */
  function resolveZoneFileToPerson(zoneFile, publicKeyOrAddress, callback) {
      let zoneFileJson = null;
      try {
          zoneFileJson = zone_file_1.parseZoneFile(zoneFile);
          if (!zoneFileJson.hasOwnProperty('$origin')) {
              zoneFileJson = null;
              throw new Error('zone file is missing an origin');
          }
      }
      catch (e) {
          console.error(e);
      }
      let tokenFileUrl = null;
      if (zoneFileJson && Object.keys(zoneFileJson).length > 0) {
          tokenFileUrl = profileZoneFiles_1.getTokenFileUrl(zoneFileJson);
      }
      else {
          let profile = null;
          try {
              profile = JSON.parse(zoneFile);
              const person = person_1.Person.fromLegacyFormat(profile);
              profile = person.profile();
          }
          catch (error) {
              console.warn(error);
          }
          callback(profile);
          return;
      }
      if (tokenFileUrl) {
          fetchUtil_1.fetchPrivate(tokenFileUrl)
              .then(response => response.text())
              .then(responseText => JSON.parse(responseText))
              .then((responseJson) => {
              const tokenRecords = responseJson;
              const token = tokenRecords[0].token;
              const profile = profileTokens_1.extractProfile(token, publicKeyOrAddress);
              callback(profile);
          })
              .catch((error) => {
              console.warn(error);
          });
      }
      else {
          console.warn('Token file url not found');
          callback({});
      }
  }
  exports.resolveZoneFileToPerson = resolveZoneFileToPerson;
  
  },{"../../fetchUtil":59,"../profileTokens":81,"../profileZoneFiles":82,"./person":77,"zone-file":275}],81:[function(require,module,exports){
  (function (Buffer){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const bitcoinjs_lib_1 = require("bitcoinjs-lib");
  const jsontokens_1 = require("jsontokens");
  const utils_1 = require("../utils");
  const keys_1 = require("../keys");
  /**
    * Signs a profile token
    * @param {Object} profile - the JSON of the profile to be signed
    * @param {String} privateKey - the signing private key
    * @param {Object} subject - the entity that the information is about
    * @param {Object} issuer - the entity that is issuing the token
    * @param {String} signingAlgorithm - the signing algorithm to use
    * @param {Date} issuedAt - the time of issuance of the token
    * @param {Date} expiresAt - the time of expiration of the token
    * @returns {Object} - the signed profile token
    *
    */
  function signProfileToken(profile, privateKey, subject, issuer, signingAlgorithm = 'ES256K', issuedAt = new Date(), expiresAt = utils_1.nextYear()) {
      if (signingAlgorithm !== 'ES256K') {
          throw new Error('Signing algorithm not supported');
      }
      const publicKey = jsontokens_1.SECP256K1Client.derivePublicKey(privateKey);
      if (!subject) {
          subject = { publicKey };
      }
      if (!issuer) {
          issuer = { publicKey };
      }
      const tokenSigner = new jsontokens_1.TokenSigner(signingAlgorithm, privateKey);
      const payload = {
          jti: utils_1.makeUUID4(),
          iat: issuedAt.toISOString(),
          exp: expiresAt.toISOString(),
          subject,
          issuer,
          claim: profile
      };
      return tokenSigner.sign(payload);
  }
  exports.signProfileToken = signProfileToken;
  /**
    * Wraps a token for a profile token file
    * @param {String} token - the token to be wrapped
    * @returns {Object} - including `token` and `decodedToken`
    */
  function wrapProfileToken(token) {
      return {
          token,
          decodedToken: jsontokens_1.decodeToken(token)
      };
  }
  exports.wrapProfileToken = wrapProfileToken;
  /**
    * Verifies a profile token
    * @param {String} token - the token to be verified
    * @param {String} publicKeyOrAddress - the public key or address of the
    *   keypair that is thought to have signed the token
    * @returns {Object} - the verified, decoded profile token
    * @throws {Error} - throws an error if token verification fails
    */
  function verifyProfileToken(token, publicKeyOrAddress) {
      const decodedToken = jsontokens_1.decodeToken(token);
      const payload = decodedToken.payload;
      if (typeof payload === 'string') {
          throw new Error('Unexpected token payload type of string');
      }
      // Inspect and verify the subject
      if (payload.hasOwnProperty('subject')) {
          if (!payload.subject.hasOwnProperty('publicKey')) {
              throw new Error('Token doesn\'t have a subject public key');
          }
      }
      else {
          throw new Error('Token doesn\'t have a subject');
      }
      // Inspect and verify the issuer
      if (payload.hasOwnProperty('issuer')) {
          if (!payload.issuer.hasOwnProperty('publicKey')) {
              throw new Error('Token doesn\'t have an issuer public key');
          }
      }
      else {
          throw new Error('Token doesn\'t have an issuer');
      }
      // Inspect and verify the claim
      if (!payload.hasOwnProperty('claim')) {
          throw new Error('Token doesn\'t have a claim');
      }
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
      const issuerPublicKey = payload.issuer.publicKey;
      const publicKeyBuffer = Buffer.from(issuerPublicKey, 'hex');
      const compressedKeyPair = bitcoinjs_lib_1.ECPair.fromPublicKey(publicKeyBuffer, { compressed: true });
      const compressedAddress = keys_1.ecPairToAddress(compressedKeyPair);
      const uncompressedKeyPair = bitcoinjs_lib_1.ECPair.fromPublicKey(publicKeyBuffer, { compressed: false });
      const uncompressedAddress = keys_1.ecPairToAddress(uncompressedKeyPair);
      if (publicKeyOrAddress === issuerPublicKey) {
          // pass
      }
      else if (publicKeyOrAddress === compressedAddress) {
          // pass
      }
      else if (publicKeyOrAddress === uncompressedAddress) {
          // pass
      }
      else {
          throw new Error('Token issuer public key does not match the verifying value');
      }
      const tokenVerifier = new jsontokens_1.TokenVerifier(decodedToken.header.alg, issuerPublicKey);
      if (!tokenVerifier) {
          throw new Error('Invalid token verifier');
      }
      const tokenVerified = tokenVerifier.verify(token);
      if (!tokenVerified) {
          throw new Error('Token verification failed');
      }
      return decodedToken;
  }
  exports.verifyProfileToken = verifyProfileToken;
  /**
    * Extracts a profile from an encoded token and optionally verifies it,
    * if `publicKeyOrAddress` is provided.
    * @param {String} token - the token to be extracted
    * @param {String} publicKeyOrAddress - the public key or address of the
    *   keypair that is thought to have signed the token
    * @returns {Object} - the profile extracted from the encoded token
    * @throws {Error} - if the token isn't signed by the provided `publicKeyOrAddress`
    */
  function extractProfile(token, publicKeyOrAddress = null) {
      let decodedToken;
      if (publicKeyOrAddress) {
          decodedToken = verifyProfileToken(token, publicKeyOrAddress);
      }
      else {
          decodedToken = jsontokens_1.decodeToken(token);
      }
      let profile = {};
      if (decodedToken.hasOwnProperty('payload')) {
          const payload = decodedToken.payload;
          if (typeof payload === 'string') {
              throw new Error('Unexpected token payload type of string');
          }
          if (payload.hasOwnProperty('claim')) {
              profile = payload.claim;
          }
      }
      return profile;
  }
  exports.extractProfile = extractProfile;
  
  }).call(this,require("buffer").Buffer)
  },{"../keys":61,"../utils":95,"bitcoinjs-lib":148,"buffer":3,"jsontokens":237}],82:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  // @ts-ignore: Could not find a declaration file for module
  const zone_file_1 = require("zone-file");
  const profileTokens_1 = require("./profileTokens");
  const person_1 = require("./profileSchemas/person");
  const logger_1 = require("../logger");
  const fetchUtil_1 = require("../fetchUtil");
  /**
   *
   * @param origin
   * @param tokenFileUrl
   *
   * @ignore
   */
  function makeProfileZoneFile(origin, tokenFileUrl) {
      if (tokenFileUrl.indexOf('://') < 0) {
          throw new Error('Invalid token file url');
      }
      const urlScheme = tokenFileUrl.split('://')[0];
      const urlParts = tokenFileUrl.split('://')[1].split('/');
      const domain = urlParts[0];
      const pathname = `/${urlParts.slice(1).join('/')}`;
      const zoneFile = {
          $origin: origin,
          $ttl: 3600,
          uri: [
              {
                  name: '_http._tcp',
                  priority: 10,
                  weight: 1,
                  target: `${urlScheme}://${domain}${pathname}`
              }
          ]
      };
      const zoneFileTemplate = '{$origin}\n{$ttl}\n{uri}\n';
      return zone_file_1.makeZoneFile(zoneFile, zoneFileTemplate);
  }
  exports.makeProfileZoneFile = makeProfileZoneFile;
  /**
   *
   * @param zoneFileJson
   *
   * @ignore
   */
  function getTokenFileUrl(zoneFileJson) {
      if (!zoneFileJson.hasOwnProperty('uri')) {
          return null;
      }
      if (!Array.isArray(zoneFileJson.uri)) {
          return null;
      }
      if (zoneFileJson.uri.length < 1) {
          return null;
      }
      const firstUriRecord = zoneFileJson.uri[0];
      if (!firstUriRecord.hasOwnProperty('target')) {
          return null;
      }
      let tokenFileUrl = firstUriRecord.target;
      if (tokenFileUrl.startsWith('https')) {
          // pass
      }
      else if (tokenFileUrl.startsWith('http')) {
          // pass
      }
      else {
          tokenFileUrl = `https://${tokenFileUrl}`;
      }
      return tokenFileUrl;
  }
  exports.getTokenFileUrl = getTokenFileUrl;
  /**
   *
   * @param zoneFile
   * @param publicKeyOrAddress
   *
   * @ignore
   */
  function resolveZoneFileToProfile(zoneFile, publicKeyOrAddress) {
      return new Promise((resolve, reject) => {
          let zoneFileJson = null;
          try {
              zoneFileJson = zone_file_1.parseZoneFile(zoneFile);
              if (!zoneFileJson.hasOwnProperty('$origin')) {
                  zoneFileJson = null;
              }
          }
          catch (e) {
              reject(e);
          }
          let tokenFileUrl = null;
          if (zoneFileJson && Object.keys(zoneFileJson).length > 0) {
              tokenFileUrl = getTokenFileUrl(zoneFileJson);
          }
          else {
              let profile = null;
              try {
                  profile = JSON.parse(zoneFile);
                  profile = person_1.Person.fromLegacyFormat(profile).profile();
              }
              catch (error) {
                  reject(error);
              }
              resolve(profile);
              return;
          }
          if (tokenFileUrl) {
              fetchUtil_1.fetchPrivate(tokenFileUrl)
                  .then(response => response.text())
                  .then(responseText => JSON.parse(responseText))
                  .then((responseJson) => {
                  const tokenRecords = responseJson;
                  const profile = profileTokens_1.extractProfile(tokenRecords[0].token, publicKeyOrAddress);
                  resolve(profile);
              })
                  .catch((error) => {
                  logger_1.Logger.error(`resolveZoneFileToProfile: error fetching token file ${tokenFileUrl}: ${error}`);
                  reject(error);
              });
          }
          else {
              logger_1.Logger.debug('Token file url not found. Resolving to blank profile.');
              resolve({});
          }
      });
  }
  exports.resolveZoneFileToProfile = resolveZoneFileToProfile;
  
  },{"../fetchUtil":59,"../logger":62,"./profileSchemas/person":77,"./profileTokens":81,"zone-file":275}],83:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const service_1 = require("./service");
  class Facebook extends service_1.Service {
      getProofUrl(proof) {
          return this.normalizeUrl(proof);
      }
      normalizeUrl(proof) {
          let proofUrl = proof.proof_url.toLowerCase();
          const urlRegex = /(?:http[s]*:\/\/){0,1}(?:[a-zA-Z0-9-]+\.)+facebook\.com/;
          proofUrl = super.prefixScheme(proofUrl);
          if (proofUrl.startsWith('https://facebook.com')) {
              let tokens = proofUrl.split('https://facebook.com');
              proofUrl = `https://www.facebook.com${tokens[1]}`;
              tokens = proofUrl.split('https://www.facebook.com/')[1].split('/posts/');
              const postId = tokens[1];
              proofUrl = `https://www.facebook.com/${proof.identifier}/posts/${postId}`;
          }
          else if (proofUrl.match(urlRegex)) {
              const tokens = proofUrl.split('facebook.com/')[1].split('/posts/');
              const postId = tokens[1];
              proofUrl = `https://www.facebook.com/${proof.identifier}/posts/${postId}`;
          }
          else {
              throw new Error(`Proof url ${proof.proof_url} is not valid for service ${proof.service}`);
          }
          return proofUrl;
      }
      getProofStatement(searchText, cheerio) {
          const $ = cheerio.load(searchText);
          const statement = $('meta[name="description"]').attr('content');
          return (statement !== undefined) ? statement.trim() : '';
      }
      getBaseUrls() {
          return [];
      }
  }
  exports.Facebook = Facebook;
  
  },{"./service":89}],84:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const service_1 = require("./service");
  class Github extends service_1.Service {
      getBaseUrls() {
          const baseUrls = ['https://gist.github.com/', 'http://gist.github.com', 'gist.github.com'];
          return baseUrls;
      }
      normalizeUrl(_proof) {
          return '';
      }
      getProofUrl(proof) {
          const baseUrls = this.getBaseUrls();
          let proofUrl = proof.proof_url.toLowerCase();
          proofUrl = super.prefixScheme(proofUrl);
          for (let i = 0; i < baseUrls.length; i++) {
              const requiredPrefix = `${baseUrls[i]}${proof.identifier}`.toLowerCase();
              if (proofUrl.startsWith(requiredPrefix)) {
                  const raw = proofUrl.endsWith('/') ? 'raw' : '/raw';
                  return `${proofUrl}${raw}`;
              }
          }
          throw new Error(`Proof url ${proof.proof_url} is not valid for service ${proof.service}`);
      }
      getProofStatement(searchText, _cheerio) {
          return searchText;
      }
  }
  exports.Github = Github;
  
  },{"./service":89}],85:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const service_1 = require("./service");
  class HackerNews extends service_1.Service {
      getBaseUrls() {
          const baseUrls = [
              'https://news.ycombinator.com/user?id=',
              'http://news.ycombinator.com/user?id=',
              'news.ycombinator.com/user?id='
          ];
          return baseUrls;
      }
      getProofUrl(proof) {
          const baseUrls = this.getBaseUrls();
          const proofUrl = super.prefixScheme(proof.proof_url);
          for (let i = 0; i < baseUrls.length; i++) {
              if (proofUrl === `${baseUrls[i]}${proof.identifier}`) {
                  return proofUrl;
              }
          }
          throw new Error(`Proof url ${proof.proof_url} is not valid for service ${proof.service}`);
      }
      normalizeUrl(_proof) {
          return '';
      }
      getProofStatement(searchText, cheerio) {
          const $ = cheerio.load(searchText);
          const tables = $('#hnmain').children().find('table');
          let statement = '';
          if (tables.length > 0) {
              tables.each((tableIndex, table) => {
                  const rows = $(table).find('tr');
                  if (rows.length > 0) {
                      rows.each((idx, row) => {
                          const heading = $(row).find('td')
                              .first()
                              .text()
                              .trim();
                          if (heading === 'about:') {
                              statement = $(row).find('td')
                                  .last()
                                  .text()
                                  .trim();
                          }
                      });
                  }
              });
          }
          return statement;
      }
  }
  exports.HackerNews = HackerNews;
  
  },{"./service":89}],86:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const facebook_1 = require("./facebook");
  const github_1 = require("./github");
  const twitter_1 = require("./twitter");
  const instagram_1 = require("./instagram");
  const hackerNews_1 = require("./hackerNews");
  const linkedIn_1 = require("./linkedIn");
  /** @ignore */
  exports.profileServices = {
      facebook: new facebook_1.Facebook(),
      github: new github_1.Github(),
      twitter: new twitter_1.Twitter(),
      instagram: new instagram_1.Instagram(),
      hackerNews: new hackerNews_1.HackerNews(),
      linkedIn: new linkedIn_1.LinkedIn()
  };
  
  },{"./facebook":83,"./github":84,"./hackerNews":85,"./instagram":87,"./linkedIn":88,"./twitter":91}],87:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const service_1 = require("./service");
  class Instagram extends service_1.Service {
      getBaseUrls() {
          const baseUrls = ['https://www.instagram.com/', 'https://instagram.com/'];
          return baseUrls;
      }
      getProofUrl(proof) {
          const baseUrls = this.getBaseUrls();
          const normalizedProofUrl = this.normalizeUrl(proof);
          for (let i = 0; i < baseUrls.length; i++) {
              if (normalizedProofUrl.startsWith(`${baseUrls[i]}`)) {
                  return normalizedProofUrl;
              }
          }
          throw new Error(`Proof url ${proof.proof_url} is not valid for service ${proof.service}`);
      }
      normalizeUrl(proof) {
          let proofUrl = proof.proof_url;
          proofUrl = super.prefixScheme(proofUrl);
          if (proofUrl.startsWith('https://instagram.com')) {
              const tokens = proofUrl.split('https://instagram.com');
              proofUrl = `https://www.instagram.com${tokens[1]}`;
          }
          return proofUrl;
      }
      shouldValidateIdentityInBody() {
          return true;
      }
      getProofIdentity(searchText, cheerio) {
          const $ = cheerio.load(searchText);
          const username = $('meta[property="og:description"]').attr('content');
          if (username !== undefined && username.split(':').length > 1) {
              return username.split(':')[0].match(/(@\w+)/)[0].substr(1);
          }
          else {
              return '';
          }
      }
      getProofStatement(searchText, cheerio) {
          const $ = cheerio.load(searchText);
          const statement = $('meta[property="og:description"]')
              .attr('content');
          if (statement !== undefined && statement.split(':').length > 1) {
              return statement.split(':')[1].trim().replace('', '').replace('', '');
          }
          else {
              return '';
          }
      }
  }
  exports.Instagram = Instagram;
  
  },{"./service":89}],88:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const service_1 = require("./service");
  class LinkedIn extends service_1.Service {
      getBaseUrls() {
          const baseUrls = [
              'https://www.linkedin.com/feed/update/',
              'http://www.linkedin.com/feed/update/',
              'www.linkedin.com/feed/update/'
          ];
          return baseUrls;
      }
      getProofUrl(proof) {
          const baseUrls = this.getBaseUrls();
          let proofUrl = proof.proof_url.toLowerCase();
          proofUrl = super.prefixScheme(proofUrl);
          for (let i = 0; i < baseUrls.length; i++) {
              if (proofUrl.startsWith(`${baseUrls[i]}`)) {
                  return proofUrl;
              }
          }
          throw new Error(`Proof url ${proof.proof_url} is not valid for service ${proof.service}`);
      }
      normalizeUrl(_proof) {
          return '';
      }
      shouldValidateIdentityInBody() {
          return true;
      }
      getProofIdentity(searchText, cheerio) {
          const $ = cheerio.load(searchText);
          const profileLink = $('body > main header a');
          if (profileLink !== undefined) {
              if (profileLink.attr('href') === undefined) {
                  return '';
              }
              const url = profileLink.attr('href');
              // Parse URL for identifier
              const identifier = url.split('?').shift().split('/').pop();
              return identifier;
          }
          else {
              return '';
          }
      }
      getProofStatement(searchText, cheerio) {
          const $ = cheerio.load(searchText);
          const postContent = $('head > meta[property="og:title"]');
          let statement = '';
          if (postContent !== undefined) {
              statement = postContent.attr('content');
          }
          return statement;
      }
  }
  exports.LinkedIn = LinkedIn;
  
  },{"./service":89}],89:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const tslib_1 = require("tslib");
  const serviceUtils_1 = require("./serviceUtils");
  const fetchUtil_1 = require("../../fetchUtil");
  /**
   * @ignore
   */
  class Service {
      validateProof(proof, ownerAddress, cheerio, name = null) {
          return tslib_1.__awaiter(this, void 0, void 0, function* () {
              try {
                  const proofUrl = this.getProofUrl(proof);
                  const res = yield fetchUtil_1.fetchPrivate(proofUrl);
                  if (res.status !== 200) {
                      throw new Error(`Proof url ${proofUrl} returned unexpected http status ${res.status}.
              Unable to validate proof.`);
                  }
                  const text = yield res.text();
                  // Validate identity in provided proof body/tags if required
                  if (this.shouldValidateIdentityInBody()
                      && proof.identifier !== this.getProofIdentity(text, cheerio)) {
                      return proof;
                  }
                  const proofText = this.getProofStatement(text, cheerio);
                  proof.valid = serviceUtils_1.containsValidProofStatement(proofText, name)
                      || serviceUtils_1.containsValidAddressProofStatement(proofText, ownerAddress);
                  return proof;
              }
              catch (error) {
                  console.error(error);
                  proof.valid = false;
                  return proof;
              }
          });
      }
      shouldValidateIdentityInBody() {
          return false;
      }
      prefixScheme(proofUrl) {
          if (!proofUrl.startsWith('https://') && !proofUrl.startsWith('http://')) {
              return `https://${proofUrl}`;
          }
          else if (proofUrl.startsWith('http://')) {
              return proofUrl.replace('http://', 'https://');
          }
          else {
              return proofUrl;
          }
      }
      getProofIdentity(searchText, _cheerio) {
          return searchText;
      }
  }
  exports.Service = Service;
  
  },{"../../fetchUtil":59,"./serviceUtils":90,"tslib":268}],90:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  /**
   *
   * @ignore
   */
  function containsValidProofStatement(searchText, name = null) {
      if (!name) {
          return false;
      }
      searchText = searchText.toLowerCase();
      if (name.split('.').length < 2) {
          throw new Error('Please provide the fully qualified Blockstack name.');
      }
      let username = null;
      // support legacy Blockstack ID proofs
      if (name.endsWith('.id')) {
          username = name.split('.id')[0];
      }
      const verificationStyles = username != null ? [
          `verifying myself: my bitcoin username is +${username}`,
          `verifying myself: my bitcoin username is ${username}`,
          `verifying myself: my openname is ${username}`,
          `verifying that +${username} is my bitcoin username`,
          `verifying that ${username} is my bitcoin username`,
          `verifying that ${username} is my openname`,
          `verifying that +${username} is my openname`,
          `verifying i am +${username} on my passcard`,
          `verifying that +${username} is my blockchain id`,
          `verifying that "${name}" is my blockstack id`,
          `verifying that ${name} is my blockstack id`,
          `verifying that &quot;${name}&quot; is my blockstack id`
      ] : [
          `verifying that "${name}" is my blockstack id`,
          `verifying that ${name} is my blockstack id`,
          `verifying that &quot;${name}&quot; is my blockstack id`
      ];
      for (let i = 0; i < verificationStyles.length; i++) {
          const verificationStyle = verificationStyles[i];
          if (searchText.includes(verificationStyle)) {
              return true;
          }
      }
      if (username != null
          && searchText.includes('verifymyonename')
          && searchText.includes(`+${username}`)) {
          return true;
      }
      return false;
  }
  exports.containsValidProofStatement = containsValidProofStatement;
  /**
   *
   * @ignore
   */
  function containsValidAddressProofStatement(proofStatement, address) {
      proofStatement = proofStatement.split(address)[0].toLowerCase() + address;
      const verificationStyles = [
          `verifying my blockstack id is secured with the address ${address}`
      ];
      for (let i = 0; i < verificationStyles.length; i++) {
          const verificationStyle = verificationStyles[i];
          if (proofStatement.includes(verificationStyle)) {
              return true;
          }
      }
      return false;
  }
  exports.containsValidAddressProofStatement = containsValidAddressProofStatement;
  
  },{}],91:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const service_1 = require("./service");
  class Twitter extends service_1.Service {
      getBaseUrls() {
          const baseUrls = [
              'https://twitter.com/',
              'http://twitter.com/',
              'twitter.com/'
          ];
          return baseUrls;
      }
      normalizeUrl(_proof) {
          return '';
      }
      getProofStatement(searchText, cheerio) {
          const $ = cheerio.load(searchText);
          const statement = $('meta[property="og:description"]').attr('content');
          if (statement !== undefined) {
              return statement.trim().replace('', '').replace('', '');
          }
          else {
              return '';
          }
      }
      getProofUrl(proof) {
          const baseUrls = this.getBaseUrls();
          let proofUrl = proof.proof_url.toLowerCase();
          proofUrl = this.prefixScheme(proofUrl);
          for (let i = 0; i < baseUrls.length; i++) {
              const requiredPrefix = `${baseUrls[i]}${proof.identifier}`.toLowerCase();
              if (proofUrl.startsWith(requiredPrefix)) {
                  return proofUrl;
              }
          }
          throw new Error(`Proof url ${proof.proof_url} is not valid for service ${proof.service}`);
      }
  }
  exports.Twitter = Twitter;
  
  },{"./service":89}],92:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const tslib_1 = require("tslib");
  const protocolEchoDetection_1 = require("./auth/protocolEchoDetection");
  try {
      /**
       * Located here so it executes ASAP. The protocol handler detection is designed to work
       * as a drop-in-replacement (non-breaking upgrade) for apps using blockstack.js. That
       * requires doing this global and immediate detection.
       * This function is also called in `isSignInPending` so that web app bundling the
       * blockstack.js lib in a more modular way will still perform the protocol detection
       * handling without any changes if this index file is not bundled in.
       */
      protocolEchoDetection_1.protocolEchoReplyDetection();
  }
  catch (error) {
      console.error(`Error performing global protocol echo reply detection: ${error}`);
  }
  tslib_1.__exportStar(require("./auth"), exports);
  tslib_1.__exportStar(require("./profiles"), exports);
  tslib_1.__exportStar(require("./storage"), exports);
  var dids_1 = require("./dids");
  exports.makeDIDFromAddress = dids_1.makeDIDFromAddress;
  exports.makeDIDFromPublicKey = dids_1.makeDIDFromPublicKey;
  exports.getDIDType = dids_1.getDIDType;
  exports.getAddressFromDID = dids_1.getAddressFromDID;
  var keys_1 = require("./keys");
  exports.getEntropy = keys_1.getEntropy;
  exports.makeECPrivateKey = keys_1.makeECPrivateKey;
  exports.publicKeyToAddress = keys_1.publicKeyToAddress;
  exports.getPublicKeyFromPrivate = keys_1.getPublicKeyFromPrivate;
  exports.hexStringToECPair = keys_1.hexStringToECPair;
  exports.ecPairToHexString = keys_1.ecPairToHexString;
  exports.ecPairToAddress = keys_1.ecPairToAddress;
  var utils_1 = require("./utils");
  exports.nextYear = utils_1.nextYear;
  exports.nextMonth = utils_1.nextMonth;
  exports.nextHour = utils_1.nextHour;
  exports.makeUUID4 = utils_1.makeUUID4;
  exports.updateQueryStringParameter = utils_1.updateQueryStringParameter;
  exports.isLaterVersion = utils_1.isLaterVersion;
  exports.isSameOriginAbsoluteUrl = utils_1.isSameOriginAbsoluteUrl;
  var operations_1 = require("./operations");
  exports.transactions = operations_1.transactions;
  exports.safety = operations_1.safety;
  exports.PubkeyHashSigner = operations_1.PubkeyHashSigner;
  exports.addUTXOsToFund = operations_1.addUTXOsToFund;
  exports.estimateTXBytes = operations_1.estimateTXBytes;
  var wallet_1 = require("./wallet");
  exports.BlockstackWallet = wallet_1.BlockstackWallet;
  var network_1 = require("./network");
  exports.network = network_1.network;
  var jsontokens_1 = require("jsontokens");
  exports.decodeToken = jsontokens_1.decodeToken;
  var config_1 = require("./config");
  exports.config = config_1.config;
  var encryption_1 = require("./encryption");
  exports.encryptMnemonic = encryption_1.encryptMnemonic;
  exports.decryptMnemonic = encryption_1.decryptMnemonic;
  var userSession_1 = require("./auth/userSession");
  exports.UserSession = userSession_1.UserSession;
  
  },{"./auth":40,"./auth/protocolEchoDetection":41,"./auth/userSession":45,"./config":46,"./dids":47,"./encryption":54,"./keys":61,"./network":63,"./operations":64,"./profiles":70,"./storage":94,"./utils":95,"./wallet":96,"jsontokens":237,"tslib":268}],93:[function(require,module,exports){
  (function (Buffer){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const tslib_1 = require("tslib");
  const bitcoinjs_lib_1 = require("bitcoinjs-lib");
  const jsontokens_1 = require("jsontokens");
  const utils_1 = require("../utils");
  const fetchUtil_1 = require("../fetchUtil");
  const keys_1 = require("../keys");
  const logger_1 = require("../logger");
  const cryptoRandom_1 = require("../encryption/cryptoRandom");
  const sha2Hash_1 = require("../encryption/sha2Hash");
  /**
   * @ignore
   */
  exports.BLOCKSTACK_GAIA_HUB_LABEL = 'blockstack-gaia-hub-config';
  /**
   *
   * @param filename
   * @param contents
   * @param hubConfig
   * @param contentType
   *
   * @ignore
   */
  function uploadToGaiaHub(filename, contents, hubConfig, contentType = 'application/octet-stream', newFile = true, etag) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          logger_1.Logger.debug(`uploadToGaiaHub: uploading ${filename} to ${hubConfig.server}`);
          const headers = {
              'Content-Type': contentType,
              Authorization: `bearer ${hubConfig.token}`
          };
          if (newFile) {
              headers['If-None-Match'] = '*';
          }
          else if (etag) {
              headers['If-Match'] = etag;
          }
          const response = yield fetchUtil_1.fetchPrivate(`${hubConfig.server}/store/${hubConfig.address}/${filename}`, {
              method: 'POST',
              headers,
              body: contents
          });
          if (!response.ok) {
              throw yield utils_1.getBlockstackErrorFromResponse(response, 'Error when uploading to Gaia hub.', hubConfig);
          }
          const responseText = yield response.text();
          const responseJSON = JSON.parse(responseText);
          return responseJSON;
      });
  }
  exports.uploadToGaiaHub = uploadToGaiaHub;
  function deleteFromGaiaHub(filename, hubConfig) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          logger_1.Logger.debug(`deleteFromGaiaHub: deleting ${filename} from ${hubConfig.server}`);
          const response = yield fetchUtil_1.fetchPrivate(`${hubConfig.server}/delete/${hubConfig.address}/${filename}`, {
              method: 'DELETE',
              headers: {
                  Authorization: `bearer ${hubConfig.token}`
              }
          });
          if (!response.ok) {
              throw yield utils_1.getBlockstackErrorFromResponse(response, 'Error deleting file from Gaia hub.', hubConfig);
          }
      });
  }
  exports.deleteFromGaiaHub = deleteFromGaiaHub;
  /**
   *
   * @param filename
   * @param hubConfig
   *
   * @ignore
   */
  function getFullReadUrl(filename, hubConfig) {
      return Promise.resolve(`${hubConfig.url_prefix}${hubConfig.address}/${filename}`);
  }
  exports.getFullReadUrl = getFullReadUrl;
  /**
   *
   * @param challengeText
   * @param signerKeyHex
   *
   * @ignore
   */
  function makeLegacyAuthToken(challengeText, signerKeyHex) {
      // only sign specific legacy auth challenges.
      let parsedChallenge;
      try {
          parsedChallenge = JSON.parse(challengeText);
      }
      catch (err) {
          throw new Error('Failed in parsing legacy challenge text from the gaia hub.');
      }
      if (parsedChallenge[0] === 'gaiahub'
          && parsedChallenge[3] === 'blockstack_storage_please_sign') {
          const signer = keys_1.hexStringToECPair(signerKeyHex
              + (signerKeyHex.length === 64 ? '01' : ''));
          const digest = sha2Hash_1.hashSha256Sync(Buffer.from(challengeText));
          const signatureBuffer = signer.sign(digest);
          const signatureWithHash = bitcoinjs_lib_1.script.signature.encode(signatureBuffer, bitcoinjs_lib_1.Transaction.SIGHASH_NONE);
          // We only want the DER encoding so remove the sighash version byte at the end.
          // See: https://github.com/bitcoinjs/bitcoinjs-lib/issues/1241#issuecomment-428062912
          const signature = signatureWithHash.toString('hex').slice(0, -2);
          const publickey = keys_1.getPublicKeyFromPrivate(signerKeyHex);
          const token = Buffer.from(JSON.stringify({ publickey, signature })).toString('base64');
          return token;
      }
      else {
          throw new Error('Failed to connect to legacy gaia hub. If you operate this hub, please update.');
      }
  }
  /**
   *
   * @param hubInfo
   * @param signerKeyHex
   * @param hubUrl
   * @param associationToken
   *
   * @ignore
   */
  function makeV1GaiaAuthToken(hubInfo, signerKeyHex, hubUrl, associationToken) {
      const challengeText = hubInfo.challenge_text;
      const handlesV1Auth = (hubInfo.latest_auth_version
          && parseInt(hubInfo.latest_auth_version.slice(1), 10) >= 1);
      const iss = keys_1.getPublicKeyFromPrivate(signerKeyHex);
      if (!handlesV1Auth) {
          return makeLegacyAuthToken(challengeText, signerKeyHex);
      }
      const salt = cryptoRandom_1.randomBytes(16).toString('hex');
      const payload = {
          gaiaChallenge: challengeText,
          hubUrl,
          iss,
          salt,
          associationToken
      };
      const token = new jsontokens_1.TokenSigner('ES256K', signerKeyHex).sign(payload);
      return `v1:${token}`;
  }
  /**
   *
   * @ignore
   */
  function connectToGaiaHub(gaiaHubUrl, challengeSignerHex, associationToken) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          logger_1.Logger.debug(`connectToGaiaHub: ${gaiaHubUrl}/hub_info`);
          const response = yield fetchUtil_1.fetchPrivate(`${gaiaHubUrl}/hub_info`);
          const hubInfo = yield response.json();
          const readURL = hubInfo.read_url_prefix;
          const token = makeV1GaiaAuthToken(hubInfo, challengeSignerHex, gaiaHubUrl, associationToken);
          const address = keys_1.ecPairToAddress(keys_1.hexStringToECPair(challengeSignerHex
              + (challengeSignerHex.length === 64 ? '01' : '')));
          return {
              url_prefix: readURL,
              max_file_upload_size_megabytes: hubInfo.max_file_upload_size_megabytes,
              address,
              token,
              server: gaiaHubUrl
          };
      });
  }
  exports.connectToGaiaHub = connectToGaiaHub;
  /**
   *
   * @param gaiaHubUrl
   * @param appPrivateKey
   *
   * @ignore
   */
  function getBucketUrl(gaiaHubUrl, appPrivateKey) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const challengeSigner = bitcoinjs_lib_1.ECPair.fromPrivateKey(Buffer.from(appPrivateKey, 'hex'));
          const response = yield fetchUtil_1.fetchPrivate(`${gaiaHubUrl}/hub_info`);
          const responseText = yield response.text();
          const responseJSON = JSON.parse(responseText);
          const readURL = responseJSON.read_url_prefix;
          const address = keys_1.ecPairToAddress(challengeSigner);
          const bucketUrl = `${readURL}${address}/`;
          return bucketUrl;
      });
  }
  exports.getBucketUrl = getBucketUrl;
  
  }).call(this,require("buffer").Buffer)
  },{"../encryption/cryptoRandom":49,"../encryption/sha2Hash":56,"../fetchUtil":59,"../keys":61,"../logger":62,"../utils":95,"bitcoinjs-lib":148,"buffer":3,"jsontokens":237,"tslib":268}],94:[function(require,module,exports){
  (function (Buffer){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const tslib_1 = require("tslib");
  const hub_1 = require("./hub");
  exports.connectToGaiaHub = hub_1.connectToGaiaHub;
  exports.uploadToGaiaHub = hub_1.uploadToGaiaHub;
  exports.BLOCKSTACK_GAIA_HUB_LABEL = hub_1.BLOCKSTACK_GAIA_HUB_LABEL;
  // export { type GaiaHubConfig } from './hub'
  const ec_1 = require("../encryption/ec");
  const keys_1 = require("../keys");
  const profileLookup_1 = require("../profiles/profileLookup");
  const errors_1 = require("../errors");
  const userSession_1 = require("../auth/userSession");
  const authConstants_1 = require("../auth/authConstants");
  const utils_1 = require("../utils");
  const fetchUtil_1 = require("../fetchUtil");
  const etags = {};
  const SIGNATURE_FILE_SUFFIX = '.sig';
  /**
   * Fetch the public read URL of a user file for the specified app.
   * @param {String} path - the path to the file to read
   * @param {String} username - The Blockstack ID of the user to look up
   * @param {String} appOrigin - The app origin
   * @param {String} [zoneFileLookupURL=null] - The URL
   * to use for zonefile lookup. If falsey, this will use the
   * blockstack.js's [[getNameInfo]] function instead.
   * @return {Promise<string>} that resolves to the public read URL of the file
   * or rejects with an error
   */
  function getUserAppFileUrl(path, username, appOrigin, zoneFileLookupURL) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const profile = yield profileLookup_1.lookupProfile(username, zoneFileLookupURL);
          let bucketUrl = null;
          if (profile.hasOwnProperty('apps')) {
              if (profile.apps.hasOwnProperty(appOrigin)) {
                  const url = profile.apps[appOrigin];
                  const bucket = url.replace(/\/?(\?|#|$)/, '/$1');
                  bucketUrl = `${bucket}${path}`;
              }
          }
          return bucketUrl;
      });
  }
  exports.getUserAppFileUrl = getUserAppFileUrl;
  /**
   *
   *
   * @deprecated
   * #### v19 Use [[UserSession.encryptContent]].
   *
   * Encrypts the data provided with the app public key.
   * @param {String|Buffer} content - data to encrypt
   * @param {Object} [options=null] - options object
   * @param {String} options.publicKey - the hex string of the ECDSA public
   * key to use for encryption. If not provided, will use user's appPublicKey.
   * @return {String} Stringified ciphertext object
   */
  function encryptContent(content, options, caller) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const opts = Object.assign({}, options);
          let privateKey;
          if (!opts.publicKey) {
              privateKey = (caller || new userSession_1.UserSession()).loadUserData().appPrivateKey;
              opts.publicKey = keys_1.getPublicKeyFromPrivate(privateKey);
          }
          let wasString;
          if (typeof opts.wasString === 'boolean') {
              wasString = opts.wasString;
          }
          else {
              wasString = typeof content === 'string';
          }
          const contentBuffer = typeof content === 'string' ? Buffer.from(content) : content;
          const cipherObject = yield ec_1.encryptECIES(opts.publicKey, contentBuffer, wasString, opts.cipherTextEncoding);
          let cipherPayload = JSON.stringify(cipherObject);
          if (opts.sign) {
              if (typeof opts.sign === 'string') {
                  privateKey = opts.sign;
              }
              else if (!privateKey) {
                  privateKey = (caller || new userSession_1.UserSession()).loadUserData().appPrivateKey;
              }
              const signatureObject = ec_1.signECDSA(privateKey, cipherPayload);
              const signedCipherObject = {
                  signature: signatureObject.signature,
                  publicKey: signatureObject.publicKey,
                  cipherText: cipherPayload
              };
              cipherPayload = JSON.stringify(signedCipherObject);
          }
          return cipherPayload;
      });
  }
  exports.encryptContent = encryptContent;
  /**
   *
   * @deprecated
   * #### v19 Use [[UserSession.decryptContent]].
   *
   * Decrypts data encrypted with `encryptContent` with the
   * transit private key.
   * @param {String|Buffer} content - encrypted content.
   * @param {Object} [options=null] - options object
   * @param {String} options.privateKey - the hex string of the ECDSA private
   * key to use for decryption. If not provided, will use user's appPrivateKey.
   * @return {String|Buffer} decrypted content.
   */
  function decryptContent(content, options, caller) {
      const opts = Object.assign({}, options);
      if (!opts.privateKey) {
          opts.privateKey = (caller || new userSession_1.UserSession()).loadUserData().appPrivateKey;
      }
      try {
          const cipherObject = JSON.parse(content);
          return ec_1.decryptECIES(opts.privateKey, cipherObject);
      }
      catch (err) {
          if (err instanceof SyntaxError) {
              throw new Error('Failed to parse encrypted content JSON. The content may not '
                  + 'be encrypted. If using getFile, try passing { decrypt: false }.');
          }
          else {
              throw err;
          }
      }
  }
  exports.decryptContent = decryptContent;
  /* Get the gaia address used for servicing multiplayer reads for the given
   * (username, app) pair.
   * @private
   * @ignore
   */
  function getGaiaAddress(app, username, zoneFileLookupURL, caller) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const opts = normalizeOptions({ app, username, zoneFileLookupURL }, caller);
          let fileUrl;
          if (username) {
              fileUrl = yield getUserAppFileUrl('/', opts.username, opts.app, opts.zoneFileLookupURL);
          }
          else {
              if (!caller) {
                  caller = new userSession_1.UserSession();
              }
              const gaiaHubConfig = yield caller.getOrSetLocalGaiaHubConnection();
              fileUrl = yield hub_1.getFullReadUrl('/', gaiaHubConfig);
          }
          const matches = fileUrl.match(/([13][a-km-zA-HJ-NP-Z0-9]{26,35})/);
          if (!matches) {
              throw new Error('Failed to parse gaia address');
          }
          return matches[matches.length - 1];
      });
  }
  /**
   * @param {Object} [options=null] - options object
   * @param {String} options.username - the Blockstack ID to lookup for multi-player storage
   * @param {String} options.app - the app to lookup for multi-player storage -
   * defaults to current origin
   *
   * @ignore
   */
  function normalizeOptions(options, caller) {
      const opts = Object.assign({}, options);
      if (opts.username) {
          if (!opts.app) {
              caller = caller || new userSession_1.UserSession();
              if (!caller.appConfig) {
                  throw new errors_1.InvalidStateError('Missing AppConfig');
              }
              opts.app = caller.appConfig.appDomain;
          }
          if (!opts.zoneFileLookupURL) {
              caller = caller || new userSession_1.UserSession();
              if (!caller.appConfig) {
                  throw new errors_1.InvalidStateError('Missing AppConfig');
              }
              if (!caller.store) {
                  throw new errors_1.InvalidStateError('Missing store UserSession');
              }
              const sessionData = caller.store.getSessionData();
              // Use the user specified coreNode if available, otherwise use the app specified coreNode. 
              const configuredCoreNode = sessionData.userData.coreNode || caller.appConfig.coreNode;
              if (configuredCoreNode) {
                  opts.zoneFileLookupURL = `${configuredCoreNode}${authConstants_1.NAME_LOOKUP_PATH}`;
              }
          }
      }
      return opts;
  }
  /**
   * @deprecated
   * #### v19 Use [[UserSession.getFileUrl]] instead.
   *
   * @param {String} path - the path to the file to read
   * @returns {Promise<string>} that resolves to the URL or rejects with an error
   */
  function getFileUrl(path, options, caller) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const opts = normalizeOptions(options, caller);
          let readUrl;
          if (opts.username) {
              readUrl = yield getUserAppFileUrl(path, opts.username, opts.app, opts.zoneFileLookupURL);
          }
          else {
              const gaiaHubConfig = yield (caller || new userSession_1.UserSession()).getOrSetLocalGaiaHubConnection();
              readUrl = yield hub_1.getFullReadUrl(path, gaiaHubConfig);
          }
          if (!readUrl) {
              throw new Error('Missing readURL');
          }
          else {
              return readUrl;
          }
      });
  }
  exports.getFileUrl = getFileUrl;
  /* Handle fetching the contents from a given path. Handles both
   *  multi-player reads and reads from own storage.
   * @private
   * @ignore
   */
  function getFileContents(path, app, username, zoneFileLookupURL, forceText, caller) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const opts = { app, username, zoneFileLookupURL };
          const readUrl = yield getFileUrl(path, opts, caller);
          const response = yield fetchUtil_1.fetchPrivate(readUrl);
          if (!response.ok) {
              throw yield utils_1.getBlockstackErrorFromResponse(response, `getFile ${path} failed.`, null);
          }
          let contentType = response.headers.get('Content-Type');
          if (typeof contentType === 'string') {
              contentType = contentType.toLowerCase();
          }
          const etag = response.headers.get('ETag');
          if (etag) {
              etags[path] = etag;
          }
          if (forceText || contentType === null
              || contentType.startsWith('text')
              || contentType.startsWith('application/json')) {
              return response.text();
          }
          else {
              return response.arrayBuffer();
          }
      });
  }
  /* Handle fetching an unencrypted file, its associated signature
   *  and then validate it. Handles both multi-player reads and reads
   *  from own storage.
   * @private
   * @ignore
   */
  function getFileSignedUnencrypted(path, opt, caller) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          // future optimization note:
          //    in the case of _multi-player_ reads, this does a lot of excess
          //    profile lookups to figure out where to read files
          //    do browsers cache all these requests if Content-Cache is set?
          const sigPath = `${path}${SIGNATURE_FILE_SUFFIX}`;
          try {
              const [fileContents, signatureContents, gaiaAddress] = yield Promise.all([
                  getFileContents(path, opt.app, opt.username, opt.zoneFileLookupURL, false, caller),
                  getFileContents(sigPath, opt.app, opt.username, opt.zoneFileLookupURL, true, caller),
                  getGaiaAddress(opt.app, opt.username, opt.zoneFileLookupURL, caller)
              ]);
              if (!fileContents) {
                  return fileContents;
              }
              if (!gaiaAddress) {
                  throw new errors_1.SignatureVerificationError('Failed to get gaia address for verification of: '
                      + `${path}`);
              }
              if (!signatureContents || typeof signatureContents !== 'string') {
                  throw new errors_1.SignatureVerificationError('Failed to obtain signature for file: '
                      + `${path} -- looked in ${path}${SIGNATURE_FILE_SUFFIX}`);
              }
              let signature;
              let publicKey;
              try {
                  const sigObject = JSON.parse(signatureContents);
                  signature = sigObject.signature;
                  publicKey = sigObject.publicKey;
              }
              catch (err) {
                  if (err instanceof SyntaxError) {
                      throw new Error('Failed to parse signature content JSON '
                          + `(path: ${path}${SIGNATURE_FILE_SUFFIX})`
                          + ' The content may be corrupted.');
                  }
                  else {
                      throw err;
                  }
              }
              const signerAddress = keys_1.publicKeyToAddress(publicKey);
              if (gaiaAddress !== signerAddress) {
                  throw new errors_1.SignatureVerificationError(`Signer pubkey address (${signerAddress}) doesn't`
                      + ` match gaia address (${gaiaAddress})`);
              }
              else if (!ec_1.verifyECDSA(fileContents, publicKey, signature)) {
                  throw new errors_1.SignatureVerificationError('Contents do not match ECDSA signature: '
                      + `path: ${path}, signature: ${path}${SIGNATURE_FILE_SUFFIX}`);
              }
              else {
                  return fileContents;
              }
          }
          catch (err) {
              // For missing .sig files, throw `SignatureVerificationError` instead of `DoesNotExist` error.
              if (err instanceof errors_1.DoesNotExist && err.message.indexOf(sigPath) >= 0) {
                  throw new errors_1.SignatureVerificationError('Failed to obtain signature for file: '
                      + `${path} -- looked in ${path}${SIGNATURE_FILE_SUFFIX}`);
              }
              else {
                  throw err;
              }
          }
      });
  }
  /* Handle signature verification and decryption for contents which are
   *  expected to be signed and encrypted. This works for single and
   *  multiplayer reads. In the case of multiplayer reads, it uses the
   *  gaia address for verification of the claimed public key.
   * @private
   * @ignore
   */
  function handleSignedEncryptedContents(caller, path, storedContents, app, privateKey, username, zoneFileLookupURL) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const appPrivateKey = privateKey || caller.loadUserData().appPrivateKey;
          const appPublicKey = keys_1.getPublicKeyFromPrivate(appPrivateKey);
          let address;
          if (username) {
              address = yield getGaiaAddress(app, username, zoneFileLookupURL, caller);
          }
          else {
              address = keys_1.publicKeyToAddress(appPublicKey);
          }
          if (!address) {
              throw new errors_1.SignatureVerificationError('Failed to get gaia address for verification of: '
                  + `${path}`);
          }
          let sigObject;
          try {
              sigObject = JSON.parse(storedContents);
          }
          catch (err) {
              if (err instanceof SyntaxError) {
                  throw new Error('Failed to parse encrypted, signed content JSON. The content may not '
                      + 'be encrypted. If using getFile, try passing'
                      + ' { verify: false, decrypt: false }.');
              }
              else {
                  throw err;
              }
          }
          const signature = sigObject.signature;
          const signerPublicKey = sigObject.publicKey;
          const cipherText = sigObject.cipherText;
          const signerAddress = keys_1.publicKeyToAddress(signerPublicKey);
          if (!signerPublicKey || !cipherText || !signature) {
              throw new errors_1.SignatureVerificationError('Failed to get signature verification data from file:'
                  + ` ${path}`);
          }
          else if (signerAddress !== address) {
              throw new errors_1.SignatureVerificationError(`Signer pubkey address (${signerAddress}) doesn't`
                  + ` match gaia address (${address})`);
          }
          else if (!ec_1.verifyECDSA(cipherText, signerPublicKey, signature)) {
              throw new errors_1.SignatureVerificationError('Contents do not match ECDSA signature in file:'
                  + ` ${path}`);
          }
          else if (typeof (privateKey) === 'string') {
              const decryptOpt = { privateKey };
              return caller.decryptContent(cipherText, decryptOpt);
          }
          else {
              return caller.decryptContent(cipherText);
          }
      });
  }
  /**
   * Retrieves the specified file from the app's data store.
   * @param {String} path - the path to the file to read
   * @returns {Promise} that resolves to the raw data in the file
   * or rejects with an error
   */
  function getFile(path, options, caller) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const defaults = {
              decrypt: true,
              verify: false,
              username: null,
              app: utils_1.getGlobalObject('location', { returnEmptyObject: true }).origin,
              zoneFileLookupURL: null
          };
          const opt = Object.assign({}, defaults, options);
          if (!caller) {
              caller = new userSession_1.UserSession();
          }
          // in the case of signature verification, but no
          //  encryption expected, need to fetch _two_ files.
          if (opt.verify && !opt.decrypt) {
              return getFileSignedUnencrypted(path, opt, caller);
          }
          const storedContents = yield getFileContents(path, opt.app, opt.username, opt.zoneFileLookupURL, !!opt.decrypt, caller);
          if (storedContents === null) {
              return storedContents;
          }
          else if (opt.decrypt && !opt.verify) {
              if (typeof storedContents !== 'string') {
                  throw new Error('Expected to get back a string for the cipherText');
              }
              if (typeof (opt.decrypt) === 'string') {
                  const decryptOpt = { privateKey: opt.decrypt };
                  return caller.decryptContent(storedContents, decryptOpt);
              }
              else {
                  return caller.decryptContent(storedContents);
              }
          }
          else if (opt.decrypt && opt.verify) {
              if (typeof storedContents !== 'string') {
                  throw new Error('Expected to get back a string for the cipherText');
              }
              let decryptionKey;
              if (typeof (opt.decrypt) === 'string') {
                  decryptionKey = opt.decrypt;
              }
              return handleSignedEncryptedContents(caller, path, storedContents, opt.app, decryptionKey, opt.username, opt.zoneFileLookupURL);
          }
          else if (!opt.verify && !opt.decrypt) {
              return storedContents;
          }
          else {
              throw new Error('Should be unreachable.');
          }
      });
  }
  exports.getFile = getFile;
  /** @ignore */
  class FileContentLoader {
      constructor(content, contentType) {
          this.wasString = typeof content === 'string';
          this.content = FileContentLoader.normalizeContentDataType(content, contentType);
          this.contentType = contentType || this.detectContentType();
          this.contentByteLength = this.detectContentLength();
      }
      static normalizeContentDataType(content, contentType) {
          try {
              if (typeof content === 'string') {
                  // If a charset is specified it must be either utf8 or ascii, otherwise the encoded content 
                  // length cannot be reliably detected. If no charset specified it will be treated as utf8. 
                  const charset = (contentType || '').toLowerCase().replace('-', '');
                  if (charset.includes('charset') && !charset.includes('charset=utf8') && !charset.includes('charset=ascii')) {
                      throw new Error(`Unable to determine byte length with charset: ${contentType}`);
                  }
                  if (typeof TextEncoder !== 'undefined') {
                      const encodedString = new TextEncoder().encode(content);
                      return Buffer.from(encodedString.buffer);
                  }
                  return Buffer.from(content);
              }
              else if (Buffer.isBuffer(content)) {
                  return content;
              }
              else if (ArrayBuffer.isView(content)) {
                  return Buffer.from(content.buffer, content.byteOffset, content.byteLength);
              }
              else if (typeof Blob !== 'undefined' && content instanceof Blob) {
                  return content;
              }
              else if (typeof ArrayBuffer !== 'undefined' && content instanceof ArrayBuffer) {
                  return Buffer.from(content);
              }
              else if (Array.isArray(content)) {
                  // Provided with a regular number `Array` -- this is either an (old) method 
                  // of representing an octet array, or a dev error. Perform basic check for octet array. 
                  if (content.length > 0
                      && (!Number.isInteger(content[0]) || content[0] < 0 || content[0] > 255)) {
                      throw new Error(`Unexpected array values provided as file data: value "${content[0]}" at index 0 is not an octet number. ${this.supportedTypesMsg}`);
                  }
                  return Buffer.from(content);
              }
              else {
                  const typeName = Object.prototype.toString.call(content);
                  throw new Error(`Unexpected type provided as file data: ${typeName}. ${this.supportedTypesMsg}`);
              }
          }
          catch (error) {
              console.error(error);
              throw new Error(`Error processing data: ${error}`);
          }
      }
      detectContentType() {
          if (this.wasString) {
              return 'text/plain; charset=utf-8';
          }
          else if (typeof Blob !== 'undefined' && this.content instanceof Blob && this.content.type) {
              return this.content.type;
          }
          else {
              return 'application/octet-stream';
          }
      }
      detectContentLength() {
          if (ArrayBuffer.isView(this.content) || Buffer.isBuffer(this.content)) {
              return this.content.byteLength;
          }
          else if (typeof Blob !== 'undefined' && this.content instanceof Blob) {
              return this.content.size;
          }
          const typeName = Object.prototype.toString.call(this.content);
          const error = new Error(`Unexpected type "${typeName}" while detecting content length`);
          console.error(error);
          throw error;
      }
      loadContent() {
          return tslib_1.__awaiter(this, void 0, void 0, function* () {
              try {
                  if (Buffer.isBuffer(this.content)) {
                      return this.content;
                  }
                  else if (ArrayBuffer.isView(this.content)) {
                      return Buffer.from(this.content.buffer, this.content.byteOffset, this.content.byteLength);
                  }
                  else if (typeof Blob !== 'undefined' && this.content instanceof Blob) {
                      const reader = new FileReader();
                      const readPromise = new Promise((resolve, reject) => {
                          reader.onerror = (err) => {
                              reject(err);
                          };
                          reader.onload = () => {
                              const arrayBuffer = reader.result;
                              resolve(Buffer.from(arrayBuffer));
                          };
                          reader.readAsArrayBuffer(this.content);
                      });
                      const result = yield readPromise;
                      return result;
                  }
                  else {
                      const typeName = Object.prototype.toString.call(this.content);
                      throw new Error(`Unexpected type ${typeName}`);
                  }
              }
              catch (error) {
                  console.error(error);
                  const loadContentError = new Error(`Error loading content: ${error}`);
                  console.error(loadContentError);
                  throw loadContentError;
              }
          });
      }
      load() {
          if (this.loadedData === undefined) {
              this.loadedData = this.loadContent();
          }
          return this.loadedData;
      }
  }
  FileContentLoader.supportedTypesMsg = 'Supported types are: `string` (to be UTF8 encoded), '
      + '`Buffer`, `Blob`, `File`, `ArrayBuffer`, `UInt8Array` or any other typed array buffer. ';
  /**
   * Determines if a gaia error response is possible to recover from
   * by refreshing the gaiaHubConfig, and retrying the request.
   */
  function isRecoverableGaiaError(error) {
      if (!error || !error.hubError || !error.hubError.statusCode) {
          return false;
      }
      const statusCode = error.hubError.statusCode;
      // 401 Unauthorized: possible expired, but renewable auth token.
      if (statusCode === 401) {
          return true;
      }
      // 409 Conflict: possible concurrent writes to a file.
      if (statusCode === 409) {
          return true;
      }
      // 500s: possible server-side transient error
      if (statusCode >= 500 && statusCode <= 599) {
          return true;
      }
      return false;
  }
  /**
   * Stores the data provided in the app's data store to to the file specified.
   * @param {String} path - the path to store the data in
   * @param {String|Buffer} content - the data to store in the file
   * @return {Promise} that resolves if the operation succeed and rejects
   * if it failed
   */
  function putFile(path, content, options, caller) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const defaults = {
              encrypt: true,
              sign: false,
              cipherTextEncoding: 'hex'
          };
          const opt = Object.assign({}, defaults, options);
          if (!caller) {
              caller = new userSession_1.UserSession();
          }
          const gaiaHubConfig = yield caller.getOrSetLocalGaiaHubConnection();
          const maxUploadBytes = utils_1.megabytesToBytes(gaiaHubConfig.max_file_upload_size_megabytes);
          const hasMaxUpload = maxUploadBytes > 0;
          const contentLoader = new FileContentLoader(content, opt.contentType);
          let contentType = contentLoader.contentType;
          // When not encrypting the content length can be checked immediately.
          if (!opt.encrypt && hasMaxUpload && contentLoader.contentByteLength > maxUploadBytes) {
              const sizeErrMsg = `The max file upload size for this hub is ${maxUploadBytes} bytes, the given content is ${contentLoader.contentByteLength} bytes`;
              const sizeErr = new errors_1.PayloadTooLargeError(sizeErrMsg, null, maxUploadBytes);
              console.error(sizeErr);
              throw sizeErr;
          }
          // When encrypting, the content length must be calculated. Certain types like `Blob`s must
          // be loaded into memory. 
          if (opt.encrypt && hasMaxUpload) {
              const encryptedSize = ec_1.eciesGetJsonStringLength({
                  contentLength: contentLoader.contentByteLength,
                  wasString: contentLoader.wasString,
                  sign: !!opt.sign,
                  cipherTextEncoding: opt.cipherTextEncoding
              });
              if (encryptedSize > maxUploadBytes) {
                  const sizeErrMsg = `The max file upload size for this hub is ${maxUploadBytes} bytes, the given content is ${encryptedSize} bytes after encryption`;
                  const sizeErr = new errors_1.PayloadTooLargeError(sizeErrMsg, null, maxUploadBytes);
                  console.error(sizeErr);
                  throw sizeErr;
              }
          }
          let etag;
          let newFile = true;
          if (etags[path]) {
              newFile = false;
              etag = etags[path];
          }
          let uploadFn;
          // In the case of signing, but *not* encrypting, we perform two uploads.
          if (!opt.encrypt && opt.sign) {
              const contentData = yield contentLoader.load();
              let privateKey;
              if (typeof opt.sign === 'string') {
                  privateKey = opt.sign;
              }
              else {
                  privateKey = caller.loadUserData().appPrivateKey;
              }
              const signatureObject = ec_1.signECDSA(privateKey, contentData);
              const signatureContent = JSON.stringify(signatureObject);
              uploadFn = (hubConfig) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                  const writeResponse = (yield Promise.all([
                      hub_1.uploadToGaiaHub(path, contentData, hubConfig, contentType, newFile, etag),
                      hub_1.uploadToGaiaHub(`${path}${SIGNATURE_FILE_SUFFIX}`, signatureContent, hubConfig, 'application/json')
                  ]))[0];
                  if (writeResponse.etag) {
                      etags[path] = writeResponse.etag;
                  }
                  return writeResponse.publicURL;
              });
          }
          else {
              // In all other cases, we only need one upload.
              let contentForUpload;
              if (!opt.encrypt && !opt.sign) {
                  // If content does not need encrypted or signed, it can be passed directly 
                  // to the fetch request without loading into memory. 
                  contentForUpload = contentLoader.content;
              }
              else {
                  // Use the `encrypt` key, otherwise the `sign` key, if neither are specified
                  // then use the current user's app public key. 
                  let publicKey;
                  if (typeof opt.encrypt === 'string') {
                      publicKey = opt.encrypt;
                  }
                  else if (typeof opt.sign === 'string') {
                      publicKey = keys_1.getPublicKeyFromPrivate(opt.sign);
                  }
                  else {
                      publicKey = keys_1.getPublicKeyFromPrivate(caller.loadUserData().appPrivateKey);
                  }
                  const contentData = yield contentLoader.load();
                  contentForUpload = yield encryptContent(contentData, {
                      publicKey,
                      wasString: contentLoader.wasString,
                      cipherTextEncoding: opt.cipherTextEncoding,
                      sign: opt.sign
                  });
                  contentType = 'application/json';
              }
              uploadFn = (hubConfig) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                  const writeResponse = yield hub_1.uploadToGaiaHub(path, contentForUpload, hubConfig, contentType, newFile, etag);
                  if (writeResponse.etag) {
                      etags[path] = writeResponse.etag;
                  }
                  return writeResponse.publicURL;
              });
          }
          try {
              return yield uploadFn(gaiaHubConfig);
          }
          catch (error) {
              // If the upload fails on first attempt, it could be due to a recoverable
              // error which may succeed by refreshing the config and retrying.
              if (isRecoverableGaiaError(error)) {
                  console.error(error);
                  console.error('Possible recoverable error during Gaia upload, retrying...');
                  const freshHubConfig = yield caller.setLocalGaiaHubConnection();
                  return yield uploadFn(freshHubConfig);
              }
              else {
                  throw error;
              }
          }
      });
  }
  exports.putFile = putFile;
  /**
   * Deletes the specified file from the app's data store.
   * @param path - The path to the file to delete.
   * @param options - Optional options object.
   * @param options.wasSigned - Set to true if the file was originally signed
   * in order for the corresponding signature file to also be deleted.
   * @returns Resolves when the file has been removed or rejects with an error.
   */
  function deleteFile(path, options, caller) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!caller) {
              caller = new userSession_1.UserSession();
          }
          const gaiaHubConfig = yield caller.getOrSetLocalGaiaHubConnection();
          const opts = Object.assign({}, options);
          if (opts.wasSigned) {
              // If signed, delete both the content file and the .sig file
              try {
                  yield hub_1.deleteFromGaiaHub(path, gaiaHubConfig);
                  yield hub_1.deleteFromGaiaHub(`${path}${SIGNATURE_FILE_SUFFIX}`, gaiaHubConfig);
              }
              catch (error) {
                  const freshHubConfig = yield caller.setLocalGaiaHubConnection();
                  yield hub_1.deleteFromGaiaHub(path, freshHubConfig);
                  yield hub_1.deleteFromGaiaHub(`${path}${SIGNATURE_FILE_SUFFIX}`, gaiaHubConfig);
              }
          }
          else {
              try {
                  yield hub_1.deleteFromGaiaHub(path, gaiaHubConfig);
              }
              catch (error) {
                  const freshHubConfig = yield caller.setLocalGaiaHubConnection();
                  yield hub_1.deleteFromGaiaHub(path, freshHubConfig);
              }
          }
      });
  }
  exports.deleteFile = deleteFile;
  /**
   * Get the app storage bucket URL
   * @param {String} gaiaHubUrl - the gaia hub URL
   * @param {String} appPrivateKey - the app private key used to generate the app address
   * @returns {Promise} That resolves to the URL of the app index file
   * or rejects if it fails
   */
  function getAppBucketUrl(gaiaHubUrl, appPrivateKey) {
      return hub_1.getBucketUrl(gaiaHubUrl, appPrivateKey);
  }
  exports.getAppBucketUrl = getAppBucketUrl;
  /**
   * Loop over the list of files in a Gaia hub, and run a callback on each entry.
   * Not meant to be called by external clients.
   * @param {GaiaHubConfig} hubConfig - the Gaia hub config
   * @param {String | null} page - the page ID
   * @param {number} callCount - the loop count
   * @param {number} fileCount - the number of files listed so far
   * @param {function} callback - the callback to invoke on each file.  If it returns a falsey
   *  value, then the loop stops.  If it returns a truthy value, the loop continues.
   * @returns {Promise} that resolves to the number of files listed.
   * @private
   * @ignore
   */
  function listFilesLoop(caller, hubConfig, page, callCount, fileCount, callback) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (callCount > 65536) {
              // this is ridiculously huge, and probably indicates
              // a faulty Gaia hub anyway (e.g. on that serves endless data)
              throw new Error('Too many entries to list');
          }
          hubConfig = hubConfig || (yield caller.getOrSetLocalGaiaHubConnection());
          let response;
          try {
              const pageRequest = JSON.stringify({ page });
              const fetchOptions = {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/json',
                      'Content-Length': `${pageRequest.length}`,
                      Authorization: `bearer ${hubConfig.token}`
                  },
                  body: pageRequest
              };
              response = yield fetchUtil_1.fetchPrivate(`${hubConfig.server}/list-files/${hubConfig.address}`, fetchOptions);
              if (!response.ok) {
                  throw yield utils_1.getBlockstackErrorFromResponse(response, 'ListFiles failed.', hubConfig);
              }
          }
          catch (error) {
              // If error occurs on the first call, perform a gaia re-connection and retry.
              // Same logic as other gaia requests (putFile, getFile, etc).
              if (callCount === 0) {
                  const freshHubConfig = yield caller.setLocalGaiaHubConnection();
                  return listFilesLoop(caller, freshHubConfig, page, callCount + 1, 0, callback);
              }
              throw error;
          }
          const responseText = yield response.text();
          const responseJSON = JSON.parse(responseText);
          const entries = responseJSON.entries;
          const nextPage = responseJSON.page;
          if (entries === null || entries === undefined) {
              // indicates a misbehaving Gaia hub or a misbehaving driver
              // (i.e. the data is malformed)
              throw new Error('Bad listFiles response: no entries');
          }
          let entriesLength = 0;
          for (let i = 0; i < entries.length; i++) {
              // An entry array can have null entries, signifying a filtered entry and that there may be
              // additional pages
              if (entries[i] !== null) {
                  entriesLength++;
                  const rc = callback(entries[i]);
                  if (!rc) {
                      // callback indicates that we're done
                      return fileCount + i;
                  }
              }
          }
          if (nextPage && entries.length > 0) {
              // keep going -- have more entries
              return listFilesLoop(caller, hubConfig, nextPage, callCount + 1, fileCount + entriesLength, callback);
          }
          else {
              // no more entries -- end of data
              return fileCount + entriesLength;
          }
      });
  }
  /**
   * List the set of files in this application's Gaia storage bucket.
   * @param {function} callback - a callback to invoke on each named file that
   * returns `true` to continue the listing operation or `false` to end it
   * @return {Promise} that resolves to the total number of listed files.
   * If the call is ended early by the callback, the last file is excluded.
   * If an error occurs the entire call is rejected.
   */
  function listFiles(callback, caller) {
      caller = caller || new userSession_1.UserSession();
      return listFilesLoop(caller, null, null, 0, 0, callback);
  }
  exports.listFiles = listFiles;
  
  }).call(this,require("buffer").Buffer)
  },{"../auth/authConstants":35,"../auth/userSession":45,"../encryption/ec":51,"../errors":58,"../fetchUtil":59,"../keys":61,"../profiles/profileLookup":72,"../utils":95,"./hub":93,"buffer":3,"tslib":268}],95:[function(require,module,exports){
  (function (global){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const tslib_1 = require("tslib");
  const logger_1 = require("./logger");
  const errors_1 = require("./errors");
  /**
   *  @ignore
   */
  exports.BLOCKSTACK_HANDLER = 'blockstack';
  /**
   * Time
   * @private
   * @ignore
   */
  function nextYear() {
      return new Date(new Date().setFullYear(new Date().getFullYear() + 1));
  }
  exports.nextYear = nextYear;
  /**
   * Time
   * @private
   * @ignore
   */
  function nextMonth() {
      return new Date(new Date().setMonth(new Date().getMonth() + 1));
  }
  exports.nextMonth = nextMonth;
  /**
   * Time
   * @private
   * @ignore
   */
  function nextHour() {
      return new Date(new Date().setHours(new Date().getHours() + 1));
  }
  exports.nextHour = nextHour;
  /**
   * Converts megabytes to bytes. Returns 0 if the input is not a finite number.
   * @ignore
   */
  function megabytesToBytes(megabytes) {
      if (!Number.isFinite(megabytes)) {
          return 0;
      }
      return Math.floor(megabytes * 1024 * 1024);
  }
  exports.megabytesToBytes = megabytesToBytes;
  /**
   * Calculate the AES-CBC ciphertext output byte length a given input length.
   * AES has a fixed block size of 16-bytes regardless key size.
   * @ignore
   */
  function getAesCbcOutputLength(inputByteLength) {
      // AES-CBC block mode rounds up to the next block size. 
      const cipherTextLength = (Math.floor(inputByteLength / 16) + 1) * 16;
      return cipherTextLength;
  }
  exports.getAesCbcOutputLength = getAesCbcOutputLength;
  /**
   * Calculate the base64 encoded string length for a given input length.
   * This is equivalent to the byte length when the string is ASCII or UTF8-8
   * encoded.
   * @param number
   */
  function getBase64OutputLength(inputByteLength) {
      const encodedLength = (Math.ceil(inputByteLength / 3) * 4);
      return encodedLength;
  }
  exports.getBase64OutputLength = getBase64OutputLength;
  /**
   * Query Strings
   * @private
   * @ignore
   */
  function updateQueryStringParameter(uri, key, value) {
      const re = new RegExp(`([?&])${key}=.*?(&|$)`, 'i');
      const separator = uri.indexOf('?') !== -1 ? '&' : '?';
      if (uri.match(re)) {
          return uri.replace(re, `$1${key}=${value}$2`);
      }
      else {
          return `${uri}${separator}${key}=${value}`;
      }
  }
  exports.updateQueryStringParameter = updateQueryStringParameter;
  /**
   * Versioning
   * @param {string} v1 - the left half of the version inequality
   * @param {string} v2 - right half of the version inequality
   * @returns {bool} iff v1 >= v2
   * @private
   * @ignore
   */
  function isLaterVersion(v1, v2) {
      if (v1 === undefined) {
          v1 = '0.0.0';
      }
      if (v2 === undefined) {
          v2 = '0.0.0';
      }
      const v1tuple = v1.split('.').map(x => parseInt(x, 10));
      const v2tuple = v2.split('.').map(x => parseInt(x, 10));
      for (let index = 0; index < v2.length; index++) {
          if (index >= v1.length) {
              v2tuple.push(0);
          }
          if (v1tuple[index] < v2tuple[index]) {
              return false;
          }
      }
      return true;
  }
  exports.isLaterVersion = isLaterVersion;
  /**
   * UUIDs
   * @private
   * @ignore
   */
  function makeUUID4() {
      let d = new Date().getTime();
      if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
          d += performance.now(); // use high-precision timer if available
      }
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
          const r = (d + Math.random() * 16) % 16 | 0;
          d = Math.floor(d / 16);
          return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
      });
  }
  exports.makeUUID4 = makeUUID4;
  /**
   * Checks if both urls pass the same origin check & are absolute
   * @param  {[type]}  uri1 first uri to check
   * @param  {[type]}  uri2 second uri to check
   * @return {Boolean} true if they pass the same origin check
   * @private
   * @ignore
   */
  function isSameOriginAbsoluteUrl(uri1, uri2) {
      try {
          // The globally scoped WHATWG `URL` class is available in modern browsers and
          // NodeJS v10 or higher. In older NodeJS versions it must be required from the
          // `url` module.
          let parseUrl;
          if (typeof URL !== 'undefined') {
              parseUrl = url => new URL(url);
          }
          else {
              try {
                  // eslint-disable-next-line import/no-nodejs-modules, global-require
                  const nodeUrl = require('url').URL;
                  parseUrl = url => new nodeUrl(url);
              }
              catch (error) {
                  console.log(error);
                  console.error('Global URL class is not available');
              }
          }
          const parsedUri1 = parseUrl(uri1);
          const parsedUri2 = parseUrl(uri2);
          const port1 = parseInt(parsedUri1.port || '0', 10) | 0 || (parsedUri1.protocol === 'https:' ? 443 : 80);
          const port2 = parseInt(parsedUri2.port || '0', 10) | 0 || (parsedUri2.protocol === 'https:' ? 443 : 80);
          const match = {
              scheme: parsedUri1.protocol === parsedUri2.protocol,
              hostname: parsedUri1.hostname === parsedUri2.hostname,
              port: port1 === port2,
              absolute: (uri1.includes('http://') || uri1.includes('https://'))
                  && (uri2.includes('http://') || uri2.includes('https://'))
          };
          return match.scheme && match.hostname && match.port && match.absolute;
      }
      catch (error) {
          console.log(error);
          console.log('Parsing error in same URL origin check');
          // Parse error
          return false;
      }
  }
  exports.isSameOriginAbsoluteUrl = isSameOriginAbsoluteUrl;
  /**
   * Returns the global scope `Window`, `WorkerGlobalScope`, or `NodeJS.Global` if available in the
   * currently executing environment.
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/self
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/self
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope
   *
   * This could be switched to `globalThis` once it is standardized and widely available.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis
   * @ignore
   */
  function getGlobalScope() {
      if (typeof self !== 'undefined') {
          return self;
      }
      if (typeof window !== 'undefined') {
          return window;
      }
      // This function is meant to be called when accessing APIs that are typically only available in
      // web-browser/DOM environments, but we also want to support situations where running in Node.js 
      // environment, and a polyfill was added to the Node.js `global` object scope without adding the 
      // `window` global object as well. 
      if (typeof global !== 'undefined') {
          return global;
      }
      throw new Error('Unexpected runtime environment - no supported global scope (`window`, `self`, `global`) available');
  }
  exports.getGlobalScope = getGlobalScope;
  function getAPIUsageErrorMessage(scopeObject, apiName, usageDesc) {
      if (usageDesc) {
          return `Use of '${usageDesc}' requires \`${apiName}\` which is unavailable on the '${scopeObject}' object within the currently executing environment.`;
      }
      else {
          return `\`${apiName}\` is unavailable on the '${scopeObject}' object within the currently executing environment.`;
      }
  }
  /**
   * Returns an object from the global scope (`Window` or `WorkerGlobalScope`) if it
   * is available within the currently executing environment.
   * When executing within the Node.js runtime these APIs are unavailable and will be
   * `undefined` unless the API is provided via polyfill.
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/self
   * @ignore
   */
  function getGlobalObject(name, { throwIfUnavailable, usageDesc, returnEmptyObject } = {}) {
      let globalScope;
      try {
          globalScope = getGlobalScope();
          if (globalScope) {
              const obj = globalScope[name];
              if (obj) {
                  return obj;
              }
          }
      }
      catch (error) {
          logger_1.Logger.error(`Error getting object '${name}' from global scope '${globalScope}': ${error}`);
      }
      if (throwIfUnavailable) {
          const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);
          logger_1.Logger.error(errMsg);
          throw new Error(errMsg);
      }
      if (returnEmptyObject) {
          return {};
      }
      return undefined;
  }
  exports.getGlobalObject = getGlobalObject;
  /**
   * Returns a specified subset of objects from the global scope (`Window` or `WorkerGlobalScope`)
   * if they are available within the currently executing environment.
   * When executing within the Node.js runtime these APIs are unavailable will be `undefined`
   * unless the API is provided via polyfill.
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/self
   * @ignore
   */
  function getGlobalObjects(names, { throwIfUnavailable, usageDesc, returnEmptyObject } = {}) {
      let globalScope;
      try {
          globalScope = getGlobalScope();
      }
      catch (error) {
          logger_1.Logger.error(`Error getting global scope: ${error}`);
          if (throwIfUnavailable) {
              const errMsg = getAPIUsageErrorMessage(globalScope, names[0].toString(), usageDesc);
              logger_1.Logger.error(errMsg);
              throw errMsg;
          }
          else if (returnEmptyObject) {
              globalScope = {};
          }
      }
      const result = {};
      for (let i = 0; i < names.length; i++) {
          const name = names[i];
          try {
              if (globalScope) {
                  const obj = globalScope[name];
                  if (obj) {
                      result[name] = obj;
                  }
                  else if (throwIfUnavailable) {
                      const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);
                      logger_1.Logger.error(errMsg);
                      throw new Error(errMsg);
                  }
                  else if (returnEmptyObject) {
                      result[name] = {};
                  }
              }
          }
          catch (error) {
              if (throwIfUnavailable) {
                  const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);
                  logger_1.Logger.error(errMsg);
                  throw new Error(errMsg);
              }
          }
      }
      return result;
  }
  exports.getGlobalObjects = getGlobalObjects;
  function getGaiaErrorResponse(response) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          let responseMsg = '';
          let responseJson;
          try {
              responseMsg = yield response.text();
              try {
                  responseJson = JSON.parse(responseMsg);
              }
              catch (error) {
                  // Use text instead
              }
          }
          catch (error) {
              logger_1.Logger.debug(`Error getting bad http response text: ${error}`);
          }
          const status = response.status;
          const statusText = response.statusText;
          const body = responseJson || responseMsg;
          return { status, statusText, body };
      });
  }
  /**
   * Returns a BlockstackError correlating to the given HTTP response,
   * with the provided errorMsg. Throws if the HTTP response is 'ok'.
   */
  function getBlockstackErrorFromResponse(response, errorMsg, hubConfig) {
      var _a;
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (response.ok) {
              throw new Error('Cannot get a BlockstackError from a valid response.');
          }
          const gaiaResponse = yield getGaiaErrorResponse(response);
          if (gaiaResponse.status === 401) {
              return new errors_1.ValidationError(errorMsg, gaiaResponse);
          }
          else if (gaiaResponse.status === 402) {
              return new errors_1.NotEnoughProofError(errorMsg, gaiaResponse);
          }
          else if (gaiaResponse.status === 403) {
              return new errors_1.BadPathError(errorMsg, gaiaResponse);
          }
          else if (gaiaResponse.status === 404) {
              throw new errors_1.DoesNotExist(errorMsg, gaiaResponse);
          }
          else if (gaiaResponse.status === 409) {
              return new errors_1.ConflictError(errorMsg, gaiaResponse);
          }
          else if (gaiaResponse.status === 412) {
              return new errors_1.PreconditionFailedError(errorMsg, gaiaResponse);
          }
          else if (gaiaResponse.status === 413) {
              const maxBytes = megabytesToBytes((_a = hubConfig) === null || _a === void 0 ? void 0 : _a.max_file_upload_size_megabytes);
              return new errors_1.PayloadTooLargeError(errorMsg, gaiaResponse, maxBytes);
          }
          else {
              return new Error(errorMsg);
          }
      });
  }
  exports.getBlockstackErrorFromResponse = getBlockstackErrorFromResponse;
  
  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"./errors":58,"./logger":62,"tslib":268,"url":2}],96:[function(require,module,exports){
  (function (Buffer){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const tslib_1 = require("tslib");
  const bitcoinjs_lib_1 = require("bitcoinjs-lib");
  const bip39_1 = require("bip39");
  const wallet_1 = require("./encryption/wallet");
  const cryptoRandom_1 = require("./encryption/cryptoRandom");
  const sha2Hash_1 = require("./encryption/sha2Hash");
  const keys_1 = require("./keys");
  const APPS_NODE_INDEX = 0;
  const IDENTITY_KEYCHAIN = 888;
  const BLOCKSTACK_ON_BITCOIN = 0;
  const BITCOIN_BIP_44_PURPOSE = 44;
  const BITCOIN_COIN_TYPE = 0;
  const BITCOIN_ACCOUNT_INDEX = 0;
  const EXTERNAL_ADDRESS = 'EXTERNAL_ADDRESS';
  const CHANGE_ADDRESS = 'CHANGE_ADDRESS';
  /**
   *
   * @ignore
   */
  function hashCode(string) {
      let hash = 0;
      if (string.length === 0)
          return hash;
      for (let i = 0; i < string.length; i++) {
          const character = string.charCodeAt(i);
          hash = (hash << 5) - hash + character;
          hash &= hash;
      }
      return hash & 0x7fffffff;
  }
  /**
   *
   * @ignore
   */
  function getNodePrivateKey(node) {
      return keys_1.ecPairToHexString(bitcoinjs_lib_1.ECPair.fromPrivateKey(node.privateKey));
  }
  /**
   *
   * @ignore
   */
  function getNodePublicKey(node) {
      return node.publicKey.toString('hex');
  }
  /**
   * Get a BIP32 node for an application-specific domain.
   * @param {String} appsNode - the BIP32Interface ir base58-encoded private key for
   * applications node
   * @param {String} salt - a string, used to salt the
   * application-specific addresses
   * @param {String} appDomain - the appDomain to generate a key for
   * @return {String} the private key hex-string. this will be a 64
   * character string
   * @ignore
   */
  function getLegacyAppNode(appsNode, salt, appDomain) {
      const hashBuffer = sha2Hash_1.hashSha256Sync(Buffer.from(`${appDomain}${salt}`));
      const hash = hashBuffer.toString('hex');
      const appIndex = hashCode(hash);
      const appNodeInstance = typeof appsNode === 'string' ? bitcoinjs_lib_1.bip32.fromBase58(appsNode) : appsNode;
      return appNodeInstance.deriveHardened(appIndex);
  }
  exports.getLegacyAppNode = getLegacyAppNode;
  /**
   * The `BlockstackWallet` class manages the hierarchical derivation
   * paths for a standard Blockstack client wallet. This includes paths
   * for Bitcoin payment address, Blockstack identity addresses, Blockstack
   * application specific addresses.
   *
   * @ignore
   */
  class BlockstackWallet {
      constructor(rootNode) {
          this.rootNode = rootNode;
      }
      toBase58() {
          return this.rootNode.toBase58();
      }
      /**
       * Initialize a Blockstack wallet from a seed buffer
       * @param {Buffer} seed - the input seed for initializing the root node
       *  of the hierarchical wallet
       * @return {BlockstackWallet} the constructed wallet
       */
      static fromSeedBuffer(seed) {
          return new BlockstackWallet(bitcoinjs_lib_1.bip32.fromSeed(seed));
      }
      /**
       * Initialize a Blockstack wallet from a base58 string
       * @param {string} keychain - the Base58 string used to initialize
       *  the root node of the hierarchical wallet
       * @return {BlockstackWallet} the constructed wallet
       */
      static fromBase58(keychain) {
          return new BlockstackWallet(bitcoinjs_lib_1.bip32.fromBase58(keychain));
      }
      /**
       * Initialize a blockstack wallet from an encrypted phrase & password. Throws
       * if the password is incorrect. Supports all formats of Blockstack phrases.
       * @param {string} data - The encrypted phrase as a hex-encoded string
       * @param {string} password - The plain password
       * @return {Promise<BlockstackWallet>} the constructed wallet
       *
       * @ignore
       */
      static fromEncryptedMnemonic(data, password, triplesecDecrypt) {
          return tslib_1.__awaiter(this, void 0, void 0, function* () {
              try {
                  const mnemonic = yield wallet_1.decryptMnemonic(data, password, triplesecDecrypt);
                  const seed = yield bip39_1.mnemonicToSeed(mnemonic);
                  return new BlockstackWallet(bitcoinjs_lib_1.bip32.fromSeed(seed));
              }
              catch (err) {
                  if (err.message && err.message.startsWith('bad header;')) {
                      throw new Error('Incorrect password');
                  }
                  else {
                      throw err;
                  }
              }
          });
      }
      /**
       * Generate a BIP-39 12 word mnemonic
       * @return {Promise<string>} space-separated 12 word phrase
       */
      static generateMnemonic() {
          return bip39_1.generateMnemonic(128, cryptoRandom_1.randomBytes);
      }
      /**
       * Encrypt a mnemonic phrase with a password
       * @param {string} mnemonic - Raw mnemonic phrase
       * @param {string} password - Password to encrypt mnemonic with
       * @return {Promise<string>} Hex-encoded encrypted mnemonic
       *
       */
      static encryptMnemonic(mnemonic, password, opts) {
          return tslib_1.__awaiter(this, void 0, void 0, function* () {
              const encryptedBuffer = yield wallet_1.encryptMnemonic(mnemonic, password, opts);
              return encryptedBuffer.toString('hex');
          });
      }
      getIdentityPrivateKeychain() {
          return this.rootNode
              .deriveHardened(IDENTITY_KEYCHAIN)
              .deriveHardened(BLOCKSTACK_ON_BITCOIN);
      }
      getBitcoinPrivateKeychain() {
          return this.rootNode
              .deriveHardened(BITCOIN_BIP_44_PURPOSE)
              .deriveHardened(BITCOIN_COIN_TYPE)
              .deriveHardened(BITCOIN_ACCOUNT_INDEX);
      }
      getBitcoinNode(addressIndex, chainType = EXTERNAL_ADDRESS) {
          return BlockstackWallet.getNodeFromBitcoinKeychain(this.getBitcoinPrivateKeychain().toBase58(), addressIndex, chainType);
      }
      getIdentityAddressNode(identityIndex) {
          const identityPrivateKeychain = this.getIdentityPrivateKeychain();
          return identityPrivateKeychain.deriveHardened(identityIndex);
      }
      static getAppsNode(identityNode) {
          return identityNode.deriveHardened(APPS_NODE_INDEX);
      }
      /**
       * Get a salt for use with creating application specific addresses
       * @return {String} the salt
       */
      getIdentitySalt() {
          const identityPrivateKeychain = this.getIdentityPrivateKeychain();
          // NOTE: This is being decoded as a utf8 string rather than a hex string
          const publicKeyHex = Buffer.from(getNodePublicKey(identityPrivateKeychain));
          return sha2Hash_1.hashSha256Sync(publicKeyHex).toString('hex');
      }
      /**
       * Get a bitcoin receive address at a given index
       * @param {number} addressIndex - the index of the address
       * @return {String} address
       */
      getBitcoinAddress(addressIndex) {
          return BlockstackWallet.getAddressFromBIP32Node(this.getBitcoinNode(addressIndex));
      }
      /**
       * Get the private key hex-string for a given bitcoin receive address
       * @param {number} addressIndex - the index of the address
       * @return {String} the hex-string. this will be either 64
       * characters long to denote an uncompressed bitcoin address, or 66
       * characters long for a compressed bitcoin address.
       */
      getBitcoinPrivateKey(addressIndex) {
          return getNodePrivateKey(this.getBitcoinNode(addressIndex));
      }
      /**
       * Get the root node for the bitcoin public keychain
       * @return {String} base58-encoding of the public node
       */
      getBitcoinPublicKeychain() {
          return this.getBitcoinPrivateKeychain().neutered();
      }
      /**
       * Get the root node for the identity public keychain
       * @return {String} base58-encoding of the public node
       */
      getIdentityPublicKeychain() {
          return this.getIdentityPrivateKeychain().neutered();
      }
      static getNodeFromBitcoinKeychain(keychainBase58, addressIndex, chainType = EXTERNAL_ADDRESS) {
          let chain;
          if (chainType === EXTERNAL_ADDRESS) {
              chain = 0;
          }
          else if (chainType === CHANGE_ADDRESS) {
              chain = 1;
          }
          else {
              throw new Error('Invalid chain type');
          }
          const keychain = bitcoinjs_lib_1.bip32.fromBase58(keychainBase58);
          return keychain.derive(chain).derive(addressIndex);
      }
      /**
       * Get a bitcoin address given a base-58 encoded bitcoin node
       * (usually called the account node)
       * @param {String} keychainBase58 - base58-encoding of the node
       * @param {number} addressIndex - index of the address to get
       * @param {String} chainType - either 'EXTERNAL_ADDRESS' (for a
       * "receive" address) or 'CHANGE_ADDRESS'
       * @return {String} the address
       */
      static getAddressFromBitcoinKeychain(keychainBase58, addressIndex, chainType = EXTERNAL_ADDRESS) {
          return BlockstackWallet.getAddressFromBIP32Node(BlockstackWallet
              .getNodeFromBitcoinKeychain(keychainBase58, addressIndex, chainType));
      }
      /**
       * Get a ECDSA private key hex-string for an application-specific
       *  address.
       * @param {String} appsNodeKey - the base58-encoded private key for
       * applications node (the `appsNodeKey` return in getIdentityKeyPair())
       * @param {String} salt - a string, used to salt the
       * application-specific addresses
       * @param {String} appDomain - the appDomain to generate a key for
       * @return {String} the private key hex-string. this will be a 64
       * character string
       */
      static getLegacyAppPrivateKey(appsNodeKey, salt, appDomain) {
          const appNode = getLegacyAppNode(appsNodeKey, salt, appDomain);
          return getNodePrivateKey(appNode).slice(0, 64);
      }
      static getAddressFromBIP32Node(node) {
          return bitcoinjs_lib_1.payments.p2pkh({ pubkey: node.publicKey }).address;
      }
      /**
       * Get a ECDSA private key hex-string for an application-specific
       *  address.
       * @param {String} appsNodeKey - the base58-encoded private key for
       * applications node (the `appsNodeKey` return in getIdentityKeyPair())
       * @param {String} salt - a string, used to salt the
       * application-specific addresses
       * @param {String} appDomain - the appDomain to generate a key for
       * @return {String} the private key hex-string. this will be a 64
       * character string
       */
      static getAppPrivateKey(appsNodeKey, salt, appDomain) {
          const hashBuffer = sha2Hash_1.hashSha256Sync(Buffer.from(`${appDomain}${salt}`));
          const hash = hashBuffer.toString('hex');
          const appIndexHexes = [];
          // note: there's hardcoded numbers here, precisely because I want this
          //   code to be very specific to the derivation paths we expect.
          if (hash.length !== 64) {
              throw new Error(`Unexpected app-domain hash length of ${hash.length}`);
          }
          for (let i = 0; i < 11; i++) { // split the hash into 3-byte chunks
              // because child nodes can only be up to 2^31,
              // and we shouldn't deal in partial bytes.
              appIndexHexes.push(hash.slice(i * 6, i * 6 + 6));
          }
          let appNode = bitcoinjs_lib_1.bip32.fromBase58(appsNodeKey);
          appIndexHexes.forEach((hex) => {
              if (hex.length > 6) {
                  throw new Error('Invalid hex string length');
              }
              appNode = appNode.deriveHardened(parseInt(hex, 16));
          });
          return getNodePrivateKey(appNode).slice(0, 64);
      }
      /**
       * Get the keypair information for a given identity index. This
       * information is used to obtain the private key for an identity address
       * and derive application specific keys for that address.
       * @param {number} addressIndex - the identity index
       * @param {boolean} alwaysUncompressed - if true, always return a
       *   private-key hex string corresponding to the uncompressed address
       * @return {Object} an IdentityKeyPair type object with keys:
       *   .key {String} - the private key hex-string
       *   .keyID {String} - the public key hex-string
       *   .address {String} - the identity address
       *   .appsNodeKey {String} - the base-58 encoding of the applications node
       *   .salt {String} - the salt used for creating app-specific addresses
       */
      getIdentityKeyPair(addressIndex, alwaysUncompressed = false) {
          const identityNode = this.getIdentityAddressNode(addressIndex);
          const address = BlockstackWallet.getAddressFromBIP32Node(identityNode);
          let identityKey = getNodePrivateKey(identityNode);
          if (alwaysUncompressed && identityKey.length === 66) {
              identityKey = identityKey.slice(0, 64);
          }
          const identityKeyID = getNodePublicKey(identityNode);
          const appsNodeKey = BlockstackWallet.getAppsNode(identityNode).toBase58();
          const salt = this.getIdentitySalt();
          const keyPair = {
              key: identityKey,
              keyID: identityKeyID,
              address,
              appsNodeKey,
              salt
          };
          return keyPair;
      }
  }
  exports.BlockstackWallet = BlockstackWallet;
  
  }).call(this,require("buffer").Buffer)
  },{"./encryption/cryptoRandom":49,"./encryption/sha2Hash":56,"./encryption/wallet":57,"./keys":61,"bip39":130,"bitcoinjs-lib":148,"buffer":3,"tslib":268}],97:[function(require,module,exports){
  (function (process,setImmediate){
  (function (global, factory) {
      typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
      typeof define === 'function' && define.amd ? define(['exports'], factory) :
      (factory((global.async = {})));
  }(this, (function (exports) { 'use strict';
  
      /**
       * Creates a continuation function with some arguments already applied.
       *
       * Useful as a shorthand when combined with other control flow functions. Any
       * arguments passed to the returned function are added to the arguments
       * originally passed to apply.
       *
       * @name apply
       * @static
       * @memberOf module:Utils
       * @method
       * @category Util
       * @param {Function} fn - The function you want to eventually apply all
       * arguments to. Invokes with (arguments...).
       * @param {...*} arguments... - Any number of arguments to automatically apply
       * when the continuation is called.
       * @returns {Function} the partially-applied function
       * @example
       *
       * // using apply
       * async.parallel([
       *     async.apply(fs.writeFile, 'testfile1', 'test1'),
       *     async.apply(fs.writeFile, 'testfile2', 'test2')
       * ]);
       *
       *
       * // the same process without using apply
       * async.parallel([
       *     function(callback) {
       *         fs.writeFile('testfile1', 'test1', callback);
       *     },
       *     function(callback) {
       *         fs.writeFile('testfile2', 'test2', callback);
       *     }
       * ]);
       *
       * // It's possible to pass any number of additional arguments when calling the
       * // continuation:
       *
       * node> var fn = async.apply(sys.puts, 'one');
       * node> fn('two', 'three');
       * one
       * two
       * three
       */
      function apply(fn, ...args) {
          return (...callArgs) => fn(...args,...callArgs);
      }
  
      function initialParams (fn) {
          return function (...args/*, callback*/) {
              var callback = args.pop();
              return fn.call(this, args, callback);
          };
      }
  
      /* istanbul ignore file */
  
      var hasSetImmediate = typeof setImmediate === 'function' && setImmediate;
      var hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';
  
      function fallback(fn) {
          setTimeout(fn, 0);
      }
  
      function wrap(defer) {
          return (fn, ...args) => defer(() => fn(...args));
      }
  
      var _defer;
  
      if (hasSetImmediate) {
          _defer = setImmediate;
      } else if (hasNextTick) {
          _defer = process.nextTick;
      } else {
          _defer = fallback;
      }
  
      var setImmediate$1 = wrap(_defer);
  
      /**
       * Take a sync function and make it async, passing its return value to a
       * callback. This is useful for plugging sync functions into a waterfall,
       * series, or other async functions. Any arguments passed to the generated
       * function will be passed to the wrapped function (except for the final
       * callback argument). Errors thrown will be passed to the callback.
       *
       * If the function passed to `asyncify` returns a Promise, that promises's
       * resolved/rejected state will be used to call the callback, rather than simply
       * the synchronous return value.
       *
       * This also means you can asyncify ES2017 `async` functions.
       *
       * @name asyncify
       * @static
       * @memberOf module:Utils
       * @method
       * @alias wrapSync
       * @category Util
       * @param {Function} func - The synchronous function, or Promise-returning
       * function to convert to an {@link AsyncFunction}.
       * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
       * invoked with `(args..., callback)`.
       * @example
       *
       * // passing a regular synchronous function
       * async.waterfall([
       *     async.apply(fs.readFile, filename, "utf8"),
       *     async.asyncify(JSON.parse),
       *     function (data, next) {
       *         // data is the result of parsing the text.
       *         // If there was a parsing error, it would have been caught.
       *     }
       * ], callback);
       *
       * // passing a function returning a promise
       * async.waterfall([
       *     async.apply(fs.readFile, filename, "utf8"),
       *     async.asyncify(function (contents) {
       *         return db.model.create(contents);
       *     }),
       *     function (model, next) {
       *         // `model` is the instantiated model object.
       *         // If there was an error, this function would be skipped.
       *     }
       * ], callback);
       *
       * // es2017 example, though `asyncify` is not needed if your JS environment
       * // supports async functions out of the box
       * var q = async.queue(async.asyncify(async function(file) {
       *     var intermediateStep = await processFile(file);
       *     return await somePromise(intermediateStep)
       * }));
       *
       * q.push(files);
       */
      function asyncify(func) {
          if (isAsync(func)) {
              return function (...args/*, callback*/) {
                  const callback = args.pop();
                  const promise = func.apply(this, args);
                  return handlePromise(promise, callback)
              }
          }
  
          return initialParams(function (args, callback) {
              var result;
              try {
                  result = func.apply(this, args);
              } catch (e) {
                  return callback(e);
              }
              // if result is Promise object
              if (result && typeof result.then === 'function') {
                  return handlePromise(result, callback)
              } else {
                  callback(null, result);
              }
          });
      }
  
      function handlePromise(promise, callback) {
          return promise.then(value => {
              invokeCallback(callback, null, value);
          }, err => {
              invokeCallback(callback, err && err.message ? err : new Error(err));
          });
      }
  
      function invokeCallback(callback, error, value) {
          try {
              callback(error, value);
          } catch (err) {
              setImmediate$1(e => { throw e }, err);
          }
      }
  
      function isAsync(fn) {
          return fn[Symbol.toStringTag] === 'AsyncFunction';
      }
  
      function isAsyncGenerator(fn) {
          return fn[Symbol.toStringTag] === 'AsyncGenerator';
      }
  
      function isAsyncIterable(obj) {
          return typeof obj[Symbol.asyncIterator] === 'function';
      }
  
      function wrapAsync(asyncFn) {
          if (typeof asyncFn !== 'function') throw new Error('expected a function')
          return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
      }
  
      // conditionally promisify a function.
      // only return a promise if a callback is omitted
      function awaitify (asyncFn, arity = asyncFn.length) {
          if (!arity) throw new Error('arity is undefined')
          function awaitable (...args) {
              if (typeof args[arity - 1] === 'function') {
                  return asyncFn.apply(this, args)
              }
  
              return new Promise((resolve, reject) => {
                  args[arity - 1] = (err, ...cbArgs) => {
                      if (err) return reject(err)
                      resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
                  };
                  asyncFn.apply(this, args);
              })
          }
  
          return awaitable
      }
  
      function applyEach (eachfn) {
          return function applyEach(fns, ...callArgs) {
              const go = awaitify(function (callback) {
                  var that = this;
                  return eachfn(fns, (fn, cb) => {
                      wrapAsync(fn).apply(that, callArgs.concat(cb));
                  }, callback);
              });
              return go;
          };
      }
  
      function _asyncMap(eachfn, arr, iteratee, callback) {
          arr = arr || [];
          var results = [];
          var counter = 0;
          var _iteratee = wrapAsync(iteratee);
  
          return eachfn(arr, (value, _, iterCb) => {
              var index = counter++;
              _iteratee(value, (err, v) => {
                  results[index] = v;
                  iterCb(err);
              });
          }, err => {
              callback(err, results);
          });
      }
  
      function isArrayLike(value) {
          return value &&
              typeof value.length === 'number' &&
              value.length >= 0 &&
              value.length % 1 === 0;
      }
  
      // A temporary value used to identify if the loop should be broken.
      // See #1064, #1293
      const breakLoop = {};
  
      function once(fn) {
          function wrapper (...args) {
              if (fn === null) return;
              var callFn = fn;
              fn = null;
              callFn.apply(this, args);
          }
          Object.assign(wrapper, fn);
          return wrapper
      }
  
      function getIterator (coll) {
          return coll[Symbol.iterator] && coll[Symbol.iterator]();
      }
  
      function createArrayIterator(coll) {
          var i = -1;
          var len = coll.length;
          return function next() {
              return ++i < len ? {value: coll[i], key: i} : null;
          }
      }
  
      function createES2015Iterator(iterator) {
          var i = -1;
          return function next() {
              var item = iterator.next();
              if (item.done)
                  return null;
              i++;
              return {value: item.value, key: i};
          }
      }
  
      function createObjectIterator(obj) {
          var okeys = obj ? Object.keys(obj) : [];
          var i = -1;
          var len = okeys.length;
          return function next() {
              var key = okeys[++i];
              return i < len ? {value: obj[key], key} : null;
          };
      }
  
      function createIterator(coll) {
          if (isArrayLike(coll)) {
              return createArrayIterator(coll);
          }
  
          var iterator = getIterator(coll);
          return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
      }
  
      function onlyOnce(fn) {
          return function (...args) {
              if (fn === null) throw new Error("Callback was already called.");
              var callFn = fn;
              fn = null;
              callFn.apply(this, args);
          };
      }
  
      // for async generators
      function asyncEachOfLimit(generator, limit, iteratee, callback) {
          let done = false;
          let canceled = false;
          let awaiting = false;
          let running = 0;
          let idx = 0;
  
          function replenish() {
              //console.log('replenish')
              if (running >= limit || awaiting || done) return
              //console.log('replenish awaiting')
              awaiting = true;
              generator.next().then(({value, done: iterDone}) => {
                  //console.log('got value', value)
                  if (canceled || done) return
                  awaiting = false;
                  if (iterDone) {
                      done = true;
                      if (running <= 0) {
                          //console.log('done nextCb')
                          callback(null);
                      }
                      return;
                  }
                  running++;
                  iteratee(value, idx, iterateeCallback);
                  idx++;
                  replenish();
              }).catch(handleError);
          }
  
          function iterateeCallback(err, result) {
              //console.log('iterateeCallback')
              running -= 1;
              if (canceled) return
              if (err) return handleError(err)
  
              if (err === false) {
                  done = true;
                  canceled = true;
                  return
              }
  
              if (result === breakLoop || (done && running <= 0)) {
                  done = true;
                  //console.log('done iterCb')
                  return callback(null);
              }
              replenish();
          }
  
          function handleError(err) {
              if (canceled) return
              awaiting = false;
              done = true;
              callback(err);
          }
  
          replenish();
      }
  
      var eachOfLimit = (limit) => {
          return (obj, iteratee, callback) => {
              callback = once(callback);
              if (limit <= 0) {
                  throw new RangeError('concurrency limit cannot be less than 1')
              }
              if (!obj) {
                  return callback(null);
              }
              if (isAsyncGenerator(obj)) {
                  return asyncEachOfLimit(obj, limit, iteratee, callback)
              }
              if (isAsyncIterable(obj)) {
                  return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback)
              }
              var nextElem = createIterator(obj);
              var done = false;
              var canceled = false;
              var running = 0;
              var looping = false;
  
              function iterateeCallback(err, value) {
                  if (canceled) return
                  running -= 1;
                  if (err) {
                      done = true;
                      callback(err);
                  }
                  else if (err === false) {
                      done = true;
                      canceled = true;
                  }
                  else if (value === breakLoop || (done && running <= 0)) {
                      done = true;
                      return callback(null);
                  }
                  else if (!looping) {
                      replenish();
                  }
              }
  
              function replenish () {
                  looping = true;
                  while (running < limit && !done) {
                      var elem = nextElem();
                      if (elem === null) {
                          done = true;
                          if (running <= 0) {
                              callback(null);
                          }
                          return;
                      }
                      running += 1;
                      iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
                  }
                  looping = false;
              }
  
              replenish();
          };
      };
  
      /**
       * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a
       * time.
       *
       * @name eachOfLimit
       * @static
       * @memberOf module:Collections
       * @method
       * @see [async.eachOf]{@link module:Collections.eachOf}
       * @alias forEachOfLimit
       * @category Collection
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {number} limit - The maximum number of async operations at a time.
       * @param {AsyncFunction} iteratee - An async function to apply to each
       * item in `coll`. The `key` is the item's key, or index in the case of an
       * array.
       * Invoked with (item, key, callback).
       * @param {Function} [callback] - A callback which is called when all
       * `iteratee` functions have finished, or an error occurs. Invoked with (err).
       * @returns {Promise} a promise, if a callback is omitted
       */
      function eachOfLimit$1(coll, limit, iteratee, callback) {
          return eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
      }
  
      var eachOfLimit$2 = awaitify(eachOfLimit$1, 4);
  
      // eachOf implementation optimized for array-likes
      function eachOfArrayLike(coll, iteratee, callback) {
          callback = once(callback);
          var index = 0,
              completed = 0,
              {length} = coll,
              canceled = false;
          if (length === 0) {
              callback(null);
          }
  
          function iteratorCallback(err, value) {
              if (err === false) {
                  canceled = true;
              }
              if (canceled === true) return
              if (err) {
                  callback(err);
              } else if ((++completed === length) || value === breakLoop) {
                  callback(null);
              }
          }
  
          for (; index < length; index++) {
              iteratee(coll[index], index, onlyOnce(iteratorCallback));
          }
      }
  
      // a generic version of eachOf which can handle array, object, and iterator cases.
      function eachOfGeneric (coll, iteratee, callback) {
          return eachOfLimit$2(coll, Infinity, iteratee, callback);
      }
  
      /**
       * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument
       * to the iteratee.
       *
       * @name eachOf
       * @static
       * @memberOf module:Collections
       * @method
       * @alias forEachOf
       * @category Collection
       * @see [async.each]{@link module:Collections.each}
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {AsyncFunction} iteratee - A function to apply to each
       * item in `coll`.
       * The `key` is the item's key, or index in the case of an array.
       * Invoked with (item, key, callback).
       * @param {Function} [callback] - A callback which is called when all
       * `iteratee` functions have finished, or an error occurs. Invoked with (err).
       * @returns {Promise} a promise, if a callback is omitted
       * @example
       *
       * var obj = {dev: "/dev.json", test: "/test.json", prod: "/prod.json"};
       * var configs = {};
       *
       * async.forEachOf(obj, function (value, key, callback) {
       *     fs.readFile(__dirname + value, "utf8", function (err, data) {
       *         if (err) return callback(err);
       *         try {
       *             configs[key] = JSON.parse(data);
       *         } catch (e) {
       *             return callback(e);
       *         }
       *         callback();
       *     });
       * }, function (err) {
       *     if (err) console.error(err.message);
       *     // configs is now a map of JSON data
       *     doSomethingWith(configs);
       * });
       */
      function eachOf(coll, iteratee, callback) {
          var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
          return eachOfImplementation(coll, wrapAsync(iteratee), callback);
      }
  
      var eachOf$1 = awaitify(eachOf, 3);
  
      /**
       * Produces a new collection of values by mapping each value in `coll` through
       * the `iteratee` function. The `iteratee` is called with an item from `coll`
       * and a callback for when it has finished processing. Each of these callback
       * takes 2 arguments: an `error`, and the transformed item from `coll`. If
       * `iteratee` passes an error to its callback, the main `callback` (for the
       * `map` function) is immediately called with the error.
       *
       * Note, that since this function applies the `iteratee` to each item in
       * parallel, there is no guarantee that the `iteratee` functions will complete
       * in order. However, the results array will be in the same order as the
       * original `coll`.
       *
       * If `map` is passed an Object, the results will be an Array.  The results
       * will roughly be in the order of the original Objects' keys (but this can
       * vary across JavaScript engines).
       *
       * @name map
       * @static
       * @memberOf module:Collections
       * @method
       * @category Collection
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {AsyncFunction} iteratee - An async function to apply to each item in
       * `coll`.
       * The iteratee should complete with the transformed item.
       * Invoked with (item, callback).
       * @param {Function} [callback] - A callback which is called when all `iteratee`
       * functions have finished, or an error occurs. Results is an Array of the
       * transformed items from the `coll`. Invoked with (err, results).
       * @returns {Promise} a promise, if no callback is passed
       * @example
       *
       * async.map(['file1','file2','file3'], fs.stat, function(err, results) {
       *     // results is now an array of stats for each file
       * });
       */
      function map (coll, iteratee, callback) {
          return _asyncMap(eachOf$1, coll, iteratee, callback)
      }
      var map$1 = awaitify(map, 3);
  
      /**
       * Applies the provided arguments to each function in the array, calling
       * `callback` after all functions have completed. If you only provide the first
       * argument, `fns`, then it will return a function which lets you pass in the
       * arguments as if it were a single function call. If more arguments are
       * provided, `callback` is required while `args` is still optional. The results
       * for each of the applied async functions are passed to the final callback
       * as an array.
       *
       * @name applyEach
       * @static
       * @memberOf module:ControlFlow
       * @method
       * @category Control Flow
       * @param {Array|Iterable|AsyncIterable|Object} fns - A collection of {@link AsyncFunction}s
       * to all call with the same arguments
       * @param {...*} [args] - any number of separate arguments to pass to the
       * function.
       * @param {Function} [callback] - the final argument should be the callback,
       * called when all functions have completed processing.
       * @returns {AsyncFunction} - Returns a function that takes no args other than
       * an optional callback, that is the result of applying the `args` to each
       * of the functions.
       * @example
       *
       * const appliedFn = async.applyEach([enableSearch, updateSchema], 'bucket')
       *
       * appliedFn((err, results) => {
       *     // results[0] is the results for `enableSearch`
       *     // results[1] is the results for `updateSchema`
       * });
       *
       * // partial application example:
       * async.each(
       *     buckets,
       *     async (bucket) => async.applyEach([enableSearch, updateSchema], bucket)(),
       *     callback
       * );
       */
      var applyEach$1 = applyEach(map$1);
  
      /**
       * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.
       *
       * @name eachOfSeries
       * @static
       * @memberOf module:Collections
       * @method
       * @see [async.eachOf]{@link module:Collections.eachOf}
       * @alias forEachOfSeries
       * @category Collection
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {AsyncFunction} iteratee - An async function to apply to each item in
       * `coll`.
       * Invoked with (item, key, callback).
       * @param {Function} [callback] - A callback which is called when all `iteratee`
       * functions have finished, or an error occurs. Invoked with (err).
       * @returns {Promise} a promise, if a callback is omitted
       */
      function eachOfSeries(coll, iteratee, callback) {
          return eachOfLimit$2(coll, 1, iteratee, callback)
      }
      var eachOfSeries$1 = awaitify(eachOfSeries, 3);
  
      /**
       * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.
       *
       * @name mapSeries
       * @static
       * @memberOf module:Collections
       * @method
       * @see [async.map]{@link module:Collections.map}
       * @category Collection
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {AsyncFunction} iteratee - An async function to apply to each item in
       * `coll`.
       * The iteratee should complete with the transformed item.
       * Invoked with (item, callback).
       * @param {Function} [callback] - A callback which is called when all `iteratee`
       * functions have finished, or an error occurs. Results is an array of the
       * transformed items from the `coll`. Invoked with (err, results).
       * @returns {Promise} a promise, if no callback is passed
       */
      function mapSeries (coll, iteratee, callback) {
          return _asyncMap(eachOfSeries$1, coll, iteratee, callback)
      }
      var mapSeries$1 = awaitify(mapSeries, 3);
  
      /**
       * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.
       *
       * @name applyEachSeries
       * @static
       * @memberOf module:ControlFlow
       * @method
       * @see [async.applyEach]{@link module:ControlFlow.applyEach}
       * @category Control Flow
       * @param {Array|Iterable|AsyncIterable|Object} fns - A collection of {@link AsyncFunction}s to all
       * call with the same arguments
       * @param {...*} [args] - any number of separate arguments to pass to the
       * function.
       * @param {Function} [callback] - the final argument should be the callback,
       * called when all functions have completed processing.
       * @returns {AsyncFunction} - A function, that when called, is the result of
       * appling the `args` to the list of functions.  It takes no args, other than
       * a callback.
       */
      var applyEachSeries = applyEach(mapSeries$1);
  
      const PROMISE_SYMBOL = Symbol('promiseCallback');
  
      function promiseCallback () {
          let resolve, reject;
          function callback (err, ...args) {
              if (err) return reject(err)
              resolve(args.length > 1 ? args : args[0]);
          }
  
          callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
              resolve = res,
              reject = rej;
          });
  
          return callback
      }
  
      /**
       * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on
       * their requirements. Each function can optionally depend on other functions
       * being completed first, and each function is run as soon as its requirements
       * are satisfied.
       *
       * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence
       * will stop. Further tasks will not execute (so any other functions depending
       * on it will not run), and the main `callback` is immediately called with the
       * error.
       *
       * {@link AsyncFunction}s also receive an object containing the results of functions which
       * have completed so far as the first argument, if they have dependencies. If a
       * task function has no dependencies, it will only be passed a callback.
       *
       * @name auto
       * @static
       * @memberOf module:ControlFlow
       * @method
       * @category Control Flow
       * @param {Object} tasks - An object. Each of its properties is either a
       * function or an array of requirements, with the {@link AsyncFunction} itself the last item
       * in the array. The object's key of a property serves as the name of the task
       * defined by that property, i.e. can be used when specifying requirements for
       * other tasks. The function receives one or two arguments:
       * * a `results` object, containing the results of the previously executed
       *   functions, only passed if the task has any dependencies,
       * * a `callback(err, result)` function, which must be called when finished,
       *   passing an `error` (which can be `null`) and the result of the function's
       *   execution.
       * @param {number} [concurrency=Infinity] - An optional `integer` for
       * determining the maximum number of tasks that can be run in parallel. By
       * default, as many as possible.
       * @param {Function} [callback] - An optional callback which is called when all
       * the tasks have been completed. It receives the `err` argument if any `tasks`
       * pass an error to their callback. Results are always returned; however, if an
       * error occurs, no further `tasks` will be performed, and the results object
       * will only contain partial results. Invoked with (err, results).
       * @returns {Promise} a promise, if a callback is not passed
       * @example
       *
       * async.auto({
       *     // this function will just be passed a callback
       *     readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),
       *     showData: ['readData', function(results, cb) {
       *         // results.readData is the file's contents
       *         // ...
       *     }]
       * }, callback);
       *
       * async.auto({
       *     get_data: function(callback) {
       *         console.log('in get_data');
       *         // async code to get some data
       *         callback(null, 'data', 'converted to array');
       *     },
       *     make_folder: function(callback) {
       *         console.log('in make_folder');
       *         // async code to create a directory to store a file in
       *         // this is run at the same time as getting the data
       *         callback(null, 'folder');
       *     },
       *     write_file: ['get_data', 'make_folder', function(results, callback) {
       *         console.log('in write_file', JSON.stringify(results));
       *         // once there is some data and the directory exists,
       *         // write the data to a file in the directory
       *         callback(null, 'filename');
       *     }],
       *     email_link: ['write_file', function(results, callback) {
       *         console.log('in email_link', JSON.stringify(results));
       *         // once the file is written let's email a link to it...
       *         // results.write_file contains the filename returned by write_file.
       *         callback(null, {'file':results.write_file, 'email':'user@example.com'});
       *     }]
       * }, function(err, results) {
       *     console.log('err = ', err);
       *     console.log('results = ', results);
       * });
       */
      function auto(tasks, concurrency, callback) {
          if (typeof concurrency !== 'number') {
              // concurrency is optional, shift the args.
              callback = concurrency;
              concurrency = null;
          }
          callback = once(callback || promiseCallback());
          var numTasks = Object.keys(tasks).length;
          if (!numTasks) {
              return callback(null);
          }
          if (!concurrency) {
              concurrency = numTasks;
          }
  
          var results = {};
          var runningTasks = 0;
          var canceled = false;
          var hasError = false;
  
          var listeners = Object.create(null);
  
          var readyTasks = [];
  
          // for cycle detection:
          var readyToCheck = []; // tasks that have been identified as reachable
          // without the possibility of returning to an ancestor task
          var uncheckedDependencies = {};
  
          Object.keys(tasks).forEach(key => {
              var task = tasks[key];
              if (!Array.isArray(task)) {
                  // no dependencies
                  enqueueTask(key, [task]);
                  readyToCheck.push(key);
                  return;
              }
  
              var dependencies = task.slice(0, task.length - 1);
              var remainingDependencies = dependencies.length;
              if (remainingDependencies === 0) {
                  enqueueTask(key, task);
                  readyToCheck.push(key);
                  return;
              }
              uncheckedDependencies[key] = remainingDependencies;
  
              dependencies.forEach(dependencyName => {
                  if (!tasks[dependencyName]) {
                      throw new Error('async.auto task `' + key +
                          '` has a non-existent dependency `' +
                          dependencyName + '` in ' +
                          dependencies.join(', '));
                  }
                  addListener(dependencyName, () => {
                      remainingDependencies--;
                      if (remainingDependencies === 0) {
                          enqueueTask(key, task);
                      }
                  });
              });
          });
  
          checkForDeadlocks();
          processQueue();
  
          function enqueueTask(key, task) {
              readyTasks.push(() => runTask(key, task));
          }
  
          function processQueue() {
              if (canceled) return
              if (readyTasks.length === 0 && runningTasks === 0) {
                  return callback(null, results);
              }
              while(readyTasks.length && runningTasks < concurrency) {
                  var run = readyTasks.shift();
                  run();
              }
  
          }
  
          function addListener(taskName, fn) {
              var taskListeners = listeners[taskName];
              if (!taskListeners) {
                  taskListeners = listeners[taskName] = [];
              }
  
              taskListeners.push(fn);
          }
  
          function taskComplete(taskName) {
              var taskListeners = listeners[taskName] || [];
              taskListeners.forEach(fn => fn());
              processQueue();
          }
  
  
          function runTask(key, task) {
              if (hasError) return;
  
              var taskCallback = onlyOnce((err, ...result) => {
                  runningTasks--;
                  if (err === false) {
                      canceled = true;
                      return
                  }
                  if (result.length < 2) {
                      [result] = result;
                  }
                  if (err) {
                      var safeResults = {};
                      Object.keys(results).forEach(rkey => {
                          safeResults[rkey] = results[rkey];
                      });
                      safeResults[key] = result;
                      hasError = true;
                      listeners = Object.create(null);
                      if (canceled) return
                      callback(err, safeResults);
                  } else {
                      results[key] = result;
                      taskComplete(key);
                  }
              });
  
              runningTasks++;
              var taskFn = wrapAsync(task[task.length - 1]);
              if (task.length > 1) {
                  taskFn(results, taskCallback);
              } else {
                  taskFn(taskCallback);
              }
          }
  
          function checkForDeadlocks() {
              // Kahn's algorithm
              // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm
              // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html
              var currentTask;
              var counter = 0;
              while (readyToCheck.length) {
                  currentTask = readyToCheck.pop();
                  counter++;
                  getDependents(currentTask).forEach(dependent => {
                      if (--uncheckedDependencies[dependent] === 0) {
                          readyToCheck.push(dependent);
                      }
                  });
              }
  
              if (counter !== numTasks) {
                  throw new Error(
                      'async.auto cannot execute tasks due to a recursive dependency'
                  );
              }
          }
  
          function getDependents(taskName) {
              var result = [];
              Object.keys(tasks).forEach(key => {
                  const task = tasks[key];
                  if (Array.isArray(task) && task.indexOf(taskName) >= 0) {
                      result.push(key);
                  }
              });
              return result;
          }
  
          return callback[PROMISE_SYMBOL]
      }
  
      var FN_ARGS = /^(?:async\s+)?(?:function)?\s*\w*\s*\(\s*([^)]+)\s*\)(?:\s*{)/;
      var ARROW_FN_ARGS = /^(?:async\s+)?\(?\s*([^)=]+)\s*\)?(?:\s*=>)/;
      var FN_ARG_SPLIT = /,/;
      var FN_ARG = /(=.+)?(\s*)$/;
      var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
  
      function parseParams(func) {
          const src = func.toString().replace(STRIP_COMMENTS, '');
          let match = src.match(FN_ARGS);
          if (!match) {
              match = src.match(ARROW_FN_ARGS);
          }
          if (!match) throw new Error('could not parse args in autoInject\nSource:\n' + src)
          let [, args] = match;
          return args
              .replace(/\s/g, '')
              .split(FN_ARG_SPLIT)
              .map((arg) => arg.replace(FN_ARG, '').trim());
      }
  
      /**
       * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent
       * tasks are specified as parameters to the function, after the usual callback
       * parameter, with the parameter names matching the names of the tasks it
       * depends on. This can provide even more readable task graphs which can be
       * easier to maintain.
       *
       * If a final callback is specified, the task results are similarly injected,
       * specified as named parameters after the initial error parameter.
       *
       * The autoInject function is purely syntactic sugar and its semantics are
       * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.
       *
       * @name autoInject
       * @static
       * @memberOf module:ControlFlow
       * @method
       * @see [async.auto]{@link module:ControlFlow.auto}
       * @category Control Flow
       * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of
       * the form 'func([dependencies...], callback). The object's key of a property
       * serves as the name of the task defined by that property, i.e. can be used
       * when specifying requirements for other tasks.
       * * The `callback` parameter is a `callback(err, result)` which must be called
       *   when finished, passing an `error` (which can be `null`) and the result of
       *   the function's execution. The remaining parameters name other tasks on
       *   which the task is dependent, and the results from those tasks are the
       *   arguments of those parameters.
       * @param {Function} [callback] - An optional callback which is called when all
       * the tasks have been completed. It receives the `err` argument if any `tasks`
       * pass an error to their callback, and a `results` object with any completed
       * task results, similar to `auto`.
       * @returns {Promise} a promise, if no callback is passed
       * @example
       *
       * //  The example from `auto` can be rewritten as follows:
       * async.autoInject({
       *     get_data: function(callback) {
       *         // async code to get some data
       *         callback(null, 'data', 'converted to array');
       *     },
       *     make_folder: function(callback) {
       *         // async code to create a directory to store a file in
       *         // this is run at the same time as getting the data
       *         callback(null, 'folder');
       *     },
       *     write_file: function(get_data, make_folder, callback) {
       *         // once there is some data and the directory exists,
       *         // write the data to a file in the directory
       *         callback(null, 'filename');
       *     },
       *     email_link: function(write_file, callback) {
       *         // once the file is written let's email a link to it...
       *         // write_file contains the filename returned by write_file.
       *         callback(null, {'file':write_file, 'email':'user@example.com'});
       *     }
       * }, function(err, results) {
       *     console.log('err = ', err);
       *     console.log('email_link = ', results.email_link);
       * });
       *
       * // If you are using a JS minifier that mangles parameter names, `autoInject`
       * // will not work with plain functions, since the parameter names will be
       * // collapsed to a single letter identifier.  To work around this, you can
       * // explicitly specify the names of the parameters your task function needs
       * // in an array, similar to Angular.js dependency injection.
       *
       * // This still has an advantage over plain `auto`, since the results a task
       * // depends on are still spread into arguments.
       * async.autoInject({
       *     //...
       *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {
       *         callback(null, 'filename');
       *     }],
       *     email_link: ['write_file', function(write_file, callback) {
       *         callback(null, {'file':write_file, 'email':'user@example.com'});
       *     }]
       *     //...
       * }, function(err, results) {
       *     console.log('err = ', err);
       *     console.log('email_link = ', results.email_link);
       * });
       */
      function autoInject(tasks, callback) {
          var newTasks = {};
  
          Object.keys(tasks).forEach(key => {
              var taskFn = tasks[key];
              var params;
              var fnIsAsync = isAsync(taskFn);
              var hasNoDeps =
                  (!fnIsAsync && taskFn.length === 1) ||
                  (fnIsAsync && taskFn.length === 0);
  
              if (Array.isArray(taskFn)) {
                  params = [...taskFn];
                  taskFn = params.pop();
  
                  newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
              } else if (hasNoDeps) {
                  // no dependencies, use the function as-is
                  newTasks[key] = taskFn;
              } else {
                  params = parseParams(taskFn);
                  if ((taskFn.length === 0 && !fnIsAsync) && params.length === 0) {
                      throw new Error("autoInject task functions require explicit parameters.");
                  }
  
                  // remove callback param
                  if (!fnIsAsync) params.pop();
  
                  newTasks[key] = params.concat(newTask);
              }
  
              function newTask(results, taskCb) {
                  var newArgs = params.map(name => results[name]);
                  newArgs.push(taskCb);
                  wrapAsync(taskFn)(...newArgs);
              }
          });
  
          return auto(newTasks, callback);
      }
  
      // Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation
      // used for queues. This implementation assumes that the node provided by the user can be modified
      // to adjust the next and last properties. We implement only the minimal functionality
      // for queue support.
      class DLL {
          constructor() {
              this.head = this.tail = null;
              this.length = 0;
          }
  
          removeLink(node) {
              if (node.prev) node.prev.next = node.next;
              else this.head = node.next;
              if (node.next) node.next.prev = node.prev;
              else this.tail = node.prev;
  
              node.prev = node.next = null;
              this.length -= 1;
              return node;
          }
  
          empty () {
              while(this.head) this.shift();
              return this;
          }
  
          insertAfter(node, newNode) {
              newNode.prev = node;
              newNode.next = node.next;
              if (node.next) node.next.prev = newNode;
              else this.tail = newNode;
              node.next = newNode;
              this.length += 1;
          }
  
          insertBefore(node, newNode) {
              newNode.prev = node.prev;
              newNode.next = node;
              if (node.prev) node.prev.next = newNode;
              else this.head = newNode;
              node.prev = newNode;
              this.length += 1;
          }
  
          unshift(node) {
              if (this.head) this.insertBefore(this.head, node);
              else setInitial(this, node);
          }
  
          push(node) {
              if (this.tail) this.insertAfter(this.tail, node);
              else setInitial(this, node);
          }
  
          shift() {
              return this.head && this.removeLink(this.head);
          }
  
          pop() {
              return this.tail && this.removeLink(this.tail);
          }
  
          toArray() {
              return [...this]
          }
  
          *[Symbol.iterator] () {
              var cur = this.head;
              while (cur) {
                  yield cur.data;
                  cur = cur.next;
              }
          }
  
          remove (testFn) {
              var curr = this.head;
              while(curr) {
                  var {next} = curr;
                  if (testFn(curr)) {
                      this.removeLink(curr);
                  }
                  curr = next;
              }
              return this;
          }
      }
  
      function setInitial(dll, node) {
          dll.length = 1;
          dll.head = dll.tail = node;
      }
  
      function queue(worker, concurrency, payload) {
          if (concurrency == null) {
              concurrency = 1;
          }
          else if(concurrency === 0) {
              throw new RangeError('Concurrency must not be zero');
          }
  
          var _worker = wrapAsync(worker);
          var numRunning = 0;
          var workersList = [];
          const events = {
              error: [],
              drain: [],
              saturated: [],
              unsaturated: [],
              empty: []
          };
  
          function on (event, handler) {
              events[event].push(handler);
          }
  
          function once (event, handler) {
              const handleAndRemove = (...args) => {
                  off(event, handleAndRemove);
                  handler(...args);
              };
              events[event].push(handleAndRemove);
          }
  
          function off (event, handler) {
              if (!event) return Object.keys(events).forEach(ev => events[ev] = [])
              if (!handler) return events[event] = []
              events[event] = events[event].filter(ev => ev !== handler);
          }
  
          function trigger (event, ...args) {
              events[event].forEach(handler => handler(...args));
          }
  
          var processingScheduled = false;
          function _insert(data, insertAtFront, rejectOnError, callback) {
              if (callback != null && typeof callback !== 'function') {
                  throw new Error('task callback must be a function');
              }
              q.started = true;
  
              var res, rej;
              function promiseCallback (err, ...args) {
                  // we don't care about the error, let the global error handler
                  // deal with it
                  if (err) return rejectOnError ? rej(err) : res()
                  if (args.length <= 1) return res(args[0])
                  res(args);
              }
  
              var item = {
                  data,
                  callback: rejectOnError ?
                      promiseCallback :
                      (callback || promiseCallback)
              };
  
              if (insertAtFront) {
                  q._tasks.unshift(item);
              } else {
                  q._tasks.push(item);
              }
  
              if (!processingScheduled) {
                  processingScheduled = true;
                  setImmediate$1(() => {
                      processingScheduled = false;
                      q.process();
                  });
              }
  
              if (rejectOnError || !callback) {
                  return new Promise((resolve, reject) => {
                      res = resolve;
                      rej = reject;
                  })
              }
          }
  
          function _createCB(tasks) {
              return function (err, ...args) {
                  numRunning -= 1;
  
                  for (var i = 0, l = tasks.length; i < l; i++) {
                      var task = tasks[i];
  
                      var index = workersList.indexOf(task);
                      if (index === 0) {
                          workersList.shift();
                      } else if (index > 0) {
                          workersList.splice(index, 1);
                      }
  
                      task.callback(err, ...args);
  
                      if (err != null) {
                          trigger('error', err, task.data);
                      }
                  }
  
                  if (numRunning <= (q.concurrency - q.buffer) ) {
                      trigger('unsaturated');
                  }
  
                  if (q.idle()) {
                      trigger('drain');
                  }
                  q.process();
              };
          }
  
          function _maybeDrain(data) {
              if (data.length === 0 && q.idle()) {
                  // call drain immediately if there are no tasks
                  setImmediate$1(() => trigger('drain'));
                  return true
              }
              return false
          }
  
          const eventMethod = (name) => (handler) => {
              if (!handler) {
                  return new Promise((resolve, reject) => {
                      once(name, (err, data) => {
                          if (err) return reject(err)
                          resolve(data);
                      });
                  })
              }
              off(name);
              on(name, handler);
  
          };
  
          var isProcessing = false;
          var q = {
              _tasks: new DLL(),
              *[Symbol.iterator] () {
                  yield* q._tasks[Symbol.iterator]();
              },
              concurrency,
              payload,
              buffer: concurrency / 4,
              started: false,
              paused: false,
              push (data, callback) {
                  if (Array.isArray(data)) {
                      if (_maybeDrain(data)) return
                      return data.map(datum => _insert(datum, false, false, callback))
                  }
                  return _insert(data, false, false, callback);
              },
              pushAsync (data, callback) {
                  if (Array.isArray(data)) {
                      if (_maybeDrain(data)) return
                      return data.map(datum => _insert(datum, false, true, callback))
                  }
                  return _insert(data, false, true, callback);
              },
              kill () {
                  off();
                  q._tasks.empty();
              },
              unshift (data, callback) {
                  if (Array.isArray(data)) {
                      if (_maybeDrain(data)) return
                      return data.map(datum => _insert(datum, true, false, callback))
                  }
                  return _insert(data, true, false, callback);
              },
              unshiftAsync (data, callback) {
                  if (Array.isArray(data)) {
                      if (_maybeDrain(data)) return
                      return data.map(datum => _insert(datum, true, true, callback))
                  }
                  return _insert(data, true, true, callback);
              },
              remove (testFn) {
                  q._tasks.remove(testFn);
              },
              process () {
                  // Avoid trying to start too many processing operations. This can occur
                  // when callbacks resolve synchronously (#1267).
                  if (isProcessing) {
                      return;
                  }
                  isProcessing = true;
                  while(!q.paused && numRunning < q.concurrency && q._tasks.length){
                      var tasks = [], data = [];
                      var l = q._tasks.length;
                      if (q.payload) l = Math.min(l, q.payload);
                      for (var i = 0; i < l; i++) {
                          var node = q._tasks.shift();
                          tasks.push(node);
                          workersList.push(node);
                          data.push(node.data);
                      }
  
                      numRunning += 1;
  
                      if (q._tasks.length === 0) {
                          trigger('empty');
                      }
  
                      if (numRunning === q.concurrency) {
                          trigger('saturated');
                      }
  
                      var cb = onlyOnce(_createCB(tasks));
                      _worker(data, cb);
                  }
                  isProcessing = false;
              },
              length () {
                  return q._tasks.length;
              },
              running () {
                  return numRunning;
              },
              workersList () {
                  return workersList;
              },
              idle() {
                  return q._tasks.length + numRunning === 0;
              },
              pause () {
                  q.paused = true;
              },
              resume () {
                  if (q.paused === false) { return; }
                  q.paused = false;
                  setImmediate$1(q.process);
              }
          };
          // define these as fixed properties, so people get useful errors when updating
          Object.defineProperties(q, {
              saturated: {
                  writable: false,
                  value: eventMethod('saturated')
              },
              unsaturated: {
                  writable: false,
                  value: eventMethod('unsaturated')
              },
              empty: {
                  writable: false,
                  value: eventMethod('empty')
              },
              drain: {
                  writable: false,
                  value: eventMethod('drain')
              },
              error: {
                  writable: false,
                  value: eventMethod('error')
              },
          });
          return q;
      }
  
      /**
       * Creates a `cargo` object with the specified payload. Tasks added to the
       * cargo will be processed altogether (up to the `payload` limit). If the
       * `worker` is in progress, the task is queued until it becomes available. Once
       * the `worker` has completed some tasks, each callback of those tasks is
       * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)
       * for how `cargo` and `queue` work.
       *
       * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers
       * at a time, cargo passes an array of tasks to a single worker, repeating
       * when the worker is finished.
       *
       * @name cargo
       * @static
       * @memberOf module:ControlFlow
       * @method
       * @see [async.queue]{@link module:ControlFlow.queue}
       * @category Control Flow
       * @param {AsyncFunction} worker - An asynchronous function for processing an array
       * of queued tasks. Invoked with `(tasks, callback)`.
       * @param {number} [payload=Infinity] - An optional `integer` for determining
       * how many tasks should be processed per round; if omitted, the default is
       * unlimited.
       * @returns {module:ControlFlow.QueueObject} A cargo object to manage the tasks. Callbacks can
       * attached as certain properties to listen for specific events during the
       * lifecycle of the cargo and inner queue.
       * @example
       *
       * // create a cargo object with payload 2
       * var cargo = async.cargo(function(tasks, callback) {
       *     for (var i=0; i<tasks.length; i++) {
       *         console.log('hello ' + tasks[i].name);
       *     }
       *     callback();
       * }, 2);
       *
       * // add some items
       * cargo.push({name: 'foo'}, function(err) {
       *     console.log('finished processing foo');
       * });
       * cargo.push({name: 'bar'}, function(err) {
       *     console.log('finished processing bar');
       * });
       * await cargo.push({name: 'baz'});
       * console.log('finished processing baz');
       */
      function cargo(worker, payload) {
          return queue(worker, 1, payload);
      }
  
      /**
       * Creates a `cargoQueue` object with the specified payload. Tasks added to the
       * cargoQueue will be processed together (up to the `payload` limit) in `concurrency` parallel workers.
       * If the all `workers` are in progress, the task is queued until one becomes available. Once
       * a `worker` has completed some tasks, each callback of those tasks is
       * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)
       * for how `cargo` and `queue` work.
       *
       * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers
       * at a time, and [`cargo`]{@link module:ControlFlow.cargo} passes an array of tasks to a single worker,
       * the cargoQueue passes an array of tasks to multiple parallel workers.
       *
       * @name cargoQueue
       * @static
       * @memberOf module:ControlFlow
       * @method
       * @see [async.queue]{@link module:ControlFlow.queue}
       * @see [async.cargo]{@link module:ControlFLow.cargo}
       * @category Control Flow
       * @param {AsyncFunction} worker - An asynchronous function for processing an array
       * of queued tasks. Invoked with `(tasks, callback)`.
       * @param {number} [concurrency=1] - An `integer` for determining how many
       * `worker` functions should be run in parallel.  If omitted, the concurrency
       * defaults to `1`.  If the concurrency is `0`, an error is thrown.
       * @param {number} [payload=Infinity] - An optional `integer` for determining
       * how many tasks should be processed per round; if omitted, the default is
       * unlimited.
       * @returns {module:ControlFlow.QueueObject} A cargoQueue object to manage the tasks. Callbacks can
       * attached as certain properties to listen for specific events during the
       * lifecycle of the cargoQueue and inner queue.
       * @example
       *
       * // create a cargoQueue object with payload 2 and concurrency 2
       * var cargoQueue = async.cargoQueue(function(tasks, callback) {
       *     for (var i=0; i<tasks.length; i++) {
       *         console.log('hello ' + tasks[i].name);
       *     }
       *     callback();
       * }, 2, 2);
       *
       * // add some items
       * cargoQueue.push({name: 'foo'}, function(err) {
       *     console.log('finished processing foo');
       * });
       * cargoQueue.push({name: 'bar'}, function(err) {
       *     console.log('finished processing bar');
       * });
       * cargoQueue.push({name: 'baz'}, function(err) {
       *     console.log('finished processing baz');
       * });
       * cargoQueue.push({name: 'boo'}, function(err) {
       *     console.log('finished processing boo');
       * });
       */
      function cargo$1(worker, concurrency, payload) {
          return queue(worker, concurrency, payload);
      }
  
      /**
       * Reduces `coll` into a single value using an async `iteratee` to return each
       * successive step. `memo` is the initial state of the reduction. This function
       * only operates in series.
       *
       * For performance reasons, it may make sense to split a call to this function
       * into a parallel map, and then use the normal `Array.prototype.reduce` on the
       * results. This function is for situations where each step in the reduction
       * needs to be async; if you can get the data before reducing it, then it's
       * probably a good idea to do so.
       *
       * @name reduce
       * @static
       * @memberOf module:Collections
       * @method
       * @alias inject
       * @alias foldl
       * @category Collection
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {*} memo - The initial state of the reduction.
       * @param {AsyncFunction} iteratee - A function applied to each item in the
       * array to produce the next step in the reduction.
       * The `iteratee` should complete with the next state of the reduction.
       * If the iteratee complete with an error, the reduction is stopped and the
       * main `callback` is immediately called with the error.
       * Invoked with (memo, item, callback).
       * @param {Function} [callback] - A callback which is called after all the
       * `iteratee` functions have finished. Result is the reduced value. Invoked with
       * (err, result).
       * @returns {Promise} a promise, if no callback is passed
       * @example
       *
       * async.reduce([1,2,3], 0, function(memo, item, callback) {
       *     // pointless async:
       *     process.nextTick(function() {
       *         callback(null, memo + item)
       *     });
       * }, function(err, result) {
       *     // result is now equal to the last value of memo, which is 6
       * });
       */
      function reduce(coll, memo, iteratee, callback) {
          callback = once(callback);
          var _iteratee = wrapAsync(iteratee);
          return eachOfSeries$1(coll, (x, i, iterCb) => {
              _iteratee(memo, x, (err, v) => {
                  memo = v;
                  iterCb(err);
              });
          }, err => callback(err, memo));
      }
      var reduce$1 = awaitify(reduce, 4);
  
      /**
       * Version of the compose function that is more natural to read. Each function
       * consumes the return value of the previous function. It is the equivalent of
       * [compose]{@link module:ControlFlow.compose} with the arguments reversed.
       *
       * Each function is executed with the `this` binding of the composed function.
       *
       * @name seq
       * @static
       * @memberOf module:ControlFlow
       * @method
       * @see [async.compose]{@link module:ControlFlow.compose}
       * @category Control Flow
       * @param {...AsyncFunction} functions - the asynchronous functions to compose
       * @returns {Function} a function that composes the `functions` in order
       * @example
       *
       * // Requires lodash (or underscore), express3 and dresende's orm2.
       * // Part of an app, that fetches cats of the logged user.
       * // This example uses `seq` function to avoid overnesting and error
       * // handling clutter.
       * app.get('/cats', function(request, response) {
       *     var User = request.models.User;
       *     async.seq(
       *         _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))
       *         function(user, fn) {
       *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))
       *         }
       *     )(req.session.user_id, function (err, cats) {
       *         if (err) {
       *             console.error(err);
       *             response.json({ status: 'error', message: err.message });
       *         } else {
       *             response.json({ status: 'ok', message: 'Cats found', data: cats });
       *         }
       *     });
       * });
       */
      function seq(...functions) {
          var _functions = functions.map(wrapAsync);
          return function (...args) {
              var that = this;
  
              var cb = args[args.length - 1];
              if (typeof cb == 'function') {
                  args.pop();
              } else {
                  cb = promiseCallback();
              }
  
              reduce$1(_functions, args, (newargs, fn, iterCb) => {
                  fn.apply(that, newargs.concat((err, ...nextargs) => {
                      iterCb(err, nextargs);
                  }));
              },
              (err, results) => cb(err, ...results));
  
              return cb[PROMISE_SYMBOL]
          };
      }
  
      /**
       * Creates a function which is a composition of the passed asynchronous
       * functions. Each function consumes the return value of the function that
       * follows. Composing functions `f()`, `g()`, and `h()` would produce the result
       * of `f(g(h()))`, only this version uses callbacks to obtain the return values.
       *
       * If the last argument to the composed function is not a function, a promise
       * is returned when you call it.
       *
       * Each function is executed with the `this` binding of the composed function.
       *
       * @name compose
       * @static
       * @memberOf module:ControlFlow
       * @method
       * @category Control Flow
       * @param {...AsyncFunction} functions - the asynchronous functions to compose
       * @returns {Function} an asynchronous function that is the composed
       * asynchronous `functions`
       * @example
       *
       * function add1(n, callback) {
       *     setTimeout(function () {
       *         callback(null, n + 1);
       *     }, 10);
       * }
       *
       * function mul3(n, callback) {
       *     setTimeout(function () {
       *         callback(null, n * 3);
       *     }, 10);
       * }
       *
       * var add1mul3 = async.compose(mul3, add1);
       * add1mul3(4, function (err, result) {
       *     // result now equals 15
       * });
       */
      function compose(...args) {
          return seq(...args.reverse());
      }
  
      /**
       * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.
       *
       * @name mapLimit
       * @static
       * @memberOf module:Collections
       * @method
       * @see [async.map]{@link module:Collections.map}
       * @category Collection
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {number} limit - The maximum number of async operations at a time.
       * @param {AsyncFunction} iteratee - An async function to apply to each item in
       * `coll`.
       * The iteratee should complete with the transformed item.
       * Invoked with (item, callback).
       * @param {Function} [callback] - A callback which is called when all `iteratee`
       * functions have finished, or an error occurs. Results is an array of the
       * transformed items from the `coll`. Invoked with (err, results).
       * @returns {Promise} a promise, if no callback is passed
       */
      function mapLimit (coll, limit, iteratee, callback) {
          return _asyncMap(eachOfLimit(limit), coll, iteratee, callback)
      }
      var mapLimit$1 = awaitify(mapLimit, 4);
  
      /**
       * The same as [`concat`]{@link module:Collections.concat} but runs a maximum of `limit` async operations at a time.
       *
       * @name concatLimit
       * @static
       * @memberOf module:Collections
       * @method
       * @see [async.concat]{@link module:Collections.concat}
       * @category Collection
       * @alias flatMapLimit
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {number} limit - The maximum number of async operations at a time.
       * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,
       * which should use an array as its result. Invoked with (item, callback).
       * @param {Function} [callback] - A callback which is called after all the
       * `iteratee` functions have finished, or an error occurs. Results is an array
       * containing the concatenated results of the `iteratee` function. Invoked with
       * (err, results).
       * @returns A Promise, if no callback is passed
       */
      function concatLimit(coll, limit, iteratee, callback) {
          var _iteratee = wrapAsync(iteratee);
          return mapLimit$1(coll, limit, (val, iterCb) => {
              _iteratee(val, (err, ...args) => {
                  if (err) return iterCb(err);
                  return iterCb(err, args);
              });
          }, (err, mapResults) => {
              var result = [];
              for (var i = 0; i < mapResults.length; i++) {
                  if (mapResults[i]) {
                      result = result.concat(...mapResults[i]);
                  }
              }
  
              return callback(err, result);
          });
      }
      var concatLimit$1 = awaitify(concatLimit, 4);
  
      /**
       * Applies `iteratee` to each item in `coll`, concatenating the results. Returns
       * the concatenated list. The `iteratee`s are called in parallel, and the
       * results are concatenated as they return. The results array will be returned in
       * the original order of `coll` passed to the `iteratee` function.
       *
       * @name concat
       * @static
       * @memberOf module:Collections
       * @method
       * @category Collection
       * @alias flatMap
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,
       * which should use an array as its result. Invoked with (item, callback).
       * @param {Function} [callback] - A callback which is called after all the
       * `iteratee` functions have finished, or an error occurs. Results is an array
       * containing the concatenated results of the `iteratee` function. Invoked with
       * (err, results).
       * @returns A Promise, if no callback is passed
       * @example
       *
       * async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files) {
       *     // files is now a list of filenames that exist in the 3 directories
       * });
       */
      function concat(coll, iteratee, callback) {
          return concatLimit$1(coll, Infinity, iteratee, callback)
      }
      var concat$1 = awaitify(concat, 3);
  
      /**
       * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.
       *
       * @name concatSeries
       * @static
       * @memberOf module:Collections
       * @method
       * @see [async.concat]{@link module:Collections.concat}
       * @category Collection
       * @alias flatMapSeries
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`.
       * The iteratee should complete with an array an array of results.
       * Invoked with (item, callback).
       * @param {Function} [callback] - A callback which is called after all the
       * `iteratee` functions have finished, or an error occurs. Results is an array
       * containing the concatenated results of the `iteratee` function. Invoked with
       * (err, results).
       * @returns A Promise, if no callback is passed
       */
      function concatSeries(coll, iteratee, callback) {
          return concatLimit$1(coll, 1, iteratee, callback)
      }
      var concatSeries$1 = awaitify(concatSeries, 3);
  
      /**
       * Returns a function that when called, calls-back with the values provided.
       * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to
       * [`auto`]{@link module:ControlFlow.auto}.
       *
       * @name constant
       * @static
       * @memberOf module:Utils
       * @method
       * @category Util
       * @param {...*} arguments... - Any number of arguments to automatically invoke
       * callback with.
       * @returns {AsyncFunction} Returns a function that when invoked, automatically
       * invokes the callback with the previous given arguments.
       * @example
       *
       * async.waterfall([
       *     async.constant(42),
       *     function (value, next) {
       *         // value === 42
       *     },
       *     //...
       * ], callback);
       *
       * async.waterfall([
       *     async.constant(filename, "utf8"),
       *     fs.readFile,
       *     function (fileData, next) {
       *         //...
       *     }
       *     //...
       * ], callback);
       *
       * async.auto({
       *     hostname: async.constant("https://server.net/"),
       *     port: findFreePort,
       *     launchServer: ["hostname", "port", function (options, cb) {
       *         startServer(options, cb);
       *     }],
       *     //...
       * }, callback);
       */
      function constant(...args) {
          return function (...ignoredArgs/*, callback*/) {
              var callback = ignoredArgs.pop();
              return callback(null, ...args);
          };
      }
  
      function _createTester(check, getResult) {
          return (eachfn, arr, _iteratee, cb) => {
              var testPassed = false;
              var testResult;
              const iteratee = wrapAsync(_iteratee);
              eachfn(arr, (value, _, callback) => {
                  iteratee(value, (err, result) => {
                      if (err || err === false) return callback(err);
  
                      if (check(result) && !testResult) {
                          testPassed = true;
                          testResult = getResult(true, value);
                          return callback(null, breakLoop);
                      }
                      callback();
                  });
              }, err => {
                  if (err) return cb(err);
                  cb(null, testPassed ? testResult : getResult(false));
              });
          };
      }
  
      /**
       * Returns the first value in `coll` that passes an async truth test. The
       * `iteratee` is applied in parallel, meaning the first iteratee to return
       * `true` will fire the detect `callback` with that result. That means the
       * result might not be the first item in the original `coll` (in terms of order)
       * that passes the test.
  
       * If order within the original `coll` is important, then look at
       * [`detectSeries`]{@link module:Collections.detectSeries}.
       *
       * @name detect
       * @static
       * @memberOf module:Collections
       * @method
       * @alias find
       * @category Collections
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
       * The iteratee must complete with a boolean value as its result.
       * Invoked with (item, callback).
       * @param {Function} [callback] - A callback which is called as soon as any
       * iteratee returns `true`, or after all the `iteratee` functions have finished.
       * Result will be the first item in the array that passes the truth test
       * (iteratee) or the value `undefined` if none passed. Invoked with
       * (err, result).
       * @returns A Promise, if no callback is passed
       * @example
       *
       * async.detect(['file1','file2','file3'], function(filePath, callback) {
       *     fs.access(filePath, function(err) {
       *         callback(null, !err)
       *     });
       * }, function(err, result) {
       *     // result now equals the first file in the list that exists
       * });
       */
      function detect(coll, iteratee, callback) {
          return _createTester(bool => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback)
      }
      var detect$1 = awaitify(detect, 3);
  
      /**
       * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a
       * time.
       *
       * @name detectLimit
       * @static
       * @memberOf module:Collections
       * @method
       * @see [async.detect]{@link module:Collections.detect}
       * @alias findLimit
       * @category Collections
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {number} limit - The maximum number of async operations at a time.
       * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
       * The iteratee must complete with a boolean value as its result.
       * Invoked with (item, callback).
       * @param {Function} [callback] - A callback which is called as soon as any
       * iteratee returns `true`, or after all the `iteratee` functions have finished.
       * Result will be the first item in the array that passes the truth test
       * (iteratee) or the value `undefined` if none passed. Invoked with
       * (err, result).
       * @returns a Promise if no callback is passed
       */
      function detectLimit(coll, limit, iteratee, callback) {
          return _createTester(bool => bool, (res, item) => item)(eachOfLimit(limit), coll, iteratee, callback)
      }
      var detectLimit$1 = awaitify(detectLimit, 4);
  
      /**
       * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.
       *
       * @name detectSeries
       * @static
       * @memberOf module:Collections
       * @method
       * @see [async.detect]{@link module:Collections.detect}
       * @alias findSeries
       * @category Collections
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
       * The iteratee must complete with a boolean value as its result.
       * Invoked with (item, callback).
       * @param {Function} [callback] - A callback which is called as soon as any
       * iteratee returns `true`, or after all the `iteratee` functions have finished.
       * Result will be the first item in the array that passes the truth test
       * (iteratee) or the value `undefined` if none passed. Invoked with
       * (err, result).
       * @returns a Promise if no callback is passed
       */
      function detectSeries(coll, iteratee, callback) {
          return _createTester(bool => bool, (res, item) => item)(eachOfLimit(1), coll, iteratee, callback)
      }
  
      var detectSeries$1 = awaitify(detectSeries, 3);
  
      function consoleFunc(name) {
          return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {
              if (typeof console === 'object') {
                  if (err) {
                      if (console.error) {
                          console.error(err);
                      }
                  } else if (console[name]) {
                      resultArgs.forEach(x => console[name](x));
                  }
              }
          })
      }
  
      /**
       * Logs the result of an [`async` function]{@link AsyncFunction} to the
       * `console` using `console.dir` to display the properties of the resulting object.
       * Only works in Node.js or in browsers that support `console.dir` and
       * `console.error` (such as FF and Chrome).
       * If multiple arguments are returned from the async function,
       * `console.dir` is called on each argument in order.
       *
       * @name dir
       * @static
       * @memberOf module:Utils
       * @method
       * @category Util
       * @param {AsyncFunction} function - The function you want to eventually apply
       * all arguments to.
       * @param {...*} arguments... - Any number of arguments to apply to the function.
       * @example
       *
       * // in a module
       * var hello = function(name, callback) {
       *     setTimeout(function() {
       *         callback(null, {hello: name});
       *     }, 1000);
       * };
       *
       * // in the node repl
       * node> async.dir(hello, 'world');
       * {hello: 'world'}
       */
      var dir = consoleFunc('dir');
  
      /**
       * The post-check version of [`whilst`]{@link module:ControlFlow.whilst}. To reflect the difference in
       * the order of operations, the arguments `test` and `iteratee` are switched.
       *
       * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.
       *
       * @name doWhilst
       * @static
       * @memberOf module:ControlFlow
       * @method
       * @see [async.whilst]{@link module:ControlFlow.whilst}
       * @category Control Flow
       * @param {AsyncFunction} iteratee - A function which is called each time `test`
       * passes. Invoked with (callback).
       * @param {AsyncFunction} test - asynchronous truth test to perform after each
       * execution of `iteratee`. Invoked with (...args, callback), where `...args` are the
       * non-error args from the previous callback of `iteratee`.
       * @param {Function} [callback] - A callback which is called after the test
       * function has failed and repeated execution of `iteratee` has stopped.
       * `callback` will be passed an error and any arguments passed to the final
       * `iteratee`'s callback. Invoked with (err, [results]);
       * @returns {Promise} a promise, if no callback is passed
       */
      function doWhilst(iteratee, test, callback) {
          callback = onlyOnce(callback);
          var _fn = wrapAsync(iteratee);
          var _test = wrapAsync(test);
          var results;
  
          function next(err, ...args) {
              if (err) return callback(err);
              if (err === false) return;
              results = args;
              _test(...args, check);
          }
  
          function check(err, truth) {
              if (err) return callback(err);
              if (err === false) return;
              if (!truth) return callback(null, ...results);
              _fn(next);
          }
  
          return check(null, true);
      }
  
      var doWhilst$1 = awaitify(doWhilst, 3);
  
      /**
       * Like ['doWhilst']{@link module:ControlFlow.doWhilst}, except the `test` is inverted. Note the
       * argument ordering differs from `until`.
       *
       * @name doUntil
       * @static
       * @memberOf module:ControlFlow
       * @method
       * @see [async.doWhilst]{@link module:ControlFlow.doWhilst}
       * @category Control Flow
       * @param {AsyncFunction} iteratee - An async function which is called each time
       * `test` fails. Invoked with (callback).
       * @param {AsyncFunction} test - asynchronous truth test to perform after each
       * execution of `iteratee`. Invoked with (...args, callback), where `...args` are the
       * non-error args from the previous callback of `iteratee`
       * @param {Function} [callback] - A callback which is called after the test
       * function has passed and repeated execution of `iteratee` has stopped. `callback`
       * will be passed an error and any arguments passed to the final `iteratee`'s
       * callback. Invoked with (err, [results]);
       * @returns {Promise} a promise, if no callback is passed
       */
      function doUntil(iteratee, test, callback) {
          const _test = wrapAsync(test);
          return doWhilst$1(iteratee, (...args) => {
              const cb = args.pop();
              _test(...args, (err, truth) => cb (err, !truth));
          }, callback);
      }
  
      function _withoutIndex(iteratee) {
          return (value, index, callback) => iteratee(value, callback);
      }
  
      /**
       * Applies the function `iteratee` to each item in `coll`, in parallel.
       * The `iteratee` is called with an item from the list, and a callback for when
       * it has finished. If the `iteratee` passes an error to its `callback`, the
       * main `callback` (for the `each` function) is immediately called with the
       * error.
       *
       * Note, that since this function applies `iteratee` to each item in parallel,
       * there is no guarantee that the iteratee functions will complete in order.
       *
       * @name each
       * @static
       * @memberOf module:Collections
       * @method
       * @alias forEach
       * @category Collection
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {AsyncFunction} iteratee - An async function to apply to
       * each item in `coll`. Invoked with (item, callback).
       * The array index is not passed to the iteratee.
       * If you need the index, use `eachOf`.
       * @param {Function} [callback] - A callback which is called when all
       * `iteratee` functions have finished, or an error occurs. Invoked with (err).
       * @returns {Promise} a promise, if a callback is omitted
       * @example
       *
       * // assuming openFiles is an array of file names and saveFile is a function
       * // to save the modified contents of that file:
       *
       * async.each(openFiles, saveFile, function(err){
       *   // if any of the saves produced an error, err would equal that error
       * });
       *
       * // assuming openFiles is an array of file names
       * async.each(openFiles, function(file, callback) {
       *
       *     // Perform operation on file here.
       *     console.log('Processing file ' + file);
       *
       *     if( file.length > 32 ) {
       *       console.log('This file name is too long');
       *       callback('File name too long');
       *     } else {
       *       // Do work to process file here
       *       console.log('File processed');
       *       callback();
       *     }
       * }, function(err) {
       *     // if any of the file processing produced an error, err would equal that error
       *     if( err ) {
       *       // One of the iterations produced an error.
       *       // All processing will now stop.
       *       console.log('A file failed to process');
       *     } else {
       *       console.log('All files have been processed successfully');
       *     }
       * });
       */
      function eachLimit(coll, iteratee, callback) {
          return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
      }
  
      var each = awaitify(eachLimit, 3);
  
      /**
       * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.
       *
       * @name eachLimit
       * @static
       * @memberOf module:Collections
       * @method
       * @see [async.each]{@link module:Collections.each}
       * @alias forEachLimit
       * @category Collection
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {number} limit - The maximum number of async operations at a time.
       * @param {AsyncFunction} iteratee - An async function to apply to each item in
       * `coll`.
       * The array index is not passed to the iteratee.
       * If you need the index, use `eachOfLimit`.
       * Invoked with (item, callback).
       * @param {Function} [callback] - A callback which is called when all
       * `iteratee` functions have finished, or an error occurs. Invoked with (err).
       * @returns {Promise} a promise, if a callback is omitted
       */
      function eachLimit$1(coll, limit, iteratee, callback) {
          return eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
      }
      var eachLimit$2 = awaitify(eachLimit$1, 4);
  
      /**
       * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.
       *
       * Note, that unlike [`each`]{@link module:Collections.each}, this function applies iteratee to each item
       * in series and therefore the iteratee functions will complete in order.
  
       * @name eachSeries
       * @static
       * @memberOf module:Collections
       * @method
       * @see [async.each]{@link module:Collections.each}
       * @alias forEachSeries
       * @category Collection
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {AsyncFunction} iteratee - An async function to apply to each
       * item in `coll`.
       * The array index is not passed to the iteratee.
       * If you need the index, use `eachOfSeries`.
       * Invoked with (item, callback).
       * @param {Function} [callback] - A callback which is called when all
       * `iteratee` functions have finished, or an error occurs. Invoked with (err).
       * @returns {Promise} a promise, if a callback is omitted
       */
      function eachSeries(coll, iteratee, callback) {
          return eachLimit$2(coll, 1, iteratee, callback)
      }
      var eachSeries$1 = awaitify(eachSeries, 3);
  
      /**
       * Wrap an async function and ensure it calls its callback on a later tick of
       * the event loop.  If the function already calls its callback on a next tick,
       * no extra deferral is added. This is useful for preventing stack overflows
       * (`RangeError: Maximum call stack size exceeded`) and generally keeping
       * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)
       * contained. ES2017 `async` functions are returned as-is -- they are immune
       * to Zalgo's corrupting influences, as they always resolve on a later tick.
       *
       * @name ensureAsync
       * @static
       * @memberOf module:Utils
       * @method
       * @category Util
       * @param {AsyncFunction} fn - an async function, one that expects a node-style
       * callback as its last argument.
       * @returns {AsyncFunction} Returns a wrapped function with the exact same call
       * signature as the function passed in.
       * @example
       *
       * function sometimesAsync(arg, callback) {
       *     if (cache[arg]) {
       *         return callback(null, cache[arg]); // this would be synchronous!!
       *     } else {
       *         doSomeIO(arg, callback); // this IO would be asynchronous
       *     }
       * }
       *
       * // this has a risk of stack overflows if many results are cached in a row
       * async.mapSeries(args, sometimesAsync, done);
       *
       * // this will defer sometimesAsync's callback if necessary,
       * // preventing stack overflows
       * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);
       */
      function ensureAsync(fn) {
          if (isAsync(fn)) return fn;
          return function (...args/*, callback*/) {
              var callback = args.pop();
              var sync = true;
              args.push((...innerArgs) => {
                  if (sync) {
                      setImmediate$1(() => callback(...innerArgs));
                  } else {
                      callback(...innerArgs);
                  }
              });
              fn.apply(this, args);
              sync = false;
          };
      }
  
      /**
       * Returns `true` if every element in `coll` satisfies an async test. If any
       * iteratee call returns `false`, the main `callback` is immediately called.
       *
       * @name every
       * @static
       * @memberOf module:Collections
       * @method
       * @alias all
       * @category Collection
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {AsyncFunction} iteratee - An async truth test to apply to each item
       * in the collection in parallel.
       * The iteratee must complete with a boolean result value.
       * Invoked with (item, callback).
       * @param {Function} [callback] - A callback which is called after all the
       * `iteratee` functions have finished. Result will be either `true` or `false`
       * depending on the values of the async tests. Invoked with (err, result).
       * @returns {Promise} a promise, if no callback provided
       * @example
       *
       * async.every(['file1','file2','file3'], function(filePath, callback) {
       *     fs.access(filePath, function(err) {
       *         callback(null, !err)
       *     });
       * }, function(err, result) {
       *     // if result is true then every file exists
       * });
       */
      function every(coll, iteratee, callback) {
          return _createTester(bool => !bool, res => !res)(eachOf$1, coll, iteratee, callback)
      }
      var every$1 = awaitify(every, 3);
  
      /**
       * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.
       *
       * @name everyLimit
       * @static
       * @memberOf module:Collections
       * @method
       * @see [async.every]{@link module:Collections.every}
       * @alias allLimit
       * @category Collection
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {number} limit - The maximum number of async operations at a time.
       * @param {AsyncFunction} iteratee - An async truth test to apply to each item
       * in the collection in parallel.
       * The iteratee must complete with a boolean result value.
       * Invoked with (item, callback).
       * @param {Function} [callback] - A callback which is called after all the
       * `iteratee` functions have finished. Result will be either `true` or `false`
       * depending on the values of the async tests. Invoked with (err, result).
       * @returns {Promise} a promise, if no callback provided
       */
      function everyLimit(coll, limit, iteratee, callback) {
          return _createTester(bool => !bool, res => !res)(eachOfLimit(limit), coll, iteratee, callback)
      }
      var everyLimit$1 = awaitify(everyLimit, 4);
  
      /**
       * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.
       *
       * @name everySeries
       * @static
       * @memberOf module:Collections
       * @method
       * @see [async.every]{@link module:Collections.every}
       * @alias allSeries
       * @category Collection
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {AsyncFunction} iteratee - An async truth test to apply to each item
       * in the collection in series.
       * The iteratee must complete with a boolean result value.
       * Invoked with (item, callback).
       * @param {Function} [callback] - A callback which is called after all the
       * `iteratee` functions have finished. Result will be either `true` or `false`
       * depending on the values of the async tests. Invoked with (err, result).
       * @returns {Promise} a promise, if no callback provided
       */
      function everySeries(coll, iteratee, callback) {
          return _createTester(bool => !bool, res => !res)(eachOfSeries$1, coll, iteratee, callback)
      }
      var everySeries$1 = awaitify(everySeries, 3);
  
      function filterArray(eachfn, arr, iteratee, callback) {
          var truthValues = new Array(arr.length);
          eachfn(arr, (x, index, iterCb) => {
              iteratee(x, (err, v) => {
                  truthValues[index] = !!v;
                  iterCb(err);
              });
          }, err => {
              if (err) return callback(err);
              var results = [];
              for (var i = 0; i < arr.length; i++) {
                  if (truthValues[i]) results.push(arr[i]);
              }
              callback(null, results);
          });
      }
  
      function filterGeneric(eachfn, coll, iteratee, callback) {
          var results = [];
          eachfn(coll, (x, index, iterCb) => {
              iteratee(x, (err, v) => {
                  if (err) return iterCb(err);
                  if (v) {
                      results.push({index, value: x});
                  }
                  iterCb(err);
              });
          }, err => {
              if (err) return callback(err);
              callback(null, results
                  .sort((a, b) => a.index - b.index)
                  .map(v => v.value));
          });
      }
  
      function _filter(eachfn, coll, iteratee, callback) {
          var filter = isArrayLike(coll) ? filterArray : filterGeneric;
          return filter(eachfn, coll, wrapAsync(iteratee), callback);
      }
  
      /**
       * Returns a new array of all the values in `coll` which pass an async truth
       * test. This operation is performed in parallel, but the results array will be
       * in the same order as the original.
       *
       * @name filter
       * @static
       * @memberOf module:Collections
       * @method
       * @alias select
       * @category Collection
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {Function} iteratee - A truth test to apply to each item in `coll`.
       * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
       * with a boolean argument once it has completed. Invoked with (item, callback).
       * @param {Function} [callback] - A callback which is called after all the
       * `iteratee` functions have finished. Invoked with (err, results).
       * @returns {Promise} a promise, if no callback provided
       * @example
       *
       * async.filter(['file1','file2','file3'], function(filePath, callback) {
       *     fs.access(filePath, function(err) {
       *         callback(null, !err)
       *     });
       * }, function(err, results) {
       *     // results now equals an array of the existing files
       * });
       */
      function filter (coll, iteratee, callback) {
          return _filter(eachOf$1, coll, iteratee, callback)
      }
      var filter$1 = awaitify(filter, 3);
  
      /**
       * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a
       * time.
       *
       * @name filterLimit
       * @static
       * @memberOf module:Collections
       * @method
       * @see [async.filter]{@link module:Collections.filter}
       * @alias selectLimit
       * @category Collection
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {number} limit - The maximum number of async operations at a time.
       * @param {Function} iteratee - A truth test to apply to each item in `coll`.
       * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
       * with a boolean argument once it has completed. Invoked with (item, callback).
       * @param {Function} [callback] - A callback which is called after all the
       * `iteratee` functions have finished. Invoked with (err, results).
       * @returns {Promise} a promise, if no callback provided
       */
      function filterLimit (coll, limit, iteratee, callback) {
          return _filter(eachOfLimit(limit), coll, iteratee, callback)
      }
      var filterLimit$1 = awaitify(filterLimit, 4);
  
      /**
       * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.
       *
       * @name filterSeries
       * @static
       * @memberOf module:Collections
       * @method
       * @see [async.filter]{@link module:Collections.filter}
       * @alias selectSeries
       * @category Collection
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {Function} iteratee - A truth test to apply to each item in `coll`.
       * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
       * with a boolean argument once it has completed. Invoked with (item, callback).
       * @param {Function} [callback] - A callback which is called after all the
       * `iteratee` functions have finished. Invoked with (err, results)
       * @returns {Promise} a promise, if no callback provided
       */
      function filterSeries (coll, iteratee, callback) {
          return _filter(eachOfSeries$1, coll, iteratee, callback)
      }
      var filterSeries$1 = awaitify(filterSeries, 3);
  
      /**
       * Calls the asynchronous function `fn` with a callback parameter that allows it
       * to call itself again, in series, indefinitely.
  
       * If an error is passed to the callback then `errback` is called with the
       * error, and execution stops, otherwise it will never be called.
       *
       * @name forever
       * @static
       * @memberOf module:ControlFlow
       * @method
       * @category Control Flow
       * @param {AsyncFunction} fn - an async function to call repeatedly.
       * Invoked with (next).
       * @param {Function} [errback] - when `fn` passes an error to it's callback,
       * this function will be called, and execution stops. Invoked with (err).
       * @returns {Promise} a promise that rejects if an error occurs and an errback
       * is not passed
       * @example
       *
       * async.forever(
       *     function(next) {
       *         // next is suitable for passing to things that need a callback(err [, whatever]);
       *         // it will result in this function being called again.
       *     },
       *     function(err) {
       *         // if next is called with a value in its first parameter, it will appear
       *         // in here as 'err', and execution will stop.
       *     }
       * );
       */
      function forever(fn, errback) {
          var done = onlyOnce(errback);
          var task = wrapAsync(ensureAsync(fn));
  
          function next(err) {
              if (err) return done(err);
              if (err === false) return;
              task(next);
          }
          return next();
      }
      var forever$1 = awaitify(forever, 2);
  
      /**
       * The same as [`groupBy`]{@link module:Collections.groupBy} but runs a maximum of `limit` async operations at a time.
       *
       * @name groupByLimit
       * @static
       * @memberOf module:Collections
       * @method
       * @see [async.groupBy]{@link module:Collections.groupBy}
       * @category Collection
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {number} limit - The maximum number of async operations at a time.
       * @param {AsyncFunction} iteratee - An async function to apply to each item in
       * `coll`.
       * The iteratee should complete with a `key` to group the value under.
       * Invoked with (value, callback).
       * @param {Function} [callback] - A callback which is called when all `iteratee`
       * functions have finished, or an error occurs. Result is an `Object` whoses
       * properties are arrays of values which returned the corresponding key.
       * @returns {Promise} a promise, if no callback is passed
       */
      function groupByLimit(coll, limit, iteratee, callback) {
          var _iteratee = wrapAsync(iteratee);
          return mapLimit$1(coll, limit, (val, iterCb) => {
              _iteratee(val, (err, key) => {
                  if (err) return iterCb(err);
                  return iterCb(err, {key, val});
              });
          }, (err, mapResults) => {
              var result = {};
              // from MDN, handle object having an `hasOwnProperty` prop
              var {hasOwnProperty} = Object.prototype;
  
              for (var i = 0; i < mapResults.length; i++) {
                  if (mapResults[i]) {
                      var {key} = mapResults[i];
                      var {val} = mapResults[i];
  
                      if (hasOwnProperty.call(result, key)) {
                          result[key].push(val);
                      } else {
                          result[key] = [val];
                      }
                  }
              }
  
              return callback(err, result);
          });
      }
  
      var groupByLimit$1 = awaitify(groupByLimit, 4);
  
      /**
       * Returns a new object, where each value corresponds to an array of items, from
       * `coll`, that returned the corresponding key. That is, the keys of the object
       * correspond to the values passed to the `iteratee` callback.
       *
       * Note: Since this function applies the `iteratee` to each item in parallel,
       * there is no guarantee that the `iteratee` functions will complete in order.
       * However, the values for each key in the `result` will be in the same order as
       * the original `coll`. For Objects, the values will roughly be in the order of
       * the original Objects' keys (but this can vary across JavaScript engines).
       *
       * @name groupBy
       * @static
       * @memberOf module:Collections
       * @method
       * @category Collection
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {AsyncFunction} iteratee - An async function to apply to each item in
       * `coll`.
       * The iteratee should complete with a `key` to group the value under.
       * Invoked with (value, callback).
       * @param {Function} [callback] - A callback which is called when all `iteratee`
       * functions have finished, or an error occurs. Result is an `Object` whoses
       * properties are arrays of values which returned the corresponding key.
       * @returns {Promise} a promise, if no callback is passed
       * @example
       *
       * async.groupBy(['userId1', 'userId2', 'userId3'], function(userId, callback) {
       *     db.findById(userId, function(err, user) {
       *         if (err) return callback(err);
       *         return callback(null, user.age);
       *     });
       * }, function(err, result) {
       *     // result is object containing the userIds grouped by age
       *     // e.g. { 30: ['userId1', 'userId3'], 42: ['userId2']};
       * });
       */
      function groupBy (coll, iteratee, callback) {
          return groupByLimit$1(coll, Infinity, iteratee, callback)
      }
  
      /**
       * The same as [`groupBy`]{@link module:Collections.groupBy} but runs only a single async operation at a time.
       *
       * @name groupBySeries
       * @static
       * @memberOf module:Collections
       * @method
       * @see [async.groupBy]{@link module:Collections.groupBy}
       * @category Collection
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {AsyncFunction} iteratee - An async function to apply to each item in
       * `coll`.
       * The iteratee should complete with a `key` to group the value under.
       * Invoked with (value, callback).
       * @param {Function} [callback] - A callback which is called when all `iteratee`
       * functions have finished, or an error occurs. Result is an `Object` whoses
       * properties are arrays of values which returned the corresponding key.
       * @returns {Promise} a promise, if no callback is passed
       */
      function groupBySeries (coll, iteratee, callback) {
          return groupByLimit$1(coll, 1, iteratee, callback)
      }
  
      /**
       * Logs the result of an `async` function to the `console`. Only works in
       * Node.js or in browsers that support `console.log` and `console.error` (such
       * as FF and Chrome). If multiple arguments are returned from the async
       * function, `console.log` is called on each argument in order.
       *
       * @name log
       * @static
       * @memberOf module:Utils
       * @method
       * @category Util
       * @param {AsyncFunction} function - The function you want to eventually apply
       * all arguments to.
       * @param {...*} arguments... - Any number of arguments to apply to the function.
       * @example
       *
       * // in a module
       * var hello = function(name, callback) {
       *     setTimeout(function() {
       *         callback(null, 'hello ' + name);
       *     }, 1000);
       * };
       *
       * // in the node repl
       * node> async.log(hello, 'world');
       * 'hello world'
       */
      var log = consoleFunc('log');
  
      /**
       * The same as [`mapValues`]{@link module:Collections.mapValues} but runs a maximum of `limit` async operations at a
       * time.
       *
       * @name mapValuesLimit
       * @static
       * @memberOf module:Collections
       * @method
       * @see [async.mapValues]{@link module:Collections.mapValues}
       * @category Collection
       * @param {Object} obj - A collection to iterate over.
       * @param {number} limit - The maximum number of async operations at a time.
       * @param {AsyncFunction} iteratee - A function to apply to each value and key
       * in `coll`.
       * The iteratee should complete with the transformed value as its result.
       * Invoked with (value, key, callback).
       * @param {Function} [callback] - A callback which is called when all `iteratee`
       * functions have finished, or an error occurs. `result` is a new object consisting
       * of each key from `obj`, with each transformed value on the right-hand side.
       * Invoked with (err, result).
       * @returns {Promise} a promise, if no callback is passed
       */
      function mapValuesLimit(obj, limit, iteratee, callback) {
          callback = once(callback);
          var newObj = {};
          var _iteratee = wrapAsync(iteratee);
          return eachOfLimit(limit)(obj, (val, key, next) => {
              _iteratee(val, key, (err, result) => {
                  if (err) return next(err);
                  newObj[key] = result;
                  next(err);
              });
          }, err => callback(err, newObj));
      }
  
      var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);
  
      /**
       * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.
       *
       * Produces a new Object by mapping each value of `obj` through the `iteratee`
       * function. The `iteratee` is called each `value` and `key` from `obj` and a
       * callback for when it has finished processing. Each of these callbacks takes
       * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`
       * passes an error to its callback, the main `callback` (for the `mapValues`
       * function) is immediately called with the error.
       *
       * Note, the order of the keys in the result is not guaranteed.  The keys will
       * be roughly in the order they complete, (but this is very engine-specific)
       *
       * @name mapValues
       * @static
       * @memberOf module:Collections
       * @method
       * @category Collection
       * @param {Object} obj - A collection to iterate over.
       * @param {AsyncFunction} iteratee - A function to apply to each value and key
       * in `coll`.
       * The iteratee should complete with the transformed value as its result.
       * Invoked with (value, key, callback).
       * @param {Function} [callback] - A callback which is called when all `iteratee`
       * functions have finished, or an error occurs. `result` is a new object consisting
       * of each key from `obj`, with each transformed value on the right-hand side.
       * Invoked with (err, result).
       * @returns {Promise} a promise, if no callback is passed
       * @example
       *
       * async.mapValues({
       *     f1: 'file1',
       *     f2: 'file2',
       *     f3: 'file3'
       * }, function (file, key, callback) {
       *   fs.stat(file, callback);
       * }, function(err, result) {
       *     // result is now a map of stats for each file, e.g.
       *     // {
       *     //     f1: [stats for file1],
       *     //     f2: [stats for file2],
       *     //     f3: [stats for file3]
       *     // }
       * });
       */
      function mapValues(obj, iteratee, callback) {
          return mapValuesLimit$1(obj, Infinity, iteratee, callback)
      }
  
      /**
       * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.
       *
       * @name mapValuesSeries
       * @static
       * @memberOf module:Collections
       * @method
       * @see [async.mapValues]{@link module:Collections.mapValues}
       * @category Collection
       * @param {Object} obj - A collection to iterate over.
       * @param {AsyncFunction} iteratee - A function to apply to each value and key
       * in `coll`.
       * The iteratee should complete with the transformed value as its result.
       * Invoked with (value, key, callback).
       * @param {Function} [callback] - A callback which is called when all `iteratee`
       * functions have finished, or an error occurs. `result` is a new object consisting
       * of each key from `obj`, with each transformed value on the right-hand side.
       * Invoked with (err, result).
       * @returns {Promise} a promise, if no callback is passed
       */
      function mapValuesSeries(obj, iteratee, callback) {
          return mapValuesLimit$1(obj, 1, iteratee, callback)
      }
  
      /**
       * Caches the results of an async function. When creating a hash to store
       * function results against, the callback is omitted from the hash and an
       * optional hash function can be used.
       *
       * **Note: if the async function errs, the result will not be cached and
       * subsequent calls will call the wrapped function.**
       *
       * If no hash function is specified, the first argument is used as a hash key,
       * which may work reasonably if it is a string or a data type that converts to a
       * distinct string. Note that objects and arrays will not behave reasonably.
       * Neither will cases where the other arguments are significant. In such cases,
       * specify your own hash function.
       *
       * The cache of results is exposed as the `memo` property of the function
       * returned by `memoize`.
       *
       * @name memoize
       * @static
       * @memberOf module:Utils
       * @method
       * @category Util
       * @param {AsyncFunction} fn - The async function to proxy and cache results from.
       * @param {Function} hasher - An optional function for generating a custom hash
       * for storing results. It has all the arguments applied to it apart from the
       * callback, and must be synchronous.
       * @returns {AsyncFunction} a memoized version of `fn`
       * @example
       *
       * var slow_fn = function(name, callback) {
       *     // do something
       *     callback(null, result);
       * };
       * var fn = async.memoize(slow_fn);
       *
       * // fn can now be used as if it were slow_fn
       * fn('some name', function() {
       *     // callback
       * });
       */
      function memoize(fn, hasher = v => v) {
          var memo = Object.create(null);
          var queues = Object.create(null);
          var _fn = wrapAsync(fn);
          var memoized = initialParams((args, callback) => {
              var key = hasher(...args);
              if (key in memo) {
                  setImmediate$1(() => callback(null, ...memo[key]));
              } else if (key in queues) {
                  queues[key].push(callback);
              } else {
                  queues[key] = [callback];
                  _fn(...args, (err, ...resultArgs) => {
                      // #1465 don't memoize if an error occurred
                      if (!err) {
                          memo[key] = resultArgs;
                      }
                      var q = queues[key];
                      delete queues[key];
                      for (var i = 0, l = q.length; i < l; i++) {
                          q[i](err, ...resultArgs);
                      }
                  });
              }
          });
          memoized.memo = memo;
          memoized.unmemoized = fn;
          return memoized;
      }
  
      /**
       * Calls `callback` on a later loop around the event loop. In Node.js this just
       * calls `process.nextTick`.  In the browser it will use `setImmediate` if
       * available, otherwise `setTimeout(callback, 0)`, which means other higher
       * priority events may precede the execution of `callback`.
       *
       * This is used internally for browser-compatibility purposes.
       *
       * @name nextTick
       * @static
       * @memberOf module:Utils
       * @method
       * @see [async.setImmediate]{@link module:Utils.setImmediate}
       * @category Util
       * @param {Function} callback - The function to call on a later loop around
       * the event loop. Invoked with (args...).
       * @param {...*} args... - any number of additional arguments to pass to the
       * callback on the next tick.
       * @example
       *
       * var call_order = [];
       * async.nextTick(function() {
       *     call_order.push('two');
       *     // call_order now equals ['one','two']
       * });
       * call_order.push('one');
       *
       * async.setImmediate(function (a, b, c) {
       *     // a, b, and c equal 1, 2, and 3
       * }, 1, 2, 3);
       */
      var _defer$1;
  
      if (hasNextTick) {
          _defer$1 = process.nextTick;
      } else if (hasSetImmediate) {
          _defer$1 = setImmediate;
      } else {
          _defer$1 = fallback;
      }
  
      var nextTick = wrap(_defer$1);
  
      var parallel = awaitify((eachfn, tasks, callback) => {
          var results = isArrayLike(tasks) ? [] : {};
  
          eachfn(tasks, (task, key, taskCb) => {
              wrapAsync(task)((err, ...result) => {
                  if (result.length < 2) {
                      [result] = result;
                  }
                  results[key] = result;
                  taskCb(err);
              });
          }, err => callback(err, results));
      }, 3);
  
      /**
       * Run the `tasks` collection of functions in parallel, without waiting until
       * the previous function has completed. If any of the functions pass an error to
       * its callback, the main `callback` is immediately called with the value of the
       * error. Once the `tasks` have completed, the results are passed to the final
       * `callback` as an array.
       *
       * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about
       * parallel execution of code.  If your tasks do not use any timers or perform
       * any I/O, they will actually be executed in series.  Any synchronous setup
       * sections for each task will happen one after the other.  JavaScript remains
       * single-threaded.
       *
       * **Hint:** Use [`reflect`]{@link module:Utils.reflect} to continue the
       * execution of other tasks when a task fails.
       *
       * It is also possible to use an object instead of an array. Each property will
       * be run as a function and the results will be passed to the final `callback`
       * as an object instead of an array. This can be a more readable way of handling
       * results from {@link async.parallel}.
       *
       * @name parallel
       * @static
       * @memberOf module:ControlFlow
       * @method
       * @category Control Flow
       * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection of
       * [async functions]{@link AsyncFunction} to run.
       * Each async function can complete with any number of optional `result` values.
       * @param {Function} [callback] - An optional callback to run once all the
       * functions have completed successfully. This function gets a results array
       * (or object) containing all the result arguments passed to the task callbacks.
       * Invoked with (err, results).
       * @returns {Promise} a promise, if a callback is not passed
       *
       * @example
       * async.parallel([
       *     function(callback) {
       *         setTimeout(function() {
       *             callback(null, 'one');
       *         }, 200);
       *     },
       *     function(callback) {
       *         setTimeout(function() {
       *             callback(null, 'two');
       *         }, 100);
       *     }
       * ],
       * // optional callback
       * function(err, results) {
       *     // the results array will equal ['one','two'] even though
       *     // the second function had a shorter timeout.
       * });
       *
       * // an example using an object instead of an array
       * async.parallel({
       *     one: function(callback) {
       *         setTimeout(function() {
       *             callback(null, 1);
       *         }, 200);
       *     },
       *     two: function(callback) {
       *         setTimeout(function() {
       *             callback(null, 2);
       *         }, 100);
       *     }
       * }, function(err, results) {
       *     // results is now equals to: {one: 1, two: 2}
       * });
       */
      function parallel$1(tasks, callback) {
          return parallel(eachOf$1, tasks, callback);
      }
  
      /**
       * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a
       * time.
       *
       * @name parallelLimit
       * @static
       * @memberOf module:ControlFlow
       * @method
       * @see [async.parallel]{@link module:ControlFlow.parallel}
       * @category Control Flow
       * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection of
       * [async functions]{@link AsyncFunction} to run.
       * Each async function can complete with any number of optional `result` values.
       * @param {number} limit - The maximum number of async operations at a time.
       * @param {Function} [callback] - An optional callback to run once all the
       * functions have completed successfully. This function gets a results array
       * (or object) containing all the result arguments passed to the task callbacks.
       * Invoked with (err, results).
       * @returns {Promise} a promise, if a callback is not passed
       */
      function parallelLimit(tasks, limit, callback) {
          return parallel(eachOfLimit(limit), tasks, callback);
      }
  
      /**
       * A queue of tasks for the worker function to complete.
       * @typedef {Iterable} QueueObject
       * @memberOf module:ControlFlow
       * @property {Function} length - a function returning the number of items
       * waiting to be processed. Invoke with `queue.length()`.
       * @property {boolean} started - a boolean indicating whether or not any
       * items have been pushed and processed by the queue.
       * @property {Function} running - a function returning the number of items
       * currently being processed. Invoke with `queue.running()`.
       * @property {Function} workersList - a function returning the array of items
       * currently being processed. Invoke with `queue.workersList()`.
       * @property {Function} idle - a function returning false if there are items
       * waiting or being processed, or true if not. Invoke with `queue.idle()`.
       * @property {number} concurrency - an integer for determining how many `worker`
       * functions should be run in parallel. This property can be changed after a
       * `queue` is created to alter the concurrency on-the-fly.
       * @property {number} payload - an integer that specifies how many items are
       * passed to the worker function at a time. only applies if this is a
       * [cargo]{@link module:ControlFlow.cargo} object
       * @property {AsyncFunction} push - add a new task to the `queue`. Calls `callback`
       * once the `worker` has finished processing the task. Instead of a single task,
       * a `tasks` array can be submitted. The respective callback is used for every
       * task in the list. Invoke with `queue.push(task, [callback])`,
       * @property {AsyncFunction} unshift - add a new task to the front of the `queue`.
       * Invoke with `queue.unshift(task, [callback])`.
       * @property {AsyncFunction} pushAsync - the same as `q.push`, except this returns
       * a promise that rejects if an error occurs.
       * @property {AsyncFunction} unshirtAsync - the same as `q.unshift`, except this returns
       * a promise that rejects if an error occurs.
       * @property {Function} remove - remove items from the queue that match a test
       * function.  The test function will be passed an object with a `data` property,
       * and a `priority` property, if this is a
       * [priorityQueue]{@link module:ControlFlow.priorityQueue} object.
       * Invoked with `queue.remove(testFn)`, where `testFn` is of the form
       * `function ({data, priority}) {}` and returns a Boolean.
       * @property {Function} saturated - a function that sets a callback that is
       * called when the number of running workers hits the `concurrency` limit, and
       * further tasks will be queued.  If the callback is omitted, `q.saturated()`
       * returns a promise for the next occurrence.
       * @property {Function} unsaturated - a function that sets a callback that is
       * called when the number of running workers is less than the `concurrency` &
       * `buffer` limits, and further tasks will not be queued. If the callback is
       * omitted, `q.unsaturated()` returns a promise for the next occurrence.
       * @property {number} buffer - A minimum threshold buffer in order to say that
       * the `queue` is `unsaturated`.
       * @property {Function} empty - a function that sets a callback that is called
       * when the last item from the `queue` is given to a `worker`. If the callback
       * is omitted, `q.empty()` returns a promise for the next occurrence.
       * @property {Function} drain - a function that sets a callback that is called
       * when the last item from the `queue` has returned from the `worker`. If the
       * callback is omitted, `q.drain()` returns a promise for the next occurrence.
       * @property {Function} error - a function that sets a callback that is called
       * when a task errors. Has the signature `function(error, task)`. If the
       * callback is omitted, `error()` returns a promise that rejects on the next
       * error.
       * @property {boolean} paused - a boolean for determining whether the queue is
       * in a paused state.
       * @property {Function} pause - a function that pauses the processing of tasks
       * until `resume()` is called. Invoke with `queue.pause()`.
       * @property {Function} resume - a function that resumes the processing of
       * queued tasks when the queue is paused. Invoke with `queue.resume()`.
       * @property {Function} kill - a function that removes the `drain` callback and
       * empties remaining tasks from the queue forcing it to go idle. No more tasks
       * should be pushed to the queue after calling this function. Invoke with `queue.kill()`.
       *
       * @example
       * const q = aync.queue(worker, 2)
       * q.push(item1)
       * q.push(item2)
       * q.push(item3)
       * // queues are iterable, spread into an array to inspect
       * const items = [...q] // [item1, item2, item3]
       * // or use for of
       * for (let item of q) {
       *     console.log(item)
       * }
       *
       * q.drain(() => {
       *     console.log('all done')
       * })
       * // or
       * await q.drain()
       */
  
      /**
       * Creates a `queue` object with the specified `concurrency`. Tasks added to the
       * `queue` are processed in parallel (up to the `concurrency` limit). If all
       * `worker`s are in progress, the task is queued until one becomes available.
       * Once a `worker` completes a `task`, that `task`'s callback is called.
       *
       * @name queue
       * @static
       * @memberOf module:ControlFlow
       * @method
       * @category Control Flow
       * @param {AsyncFunction} worker - An async function for processing a queued task.
       * If you want to handle errors from an individual task, pass a callback to
       * `q.push()`. Invoked with (task, callback).
       * @param {number} [concurrency=1] - An `integer` for determining how many
       * `worker` functions should be run in parallel.  If omitted, the concurrency
       * defaults to `1`.  If the concurrency is `0`, an error is thrown.
       * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can be
       * attached as certain properties to listen for specific events during the
       * lifecycle of the queue.
       * @example
       *
       * // create a queue object with concurrency 2
       * var q = async.queue(function(task, callback) {
       *     console.log('hello ' + task.name);
       *     callback();
       * }, 2);
       *
       * // assign a callback
       * q.drain(function() {
       *     console.log('all items have been processed');
       * });
       * // or await the end
       * await q.drain()
       *
       * // assign an error callback
       * q.error(function(err, task) {
       *     console.error('task experienced an error');
       * });
       *
       * // add some items to the queue
       * q.push({name: 'foo'}, function(err) {
       *     console.log('finished processing foo');
       * });
       * // callback is optional
       * q.push({name: 'bar'});
       *
       * // add some items to the queue (batch-wise)
       * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {
       *     console.log('finished processing item');
       * });
       *
       * // add some items to the front of the queue
       * q.unshift({name: 'bar'}, function (err) {
       *     console.log('finished processing bar');
       * });
       */
      function queue$1 (worker, concurrency) {
          var _worker = wrapAsync(worker);
          return queue((items, cb) => {
              _worker(items[0], cb);
          }, concurrency, 1);
      }
  
      // Binary min-heap implementation used for priority queue.
      // Implementation is stable, i.e. push time is considered for equal priorities
      class Heap {
          constructor() {
              this.heap = [];
              this.pushCount = Number.MIN_SAFE_INTEGER;
          }
  
          get length() {
              return this.heap.length;
          }
  
          empty () {
              this.heap = [];
              return this;
          }
  
          percUp(index) {
              let p;
  
              while (index > 0 && smaller(this.heap[index], this.heap[p=parent(index)])) {
                  let t = this.heap[index];
                  this.heap[index] = this.heap[p];
                  this.heap[p] = t;
  
                  index = p;
              }
          }
  
          percDown(index) {
              let l;
  
              while ((l=leftChi(index)) < this.heap.length) {
                  if (l+1 < this.heap.length && smaller(this.heap[l+1], this.heap[l])) {
                      l = l+1;
                  }
  
                  if (smaller(this.heap[index], this.heap[l])) {
                      break;
                  }
  
                  let t = this.heap[index];
                  this.heap[index] = this.heap[l];
                  this.heap[l] = t;
  
                  index = l;
              }
          }
  
          push(node) {
              node.pushCount = ++this.pushCount;
              this.heap.push(node);
              this.percUp(this.heap.length-1);
          }
  
          unshift(node) {
              return this.heap.push(node);
          }
  
          shift() {
              let [top] = this.heap;
  
              this.heap[0] = this.heap[this.heap.length-1];
              this.heap.pop();
              this.percDown(0);
  
              return top;
          }
  
          toArray() {
              return [...this];
          }
  
          *[Symbol.iterator] () {
              for (let i = 0; i < this.heap.length; i++) {
                  yield this.heap[i].data;
              }
          }
  
          remove (testFn) {
              let j = 0;
              for (let i = 0; i < this.heap.length; i++) {
                  if (!testFn(this.heap[i])) {
                      this.heap[j] = this.heap[i];
                      j++;
                  }
              }
  
              this.heap.splice(j);
  
              for (let i = parent(this.heap.length-1); i >= 0; i--) {
                  this.percDown(i);
              }
  
              return this;
          }
      }
  
      function leftChi(i) {
          return (i<<1)+1;
      }
  
      function parent(i) {
          return ((i+1)>>1)-1;
      }
  
      function smaller(x, y) {
          if (x.priority !== y.priority) {
              return x.priority < y.priority;
          }
          else {
              return x.pushCount < y.pushCount;
          }
      }
  
      /**
       * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and
       * completed in ascending priority order.
       *
       * @name priorityQueue
       * @static
       * @memberOf module:ControlFlow
       * @method
       * @see [async.queue]{@link module:ControlFlow.queue}
       * @category Control Flow
       * @param {AsyncFunction} worker - An async function for processing a queued task.
       * If you want to handle errors from an individual task, pass a callback to
       * `q.push()`.
       * Invoked with (task, callback).
       * @param {number} concurrency - An `integer` for determining how many `worker`
       * functions should be run in parallel.  If omitted, the concurrency defaults to
       * `1`.  If the concurrency is `0`, an error is thrown.
       * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are two
       * differences between `queue` and `priorityQueue` objects:
       * * `push(task, priority, [callback])` - `priority` should be a number. If an
       *   array of `tasks` is given, all tasks will be assigned the same priority.
       * * The `unshift` method was removed.
       */
      function priorityQueue(worker, concurrency) {
          // Start with a normal queue
          var q = queue$1(worker, concurrency);
  
          q._tasks = new Heap();
  
          // Override push to accept second parameter representing priority
          q.push = function(data, priority = 0, callback = () => {}) {
              if (typeof callback !== 'function') {
                  throw new Error('task callback must be a function');
              }
              q.started = true;
              if (!Array.isArray(data)) {
                  data = [data];
              }
              if (data.length === 0 && q.idle()) {
                  // call drain immediately if there are no tasks
                  return setImmediate$1(() => q.drain());
              }
  
              for (var i = 0, l = data.length; i < l; i++) {
                  var item = {
                      data: data[i],
                      priority,
                      callback
                  };
  
                  q._tasks.push(item);
              }
  
              setImmediate$1(q.process);
          };
  
          // Remove unshift function
          delete q.unshift;
  
          return q;
      }
  
      /**
       * Runs the `tasks` array of functions in parallel, without waiting until the
       * previous function has completed. Once any of the `tasks` complete or pass an
       * error to its callback, the main `callback` is immediately called. It's
       * equivalent to `Promise.race()`.
       *
       * @name race
       * @static
       * @memberOf module:ControlFlow
       * @method
       * @category Control Flow
       * @param {Array} tasks - An array containing [async functions]{@link AsyncFunction}
       * to run. Each function can complete with an optional `result` value.
       * @param {Function} callback - A callback to run once any of the functions have
       * completed. This function gets an error or result from the first function that
       * completed. Invoked with (err, result).
       * @returns undefined
       * @example
       *
       * async.race([
       *     function(callback) {
       *         setTimeout(function() {
       *             callback(null, 'one');
       *         }, 200);
       *     },
       *     function(callback) {
       *         setTimeout(function() {
       *             callback(null, 'two');
       *         }, 100);
       *     }
       * ],
       * // main callback
       * function(err, result) {
       *     // the result will be equal to 'two' as it finishes earlier
       * });
       */
      function race(tasks, callback) {
          callback = once(callback);
          if (!Array.isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));
          if (!tasks.length) return callback();
          for (var i = 0, l = tasks.length; i < l; i++) {
              wrapAsync(tasks[i])(callback);
          }
      }
  
      var race$1 = awaitify(race, 2);
  
      /**
       * Same as [`reduce`]{@link module:Collections.reduce}, only operates on `array` in reverse order.
       *
       * @name reduceRight
       * @static
       * @memberOf module:Collections
       * @method
       * @see [async.reduce]{@link module:Collections.reduce}
       * @alias foldr
       * @category Collection
       * @param {Array} array - A collection to iterate over.
       * @param {*} memo - The initial state of the reduction.
       * @param {AsyncFunction} iteratee - A function applied to each item in the
       * array to produce the next step in the reduction.
       * The `iteratee` should complete with the next state of the reduction.
       * If the iteratee complete with an error, the reduction is stopped and the
       * main `callback` is immediately called with the error.
       * Invoked with (memo, item, callback).
       * @param {Function} [callback] - A callback which is called after all the
       * `iteratee` functions have finished. Result is the reduced value. Invoked with
       * (err, result).
       * @returns {Promise} a promise, if no callback is passed
       */
      function reduceRight (array, memo, iteratee, callback) {
          var reversed = [...array].reverse();
          return reduce$1(reversed, memo, iteratee, callback);
      }
  
      /**
       * Wraps the async function in another function that always completes with a
       * result object, even when it errors.
       *
       * The result object has either the property `error` or `value`.
       *
       * @name reflect
       * @static
       * @memberOf module:Utils
       * @method
       * @category Util
       * @param {AsyncFunction} fn - The async function you want to wrap
       * @returns {Function} - A function that always passes null to it's callback as
       * the error. The second argument to the callback will be an `object` with
       * either an `error` or a `value` property.
       * @example
       *
       * async.parallel([
       *     async.reflect(function(callback) {
       *         // do some stuff ...
       *         callback(null, 'one');
       *     }),
       *     async.reflect(function(callback) {
       *         // do some more stuff but error ...
       *         callback('bad stuff happened');
       *     }),
       *     async.reflect(function(callback) {
       *         // do some more stuff ...
       *         callback(null, 'two');
       *     })
       * ],
       * // optional callback
       * function(err, results) {
       *     // values
       *     // results[0].value = 'one'
       *     // results[1].error = 'bad stuff happened'
       *     // results[2].value = 'two'
       * });
       */
      function reflect(fn) {
          var _fn = wrapAsync(fn);
          return initialParams(function reflectOn(args, reflectCallback) {
              args.push((error, ...cbArgs) => {
                  let retVal = {};
                  if (error) {
                      retVal.error = error;
                  }
                  if (cbArgs.length > 0){
                      var value = cbArgs;
                      if (cbArgs.length <= 1) {
                          [value] = cbArgs;
                      }
                      retVal.value = value;
                  }
                  reflectCallback(null, retVal);
              });
  
              return _fn.apply(this, args);
          });
      }
  
      /**
       * A helper function that wraps an array or an object of functions with `reflect`.
       *
       * @name reflectAll
       * @static
       * @memberOf module:Utils
       * @method
       * @see [async.reflect]{@link module:Utils.reflect}
       * @category Util
       * @param {Array|Object|Iterable} tasks - The collection of
       * [async functions]{@link AsyncFunction} to wrap in `async.reflect`.
       * @returns {Array} Returns an array of async functions, each wrapped in
       * `async.reflect`
       * @example
       *
       * let tasks = [
       *     function(callback) {
       *         setTimeout(function() {
       *             callback(null, 'one');
       *         }, 200);
       *     },
       *     function(callback) {
       *         // do some more stuff but error ...
       *         callback(new Error('bad stuff happened'));
       *     },
       *     function(callback) {
       *         setTimeout(function() {
       *             callback(null, 'two');
       *         }, 100);
       *     }
       * ];
       *
       * async.parallel(async.reflectAll(tasks),
       * // optional callback
       * function(err, results) {
       *     // values
       *     // results[0].value = 'one'
       *     // results[1].error = Error('bad stuff happened')
       *     // results[2].value = 'two'
       * });
       *
       * // an example using an object instead of an array
       * let tasks = {
       *     one: function(callback) {
       *         setTimeout(function() {
       *             callback(null, 'one');
       *         }, 200);
       *     },
       *     two: function(callback) {
       *         callback('two');
       *     },
       *     three: function(callback) {
       *         setTimeout(function() {
       *             callback(null, 'three');
       *         }, 100);
       *     }
       * };
       *
       * async.parallel(async.reflectAll(tasks),
       * // optional callback
       * function(err, results) {
       *     // values
       *     // results.one.value = 'one'
       *     // results.two.error = 'two'
       *     // results.three.value = 'three'
       * });
       */
      function reflectAll(tasks) {
          var results;
          if (Array.isArray(tasks)) {
              results = tasks.map(reflect);
          } else {
              results = {};
              Object.keys(tasks).forEach(key => {
                  results[key] = reflect.call(this, tasks[key]);
              });
          }
          return results;
      }
  
      function reject(eachfn, arr, _iteratee, callback) {
          const iteratee = wrapAsync(_iteratee);
          return _filter(eachfn, arr, (value, cb) => {
              iteratee(value, (err, v) => {
                  cb(err, !v);
              });
          }, callback);
      }
  
      /**
       * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.
       *
       * @name reject
       * @static
       * @memberOf module:Collections
       * @method
       * @see [async.filter]{@link module:Collections.filter}
       * @category Collection
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {Function} iteratee - An async truth test to apply to each item in
       * `coll`.
       * The should complete with a boolean value as its `result`.
       * Invoked with (item, callback).
       * @param {Function} [callback] - A callback which is called after all the
       * `iteratee` functions have finished. Invoked with (err, results).
       * @returns {Promise} a promise, if no callback is passed
       * @example
       *
       * async.reject(['file1','file2','file3'], function(filePath, callback) {
       *     fs.access(filePath, function(err) {
       *         callback(null, !err)
       *     });
       * }, function(err, results) {
       *     // results now equals an array of missing files
       *     createFiles(results);
       * });
       */
      function reject$1 (coll, iteratee, callback) {
          return reject(eachOf$1, coll, iteratee, callback)
      }
      var reject$2 = awaitify(reject$1, 3);
  
      /**
       * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a
       * time.
       *
       * @name rejectLimit
       * @static
       * @memberOf module:Collections
       * @method
       * @see [async.reject]{@link module:Collections.reject}
       * @category Collection
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {number} limit - The maximum number of async operations at a time.
       * @param {Function} iteratee - An async truth test to apply to each item in
       * `coll`.
       * The should complete with a boolean value as its `result`.
       * Invoked with (item, callback).
       * @param {Function} [callback] - A callback which is called after all the
       * `iteratee` functions have finished. Invoked with (err, results).
       * @returns {Promise} a promise, if no callback is passed
       */
      function rejectLimit (coll, limit, iteratee, callback) {
          return reject(eachOfLimit(limit), coll, iteratee, callback)
      }
      var rejectLimit$1 = awaitify(rejectLimit, 4);
  
      /**
       * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.
       *
       * @name rejectSeries
       * @static
       * @memberOf module:Collections
       * @method
       * @see [async.reject]{@link module:Collections.reject}
       * @category Collection
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {Function} iteratee - An async truth test to apply to each item in
       * `coll`.
       * The should complete with a boolean value as its `result`.
       * Invoked with (item, callback).
       * @param {Function} [callback] - A callback which is called after all the
       * `iteratee` functions have finished. Invoked with (err, results).
       * @returns {Promise} a promise, if no callback is passed
       */
      function rejectSeries (coll, iteratee, callback) {
          return reject(eachOfSeries$1, coll, iteratee, callback)
      }
      var rejectSeries$1 = awaitify(rejectSeries, 3);
  
      function constant$1(value) {
          return function () {
              return value;
          }
      }
  
      /**
       * Attempts to get a successful response from `task` no more than `times` times
       * before returning an error. If the task is successful, the `callback` will be
       * passed the result of the successful task. If all attempts fail, the callback
       * will be passed the error and result (if any) of the final attempt.
       *
       * @name retry
       * @static
       * @memberOf module:ControlFlow
       * @method
       * @category Control Flow
       * @see [async.retryable]{@link module:ControlFlow.retryable}
       * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an
       * object with `times` and `interval` or a number.
       * * `times` - The number of attempts to make before giving up.  The default
       *   is `5`.
       * * `interval` - The time to wait between retries, in milliseconds.  The
       *   default is `0`. The interval may also be specified as a function of the
       *   retry count (see example).
       * * `errorFilter` - An optional synchronous function that is invoked on
       *   erroneous result. If it returns `true` the retry attempts will continue;
       *   if the function returns `false` the retry flow is aborted with the current
       *   attempt's error and result being returned to the final callback.
       *   Invoked with (err).
       * * If `opts` is a number, the number specifies the number of times to retry,
       *   with the default interval of `0`.
       * @param {AsyncFunction} task - An async function to retry.
       * Invoked with (callback).
       * @param {Function} [callback] - An optional callback which is called when the
       * task has succeeded, or after the final failed attempt. It receives the `err`
       * and `result` arguments of the last attempt at completing the `task`. Invoked
       * with (err, results).
       * @returns {Promise} a promise if no callback provided
       *
       * @example
       *
       * // The `retry` function can be used as a stand-alone control flow by passing
       * // a callback, as shown below:
       *
       * // try calling apiMethod 3 times
       * async.retry(3, apiMethod, function(err, result) {
       *     // do something with the result
       * });
       *
       * // try calling apiMethod 3 times, waiting 200 ms between each retry
       * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {
       *     // do something with the result
       * });
       *
       * // try calling apiMethod 10 times with exponential backoff
       * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)
       * async.retry({
       *   times: 10,
       *   interval: function(retryCount) {
       *     return 50 * Math.pow(2, retryCount);
       *   }
       * }, apiMethod, function(err, result) {
       *     // do something with the result
       * });
       *
       * // try calling apiMethod the default 5 times no delay between each retry
       * async.retry(apiMethod, function(err, result) {
       *     // do something with the result
       * });
       *
       * // try calling apiMethod only when error condition satisfies, all other
       * // errors will abort the retry control flow and return to final callback
       * async.retry({
       *   errorFilter: function(err) {
       *     return err.message === 'Temporary error'; // only retry on a specific error
       *   }
       * }, apiMethod, function(err, result) {
       *     // do something with the result
       * });
       *
       * // to retry individual methods that are not as reliable within other
       * // control flow functions, use the `retryable` wrapper:
       * async.auto({
       *     users: api.getUsers.bind(api),
       *     payments: async.retryable(3, api.getPayments.bind(api))
       * }, function(err, results) {
       *     // do something with the results
       * });
       *
       */
      const DEFAULT_TIMES = 5;
      const DEFAULT_INTERVAL = 0;
  
      function retry(opts, task, callback) {
          var options = {
              times: DEFAULT_TIMES,
              intervalFunc: constant$1(DEFAULT_INTERVAL)
          };
  
          if (arguments.length < 3 && typeof opts === 'function') {
              callback = task || promiseCallback();
              task = opts;
          } else {
              parseTimes(options, opts);
              callback = callback || promiseCallback();
          }
  
          if (typeof task !== 'function') {
              throw new Error("Invalid arguments for async.retry");
          }
  
          var _task = wrapAsync(task);
  
          var attempt = 1;
          function retryAttempt() {
              _task((err, ...args) => {
                  if (err === false) return
                  if (err && attempt++ < options.times &&
                      (typeof options.errorFilter != 'function' ||
                          options.errorFilter(err))) {
                      setTimeout(retryAttempt, options.intervalFunc(attempt - 1));
                  } else {
                      callback(err, ...args);
                  }
              });
          }
  
          retryAttempt();
          return callback[PROMISE_SYMBOL]
      }
  
      function parseTimes(acc, t) {
          if (typeof t === 'object') {
              acc.times = +t.times || DEFAULT_TIMES;
  
              acc.intervalFunc = typeof t.interval === 'function' ?
                  t.interval :
                  constant$1(+t.interval || DEFAULT_INTERVAL);
  
              acc.errorFilter = t.errorFilter;
          } else if (typeof t === 'number' || typeof t === 'string') {
              acc.times = +t || DEFAULT_TIMES;
          } else {
              throw new Error("Invalid arguments for async.retry");
          }
      }
  
      /**
       * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method
       * wraps a task and makes it retryable, rather than immediately calling it
       * with retries.
       *
       * @name retryable
       * @static
       * @memberOf module:ControlFlow
       * @method
       * @see [async.retry]{@link module:ControlFlow.retry}
       * @category Control Flow
       * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional
       * options, exactly the same as from `retry`, except for a `opts.arity` that
       * is the arity of the `task` function, defaulting to `task.length`
       * @param {AsyncFunction} task - the asynchronous function to wrap.
       * This function will be passed any arguments passed to the returned wrapper.
       * Invoked with (...args, callback).
       * @returns {AsyncFunction} The wrapped function, which when invoked, will
       * retry on an error, based on the parameters specified in `opts`.
       * This function will accept the same parameters as `task`.
       * @example
       *
       * async.auto({
       *     dep1: async.retryable(3, getFromFlakyService),
       *     process: ["dep1", async.retryable(3, function (results, cb) {
       *         maybeProcessData(results.dep1, cb);
       *     })]
       * }, callback);
       */
      function retryable (opts, task) {
          if (!task) {
              task = opts;
              opts = null;
          }
          let arity = (opts && opts.arity) || task.length;
          if (isAsync(task)) {
              arity += 1;
          }
          var _task = wrapAsync(task);
          return initialParams((args, callback) => {
              if (args.length < arity - 1 || callback == null) {
                  args.push(callback);
                  callback = promiseCallback();
              }
              function taskFn(cb) {
                  _task(...args, cb);
              }
  
              if (opts) retry(opts, taskFn, callback);
              else retry(taskFn, callback);
  
              return callback[PROMISE_SYMBOL]
          });
      }
  
      /**
       * Run the functions in the `tasks` collection in series, each one running once
       * the previous function has completed. If any functions in the series pass an
       * error to its callback, no more functions are run, and `callback` is
       * immediately called with the value of the error. Otherwise, `callback`
       * receives an array of results when `tasks` have completed.
       *
       * It is also possible to use an object instead of an array. Each property will
       * be run as a function, and the results will be passed to the final `callback`
       * as an object instead of an array. This can be a more readable way of handling
       *  results from {@link async.series}.
       *
       * **Note** that while many implementations preserve the order of object
       * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)
       * explicitly states that
       *
       * > The mechanics and order of enumerating the properties is not specified.
       *
       * So if you rely on the order in which your series of functions are executed,
       * and want this to work on all platforms, consider using an array.
       *
       * @name series
       * @static
       * @memberOf module:ControlFlow
       * @method
       * @category Control Flow
       * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing
       * [async functions]{@link AsyncFunction} to run in series.
       * Each function can complete with any number of optional `result` values.
       * @param {Function} [callback] - An optional callback to run once all the
       * functions have completed. This function gets a results array (or object)
       * containing all the result arguments passed to the `task` callbacks. Invoked
       * with (err, result).
       * @return {Promise} a promise, if no callback is passed
       * @example
       * async.series([
       *     function(callback) {
       *         // do some stuff ...
       *         callback(null, 'one');
       *     },
       *     function(callback) {
       *         // do some more stuff ...
       *         callback(null, 'two');
       *     }
       * ],
       * // optional callback
       * function(err, results) {
       *     // results is now equal to ['one', 'two']
       * });
       *
       * async.series({
       *     one: function(callback) {
       *         setTimeout(function() {
       *             callback(null, 1);
       *         }, 200);
       *     },
       *     two: function(callback){
       *         setTimeout(function() {
       *             callback(null, 2);
       *         }, 100);
       *     }
       * }, function(err, results) {
       *     // results is now equal to: {one: 1, two: 2}
       * });
       */
      function series(tasks, callback) {
          return parallel(eachOfSeries$1, tasks, callback);
      }
  
      /**
       * Returns `true` if at least one element in the `coll` satisfies an async test.
       * If any iteratee call returns `true`, the main `callback` is immediately
       * called.
       *
       * @name some
       * @static
       * @memberOf module:Collections
       * @method
       * @alias any
       * @category Collection
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {AsyncFunction} iteratee - An async truth test to apply to each item
       * in the collections in parallel.
       * The iteratee should complete with a boolean `result` value.
       * Invoked with (item, callback).
       * @param {Function} [callback] - A callback which is called as soon as any
       * iteratee returns `true`, or after all the iteratee functions have finished.
       * Result will be either `true` or `false` depending on the values of the async
       * tests. Invoked with (err, result).
       * @returns {Promise} a promise, if no callback provided
       * @example
       *
       * async.some(['file1','file2','file3'], function(filePath, callback) {
       *     fs.access(filePath, function(err) {
       *         callback(null, !err)
       *     });
       * }, function(err, result) {
       *     // if result is true then at least one of the files exists
       * });
       */
      function some(coll, iteratee, callback) {
          return _createTester(Boolean, res => res)(eachOf$1, coll, iteratee, callback)
      }
      var some$1 = awaitify(some, 3);
  
      /**
       * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.
       *
       * @name someLimit
       * @static
       * @memberOf module:Collections
       * @method
       * @see [async.some]{@link module:Collections.some}
       * @alias anyLimit
       * @category Collection
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {number} limit - The maximum number of async operations at a time.
       * @param {AsyncFunction} iteratee - An async truth test to apply to each item
       * in the collections in parallel.
       * The iteratee should complete with a boolean `result` value.
       * Invoked with (item, callback).
       * @param {Function} [callback] - A callback which is called as soon as any
       * iteratee returns `true`, or after all the iteratee functions have finished.
       * Result will be either `true` or `false` depending on the values of the async
       * tests. Invoked with (err, result).
       * @returns {Promise} a promise, if no callback provided
       */
      function someLimit(coll, limit, iteratee, callback) {
          return _createTester(Boolean, res => res)(eachOfLimit(limit), coll, iteratee, callback)
      }
      var someLimit$1 = awaitify(someLimit, 4);
  
      /**
       * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.
       *
       * @name someSeries
       * @static
       * @memberOf module:Collections
       * @method
       * @see [async.some]{@link module:Collections.some}
       * @alias anySeries
       * @category Collection
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {AsyncFunction} iteratee - An async truth test to apply to each item
       * in the collections in series.
       * The iteratee should complete with a boolean `result` value.
       * Invoked with (item, callback).
       * @param {Function} [callback] - A callback which is called as soon as any
       * iteratee returns `true`, or after all the iteratee functions have finished.
       * Result will be either `true` or `false` depending on the values of the async
       * tests. Invoked with (err, result).
       * @returns {Promise} a promise, if no callback provided
       */
      function someSeries(coll, iteratee, callback) {
          return _createTester(Boolean, res => res)(eachOfSeries$1, coll, iteratee, callback)
      }
      var someSeries$1 = awaitify(someSeries, 3);
  
      /**
       * Sorts a list by the results of running each `coll` value through an async
       * `iteratee`.
       *
       * @name sortBy
       * @static
       * @memberOf module:Collections
       * @method
       * @category Collection
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {AsyncFunction} iteratee - An async function to apply to each item in
       * `coll`.
       * The iteratee should complete with a value to use as the sort criteria as
       * its `result`.
       * Invoked with (item, callback).
       * @param {Function} callback - A callback which is called after all the
       * `iteratee` functions have finished, or an error occurs. Results is the items
       * from the original `coll` sorted by the values returned by the `iteratee`
       * calls. Invoked with (err, results).
       * @returns {Promise} a promise, if no callback passed
       * @example
       *
       * async.sortBy(['file1','file2','file3'], function(file, callback) {
       *     fs.stat(file, function(err, stats) {
       *         callback(err, stats.mtime);
       *     });
       * }, function(err, results) {
       *     // results is now the original array of files sorted by
       *     // modified date
       * });
       *
       * // By modifying the callback parameter the
       * // sorting order can be influenced:
       *
       * // ascending order
       * async.sortBy([1,9,3,5], function(x, callback) {
       *     callback(null, x);
       * }, function(err,result) {
       *     // result callback
       * });
       *
       * // descending order
       * async.sortBy([1,9,3,5], function(x, callback) {
       *     callback(null, x*-1);    //<- x*-1 instead of x, turns the order around
       * }, function(err,result) {
       *     // result callback
       * });
       */
      function sortBy (coll, iteratee, callback) {
          var _iteratee = wrapAsync(iteratee);
          return map$1(coll, (x, iterCb) => {
              _iteratee(x, (err, criteria) => {
                  if (err) return iterCb(err);
                  iterCb(err, {value: x, criteria});
              });
          }, (err, results) => {
              if (err) return callback(err);
              callback(null, results.sort(comparator).map(v => v.value));
          });
  
          function comparator(left, right) {
              var a = left.criteria, b = right.criteria;
              return a < b ? -1 : a > b ? 1 : 0;
          }
      }
      var sortBy$1 = awaitify(sortBy, 3);
  
      /**
       * Sets a time limit on an asynchronous function. If the function does not call
       * its callback within the specified milliseconds, it will be called with a
       * timeout error. The code property for the error object will be `'ETIMEDOUT'`.
       *
       * @name timeout
       * @static
       * @memberOf module:Utils
       * @method
       * @category Util
       * @param {AsyncFunction} asyncFn - The async function to limit in time.
       * @param {number} milliseconds - The specified time limit.
       * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)
       * to timeout Error for more information..
       * @returns {AsyncFunction} Returns a wrapped function that can be used with any
       * of the control flow functions.
       * Invoke this function with the same parameters as you would `asyncFunc`.
       * @example
       *
       * function myFunction(foo, callback) {
       *     doAsyncTask(foo, function(err, data) {
       *         // handle errors
       *         if (err) return callback(err);
       *
       *         // do some stuff ...
       *
       *         // return processed data
       *         return callback(null, data);
       *     });
       * }
       *
       * var wrapped = async.timeout(myFunction, 1000);
       *
       * // call `wrapped` as you would `myFunction`
       * wrapped({ bar: 'bar' }, function(err, data) {
       *     // if `myFunction` takes < 1000 ms to execute, `err`
       *     // and `data` will have their expected values
       *
       *     // else `err` will be an Error with the code 'ETIMEDOUT'
       * });
       */
      function timeout(asyncFn, milliseconds, info) {
          var fn = wrapAsync(asyncFn);
  
          return initialParams((args, callback) => {
              var timedOut = false;
              var timer;
  
              function timeoutCallback() {
                  var name = asyncFn.name || 'anonymous';
                  var error  = new Error('Callback function "' + name + '" timed out.');
                  error.code = 'ETIMEDOUT';
                  if (info) {
                      error.info = info;
                  }
                  timedOut = true;
                  callback(error);
              }
  
              args.push((...cbArgs) => {
                  if (!timedOut) {
                      callback(...cbArgs);
                      clearTimeout(timer);
                  }
              });
  
              // setup timer and call original function
              timer = setTimeout(timeoutCallback, milliseconds);
              fn(...args);
          });
      }
  
      function range(size) {
          var result = Array(size);
          while (size--) {
              result[size] = size;
          }
          return result;
      }
  
      /**
       * The same as [times]{@link module:ControlFlow.times} but runs a maximum of `limit` async operations at a
       * time.
       *
       * @name timesLimit
       * @static
       * @memberOf module:ControlFlow
       * @method
       * @see [async.times]{@link module:ControlFlow.times}
       * @category Control Flow
       * @param {number} count - The number of times to run the function.
       * @param {number} limit - The maximum number of async operations at a time.
       * @param {AsyncFunction} iteratee - The async function to call `n` times.
       * Invoked with the iteration index and a callback: (n, next).
       * @param {Function} callback - see [async.map]{@link module:Collections.map}.
       * @returns {Promise} a promise, if no callback is provided
       */
      function timesLimit(count, limit, iteratee, callback) {
          var _iteratee = wrapAsync(iteratee);
          return mapLimit$1(range(count), limit, _iteratee, callback);
      }
  
      /**
       * Calls the `iteratee` function `n` times, and accumulates results in the same
       * manner you would use with [map]{@link module:Collections.map}.
       *
       * @name times
       * @static
       * @memberOf module:ControlFlow
       * @method
       * @see [async.map]{@link module:Collections.map}
       * @category Control Flow
       * @param {number} n - The number of times to run the function.
       * @param {AsyncFunction} iteratee - The async function to call `n` times.
       * Invoked with the iteration index and a callback: (n, next).
       * @param {Function} callback - see {@link module:Collections.map}.
       * @returns {Promise} a promise, if no callback is provided
       * @example
       *
       * // Pretend this is some complicated async factory
       * var createUser = function(id, callback) {
       *     callback(null, {
       *         id: 'user' + id
       *     });
       * };
       *
       * // generate 5 users
       * async.times(5, function(n, next) {
       *     createUser(n, function(err, user) {
       *         next(err, user);
       *     });
       * }, function(err, users) {
       *     // we should now have 5 users
       * });
       */
      function times (n, iteratee, callback) {
          return timesLimit(n, Infinity, iteratee, callback)
      }
  
      /**
       * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.
       *
       * @name timesSeries
       * @static
       * @memberOf module:ControlFlow
       * @method
       * @see [async.times]{@link module:ControlFlow.times}
       * @category Control Flow
       * @param {number} n - The number of times to run the function.
       * @param {AsyncFunction} iteratee - The async function to call `n` times.
       * Invoked with the iteration index and a callback: (n, next).
       * @param {Function} callback - see {@link module:Collections.map}.
       * @returns {Promise} a promise, if no callback is provided
       */
      function timesSeries (n, iteratee, callback) {
          return timesLimit(n, 1, iteratee, callback)
      }
  
      /**
       * A relative of `reduce`.  Takes an Object or Array, and iterates over each
       * element in parallel, each step potentially mutating an `accumulator` value.
       * The type of the accumulator defaults to the type of collection passed in.
       *
       * @name transform
       * @static
       * @memberOf module:Collections
       * @method
       * @category Collection
       * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
       * @param {*} [accumulator] - The initial state of the transform.  If omitted,
       * it will default to an empty Object or Array, depending on the type of `coll`
       * @param {AsyncFunction} iteratee - A function applied to each item in the
       * collection that potentially modifies the accumulator.
       * Invoked with (accumulator, item, key, callback).
       * @param {Function} [callback] - A callback which is called after all the
       * `iteratee` functions have finished. Result is the transformed accumulator.
       * Invoked with (err, result).
       * @returns {Promise} a promise, if no callback provided
       * @example
       *
       * async.transform([1,2,3], function(acc, item, index, callback) {
       *     // pointless async:
       *     process.nextTick(function() {
       *         acc[index] = item * 2
       *         callback(null)
       *     });
       * }, function(err, result) {
       *     // result is now equal to [2, 4, 6]
       * });
       *
       * @example
       *
       * async.transform({a: 1, b: 2, c: 3}, function (obj, val, key, callback) {
       *     setImmediate(function () {
       *         obj[key] = val * 2;
       *         callback();
       *     })
       * }, function (err, result) {
       *     // result is equal to {a: 2, b: 4, c: 6}
       * })
       */
      function transform (coll, accumulator, iteratee, callback) {
          if (arguments.length <= 3 && typeof accumulator === 'function') {
              callback = iteratee;
              iteratee = accumulator;
              accumulator = Array.isArray(coll) ? [] : {};
          }
          callback = once(callback || promiseCallback());
          var _iteratee = wrapAsync(iteratee);
  
          eachOf$1(coll, (v, k, cb) => {
              _iteratee(accumulator, v, k, cb);
          }, err => callback(err, accumulator));
          return callback[PROMISE_SYMBOL]
      }
  
      /**
       * It runs each task in series but stops whenever any of the functions were
       * successful. If one of the tasks were successful, the `callback` will be
       * passed the result of the successful task. If all tasks fail, the callback
       * will be passed the error and result (if any) of the final attempt.
       *
       * @name tryEach
       * @static
       * @memberOf module:ControlFlow
       * @method
       * @category Control Flow
       * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing functions to
       * run, each function is passed a `callback(err, result)` it must call on
       * completion with an error `err` (which can be `null`) and an optional `result`
       * value.
       * @param {Function} [callback] - An optional callback which is called when one
       * of the tasks has succeeded, or all have failed. It receives the `err` and
       * `result` arguments of the last attempt at completing the `task`. Invoked with
       * (err, results).
       * @returns {Promise} a promise, if no callback is passed
       * @example
       * async.tryEach([
       *     function getDataFromFirstWebsite(callback) {
       *         // Try getting the data from the first website
       *         callback(err, data);
       *     },
       *     function getDataFromSecondWebsite(callback) {
       *         // First website failed,
       *         // Try getting the data from the backup website
       *         callback(err, data);
       *     }
       * ],
       * // optional callback
       * function(err, results) {
       *     Now do something with the data.
       * });
       *
       */
      function tryEach(tasks, callback) {
          var error = null;
          var result;
          return eachSeries$1(tasks, (task, taskCb) => {
              wrapAsync(task)((err, ...args) => {
                  if (err === false) return taskCb(err);
  
                  if (args.length < 2) {
                      [result] = args;
                  } else {
                      result = args;
                  }
                  error = err;
                  taskCb(err ? null : {});
              });
          }, () => callback(error, result));
      }
  
      var tryEach$1 = awaitify(tryEach);
  
      /**
       * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,
       * unmemoized form. Handy for testing.
       *
       * @name unmemoize
       * @static
       * @memberOf module:Utils
       * @method
       * @see [async.memoize]{@link module:Utils.memoize}
       * @category Util
       * @param {AsyncFunction} fn - the memoized function
       * @returns {AsyncFunction} a function that calls the original unmemoized function
       */
      function unmemoize(fn) {
          return (...args) => {
              return (fn.unmemoized || fn)(...args);
          };
      }
  
      /**
       * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when
       * stopped, or an error occurs.
       *
       * @name whilst
       * @static
       * @memberOf module:ControlFlow
       * @method
       * @category Control Flow
       * @param {AsyncFunction} test - asynchronous truth test to perform before each
       * execution of `iteratee`. Invoked with ().
       * @param {AsyncFunction} iteratee - An async function which is called each time
       * `test` passes. Invoked with (callback).
       * @param {Function} [callback] - A callback which is called after the test
       * function has failed and repeated execution of `iteratee` has stopped. `callback`
       * will be passed an error and any arguments passed to the final `iteratee`'s
       * callback. Invoked with (err, [results]);
       * @returns {Promise} a promise, if no callback is passed
       * @example
       *
       * var count = 0;
       * async.whilst(
       *     function test(cb) { cb(null, count < 5); },
       *     function iter(callback) {
       *         count++;
       *         setTimeout(function() {
       *             callback(null, count);
       *         }, 1000);
       *     },
       *     function (err, n) {
       *         // 5 seconds have passed, n = 5
       *     }
       * );
       */
      function whilst(test, iteratee, callback) {
          callback = onlyOnce(callback);
          var _fn = wrapAsync(iteratee);
          var _test = wrapAsync(test);
          var results = [];
  
          function next(err, ...rest) {
              if (err) return callback(err);
              results = rest;
              if (err === false) return;
              _test(check);
          }
  
          function check(err, truth) {
              if (err) return callback(err);
              if (err === false) return;
              if (!truth) return callback(null, ...results);
              _fn(next);
          }
  
          return _test(check);
      }
      var whilst$1 = awaitify(whilst, 3);
  
      /**
       * Repeatedly call `iteratee` until `test` returns `true`. Calls `callback` when
       * stopped, or an error occurs. `callback` will be passed an error and any
       * arguments passed to the final `iteratee`'s callback.
       *
       * The inverse of [whilst]{@link module:ControlFlow.whilst}.
       *
       * @name until
       * @static
       * @memberOf module:ControlFlow
       * @method
       * @see [async.whilst]{@link module:ControlFlow.whilst}
       * @category Control Flow
       * @param {AsyncFunction} test - asynchronous truth test to perform before each
       * execution of `iteratee`. Invoked with (callback).
       * @param {AsyncFunction} iteratee - An async function which is called each time
       * `test` fails. Invoked with (callback).
       * @param {Function} [callback] - A callback which is called after the test
       * function has passed and repeated execution of `iteratee` has stopped. `callback`
       * will be passed an error and any arguments passed to the final `iteratee`'s
       * callback. Invoked with (err, [results]);
       * @returns {Promise} a promise, if a callback is not passed
       *
       * @example
       * const results = []
       * let finished = false
       * async.until(function test(page, cb) {
       *     cb(null, finished)
       * }, function iter(next) {
       *     fetchPage(url, (err, body) => {
       *         if (err) return next(err)
       *         results = results.concat(body.objects)
       *         finished = !!body.next
       *         next(err)
       *     })
       * }, function done (err) {
       *     // all pages have been fetched
       * })
       */
      function until(test, iteratee, callback) {
          const _test = wrapAsync(test);
          return whilst$1((cb) => _test((err, truth) => cb (err, !truth)), iteratee, callback);
      }
  
      /**
       * Runs the `tasks` array of functions in series, each passing their results to
       * the next in the array. However, if any of the `tasks` pass an error to their
       * own callback, the next function is not executed, and the main `callback` is
       * immediately called with the error.
       *
       * @name waterfall
       * @static
       * @memberOf module:ControlFlow
       * @method
       * @category Control Flow
       * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}
       * to run.
       * Each function should complete with any number of `result` values.
       * The `result` values will be passed as arguments, in order, to the next task.
       * @param {Function} [callback] - An optional callback to run once all the
       * functions have completed. This will be passed the results of the last task's
       * callback. Invoked with (err, [results]).
       * @returns undefined
       * @example
       *
       * async.waterfall([
       *     function(callback) {
       *         callback(null, 'one', 'two');
       *     },
       *     function(arg1, arg2, callback) {
       *         // arg1 now equals 'one' and arg2 now equals 'two'
       *         callback(null, 'three');
       *     },
       *     function(arg1, callback) {
       *         // arg1 now equals 'three'
       *         callback(null, 'done');
       *     }
       * ], function (err, result) {
       *     // result now equals 'done'
       * });
       *
       * // Or, with named functions:
       * async.waterfall([
       *     myFirstFunction,
       *     mySecondFunction,
       *     myLastFunction,
       * ], function (err, result) {
       *     // result now equals 'done'
       * });
       * function myFirstFunction(callback) {
       *     callback(null, 'one', 'two');
       * }
       * function mySecondFunction(arg1, arg2, callback) {
       *     // arg1 now equals 'one' and arg2 now equals 'two'
       *     callback(null, 'three');
       * }
       * function myLastFunction(arg1, callback) {
       *     // arg1 now equals 'three'
       *     callback(null, 'done');
       * }
       */
      function waterfall (tasks, callback) {
          callback = once(callback);
          if (!Array.isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));
          if (!tasks.length) return callback();
          var taskIndex = 0;
  
          function nextTask(args) {
              var task = wrapAsync(tasks[taskIndex++]);
              task(...args, onlyOnce(next));
          }
  
          function next(err, ...args) {
              if (err === false) return
              if (err || taskIndex === tasks.length) {
                  return callback(err, ...args);
              }
              nextTask(args);
          }
  
          nextTask([]);
      }
  
      var waterfall$1 = awaitify(waterfall);
  
      /**
       * An "async function" in the context of Async is an asynchronous function with
       * a variable number of parameters, with the final parameter being a callback.
       * (`function (arg1, arg2, ..., callback) {}`)
       * The final callback is of the form `callback(err, results...)`, which must be
       * called once the function is completed.  The callback should be called with a
       * Error as its first argument to signal that an error occurred.
       * Otherwise, if no error occurred, it should be called with `null` as the first
       * argument, and any additional `result` arguments that may apply, to signal
       * successful completion.
       * The callback must be called exactly once, ideally on a later tick of the
       * JavaScript event loop.
       *
       * This type of function is also referred to as a "Node-style async function",
       * or a "continuation passing-style function" (CPS). Most of the methods of this
       * library are themselves CPS/Node-style async functions, or functions that
       * return CPS/Node-style async functions.
       *
       * Wherever we accept a Node-style async function, we also directly accept an
       * [ES2017 `async` function]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}.
       * In this case, the `async` function will not be passed a final callback
       * argument, and any thrown error will be used as the `err` argument of the
       * implicit callback, and the return value will be used as the `result` value.
       * (i.e. a `rejected` of the returned Promise becomes the `err` callback
       * argument, and a `resolved` value becomes the `result`.)
       *
       * Note, due to JavaScript limitations, we can only detect native `async`
       * functions and not transpilied implementations.
       * Your environment must have `async`/`await` support for this to work.
       * (e.g. Node > v7.6, or a recent version of a modern browser).
       * If you are using `async` functions through a transpiler (e.g. Babel), you
       * must still wrap the function with [asyncify]{@link module:Utils.asyncify},
       * because the `async function` will be compiled to an ordinary function that
       * returns a promise.
       *
       * @typedef {Function} AsyncFunction
       * @static
       */
  
      var index = {
          apply,
          applyEach: applyEach$1,
          applyEachSeries,
          asyncify,
          auto,
          autoInject,
          cargo,
          cargoQueue: cargo$1,
          compose,
          concat: concat$1,
          concatLimit: concatLimit$1,
          concatSeries: concatSeries$1,
          constant,
          detect: detect$1,
          detectLimit: detectLimit$1,
          detectSeries: detectSeries$1,
          dir,
          doUntil,
          doWhilst: doWhilst$1,
          each,
          eachLimit: eachLimit$2,
          eachOf: eachOf$1,
          eachOfLimit: eachOfLimit$2,
          eachOfSeries: eachOfSeries$1,
          eachSeries: eachSeries$1,
          ensureAsync,
          every: every$1,
          everyLimit: everyLimit$1,
          everySeries: everySeries$1,
          filter: filter$1,
          filterLimit: filterLimit$1,
          filterSeries: filterSeries$1,
          forever: forever$1,
          groupBy,
          groupByLimit: groupByLimit$1,
          groupBySeries,
          log,
          map: map$1,
          mapLimit: mapLimit$1,
          mapSeries: mapSeries$1,
          mapValues,
          mapValuesLimit: mapValuesLimit$1,
          mapValuesSeries,
          memoize,
          nextTick,
          parallel: parallel$1,
          parallelLimit,
          priorityQueue,
          queue: queue$1,
          race: race$1,
          reduce: reduce$1,
          reduceRight,
          reflect,
          reflectAll,
          reject: reject$2,
          rejectLimit: rejectLimit$1,
          rejectSeries: rejectSeries$1,
          retry,
          retryable,
          seq,
          series,
          setImmediate: setImmediate$1,
          some: some$1,
          someLimit: someLimit$1,
          someSeries: someSeries$1,
          sortBy: sortBy$1,
          timeout,
          times,
          timesLimit,
          timesSeries,
          transform,
          tryEach: tryEach$1,
          unmemoize,
          until,
          waterfall: waterfall$1,
          whilst: whilst$1,
  
          // aliases
          all: every$1,
          allLimit: everyLimit$1,
          allSeries: everySeries$1,
          any: some$1,
          anyLimit: someLimit$1,
          anySeries: someSeries$1,
          find: detect$1,
          findLimit: detectLimit$1,
          findSeries: detectSeries$1,
          flatMap: concat$1,
          flatMapLimit: concatLimit$1,
          flatMapSeries: concatSeries$1,
          forEach: each,
          forEachSeries: eachSeries$1,
          forEachLimit: eachLimit$2,
          forEachOf: eachOf$1,
          forEachOfSeries: eachOfSeries$1,
          forEachOfLimit: eachOfLimit$2,
          inject: reduce$1,
          foldl: reduce$1,
          foldr: reduceRight,
          select: filter$1,
          selectLimit: filterLimit$1,
          selectSeries: filterSeries$1,
          wrapSync: asyncify,
          during: whilst$1,
          doDuring: doWhilst$1
      };
  
      exports.default = index;
      exports.apply = apply;
      exports.applyEach = applyEach$1;
      exports.applyEachSeries = applyEachSeries;
      exports.asyncify = asyncify;
      exports.auto = auto;
      exports.autoInject = autoInject;
      exports.cargo = cargo;
      exports.cargoQueue = cargo$1;
      exports.compose = compose;
      exports.concat = concat$1;
      exports.concatLimit = concatLimit$1;
      exports.concatSeries = concatSeries$1;
      exports.constant = constant;
      exports.detect = detect$1;
      exports.detectLimit = detectLimit$1;
      exports.detectSeries = detectSeries$1;
      exports.dir = dir;
      exports.doUntil = doUntil;
      exports.doWhilst = doWhilst$1;
      exports.each = each;
      exports.eachLimit = eachLimit$2;
      exports.eachOf = eachOf$1;
      exports.eachOfLimit = eachOfLimit$2;
      exports.eachOfSeries = eachOfSeries$1;
      exports.eachSeries = eachSeries$1;
      exports.ensureAsync = ensureAsync;
      exports.every = every$1;
      exports.everyLimit = everyLimit$1;
      exports.everySeries = everySeries$1;
      exports.filter = filter$1;
      exports.filterLimit = filterLimit$1;
      exports.filterSeries = filterSeries$1;
      exports.forever = forever$1;
      exports.groupBy = groupBy;
      exports.groupByLimit = groupByLimit$1;
      exports.groupBySeries = groupBySeries;
      exports.log = log;
      exports.map = map$1;
      exports.mapLimit = mapLimit$1;
      exports.mapSeries = mapSeries$1;
      exports.mapValues = mapValues;
      exports.mapValuesLimit = mapValuesLimit$1;
      exports.mapValuesSeries = mapValuesSeries;
      exports.memoize = memoize;
      exports.nextTick = nextTick;
      exports.parallel = parallel$1;
      exports.parallelLimit = parallelLimit;
      exports.priorityQueue = priorityQueue;
      exports.queue = queue$1;
      exports.race = race$1;
      exports.reduce = reduce$1;
      exports.reduceRight = reduceRight;
      exports.reflect = reflect;
      exports.reflectAll = reflectAll;
      exports.reject = reject$2;
      exports.rejectLimit = rejectLimit$1;
      exports.rejectSeries = rejectSeries$1;
      exports.retry = retry;
      exports.retryable = retryable;
      exports.seq = seq;
      exports.series = series;
      exports.setImmediate = setImmediate$1;
      exports.some = some$1;
      exports.someLimit = someLimit$1;
      exports.someSeries = someSeries$1;
      exports.sortBy = sortBy$1;
      exports.timeout = timeout;
      exports.times = times;
      exports.timesLimit = timesLimit;
      exports.timesSeries = timesSeries;
      exports.transform = transform;
      exports.tryEach = tryEach$1;
      exports.unmemoize = unmemoize;
      exports.until = until;
      exports.waterfall = waterfall$1;
      exports.whilst = whilst$1;
      exports.all = every$1;
      exports.allLimit = everyLimit$1;
      exports.allSeries = everySeries$1;
      exports.any = some$1;
      exports.anyLimit = someLimit$1;
      exports.anySeries = someSeries$1;
      exports.find = detect$1;
      exports.findLimit = detectLimit$1;
      exports.findSeries = detectSeries$1;
      exports.flatMap = concat$1;
      exports.flatMapLimit = concatLimit$1;
      exports.flatMapSeries = concatSeries$1;
      exports.forEach = each;
      exports.forEachSeries = eachSeries$1;
      exports.forEachLimit = eachLimit$2;
      exports.forEachOf = eachOf$1;
      exports.forEachOfSeries = eachOfSeries$1;
      exports.forEachOfLimit = eachOfLimit$2;
      exports.inject = reduce$1;
      exports.foldl = reduce$1;
      exports.foldr = reduceRight;
      exports.select = filter$1;
      exports.selectLimit = filterLimit$1;
      exports.selectSeries = filterSeries$1;
      exports.wrapSync = asyncify;
      exports.during = whilst$1;
      exports.doDuring = doWhilst$1;
  
      Object.defineProperty(exports, '__esModule', { value: true });
  
  })));
  
  }).call(this,require('_process'),require("timers").setImmediate)
  },{"_process":11,"timers":30}],98:[function(require,module,exports){
  'use strict'
  // base-x encoding / decoding
  // Copyright (c) 2018 base-x contributors
  // Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
  // Distributed under the MIT software license, see the accompanying
  // file LICENSE or http://www.opensource.org/licenses/mit-license.php.
  // @ts-ignore
  var _Buffer = require('safe-buffer').Buffer
  function base (ALPHABET) {
    if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
    var BASE_MAP = new Uint8Array(256)
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i)
      var xc = x.charCodeAt(0)
      if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
      BASE_MAP[xc] = i
    }
    var BASE = ALPHABET.length
    var LEADER = ALPHABET.charAt(0)
    var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up
    var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up
    function encode (source) {
      if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }
      if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }
      if (source.length === 0) { return '' }
          // Skip & count leading zeroes.
      var zeroes = 0
      var length = 0
      var pbegin = 0
      var pend = source.length
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++
        zeroes++
      }
          // Allocate enough space in big-endian base58 representation.
      var size = ((pend - pbegin) * iFACTOR + 1) >>> 0
      var b58 = new Uint8Array(size)
          // Process the bytes.
      while (pbegin !== pend) {
        var carry = source[pbegin]
              // Apply "b58 = b58 * 256 + ch".
        var i = 0
        for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
          carry += (256 * b58[it1]) >>> 0
          b58[it1] = (carry % BASE) >>> 0
          carry = (carry / BASE) >>> 0
        }
        if (carry !== 0) { throw new Error('Non-zero carry') }
        length = i
        pbegin++
      }
          // Skip leading zeroes in base58 result.
      var it2 = size - length
      while (it2 !== size && b58[it2] === 0) {
        it2++
      }
          // Translate the result into a string.
      var str = LEADER.repeat(zeroes)
      for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }
      return str
    }
    function decodeUnsafe (source) {
      if (typeof source !== 'string') { throw new TypeError('Expected String') }
      if (source.length === 0) { return _Buffer.alloc(0) }
      var psz = 0
          // Skip leading spaces.
      if (source[psz] === ' ') { return }
          // Skip and count leading '1's.
      var zeroes = 0
      var length = 0
      while (source[psz] === LEADER) {
        zeroes++
        psz++
      }
          // Allocate enough space in big-endian base256 representation.
      var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.
      var b256 = new Uint8Array(size)
          // Process the characters.
      while (source[psz]) {
              // Decode character
        var carry = BASE_MAP[source.charCodeAt(psz)]
              // Invalid character
        if (carry === 255) { return }
        var i = 0
        for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
          carry += (BASE * b256[it3]) >>> 0
          b256[it3] = (carry % 256) >>> 0
          carry = (carry / 256) >>> 0
        }
        if (carry !== 0) { throw new Error('Non-zero carry') }
        length = i
        psz++
      }
          // Skip trailing spaces.
      if (source[psz] === ' ') { return }
          // Skip leading zeroes in b256.
      var it4 = size - length
      while (it4 !== size && b256[it4] === 0) {
        it4++
      }
      var vch = _Buffer.allocUnsafe(zeroes + (size - it4))
      vch.fill(0x00, 0, zeroes)
      var j = zeroes
      while (it4 !== size) {
        vch[j++] = b256[it4++]
      }
      return vch
    }
    function decode (string) {
      var buffer = decodeUnsafe(string)
      if (buffer) { return buffer }
      throw new Error('Non-base' + BASE + ' character')
    }
    return {
      encode: encode,
      decodeUnsafe: decodeUnsafe,
      decode: decode
    }
  }
  module.exports = base
  
  },{"safe-buffer":281}],99:[function(require,module,exports){
  (function (Buffer){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  var pad_string_1 = require("./pad-string");
  function encode(input, encoding) {
      if (encoding === void 0) { encoding = "utf8"; }
      if (Buffer.isBuffer(input)) {
          return fromBase64(input.toString("base64"));
      }
      return fromBase64(Buffer.from(input, encoding).toString("base64"));
  }
  ;
  function decode(base64url, encoding) {
      if (encoding === void 0) { encoding = "utf8"; }
      return Buffer.from(toBase64(base64url), "base64").toString(encoding);
  }
  function toBase64(base64url) {
      base64url = base64url.toString();
      return pad_string_1.default(base64url)
          .replace(/\-/g, "+")
          .replace(/_/g, "/");
  }
  function fromBase64(base64) {
      return base64
          .replace(/=/g, "")
          .replace(/\+/g, "-")
          .replace(/\//g, "_");
  }
  function toBuffer(base64url) {
      return Buffer.from(toBase64(base64url), "base64");
  }
  var base64url = encode;
  base64url.encode = encode;
  base64url.decode = decode;
  base64url.toBase64 = toBase64;
  base64url.fromBase64 = fromBase64;
  base64url.toBuffer = toBuffer;
  exports.default = base64url;
  
  }).call(this,require("buffer").Buffer)
  },{"./pad-string":100,"buffer":3}],100:[function(require,module,exports){
  (function (Buffer){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  function padString(input) {
      var segmentLength = 4;
      var stringLength = input.length;
      var diff = stringLength % segmentLength;
      if (!diff) {
          return input;
      }
      var position = stringLength;
      var padLength = segmentLength - diff;
      var paddedStringLength = stringLength + padLength;
      var buffer = Buffer.alloc(paddedStringLength);
      buffer.write(input);
      while (padLength--) {
          buffer.write("=", position++);
      }
      return buffer.toString();
  }
  exports.default = padString;
  
  }).call(this,require("buffer").Buffer)
  },{"buffer":3}],101:[function(require,module,exports){
  module.exports = require('./dist/base64url').default;
  module.exports.default = module.exports;
  
  },{"./dist/base64url":99}],102:[function(require,module,exports){
  'use strict'
  var ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'
  
  // pre-compute lookup table
  var ALPHABET_MAP = {}
  for (var z = 0; z < ALPHABET.length; z++) {
    var x = ALPHABET.charAt(z)
  
    if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous')
    ALPHABET_MAP[x] = z
  }
  
  function polymodStep (pre) {
    var b = pre >> 25
    return ((pre & 0x1FFFFFF) << 5) ^
      (-((b >> 0) & 1) & 0x3b6a57b2) ^
      (-((b >> 1) & 1) & 0x26508e6d) ^
      (-((b >> 2) & 1) & 0x1ea119fa) ^
      (-((b >> 3) & 1) & 0x3d4233dd) ^
      (-((b >> 4) & 1) & 0x2a1462b3)
  }
  
  function prefixChk (prefix) {
    var chk = 1
    for (var i = 0; i < prefix.length; ++i) {
      var c = prefix.charCodeAt(i)
      if (c < 33 || c > 126) throw new Error('Invalid prefix (' + prefix + ')')
  
      chk = polymodStep(chk) ^ (c >> 5)
    }
    chk = polymodStep(chk)
  
    for (i = 0; i < prefix.length; ++i) {
      var v = prefix.charCodeAt(i)
      chk = polymodStep(chk) ^ (v & 0x1f)
    }
    return chk
  }
  
  function encode (prefix, words, LIMIT) {
    LIMIT = LIMIT || 90
    if ((prefix.length + 7 + words.length) > LIMIT) throw new TypeError('Exceeds length limit')
  
    prefix = prefix.toLowerCase()
  
    // determine chk mod
    var chk = prefixChk(prefix)
    var result = prefix + '1'
    for (var i = 0; i < words.length; ++i) {
      var x = words[i]
      if ((x >> 5) !== 0) throw new Error('Non 5-bit word')
  
      chk = polymodStep(chk) ^ x
      result += ALPHABET.charAt(x)
    }
  
    for (i = 0; i < 6; ++i) {
      chk = polymodStep(chk)
    }
    chk ^= 1
  
    for (i = 0; i < 6; ++i) {
      var v = (chk >> ((5 - i) * 5)) & 0x1f
      result += ALPHABET.charAt(v)
    }
  
    return result
  }
  
  function decode (str, LIMIT) {
    LIMIT = LIMIT || 90
    if (str.length < 8) throw new TypeError(str + ' too short')
    if (str.length > LIMIT) throw new TypeError('Exceeds length limit')
  
    // don't allow mixed case
    var lowered = str.toLowerCase()
    var uppered = str.toUpperCase()
    if (str !== lowered && str !== uppered) throw new Error('Mixed-case string ' + str)
    str = lowered
  
    var split = str.lastIndexOf('1')
    if (split === -1) throw new Error('No separator character for ' + str)
    if (split === 0) throw new Error('Missing prefix for ' + str)
  
    var prefix = str.slice(0, split)
    var wordChars = str.slice(split + 1)
    if (wordChars.length < 6) throw new Error('Data too short')
  
    var chk = prefixChk(prefix)
    var words = []
    for (var i = 0; i < wordChars.length; ++i) {
      var c = wordChars.charAt(i)
      var v = ALPHABET_MAP[c]
      if (v === undefined) throw new Error('Unknown character ' + c)
      chk = polymodStep(chk) ^ v
  
      // not in the checksum?
      if (i + 6 >= wordChars.length) continue
      words.push(v)
    }
  
    if (chk !== 1) throw new Error('Invalid checksum for ' + str)
    return { prefix: prefix, words: words }
  }
  
  function convert (data, inBits, outBits, pad) {
    var value = 0
    var bits = 0
    var maxV = (1 << outBits) - 1
  
    var result = []
    for (var i = 0; i < data.length; ++i) {
      value = (value << inBits) | data[i]
      bits += inBits
  
      while (bits >= outBits) {
        bits -= outBits
        result.push((value >> bits) & maxV)
      }
    }
  
    if (pad) {
      if (bits > 0) {
        result.push((value << (outBits - bits)) & maxV)
      }
    } else {
      if (bits >= inBits) throw new Error('Excess padding')
      if ((value << (outBits - bits)) & maxV) throw new Error('Non-zero padding')
    }
  
    return result
  }
  
  function toWords (bytes) {
    return convert(bytes, 8, 5, true)
  }
  
  function fromWords (words) {
    return convert(words, 5, 8, false)
  }
  
  module.exports = {
    decode: decode,
    encode: encode,
    toWords: toWords,
    fromWords: fromWords
  }
  
  },{}],103:[function(require,module,exports){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const parser_1 = require('../parser');
  function combine(psbts) {
    const self = psbts[0];
    const selfKeyVals = parser_1.psbtToKeyVals(self);
    const others = psbts.slice(1);
    if (others.length === 0) throw new Error('Combine: Nothing to combine');
    const selfTx = getTx(self);
    if (selfTx === undefined) {
      throw new Error('Combine: Self missing transaction');
    }
    const selfGlobalSet = getKeySet(selfKeyVals.globalKeyVals);
    const selfInputSets = selfKeyVals.inputKeyVals.map(getKeySet);
    const selfOutputSets = selfKeyVals.outputKeyVals.map(getKeySet);
    for (const other of others) {
      const otherTx = getTx(other);
      if (
        otherTx === undefined ||
        !otherTx.toBuffer().equals(selfTx.toBuffer())
      ) {
        throw new Error(
          'Combine: One of the Psbts does not have the same transaction.',
        );
      }
      const otherKeyVals = parser_1.psbtToKeyVals(other);
      const otherGlobalSet = getKeySet(otherKeyVals.globalKeyVals);
      otherGlobalSet.forEach(
        keyPusher(
          selfGlobalSet,
          selfKeyVals.globalKeyVals,
          otherKeyVals.globalKeyVals,
        ),
      );
      const otherInputSets = otherKeyVals.inputKeyVals.map(getKeySet);
      otherInputSets.forEach((inputSet, idx) =>
        inputSet.forEach(
          keyPusher(
            selfInputSets[idx],
            selfKeyVals.inputKeyVals[idx],
            otherKeyVals.inputKeyVals[idx],
          ),
        ),
      );
      const otherOutputSets = otherKeyVals.outputKeyVals.map(getKeySet);
      otherOutputSets.forEach((outputSet, idx) =>
        outputSet.forEach(
          keyPusher(
            selfOutputSets[idx],
            selfKeyVals.outputKeyVals[idx],
            otherKeyVals.outputKeyVals[idx],
          ),
        ),
      );
    }
    return parser_1.psbtFromKeyVals(selfTx, {
      globalMapKeyVals: selfKeyVals.globalKeyVals,
      inputKeyVals: selfKeyVals.inputKeyVals,
      outputKeyVals: selfKeyVals.outputKeyVals,
    });
  }
  exports.combine = combine;
  function keyPusher(selfSet, selfKeyVals, otherKeyVals) {
    return key => {
      if (selfSet.has(key)) return;
      const newKv = otherKeyVals.filter(kv => kv.key.toString('hex') === key)[0];
      selfKeyVals.push(newKv);
      selfSet.add(key);
    };
  }
  function getTx(psbt) {
    return psbt.globalMap.unsignedTx;
  }
  function getKeySet(keyVals) {
    const set = new Set();
    keyVals.forEach(keyVal => {
      const hex = keyVal.key.toString('hex');
      if (set.has(hex))
        throw new Error('Combine: KeyValue Map keys should be unique');
      set.add(hex);
    });
    return set;
  }
  
  },{"../parser":121}],104:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const typeFields_1 = require('../../typeFields');
  const range = n => [...Array(n).keys()];
  function decode(keyVal) {
    if (keyVal.key[0] !== typeFields_1.GlobalTypes.GLOBAL_XPUB) {
      throw new Error(
        'Decode Error: could not decode globalXpub with key 0x' +
          keyVal.key.toString('hex'),
      );
    }
    if (keyVal.key.length !== 79 || ![2, 3].includes(keyVal.key[46])) {
      throw new Error(
        'Decode Error: globalXpub has invalid extended pubkey in key 0x' +
          keyVal.key.toString('hex'),
      );
    }
    if ((keyVal.value.length / 4) % 1 !== 0) {
      throw new Error(
        'Decode Error: Global GLOBAL_XPUB value length should be multiple of 4',
      );
    }
    const extendedPubkey = keyVal.key.slice(1);
    const data = {
      masterFingerprint: keyVal.value.slice(0, 4),
      extendedPubkey,
      path: 'm',
    };
    for (const i of range(keyVal.value.length / 4 - 1)) {
      const val = keyVal.value.readUInt32LE(i * 4 + 4);
      const isHard = !!(val & 0x80000000);
      const idx = val & 0x7fffffff;
      data.path += '/' + idx.toString(10) + (isHard ? "'" : '');
    }
    return data;
  }
  exports.decode = decode;
  function encode(data) {
    const head = Buffer.from([typeFields_1.GlobalTypes.GLOBAL_XPUB]);
    const key = Buffer.concat([head, data.extendedPubkey]);
    const splitPath = data.path.split('/');
    const value = Buffer.allocUnsafe(splitPath.length * 4);
    data.masterFingerprint.copy(value, 0);
    let offset = 4;
    splitPath.slice(1).forEach(level => {
      const isHard = level.slice(-1) === "'";
      let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);
      if (isHard) num += 0x80000000;
      value.writeUInt32LE(num, offset);
      offset += 4;
    });
    return {
      key,
      value,
    };
  }
  exports.encode = encode;
  exports.expected =
    '{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }';
  function check(data) {
    const epk = data.extendedPubkey;
    const mfp = data.masterFingerprint;
    const p = data.path;
    return (
      Buffer.isBuffer(epk) &&
      epk.length === 78 &&
      [2, 3].indexOf(epk[45]) > -1 &&
      Buffer.isBuffer(mfp) &&
      mfp.length === 4 &&
      typeof p === 'string' &&
      !!p.match(/^m(\/\d+'?)+$/)
    );
  }
  exports.check = check;
  function canAddToArray(array, item, dupeSet) {
    const dupeString = item.extendedPubkey.toString('hex');
    if (dupeSet.has(dupeString)) return false;
    dupeSet.add(dupeString);
    return (
      array.filter(v => v.extendedPubkey.equals(item.extendedPubkey)).length === 0
    );
  }
  exports.canAddToArray = canAddToArray;
  
  }).call(this,require("buffer").Buffer)
  },{"../../typeFields":124,"buffer":3}],105:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const typeFields_1 = require('../../typeFields');
  function encode(data) {
    return {
      key: Buffer.from([typeFields_1.GlobalTypes.UNSIGNED_TX]),
      value: data.toBuffer(),
    };
  }
  exports.encode = encode;
  
  }).call(this,require("buffer").Buffer)
  },{"../../typeFields":124,"buffer":3}],106:[function(require,module,exports){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const typeFields_1 = require('../typeFields');
  const globalXpub = require('./global/globalXpub');
  const unsignedTx = require('./global/unsignedTx');
  const finalScriptSig = require('./input/finalScriptSig');
  const finalScriptWitness = require('./input/finalScriptWitness');
  const nonWitnessUtxo = require('./input/nonWitnessUtxo');
  const partialSig = require('./input/partialSig');
  const porCommitment = require('./input/porCommitment');
  const sighashType = require('./input/sighashType');
  const witnessUtxo = require('./input/witnessUtxo');
  const bip32Derivation = require('./shared/bip32Derivation');
  const checkPubkey = require('./shared/checkPubkey');
  const redeemScript = require('./shared/redeemScript');
  const witnessScript = require('./shared/witnessScript');
  const globals = {
    unsignedTx,
    globalXpub,
    // pass an Array of key bytes that require pubkey beside the key
    checkPubkey: checkPubkey.makeChecker([]),
  };
  exports.globals = globals;
  const inputs = {
    nonWitnessUtxo,
    partialSig,
    sighashType,
    finalScriptSig,
    finalScriptWitness,
    porCommitment,
    witnessUtxo,
    bip32Derivation: bip32Derivation.makeConverter(
      typeFields_1.InputTypes.BIP32_DERIVATION,
    ),
    redeemScript: redeemScript.makeConverter(
      typeFields_1.InputTypes.REDEEM_SCRIPT,
    ),
    witnessScript: witnessScript.makeConverter(
      typeFields_1.InputTypes.WITNESS_SCRIPT,
    ),
    checkPubkey: checkPubkey.makeChecker([
      typeFields_1.InputTypes.PARTIAL_SIG,
      typeFields_1.InputTypes.BIP32_DERIVATION,
    ]),
  };
  exports.inputs = inputs;
  const outputs = {
    bip32Derivation: bip32Derivation.makeConverter(
      typeFields_1.OutputTypes.BIP32_DERIVATION,
    ),
    redeemScript: redeemScript.makeConverter(
      typeFields_1.OutputTypes.REDEEM_SCRIPT,
    ),
    witnessScript: witnessScript.makeConverter(
      typeFields_1.OutputTypes.WITNESS_SCRIPT,
    ),
    checkPubkey: checkPubkey.makeChecker([
      typeFields_1.OutputTypes.BIP32_DERIVATION,
    ]),
  };
  exports.outputs = outputs;
  
  },{"../typeFields":124,"./global/globalXpub":104,"./global/unsignedTx":105,"./input/finalScriptSig":107,"./input/finalScriptWitness":108,"./input/nonWitnessUtxo":109,"./input/partialSig":110,"./input/porCommitment":111,"./input/sighashType":112,"./input/witnessUtxo":113,"./shared/bip32Derivation":114,"./shared/checkPubkey":115,"./shared/redeemScript":116,"./shared/witnessScript":117}],107:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const typeFields_1 = require('../../typeFields');
  function decode(keyVal) {
    if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTSIG) {
      throw new Error(
        'Decode Error: could not decode finalScriptSig with key 0x' +
          keyVal.key.toString('hex'),
      );
    }
    return keyVal.value;
  }
  exports.decode = decode;
  function encode(data) {
    const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTSIG]);
    return {
      key,
      value: data,
    };
  }
  exports.encode = encode;
  exports.expected = 'Buffer';
  function check(data) {
    return Buffer.isBuffer(data);
  }
  exports.check = check;
  function canAdd(currentData, newData) {
    return !!currentData && !!newData && currentData.finalScriptSig === undefined;
  }
  exports.canAdd = canAdd;
  
  }).call(this,require("buffer").Buffer)
  },{"../../typeFields":124,"buffer":3}],108:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const typeFields_1 = require('../../typeFields');
  function decode(keyVal) {
    if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTWITNESS) {
      throw new Error(
        'Decode Error: could not decode finalScriptWitness with key 0x' +
          keyVal.key.toString('hex'),
      );
    }
    return keyVal.value;
  }
  exports.decode = decode;
  function encode(data) {
    const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTWITNESS]);
    return {
      key,
      value: data,
    };
  }
  exports.encode = encode;
  exports.expected = 'Buffer';
  function check(data) {
    return Buffer.isBuffer(data);
  }
  exports.check = check;
  function canAdd(currentData, newData) {
    return (
      !!currentData && !!newData && currentData.finalScriptWitness === undefined
    );
  }
  exports.canAdd = canAdd;
  
  }).call(this,require("buffer").Buffer)
  },{"../../typeFields":124,"buffer":3}],109:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const typeFields_1 = require('../../typeFields');
  function decode(keyVal) {
    if (keyVal.key[0] !== typeFields_1.InputTypes.NON_WITNESS_UTXO) {
      throw new Error(
        'Decode Error: could not decode nonWitnessUtxo with key 0x' +
          keyVal.key.toString('hex'),
      );
    }
    return keyVal.value;
  }
  exports.decode = decode;
  function encode(data) {
    return {
      key: Buffer.from([typeFields_1.InputTypes.NON_WITNESS_UTXO]),
      value: data,
    };
  }
  exports.encode = encode;
  exports.expected = 'Buffer';
  function check(data) {
    return Buffer.isBuffer(data);
  }
  exports.check = check;
  function canAdd(currentData, newData) {
    return (
      !!currentData &&
      !!newData &&
      currentData.witnessUtxo === undefined &&
      currentData.nonWitnessUtxo === undefined
    );
  }
  exports.canAdd = canAdd;
  
  }).call(this,require("buffer").Buffer)
  },{"../../typeFields":124,"buffer":3}],110:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const typeFields_1 = require('../../typeFields');
  function decode(keyVal) {
    if (keyVal.key[0] !== typeFields_1.InputTypes.PARTIAL_SIG) {
      throw new Error(
        'Decode Error: could not decode partialSig with key 0x' +
          keyVal.key.toString('hex'),
      );
    }
    if (
      !(keyVal.key.length === 34 || keyVal.key.length === 66) ||
      ![2, 3, 4].includes(keyVal.key[1])
    ) {
      throw new Error(
        'Decode Error: partialSig has invalid pubkey in key 0x' +
          keyVal.key.toString('hex'),
      );
    }
    const pubkey = keyVal.key.slice(1);
    return {
      pubkey,
      signature: keyVal.value,
    };
  }
  exports.decode = decode;
  function encode(pSig) {
    const head = Buffer.from([typeFields_1.InputTypes.PARTIAL_SIG]);
    return {
      key: Buffer.concat([head, pSig.pubkey]),
      value: pSig.signature,
    };
  }
  exports.encode = encode;
  exports.expected = '{ pubkey: Buffer; signature: Buffer; }';
  function check(data) {
    return (
      Buffer.isBuffer(data.pubkey) &&
      Buffer.isBuffer(data.signature) &&
      [33, 65].includes(data.pubkey.length) &&
      [2, 3, 4].includes(data.pubkey[0]) &&
      isDerSigWithSighash(data.signature)
    );
  }
  exports.check = check;
  function isDerSigWithSighash(buf) {
    if (!Buffer.isBuffer(buf) || buf.length < 9) return false;
    if (buf[0] !== 0x30) return false;
    if (buf.length !== buf[1] + 3) return false;
    if (buf[2] !== 0x02) return false;
    const rLen = buf[3];
    if (rLen > 33 || rLen < 1) return false;
    if (buf[3 + rLen + 1] !== 0x02) return false;
    const sLen = buf[3 + rLen + 2];
    if (sLen > 33 || sLen < 1) return false;
    if (buf.length !== 3 + rLen + 2 + sLen + 2) return false;
    return true;
  }
  function canAddToArray(array, item, dupeSet) {
    const dupeString = item.pubkey.toString('hex');
    if (dupeSet.has(dupeString)) return false;
    dupeSet.add(dupeString);
    return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;
  }
  exports.canAddToArray = canAddToArray;
  
  }).call(this,require("buffer").Buffer)
  },{"../../typeFields":124,"buffer":3}],111:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const typeFields_1 = require('../../typeFields');
  function decode(keyVal) {
    if (keyVal.key[0] !== typeFields_1.InputTypes.POR_COMMITMENT) {
      throw new Error(
        'Decode Error: could not decode porCommitment with key 0x' +
          keyVal.key.toString('hex'),
      );
    }
    return keyVal.value.toString('utf8');
  }
  exports.decode = decode;
  function encode(data) {
    const key = Buffer.from([typeFields_1.InputTypes.POR_COMMITMENT]);
    return {
      key,
      value: Buffer.from(data, 'utf8'),
    };
  }
  exports.encode = encode;
  exports.expected = 'string';
  function check(data) {
    return typeof data === 'string';
  }
  exports.check = check;
  function canAdd(currentData, newData) {
    return !!currentData && !!newData && currentData.porCommitment === undefined;
  }
  exports.canAdd = canAdd;
  
  }).call(this,require("buffer").Buffer)
  },{"../../typeFields":124,"buffer":3}],112:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const typeFields_1 = require('../../typeFields');
  function decode(keyVal) {
    if (keyVal.key[0] !== typeFields_1.InputTypes.SIGHASH_TYPE) {
      throw new Error(
        'Decode Error: could not decode sighashType with key 0x' +
          keyVal.key.toString('hex'),
      );
    }
    return keyVal.value.readUInt32LE(0);
  }
  exports.decode = decode;
  function encode(data) {
    const key = Buffer.from([typeFields_1.InputTypes.SIGHASH_TYPE]);
    const value = Buffer.allocUnsafe(4);
    value.writeUInt32LE(data, 0);
    return {
      key,
      value,
    };
  }
  exports.encode = encode;
  exports.expected = 'number';
  function check(data) {
    return typeof data === 'number';
  }
  exports.check = check;
  function canAdd(currentData, newData) {
    return !!currentData && !!newData && currentData.sighashType === undefined;
  }
  exports.canAdd = canAdd;
  
  }).call(this,require("buffer").Buffer)
  },{"../../typeFields":124,"buffer":3}],113:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const typeFields_1 = require('../../typeFields');
  const tools_1 = require('../tools');
  const varuint = require('../varint');
  function decode(keyVal) {
    if (keyVal.key[0] !== typeFields_1.InputTypes.WITNESS_UTXO) {
      throw new Error(
        'Decode Error: could not decode witnessUtxo with key 0x' +
          keyVal.key.toString('hex'),
      );
    }
    const value = tools_1.readUInt64LE(keyVal.value, 0);
    let _offset = 8;
    const scriptLen = varuint.decode(keyVal.value, _offset);
    _offset += varuint.encodingLength(scriptLen);
    const script = keyVal.value.slice(_offset);
    if (script.length !== scriptLen) {
      throw new Error('Decode Error: WITNESS_UTXO script is not proper length');
    }
    return {
      script,
      value,
    };
  }
  exports.decode = decode;
  function encode(data) {
    const { script, value } = data;
    const varintLen = varuint.encodingLength(script.length);
    const result = Buffer.allocUnsafe(8 + varintLen + script.length);
    tools_1.writeUInt64LE(result, value, 0);
    varuint.encode(script.length, result, 8);
    script.copy(result, 8 + varintLen);
    return {
      key: Buffer.from([typeFields_1.InputTypes.WITNESS_UTXO]),
      value: result,
    };
  }
  exports.encode = encode;
  exports.expected = '{ script: Buffer; value: number; }';
  function check(data) {
    return Buffer.isBuffer(data.script) && typeof data.value === 'number';
  }
  exports.check = check;
  function canAdd(currentData, newData) {
    return (
      !!currentData &&
      !!newData &&
      currentData.witnessUtxo === undefined &&
      currentData.nonWitnessUtxo === undefined
    );
  }
  exports.canAdd = canAdd;
  
  }).call(this,require("buffer").Buffer)
  },{"../../typeFields":124,"../tools":118,"../varint":119,"buffer":3}],114:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const range = n => [...Array(n).keys()];
  function makeConverter(TYPE_BYTE) {
    function decode(keyVal) {
      if (keyVal.key[0] !== TYPE_BYTE) {
        throw new Error(
          'Decode Error: could not decode bip32Derivation with key 0x' +
            keyVal.key.toString('hex'),
        );
      }
      if (
        !(keyVal.key.length === 34 || keyVal.key.length === 66) ||
        ![2, 3, 4].includes(keyVal.key[1])
      ) {
        throw new Error(
          'Decode Error: bip32Derivation has invalid pubkey in key 0x' +
            keyVal.key.toString('hex'),
        );
      }
      if ((keyVal.value.length / 4) % 1 !== 0) {
        throw new Error(
          'Decode Error: Input BIP32_DERIVATION value length should be multiple of 4',
        );
      }
      const pubkey = keyVal.key.slice(1);
      const data = {
        masterFingerprint: keyVal.value.slice(0, 4),
        pubkey,
        path: 'm',
      };
      for (const i of range(keyVal.value.length / 4 - 1)) {
        const val = keyVal.value.readUInt32LE(i * 4 + 4);
        const isHard = !!(val & 0x80000000);
        const idx = val & 0x7fffffff;
        data.path += '/' + idx.toString(10) + (isHard ? "'" : '');
      }
      return data;
    }
    function encode(data) {
      const head = Buffer.from([TYPE_BYTE]);
      const key = Buffer.concat([head, data.pubkey]);
      const splitPath = data.path.split('/');
      const value = Buffer.allocUnsafe(splitPath.length * 4);
      data.masterFingerprint.copy(value, 0);
      let offset = 4;
      splitPath.slice(1).forEach(level => {
        const isHard = level.slice(-1) === "'";
        let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);
        if (isHard) num += 0x80000000;
        value.writeUInt32LE(num, offset);
        offset += 4;
      });
      return {
        key,
        value,
      };
    }
    const expected =
      '{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }';
    function check(data) {
      return (
        Buffer.isBuffer(data.pubkey) &&
        Buffer.isBuffer(data.masterFingerprint) &&
        typeof data.path === 'string' &&
        [33, 65].includes(data.pubkey.length) &&
        [2, 3, 4].includes(data.pubkey[0]) &&
        data.masterFingerprint.length === 4
      );
    }
    function canAddToArray(array, item, dupeSet) {
      const dupeString = item.pubkey.toString('hex');
      if (dupeSet.has(dupeString)) return false;
      dupeSet.add(dupeString);
      return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;
    }
    return {
      decode,
      encode,
      check,
      expected,
      canAddToArray,
    };
  }
  exports.makeConverter = makeConverter;
  
  }).call(this,require("buffer").Buffer)
  },{"buffer":3}],115:[function(require,module,exports){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  function makeChecker(pubkeyTypes) {
    return checkPubkey;
    function checkPubkey(keyVal) {
      let pubkey;
      if (pubkeyTypes.includes(keyVal.key[0])) {
        pubkey = keyVal.key.slice(1);
        if (
          !(pubkey.length === 33 || pubkey.length === 65) ||
          ![2, 3, 4].includes(pubkey[0])
        ) {
          throw new Error(
            'Format Error: invalid pubkey in key 0x' + keyVal.key.toString('hex'),
          );
        }
      }
      return pubkey;
    }
  }
  exports.makeChecker = makeChecker;
  
  },{}],116:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  function makeConverter(TYPE_BYTE) {
    function decode(keyVal) {
      if (keyVal.key[0] !== TYPE_BYTE) {
        throw new Error(
          'Decode Error: could not decode redeemScript with key 0x' +
            keyVal.key.toString('hex'),
        );
      }
      return keyVal.value;
    }
    function encode(data) {
      const key = Buffer.from([TYPE_BYTE]);
      return {
        key,
        value: data,
      };
    }
    const expected = 'Buffer';
    function check(data) {
      return Buffer.isBuffer(data);
    }
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.redeemScript === undefined;
    }
    return {
      decode,
      encode,
      check,
      expected,
      canAdd,
    };
  }
  exports.makeConverter = makeConverter;
  
  }).call(this,require("buffer").Buffer)
  },{"buffer":3}],117:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  function makeConverter(TYPE_BYTE) {
    function decode(keyVal) {
      if (keyVal.key[0] !== TYPE_BYTE) {
        throw new Error(
          'Decode Error: could not decode witnessScript with key 0x' +
            keyVal.key.toString('hex'),
        );
      }
      return keyVal.value;
    }
    function encode(data) {
      const key = Buffer.from([TYPE_BYTE]);
      return {
        key,
        value: data,
      };
    }
    const expected = 'Buffer';
    function check(data) {
      return Buffer.isBuffer(data);
    }
    function canAdd(currentData, newData) {
      return (
        !!currentData && !!newData && currentData.witnessScript === undefined
      );
    }
    return {
      decode,
      encode,
      check,
      expected,
      canAdd,
    };
  }
  exports.makeConverter = makeConverter;
  
  }).call(this,require("buffer").Buffer)
  },{"buffer":3}],118:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const varuint = require('./varint');
  exports.range = n => [...Array(n).keys()];
  function reverseBuffer(buffer) {
    if (buffer.length < 1) return buffer;
    let j = buffer.length - 1;
    let tmp = 0;
    for (let i = 0; i < buffer.length / 2; i++) {
      tmp = buffer[i];
      buffer[i] = buffer[j];
      buffer[j] = tmp;
      j--;
    }
    return buffer;
  }
  exports.reverseBuffer = reverseBuffer;
  function keyValsToBuffer(keyVals) {
    const buffers = keyVals.map(keyValToBuffer);
    buffers.push(Buffer.from([0]));
    return Buffer.concat(buffers);
  }
  exports.keyValsToBuffer = keyValsToBuffer;
  function keyValToBuffer(keyVal) {
    const keyLen = keyVal.key.length;
    const valLen = keyVal.value.length;
    const keyVarIntLen = varuint.encodingLength(keyLen);
    const valVarIntLen = varuint.encodingLength(valLen);
    const buffer = Buffer.allocUnsafe(
      keyVarIntLen + keyLen + valVarIntLen + valLen,
    );
    varuint.encode(keyLen, buffer, 0);
    keyVal.key.copy(buffer, keyVarIntLen);
    varuint.encode(valLen, buffer, keyVarIntLen + keyLen);
    keyVal.value.copy(buffer, keyVarIntLen + keyLen + valVarIntLen);
    return buffer;
  }
  exports.keyValToBuffer = keyValToBuffer;
  // https://github.com/feross/buffer/blob/master/index.js#L1127
  function verifuint(value, max) {
    if (typeof value !== 'number')
      throw new Error('cannot write a non-number as a number');
    if (value < 0)
      throw new Error('specified a negative value for writing an unsigned value');
    if (value > max) throw new Error('RangeError: value out of range');
    if (Math.floor(value) !== value)
      throw new Error('value has a fractional component');
  }
  function readUInt64LE(buffer, offset) {
    const a = buffer.readUInt32LE(offset);
    let b = buffer.readUInt32LE(offset + 4);
    b *= 0x100000000;
    verifuint(b + a, 0x001fffffffffffff);
    return b + a;
  }
  exports.readUInt64LE = readUInt64LE;
  function writeUInt64LE(buffer, value, offset) {
    verifuint(value, 0x001fffffffffffff);
    buffer.writeInt32LE(value & -1, offset);
    buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);
    return offset + 8;
  }
  exports.writeUInt64LE = writeUInt64LE;
  
  }).call(this,require("buffer").Buffer)
  },{"./varint":119,"buffer":3}],119:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  // Number.MAX_SAFE_INTEGER
  const MAX_SAFE_INTEGER = 9007199254740991;
  function checkUInt53(n) {
    if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0)
      throw new RangeError('value out of range');
  }
  function encode(_number, buffer, offset) {
    checkUInt53(_number);
    if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(_number));
    if (!Buffer.isBuffer(buffer))
      throw new TypeError('buffer must be a Buffer instance');
    if (!offset) offset = 0;
    // 8 bit
    if (_number < 0xfd) {
      buffer.writeUInt8(_number, offset);
      Object.assign(encode, { bytes: 1 });
      // 16 bit
    } else if (_number <= 0xffff) {
      buffer.writeUInt8(0xfd, offset);
      buffer.writeUInt16LE(_number, offset + 1);
      Object.assign(encode, { bytes: 3 });
      // 32 bit
    } else if (_number <= 0xffffffff) {
      buffer.writeUInt8(0xfe, offset);
      buffer.writeUInt32LE(_number, offset + 1);
      Object.assign(encode, { bytes: 5 });
      // 64 bit
    } else {
      buffer.writeUInt8(0xff, offset);
      buffer.writeUInt32LE(_number >>> 0, offset + 1);
      buffer.writeUInt32LE((_number / 0x100000000) | 0, offset + 5);
      Object.assign(encode, { bytes: 9 });
    }
    return buffer;
  }
  exports.encode = encode;
  function decode(buffer, offset) {
    if (!Buffer.isBuffer(buffer))
      throw new TypeError('buffer must be a Buffer instance');
    if (!offset) offset = 0;
    const first = buffer.readUInt8(offset);
    // 8 bit
    if (first < 0xfd) {
      Object.assign(decode, { bytes: 1 });
      return first;
      // 16 bit
    } else if (first === 0xfd) {
      Object.assign(decode, { bytes: 3 });
      return buffer.readUInt16LE(offset + 1);
      // 32 bit
    } else if (first === 0xfe) {
      Object.assign(decode, { bytes: 5 });
      return buffer.readUInt32LE(offset + 1);
      // 64 bit
    } else {
      Object.assign(decode, { bytes: 9 });
      const lo = buffer.readUInt32LE(offset + 1);
      const hi = buffer.readUInt32LE(offset + 5);
      const _number = hi * 0x0100000000 + lo;
      checkUInt53(_number);
      return _number;
    }
  }
  exports.decode = decode;
  function encodingLength(_number) {
    checkUInt53(_number);
    return _number < 0xfd
      ? 1
      : _number <= 0xffff
      ? 3
      : _number <= 0xffffffff
      ? 5
      : 9;
  }
  exports.encodingLength = encodingLength;
  
  }).call(this,require("buffer").Buffer)
  },{"buffer":3}],120:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const convert = require('../converter');
  const tools_1 = require('../converter/tools');
  const varuint = require('../converter/varint');
  const typeFields_1 = require('../typeFields');
  function psbtFromBuffer(buffer, txGetter) {
    let offset = 0;
    function varSlice() {
      const keyLen = varuint.decode(buffer, offset);
      offset += varuint.encodingLength(keyLen);
      const key = buffer.slice(offset, offset + keyLen);
      offset += keyLen;
      return key;
    }
    function readUInt32BE() {
      const num = buffer.readUInt32BE(offset);
      offset += 4;
      return num;
    }
    function readUInt8() {
      const num = buffer.readUInt8(offset);
      offset += 1;
      return num;
    }
    function getKeyValue() {
      const key = varSlice();
      const value = varSlice();
      return {
        key,
        value,
      };
    }
    function checkEndOfKeyValPairs() {
      if (offset >= buffer.length) {
        throw new Error('Format Error: Unexpected End of PSBT');
      }
      const isEnd = buffer.readUInt8(offset) === 0;
      if (isEnd) {
        offset++;
      }
      return isEnd;
    }
    if (readUInt32BE() !== 0x70736274) {
      throw new Error('Format Error: Invalid Magic Number');
    }
    if (readUInt8() !== 0xff) {
      throw new Error(
        'Format Error: Magic Number must be followed by 0xff separator',
      );
    }
    const globalMapKeyVals = [];
    const globalKeyIndex = {};
    while (!checkEndOfKeyValPairs()) {
      const keyVal = getKeyValue();
      const hexKey = keyVal.key.toString('hex');
      if (globalKeyIndex[hexKey]) {
        throw new Error(
          'Format Error: Keys must be unique for global keymap: key ' + hexKey,
        );
      }
      globalKeyIndex[hexKey] = 1;
      globalMapKeyVals.push(keyVal);
    }
    const unsignedTxMaps = globalMapKeyVals.filter(
      keyVal => keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX,
    );
    if (unsignedTxMaps.length !== 1) {
      throw new Error('Format Error: Only one UNSIGNED_TX allowed');
    }
    const unsignedTx = txGetter(unsignedTxMaps[0].value);
    // Get input and output counts to loop the respective fields
    const { inputCount, outputCount } = unsignedTx.getInputOutputCounts();
    const inputKeyVals = [];
    const outputKeyVals = [];
    // Get input fields
    for (const index of tools_1.range(inputCount)) {
      const inputKeyIndex = {};
      const input = [];
      while (!checkEndOfKeyValPairs()) {
        const keyVal = getKeyValue();
        const hexKey = keyVal.key.toString('hex');
        if (inputKeyIndex[hexKey]) {
          throw new Error(
            'Format Error: Keys must be unique for each input: ' +
              'input index ' +
              index +
              ' key ' +
              hexKey,
          );
        }
        inputKeyIndex[hexKey] = 1;
        input.push(keyVal);
      }
      inputKeyVals.push(input);
    }
    for (const index of tools_1.range(outputCount)) {
      const outputKeyIndex = {};
      const output = [];
      while (!checkEndOfKeyValPairs()) {
        const keyVal = getKeyValue();
        const hexKey = keyVal.key.toString('hex');
        if (outputKeyIndex[hexKey]) {
          throw new Error(
            'Format Error: Keys must be unique for each output: ' +
              'output index ' +
              index +
              ' key ' +
              hexKey,
          );
        }
        outputKeyIndex[hexKey] = 1;
        output.push(keyVal);
      }
      outputKeyVals.push(output);
    }
    return psbtFromKeyVals(unsignedTx, {
      globalMapKeyVals,
      inputKeyVals,
      outputKeyVals,
    });
  }
  exports.psbtFromBuffer = psbtFromBuffer;
  function checkKeyBuffer(type, keyBuf, keyNum) {
    if (!keyBuf.equals(Buffer.from([keyNum]))) {
      throw new Error(
        `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,
      );
    }
  }
  exports.checkKeyBuffer = checkKeyBuffer;
  function psbtFromKeyVals(
    unsignedTx,
    { globalMapKeyVals, inputKeyVals, outputKeyVals },
  ) {
    // That was easy :-)
    const globalMap = {
      unsignedTx,
    };
    let txCount = 0;
    for (const keyVal of globalMapKeyVals) {
      // If a globalMap item needs pubkey, uncomment
      // const pubkey = convert.globals.checkPubkey(keyVal);
      switch (keyVal.key[0]) {
        case typeFields_1.GlobalTypes.UNSIGNED_TX:
          checkKeyBuffer(
            'global',
            keyVal.key,
            typeFields_1.GlobalTypes.UNSIGNED_TX,
          );
          if (txCount > 0) {
            throw new Error('Format Error: GlobalMap has multiple UNSIGNED_TX');
          }
          txCount++;
          break;
        case typeFields_1.GlobalTypes.GLOBAL_XPUB:
          if (globalMap.globalXpub === undefined) {
            globalMap.globalXpub = [];
          }
          globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));
          break;
        default:
          // This will allow inclusion during serialization.
          if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];
          globalMap.unknownKeyVals.push(keyVal);
      }
    }
    // Get input and output counts to loop the respective fields
    const inputCount = inputKeyVals.length;
    const outputCount = outputKeyVals.length;
    const inputs = [];
    const outputs = [];
    // Get input fields
    for (const index of tools_1.range(inputCount)) {
      const input = {};
      for (const keyVal of inputKeyVals[index]) {
        convert.inputs.checkPubkey(keyVal);
        switch (keyVal.key[0]) {
          case typeFields_1.InputTypes.NON_WITNESS_UTXO:
            checkKeyBuffer(
              'input',
              keyVal.key,
              typeFields_1.InputTypes.NON_WITNESS_UTXO,
            );
            if (
              input.nonWitnessUtxo !== undefined ||
              input.witnessUtxo !== undefined
            ) {
              throw new Error(
                'Format Error: Input has multiple [NON_]WITNESS_UTXO',
              );
            }
            input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);
            break;
          case typeFields_1.InputTypes.WITNESS_UTXO:
            checkKeyBuffer(
              'input',
              keyVal.key,
              typeFields_1.InputTypes.WITNESS_UTXO,
            );
            if (
              input.nonWitnessUtxo !== undefined ||
              input.witnessUtxo !== undefined
            ) {
              throw new Error(
                'Format Error: Input has multiple [NON_]WITNESS_UTXO',
              );
            }
            input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);
            break;
          case typeFields_1.InputTypes.PARTIAL_SIG:
            if (input.partialSig === undefined) {
              input.partialSig = [];
            }
            input.partialSig.push(convert.inputs.partialSig.decode(keyVal));
            break;
          case typeFields_1.InputTypes.SIGHASH_TYPE:
            checkKeyBuffer(
              'input',
              keyVal.key,
              typeFields_1.InputTypes.SIGHASH_TYPE,
            );
            if (input.sighashType !== undefined) {
              throw new Error('Format Error: Input has multiple SIGHASH_TYPE');
            }
            input.sighashType = convert.inputs.sighashType.decode(keyVal);
            break;
          case typeFields_1.InputTypes.REDEEM_SCRIPT:
            checkKeyBuffer(
              'input',
              keyVal.key,
              typeFields_1.InputTypes.REDEEM_SCRIPT,
            );
            if (input.redeemScript !== undefined) {
              throw new Error('Format Error: Input has multiple REDEEM_SCRIPT');
            }
            input.redeemScript = convert.inputs.redeemScript.decode(keyVal);
            break;
          case typeFields_1.InputTypes.WITNESS_SCRIPT:
            checkKeyBuffer(
              'input',
              keyVal.key,
              typeFields_1.InputTypes.WITNESS_SCRIPT,
            );
            if (input.witnessScript !== undefined) {
              throw new Error('Format Error: Input has multiple WITNESS_SCRIPT');
            }
            input.witnessScript = convert.inputs.witnessScript.decode(keyVal);
            break;
          case typeFields_1.InputTypes.BIP32_DERIVATION:
            if (input.bip32Derivation === undefined) {
              input.bip32Derivation = [];
            }
            input.bip32Derivation.push(
              convert.inputs.bip32Derivation.decode(keyVal),
            );
            break;
          case typeFields_1.InputTypes.FINAL_SCRIPTSIG:
            checkKeyBuffer(
              'input',
              keyVal.key,
              typeFields_1.InputTypes.FINAL_SCRIPTSIG,
            );
            input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);
            break;
          case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:
            checkKeyBuffer(
              'input',
              keyVal.key,
              typeFields_1.InputTypes.FINAL_SCRIPTWITNESS,
            );
            input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(
              keyVal,
            );
            break;
          case typeFields_1.InputTypes.POR_COMMITMENT:
            checkKeyBuffer(
              'input',
              keyVal.key,
              typeFields_1.InputTypes.POR_COMMITMENT,
            );
            input.porCommitment = convert.inputs.porCommitment.decode(keyVal);
            break;
          default:
            // This will allow inclusion during serialization.
            if (!input.unknownKeyVals) input.unknownKeyVals = [];
            input.unknownKeyVals.push(keyVal);
        }
      }
      inputs.push(input);
    }
    for (const index of tools_1.range(outputCount)) {
      const output = {};
      for (const keyVal of outputKeyVals[index]) {
        convert.outputs.checkPubkey(keyVal);
        switch (keyVal.key[0]) {
          case typeFields_1.OutputTypes.REDEEM_SCRIPT:
            checkKeyBuffer(
              'output',
              keyVal.key,
              typeFields_1.OutputTypes.REDEEM_SCRIPT,
            );
            if (output.redeemScript !== undefined) {
              throw new Error('Format Error: Output has multiple REDEEM_SCRIPT');
            }
            output.redeemScript = convert.outputs.redeemScript.decode(keyVal);
            break;
          case typeFields_1.OutputTypes.WITNESS_SCRIPT:
            checkKeyBuffer(
              'output',
              keyVal.key,
              typeFields_1.OutputTypes.WITNESS_SCRIPT,
            );
            if (output.witnessScript !== undefined) {
              throw new Error('Format Error: Output has multiple WITNESS_SCRIPT');
            }
            output.witnessScript = convert.outputs.witnessScript.decode(keyVal);
            break;
          case typeFields_1.OutputTypes.BIP32_DERIVATION:
            if (output.bip32Derivation === undefined) {
              output.bip32Derivation = [];
            }
            output.bip32Derivation.push(
              convert.outputs.bip32Derivation.decode(keyVal),
            );
            break;
          default:
            if (!output.unknownKeyVals) output.unknownKeyVals = [];
            output.unknownKeyVals.push(keyVal);
        }
      }
      outputs.push(output);
    }
    return { globalMap, inputs, outputs };
  }
  exports.psbtFromKeyVals = psbtFromKeyVals;
  
  }).call(this,require("buffer").Buffer)
  },{"../converter":106,"../converter/tools":118,"../converter/varint":119,"../typeFields":124,"buffer":3}],121:[function(require,module,exports){
  'use strict';
  function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
  Object.defineProperty(exports, '__esModule', { value: true });
  __export(require('./fromBuffer'));
  __export(require('./toBuffer'));
  
  },{"./fromBuffer":120,"./toBuffer":122}],122:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const convert = require('../converter');
  const tools_1 = require('../converter/tools');
  function psbtToBuffer({ globalMap, inputs, outputs }) {
    const { globalKeyVals, inputKeyVals, outputKeyVals } = psbtToKeyVals({
      globalMap,
      inputs,
      outputs,
    });
    const globalBuffer = tools_1.keyValsToBuffer(globalKeyVals);
    const keyValsOrEmptyToBuffer = keyVals =>
      keyVals.length === 0
        ? [Buffer.from([0])]
        : keyVals.map(tools_1.keyValsToBuffer);
    const inputBuffers = keyValsOrEmptyToBuffer(inputKeyVals);
    const outputBuffers = keyValsOrEmptyToBuffer(outputKeyVals);
    const header = Buffer.allocUnsafe(5);
    header.writeUIntBE(0x70736274ff, 0, 5);
    return Buffer.concat(
      [header, globalBuffer].concat(inputBuffers, outputBuffers),
    );
  }
  exports.psbtToBuffer = psbtToBuffer;
  const sortKeyVals = (a, b) => {
    return a.key.compare(b.key);
  };
  function keyValsFromMap(keyValMap, converterFactory) {
    const keyHexSet = new Set();
    const keyVals = Object.entries(keyValMap).reduce((result, [key, value]) => {
      if (key === 'unknownKeyVals') return result;
      // We are checking for undefined anyways. So ignore TS error
      // @ts-ignore
      const converter = converterFactory[key];
      if (converter === undefined) return result;
      const encodedKeyVals = (Array.isArray(value) ? value : [value]).map(
        converter.encode,
      );
      const keyHexes = encodedKeyVals.map(kv => kv.key.toString('hex'));
      keyHexes.forEach(hex => {
        if (keyHexSet.has(hex))
          throw new Error('Serialize Error: Duplicate key: ' + hex);
        keyHexSet.add(hex);
      });
      return result.concat(encodedKeyVals);
    }, []);
    // Get other keyVals that have not yet been gotten
    const otherKeyVals = keyValMap.unknownKeyVals
      ? keyValMap.unknownKeyVals.filter(keyVal => {
          return !keyHexSet.has(keyVal.key.toString('hex'));
        })
      : [];
    return keyVals.concat(otherKeyVals).sort(sortKeyVals);
  }
  function psbtToKeyVals({ globalMap, inputs, outputs }) {
    // First parse the global keyVals
    // Get any extra keyvals to pass along
    return {
      globalKeyVals: keyValsFromMap(globalMap, convert.globals),
      inputKeyVals: inputs.map(i => keyValsFromMap(i, convert.inputs)),
      outputKeyVals: outputs.map(o => keyValsFromMap(o, convert.outputs)),
    };
  }
  exports.psbtToKeyVals = psbtToKeyVals;
  
  }).call(this,require("buffer").Buffer)
  },{"../converter":106,"../converter/tools":118,"buffer":3}],123:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const combiner_1 = require('./combiner');
  const parser_1 = require('./parser');
  const typeFields_1 = require('./typeFields');
  const utils_1 = require('./utils');
  class Psbt {
    constructor(tx) {
      this.inputs = [];
      this.outputs = [];
      this.globalMap = {
        unsignedTx: tx,
      };
    }
    static fromBase64(data, txFromBuffer) {
      const buffer = Buffer.from(data, 'base64');
      return this.fromBuffer(buffer, txFromBuffer);
    }
    static fromHex(data, txFromBuffer) {
      const buffer = Buffer.from(data, 'hex');
      return this.fromBuffer(buffer, txFromBuffer);
    }
    static fromBuffer(buffer, txFromBuffer) {
      const results = parser_1.psbtFromBuffer(buffer, txFromBuffer);
      const psbt = new this(results.globalMap.unsignedTx);
      Object.assign(psbt, results);
      return psbt;
    }
    toBase64() {
      const buffer = this.toBuffer();
      return buffer.toString('base64');
    }
    toHex() {
      const buffer = this.toBuffer();
      return buffer.toString('hex');
    }
    toBuffer() {
      return parser_1.psbtToBuffer(this);
    }
    updateGlobal(updateData) {
      utils_1.updateGlobal(updateData, this.globalMap);
      return this;
    }
    updateInput(inputIndex, updateData) {
      const input = utils_1.checkForInput(this.inputs, inputIndex);
      utils_1.updateInput(updateData, input);
      return this;
    }
    updateOutput(outputIndex, updateData) {
      const output = utils_1.checkForOutput(this.outputs, outputIndex);
      utils_1.updateOutput(updateData, output);
      return this;
    }
    addUnknownKeyValToGlobal(keyVal) {
      utils_1.checkHasKey(
        keyVal,
        this.globalMap.unknownKeyVals,
        utils_1.getEnumLength(typeFields_1.GlobalTypes),
      );
      if (!this.globalMap.unknownKeyVals) this.globalMap.unknownKeyVals = [];
      this.globalMap.unknownKeyVals.push(keyVal);
      return this;
    }
    addUnknownKeyValToInput(inputIndex, keyVal) {
      const input = utils_1.checkForInput(this.inputs, inputIndex);
      utils_1.checkHasKey(
        keyVal,
        input.unknownKeyVals,
        utils_1.getEnumLength(typeFields_1.InputTypes),
      );
      if (!input.unknownKeyVals) input.unknownKeyVals = [];
      input.unknownKeyVals.push(keyVal);
      return this;
    }
    addUnknownKeyValToOutput(outputIndex, keyVal) {
      const output = utils_1.checkForOutput(this.outputs, outputIndex);
      utils_1.checkHasKey(
        keyVal,
        output.unknownKeyVals,
        utils_1.getEnumLength(typeFields_1.OutputTypes),
      );
      if (!output.unknownKeyVals) output.unknownKeyVals = [];
      output.unknownKeyVals.push(keyVal);
      return this;
    }
    addInput(inputData) {
      this.globalMap.unsignedTx.addInput(inputData);
      this.inputs.push({
        unknownKeyVals: [],
      });
      const addKeyVals = inputData.unknownKeyVals || [];
      const inputIndex = this.inputs.length - 1;
      if (!Array.isArray(addKeyVals)) {
        throw new Error('unknownKeyVals must be an Array');
      }
      addKeyVals.forEach(keyVal =>
        this.addUnknownKeyValToInput(inputIndex, keyVal),
      );
      utils_1.addInputAttributes(this.inputs, inputData);
      return this;
    }
    addOutput(outputData) {
      this.globalMap.unsignedTx.addOutput(outputData);
      this.outputs.push({
        unknownKeyVals: [],
      });
      const addKeyVals = outputData.unknownKeyVals || [];
      const outputIndex = this.outputs.length - 1;
      if (!Array.isArray(addKeyVals)) {
        throw new Error('unknownKeyVals must be an Array');
      }
      addKeyVals.forEach(keyVal =>
        this.addUnknownKeyValToInput(outputIndex, keyVal),
      );
      utils_1.addOutputAttributes(this.outputs, outputData);
      return this;
    }
    clearFinalizedInput(inputIndex) {
      const input = utils_1.checkForInput(this.inputs, inputIndex);
      utils_1.inputCheckUncleanFinalized(inputIndex, input);
      for (const key of Object.keys(input)) {
        if (
          ![
            'witnessUtxo',
            'nonWitnessUtxo',
            'finalScriptSig',
            'finalScriptWitness',
            'unknownKeyVals',
          ].includes(key)
        ) {
          // @ts-ignore
          delete input[key];
        }
      }
      return this;
    }
    combine(...those) {
      // Combine this with those.
      // Return self for chaining.
      const result = combiner_1.combine([this].concat(those));
      Object.assign(this, result);
      return this;
    }
    getTransaction() {
      return this.globalMap.unsignedTx.toBuffer();
    }
  }
  exports.Psbt = Psbt;
  
  }).call(this,require("buffer").Buffer)
  },{"./combiner":103,"./parser":121,"./typeFields":124,"./utils":125,"buffer":3}],124:[function(require,module,exports){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  var GlobalTypes;
  (function(GlobalTypes) {
    GlobalTypes[(GlobalTypes['UNSIGNED_TX'] = 0)] = 'UNSIGNED_TX';
    GlobalTypes[(GlobalTypes['GLOBAL_XPUB'] = 1)] = 'GLOBAL_XPUB';
  })((GlobalTypes = exports.GlobalTypes || (exports.GlobalTypes = {})));
  exports.GLOBAL_TYPE_NAMES = ['unsignedTx', 'globalXpub'];
  var InputTypes;
  (function(InputTypes) {
    InputTypes[(InputTypes['NON_WITNESS_UTXO'] = 0)] = 'NON_WITNESS_UTXO';
    InputTypes[(InputTypes['WITNESS_UTXO'] = 1)] = 'WITNESS_UTXO';
    InputTypes[(InputTypes['PARTIAL_SIG'] = 2)] = 'PARTIAL_SIG';
    InputTypes[(InputTypes['SIGHASH_TYPE'] = 3)] = 'SIGHASH_TYPE';
    InputTypes[(InputTypes['REDEEM_SCRIPT'] = 4)] = 'REDEEM_SCRIPT';
    InputTypes[(InputTypes['WITNESS_SCRIPT'] = 5)] = 'WITNESS_SCRIPT';
    InputTypes[(InputTypes['BIP32_DERIVATION'] = 6)] = 'BIP32_DERIVATION';
    InputTypes[(InputTypes['FINAL_SCRIPTSIG'] = 7)] = 'FINAL_SCRIPTSIG';
    InputTypes[(InputTypes['FINAL_SCRIPTWITNESS'] = 8)] = 'FINAL_SCRIPTWITNESS';
    InputTypes[(InputTypes['POR_COMMITMENT'] = 9)] = 'POR_COMMITMENT';
  })((InputTypes = exports.InputTypes || (exports.InputTypes = {})));
  exports.INPUT_TYPE_NAMES = [
    'nonWitnessUtxo',
    'witnessUtxo',
    'partialSig',
    'sighashType',
    'redeemScript',
    'witnessScript',
    'bip32Derivation',
    'finalScriptSig',
    'finalScriptWitness',
    'porCommitment',
  ];
  var OutputTypes;
  (function(OutputTypes) {
    OutputTypes[(OutputTypes['REDEEM_SCRIPT'] = 0)] = 'REDEEM_SCRIPT';
    OutputTypes[(OutputTypes['WITNESS_SCRIPT'] = 1)] = 'WITNESS_SCRIPT';
    OutputTypes[(OutputTypes['BIP32_DERIVATION'] = 2)] = 'BIP32_DERIVATION';
  })((OutputTypes = exports.OutputTypes || (exports.OutputTypes = {})));
  exports.OUTPUT_TYPE_NAMES = [
    'redeemScript',
    'witnessScript',
    'bip32Derivation',
  ];
  
  },{}],125:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const converter = require('./converter');
  function checkForInput(inputs, inputIndex) {
    const input = inputs[inputIndex];
    if (input === undefined) throw new Error(`No input #${inputIndex}`);
    return input;
  }
  exports.checkForInput = checkForInput;
  function checkForOutput(outputs, outputIndex) {
    const output = outputs[outputIndex];
    if (output === undefined) throw new Error(`No output #${outputIndex}`);
    return output;
  }
  exports.checkForOutput = checkForOutput;
  function checkHasKey(checkKeyVal, keyVals, enumLength) {
    if (checkKeyVal.key[0] < enumLength) {
      throw new Error(
        `Use the method for your specific key instead of addUnknownKeyVal*`,
      );
    }
    if (
      keyVals &&
      keyVals.filter(kv => kv.key.equals(checkKeyVal.key)).length !== 0
    ) {
      throw new Error(`Duplicate Key: ${checkKeyVal.key.toString('hex')}`);
    }
  }
  exports.checkHasKey = checkHasKey;
  function getEnumLength(myenum) {
    let count = 0;
    Object.keys(myenum).forEach(val => {
      if (Number(isNaN(Number(val)))) {
        count++;
      }
    });
    return count;
  }
  exports.getEnumLength = getEnumLength;
  function inputCheckUncleanFinalized(inputIndex, input) {
    let result = false;
    if (!input.nonWitnessUtxo !== !input.witnessUtxo) {
      const needScriptSig = !!input.redeemScript;
      const needWitnessScript = !!input.witnessScript;
      const scriptSigOK = !needScriptSig || !!input.finalScriptSig;
      const witnessScriptOK = !needWitnessScript || !!input.finalScriptWitness;
      const hasOneFinal = !!input.finalScriptSig || !!input.finalScriptWitness;
      result = scriptSigOK && witnessScriptOK && hasOneFinal;
    }
    if (result === false) {
      throw new Error(
        `Input #${inputIndex} has too much or too little data to clean`,
      );
    }
  }
  exports.inputCheckUncleanFinalized = inputCheckUncleanFinalized;
  function throwForUpdateMaker(typeName, name, expected, data) {
    throw new Error(
      `Data for ${typeName} key ${name} is incorrect: Expected ` +
        `${expected} and got ${JSON.stringify(data)}`,
    );
  }
  function updateMaker(typeName) {
    return (updateData, mainData) => {
      for (const name of Object.keys(updateData)) {
        // @ts-ignore
        const data = updateData[name];
        // @ts-ignore
        const { canAdd, canAddToArray, check, expected } =
          // @ts-ignore
          converter[typeName + 's'][name] || {};
        const isArray = !!canAddToArray;
        // If unknown data. ignore and do not add
        if (check) {
          if (isArray) {
            if (
              !Array.isArray(data) ||
              // @ts-ignore
              (mainData[name] && !Array.isArray(mainData[name]))
            ) {
              throw new Error(`Key type ${name} must be an array`);
            }
            if (!data.every(check)) {
              throwForUpdateMaker(typeName, name, expected, data);
            }
            // @ts-ignore
            const arr = mainData[name] || [];
            const dupeCheckSet = new Set();
            if (!data.every(v => canAddToArray(arr, v, dupeCheckSet))) {
              throw new Error('Can not add duplicate data to array');
            }
            // @ts-ignore
            mainData[name] = arr.concat(data);
          } else {
            if (!check(data)) {
              throwForUpdateMaker(typeName, name, expected, data);
            }
            if (!canAdd(mainData, data)) {
              throw new Error(`Can not add duplicate data to ${typeName}`);
            }
            // @ts-ignore
            mainData[name] = data;
          }
        }
      }
    };
  }
  exports.updateGlobal = updateMaker('global');
  exports.updateInput = updateMaker('input');
  exports.updateOutput = updateMaker('output');
  function addInputAttributes(inputs, data) {
    const index = inputs.length - 1;
    const input = checkForInput(inputs, index);
    exports.updateInput(data, input);
  }
  exports.addInputAttributes = addInputAttributes;
  function addOutputAttributes(outputs, data) {
    const index = outputs.length - 1;
    const output = checkForInput(outputs, index);
    exports.updateOutput(data, output);
  }
  exports.addOutputAttributes = addOutputAttributes;
  function defaultVersionSetter(version, txBuf) {
    if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {
      throw new Error('Set Version: Invalid Transaction');
    }
    txBuf.writeUInt32LE(version, 0);
    return txBuf;
  }
  exports.defaultVersionSetter = defaultVersionSetter;
  function defaultLocktimeSetter(locktime, txBuf) {
    if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {
      throw new Error('Set Locktime: Invalid Transaction');
    }
    txBuf.writeUInt32LE(locktime, txBuf.length - 4);
    return txBuf;
  }
  exports.defaultLocktimeSetter = defaultLocktimeSetter;
  
  }).call(this,{"isBuffer":require("C:/Users/Johnny/AppData/Roaming/npm/node_modules/browserify/node_modules/is-buffer/index.js")})
  },{"./converter":106,"C:/Users/Johnny/AppData/Roaming/npm/node_modules/browserify/node_modules/is-buffer/index.js":8}],126:[function(require,module,exports){
  (function (Buffer){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const crypto = require("./crypto");
  const bs58check = require('bs58check');
  const ecc = require('tiny-secp256k1');
  const typeforce = require('typeforce');
  const wif = require('wif');
  const UINT256_TYPE = typeforce.BufferN(32);
  const NETWORK_TYPE = typeforce.compile({
      wif: typeforce.UInt8,
      bip32: {
          public: typeforce.UInt32,
          private: typeforce.UInt32,
      },
  });
  const BITCOIN = {
      messagePrefix: '\x18Bitcoin Signed Message:\n',
      bech32: 'bc',
      bip32: {
          public: 0x0488b21e,
          private: 0x0488ade4,
      },
      pubKeyHash: 0x00,
      scriptHash: 0x05,
      wif: 0x80,
  };
  const HIGHEST_BIT = 0x80000000;
  const UINT31_MAX = Math.pow(2, 31) - 1;
  function BIP32Path(value) {
      return (typeforce.String(value) && value.match(/^(m\/)?(\d+'?\/)*\d+'?$/) !== null);
  }
  function UInt31(value) {
      return typeforce.UInt32(value) && value <= UINT31_MAX;
  }
  class BIP32 {
      constructor(__D, __Q, chainCode, network, __DEPTH = 0, __INDEX = 0, __PARENT_FINGERPRINT = 0x00000000) {
          this.__D = __D;
          this.__Q = __Q;
          this.chainCode = chainCode;
          this.network = network;
          this.__DEPTH = __DEPTH;
          this.__INDEX = __INDEX;
          this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;
          typeforce(NETWORK_TYPE, network);
          this.lowR = false;
      }
      get depth() {
          return this.__DEPTH;
      }
      get index() {
          return this.__INDEX;
      }
      get parentFingerprint() {
          return this.__PARENT_FINGERPRINT;
      }
      get publicKey() {
          if (this.__Q === undefined)
              this.__Q = ecc.pointFromScalar(this.__D, true);
          return this.__Q;
      }
      get privateKey() {
          return this.__D;
      }
      get identifier() {
          return crypto.hash160(this.publicKey);
      }
      get fingerprint() {
          return this.identifier.slice(0, 4);
      }
      // Private === not neutered
      // Public === neutered
      isNeutered() {
          return this.__D === undefined;
      }
      neutered() {
          return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
      }
      toBase58() {
          const network = this.network;
          const version = !this.isNeutered()
              ? network.bip32.private
              : network.bip32.public;
          const buffer = Buffer.allocUnsafe(78);
          // 4 bytes: version bytes
          buffer.writeUInt32BE(version, 0);
          // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....
          buffer.writeUInt8(this.depth, 4);
          // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)
          buffer.writeUInt32BE(this.parentFingerprint, 5);
          // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.
          // This is encoded in big endian. (0x00000000 if master key)
          buffer.writeUInt32BE(this.index, 9);
          // 32 bytes: the chain code
          this.chainCode.copy(buffer, 13);
          // 33 bytes: the public key or private key data
          if (!this.isNeutered()) {
              // 0x00 + k for private keys
              buffer.writeUInt8(0, 45);
              this.privateKey.copy(buffer, 46);
              // 33 bytes: the public key
          }
          else {
              // X9.62 encoding for public keys
              this.publicKey.copy(buffer, 45);
          }
          return bs58check.encode(buffer);
      }
      toWIF() {
          if (!this.privateKey)
              throw new TypeError('Missing private key');
          return wif.encode(this.network.wif, this.privateKey, true);
      }
      // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
      derive(index) {
          typeforce(typeforce.UInt32, index);
          const isHardened = index >= HIGHEST_BIT;
          const data = Buffer.allocUnsafe(37);
          // Hardened child
          if (isHardened) {
              if (this.isNeutered())
                  throw new TypeError('Missing private key for hardened child key');
              // data = 0x00 || ser256(kpar) || ser32(index)
              data[0] = 0x00;
              this.privateKey.copy(data, 1);
              data.writeUInt32BE(index, 33);
              // Normal child
          }
          else {
              // data = serP(point(kpar)) || ser32(index)
              //      = serP(Kpar) || ser32(index)
              this.publicKey.copy(data, 0);
              data.writeUInt32BE(index, 33);
          }
          const I = crypto.hmacSHA512(this.chainCode, data);
          const IL = I.slice(0, 32);
          const IR = I.slice(32);
          // if parse256(IL) >= n, proceed with the next value for i
          if (!ecc.isPrivate(IL))
              return this.derive(index + 1);
          // Private parent key -> private child key
          let hd;
          if (!this.isNeutered()) {
              // ki = parse256(IL) + kpar (mod n)
              const ki = ecc.privateAdd(this.privateKey, IL);
              // In case ki == 0, proceed with the next value for i
              if (ki == null)
                  return this.derive(index + 1);
              hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));
              // Public parent key -> public child key
          }
          else {
              // Ki = point(parse256(IL)) + Kpar
              //    = G*IL + Kpar
              const Ki = ecc.pointAddScalar(this.publicKey, IL, true);
              // In case Ki is the point at infinity, proceed with the next value for i
              if (Ki === null)
                  return this.derive(index + 1);
              hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));
          }
          return hd;
      }
      deriveHardened(index) {
          typeforce(UInt31, index);
          // Only derives hardened private keys by default
          return this.derive(index + HIGHEST_BIT);
      }
      derivePath(path) {
          typeforce(BIP32Path, path);
          let splitPath = path.split('/');
          if (splitPath[0] === 'm') {
              if (this.parentFingerprint)
                  throw new TypeError('Expected master, got child');
              splitPath = splitPath.slice(1);
          }
          return splitPath.reduce((prevHd, indexStr) => {
              let index;
              if (indexStr.slice(-1) === `'`) {
                  index = parseInt(indexStr.slice(0, -1), 10);
                  return prevHd.deriveHardened(index);
              }
              else {
                  index = parseInt(indexStr, 10);
                  return prevHd.derive(index);
              }
          }, this);
      }
      sign(hash, lowR) {
          if (!this.privateKey)
              throw new Error('Missing private key');
          if (lowR === undefined)
              lowR = this.lowR;
          if (lowR === false) {
              return ecc.sign(hash, this.privateKey);
          }
          else {
              let sig = ecc.sign(hash, this.privateKey);
              const extraData = Buffer.alloc(32, 0);
              let counter = 0;
              // if first try is lowR, skip the loop
              // for second try and on, add extra entropy counting up
              while (sig[0] > 0x7f) {
                  counter++;
                  extraData.writeUIntLE(counter, 0, 6);
                  sig = ecc.signWithEntropy(hash, this.privateKey, extraData);
              }
              return sig;
          }
      }
      verify(hash, signature) {
          return ecc.verify(hash, this.publicKey, signature);
      }
  }
  function fromBase58(inString, network) {
      const buffer = bs58check.decode(inString);
      if (buffer.length !== 78)
          throw new TypeError('Invalid buffer length');
      network = network || BITCOIN;
      // 4 bytes: version bytes
      const version = buffer.readUInt32BE(0);
      if (version !== network.bip32.private && version !== network.bip32.public)
          throw new TypeError('Invalid network version');
      // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...
      const depth = buffer[4];
      // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)
      const parentFingerprint = buffer.readUInt32BE(5);
      if (depth === 0) {
          if (parentFingerprint !== 0x00000000)
              throw new TypeError('Invalid parent fingerprint');
      }
      // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.
      // This is encoded in MSB order. (0x00000000 if master key)
      const index = buffer.readUInt32BE(9);
      if (depth === 0 && index !== 0)
          throw new TypeError('Invalid index');
      // 32 bytes: the chain code
      const chainCode = buffer.slice(13, 45);
      let hd;
      // 33 bytes: private key data (0x00 + k)
      if (version === network.bip32.private) {
          if (buffer.readUInt8(45) !== 0x00)
              throw new TypeError('Invalid private key');
          const k = buffer.slice(46, 78);
          hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint);
          // 33 bytes: public key data (0x02 + X or 0x03 + X)
      }
      else {
          const X = buffer.slice(45, 78);
          hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);
      }
      return hd;
  }
  exports.fromBase58 = fromBase58;
  function fromPrivateKey(privateKey, chainCode, network) {
      return fromPrivateKeyLocal(privateKey, chainCode, network);
  }
  exports.fromPrivateKey = fromPrivateKey;
  function fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {
      typeforce({
          privateKey: UINT256_TYPE,
          chainCode: UINT256_TYPE,
      }, { privateKey, chainCode });
      network = network || BITCOIN;
      if (!ecc.isPrivate(privateKey))
          throw new TypeError('Private key not in range [1, n)');
      return new BIP32(privateKey, undefined, chainCode, network, depth, index, parentFingerprint);
  }
  function fromPublicKey(publicKey, chainCode, network) {
      return fromPublicKeyLocal(publicKey, chainCode, network);
  }
  exports.fromPublicKey = fromPublicKey;
  function fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {
      typeforce({
          publicKey: typeforce.BufferN(33),
          chainCode: UINT256_TYPE,
      }, { publicKey, chainCode });
      network = network || BITCOIN;
      // verify the X coordinate is a point on the curve
      if (!ecc.isPoint(publicKey))
          throw new TypeError('Point is not on the curve');
      return new BIP32(undefined, publicKey, chainCode, network, depth, index, parentFingerprint);
  }
  function fromSeed(seed, network) {
      typeforce(typeforce.Buffer, seed);
      if (seed.length < 16)
          throw new TypeError('Seed should be at least 128 bits');
      if (seed.length > 64)
          throw new TypeError('Seed should be at most 512 bits');
      network = network || BITCOIN;
      const I = crypto.hmacSHA512(Buffer.from('Bitcoin seed', 'utf8'), seed);
      const IL = I.slice(0, 32);
      const IR = I.slice(32);
      return fromPrivateKey(IL, IR, network);
  }
  exports.fromSeed = fromSeed;
  
  }).call(this,require("buffer").Buffer)
  },{"./crypto":127,"bs58check":191,"buffer":3,"tiny-secp256k1":266,"typeforce":271,"wif":274}],127:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const createHash = require('create-hash');
  const createHmac = require('create-hmac');
  function hash160(buffer) {
      const sha256Hash = createHash('sha256')
          .update(buffer)
          .digest();
      try {
          return createHash('rmd160')
              .update(sha256Hash)
              .digest();
      }
      catch (err) {
          return createHash('ripemd160')
              .update(sha256Hash)
              .digest();
      }
  }
  exports.hash160 = hash160;
  function hmacSHA512(key, data) {
      return createHmac('sha512', key)
          .update(data)
          .digest();
  }
  exports.hmacSHA512 = hmacSHA512;
  
  },{"create-hash":193,"create-hmac":195}],128:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  var bip32_1 = require("./bip32");
  exports.fromSeed = bip32_1.fromSeed;
  exports.fromBase58 = bip32_1.fromBase58;
  exports.fromPublicKey = bip32_1.fromPublicKey;
  exports.fromPrivateKey = bip32_1.fromPrivateKey;
  
  },{"./bip32":126}],129:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  // browserify by default only pulls in files that are hard coded in requires
  // In order of last to first in this file, the default wordlist will be chosen
  // based on what is present. (Bundles may remove wordlists they don't need)
  const wordlists = {};
  exports.wordlists = wordlists;
  let _default;
  exports._default = _default;
  try {
      exports._default = _default = require('./wordlists/chinese_simplified.json');
      wordlists.chinese_simplified = _default;
  }
  catch (err) { }
  try {
      exports._default = _default = require('./wordlists/chinese_traditional.json');
      wordlists.chinese_traditional = _default;
  }
  catch (err) { }
  try {
      exports._default = _default = require('./wordlists/korean.json');
      wordlists.korean = _default;
  }
  catch (err) { }
  try {
      exports._default = _default = require('./wordlists/french.json');
      wordlists.french = _default;
  }
  catch (err) { }
  try {
      exports._default = _default = require('./wordlists/italian.json');
      wordlists.italian = _default;
  }
  catch (err) { }
  try {
      exports._default = _default = require('./wordlists/spanish.json');
      wordlists.spanish = _default;
  }
  catch (err) { }
  try {
      exports._default = _default = require('./wordlists/japanese.json');
      wordlists.japanese = _default;
      wordlists.JA = _default;
  }
  catch (err) { }
  try {
      exports._default = _default = require('./wordlists/english.json');
      wordlists.english = _default;
      wordlists.EN = _default;
  }
  catch (err) { }
  
  },{"./wordlists/chinese_simplified.json":131,"./wordlists/chinese_traditional.json":132,"./wordlists/english.json":133,"./wordlists/french.json":134,"./wordlists/italian.json":135,"./wordlists/japanese.json":136,"./wordlists/korean.json":137,"./wordlists/spanish.json":138}],130:[function(require,module,exports){
  (function (Buffer){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const createHash = require("create-hash");
  const pbkdf2_1 = require("pbkdf2");
  const randomBytes = require("randombytes");
  const _wordlists_1 = require("./_wordlists");
  let DEFAULT_WORDLIST = _wordlists_1._default;
  const INVALID_MNEMONIC = 'Invalid mnemonic';
  const INVALID_ENTROPY = 'Invalid entropy';
  const INVALID_CHECKSUM = 'Invalid mnemonic checksum';
  const WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\n' +
      'Please explicitly pass a 2048 word array explicitly.';
  function lpad(str, padString, length) {
      while (str.length < length)
          str = padString + str;
      return str;
  }
  function binaryToByte(bin) {
      return parseInt(bin, 2);
  }
  function bytesToBinary(bytes) {
      return bytes.map(x => lpad(x.toString(2), '0', 8)).join('');
  }
  function deriveChecksumBits(entropyBuffer) {
      const ENT = entropyBuffer.length * 8;
      const CS = ENT / 32;
      const hash = createHash('sha256')
          .update(entropyBuffer)
          .digest();
      return bytesToBinary([...hash]).slice(0, CS);
  }
  function salt(password) {
      return 'mnemonic' + (password || '');
  }
  function mnemonicToSeedSync(mnemonic, password) {
      const mnemonicBuffer = Buffer.from((mnemonic || '').normalize('NFKD'), 'utf8');
      const saltBuffer = Buffer.from(salt((password || '').normalize('NFKD')), 'utf8');
      return pbkdf2_1.pbkdf2Sync(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');
  }
  exports.mnemonicToSeedSync = mnemonicToSeedSync;
  function mnemonicToSeed(mnemonic, password) {
      return new Promise((resolve, reject) => {
          try {
              const mnemonicBuffer = Buffer.from((mnemonic || '').normalize('NFKD'), 'utf8');
              const saltBuffer = Buffer.from(salt((password || '').normalize('NFKD')), 'utf8');
              pbkdf2_1.pbkdf2(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512', (err, data) => {
                  if (err)
                      return reject(err);
                  else
                      return resolve(data);
              });
          }
          catch (error) {
              return reject(error);
          }
      });
  }
  exports.mnemonicToSeed = mnemonicToSeed;
  function mnemonicToEntropy(mnemonic, wordlist) {
      wordlist = wordlist || DEFAULT_WORDLIST;
      if (!wordlist) {
          throw new Error(WORDLIST_REQUIRED);
      }
      const words = (mnemonic || '').normalize('NFKD').split(' ');
      if (words.length % 3 !== 0)
          throw new Error(INVALID_MNEMONIC);
      // convert word indices to 11 bit binary strings
      const bits = words
          .map(word => {
          const index = wordlist.indexOf(word);
          if (index === -1)
              throw new Error(INVALID_MNEMONIC);
          return lpad(index.toString(2), '0', 11);
      })
          .join('');
      // split the binary string into ENT/CS
      const dividerIndex = Math.floor(bits.length / 33) * 32;
      const entropyBits = bits.slice(0, dividerIndex);
      const checksumBits = bits.slice(dividerIndex);
      // calculate the checksum and compare
      const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);
      if (entropyBytes.length < 16)
          throw new Error(INVALID_ENTROPY);
      if (entropyBytes.length > 32)
          throw new Error(INVALID_ENTROPY);
      if (entropyBytes.length % 4 !== 0)
          throw new Error(INVALID_ENTROPY);
      const entropy = Buffer.from(entropyBytes);
      const newChecksum = deriveChecksumBits(entropy);
      if (newChecksum !== checksumBits)
          throw new Error(INVALID_CHECKSUM);
      return entropy.toString('hex');
  }
  exports.mnemonicToEntropy = mnemonicToEntropy;
  function entropyToMnemonic(entropy, wordlist) {
      if (!Buffer.isBuffer(entropy))
          entropy = Buffer.from(entropy, 'hex');
      wordlist = wordlist || DEFAULT_WORDLIST;
      if (!wordlist) {
          throw new Error(WORDLIST_REQUIRED);
      }
      // 128 <= ENT <= 256
      if (entropy.length < 16)
          throw new TypeError(INVALID_ENTROPY);
      if (entropy.length > 32)
          throw new TypeError(INVALID_ENTROPY);
      if (entropy.length % 4 !== 0)
          throw new TypeError(INVALID_ENTROPY);
      const entropyBits = bytesToBinary([...entropy]);
      const checksumBits = deriveChecksumBits(entropy);
      const bits = entropyBits + checksumBits;
      const chunks = bits.match(/(.{1,11})/g);
      const words = chunks.map(binary => {
          const index = binaryToByte(binary);
          return wordlist[index];
      });
      return wordlist[0] === '\u3042\u3044\u3053\u304f\u3057\u3093' // Japanese wordlist
          ? words.join('\u3000')
          : words.join(' ');
  }
  exports.entropyToMnemonic = entropyToMnemonic;
  function generateMnemonic(strength, rng, wordlist) {
      strength = strength || 128;
      if (strength % 32 !== 0)
          throw new TypeError(INVALID_ENTROPY);
      rng = rng || randomBytes;
      return entropyToMnemonic(rng(strength / 8), wordlist);
  }
  exports.generateMnemonic = generateMnemonic;
  function validateMnemonic(mnemonic, wordlist) {
      try {
          mnemonicToEntropy(mnemonic, wordlist);
      }
      catch (e) {
          return false;
      }
      return true;
  }
  exports.validateMnemonic = validateMnemonic;
  function setDefaultWordlist(language) {
      const result = _wordlists_1.wordlists[language];
      if (result)
          DEFAULT_WORDLIST = result;
      else
          throw new Error('Could not find wordlist for language "' + language + '"');
  }
  exports.setDefaultWordlist = setDefaultWordlist;
  function getDefaultWordlist() {
      if (!DEFAULT_WORDLIST)
          throw new Error('No Default Wordlist set');
      return Object.keys(_wordlists_1.wordlists).filter(lang => {
          if (lang === 'JA' || lang === 'EN')
              return false;
          return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);
      })[0];
  }
  exports.getDefaultWordlist = getDefaultWordlist;
  var _wordlists_2 = require("./_wordlists");
  exports.wordlists = _wordlists_2.wordlists;
  
  }).call(this,require("buffer").Buffer)
  },{"./_wordlists":129,"buffer":3,"create-hash":193,"pbkdf2":244,"randombytes":251}],131:[function(require,module,exports){
  module.exports=[
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
  ]
  
  },{}],132:[function(require,module,exports){
  module.exports=[
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
  ]
  
  },{}],133:[function(require,module,exports){
  module.exports=[
      "abandon",
      "ability",
      "able",
      "about",
      "above",
      "absent",
      "absorb",
      "abstract",
      "absurd",
      "abuse",
      "access",
      "accident",
      "account",
      "accuse",
      "achieve",
      "acid",
      "acoustic",
      "acquire",
      "across",
      "act",
      "action",
      "actor",
      "actress",
      "actual",
      "adapt",
      "add",
      "addict",
      "address",
      "adjust",
      "admit",
      "adult",
      "advance",
      "advice",
      "aerobic",
      "affair",
      "afford",
      "afraid",
      "again",
      "age",
      "agent",
      "agree",
      "ahead",
      "aim",
      "air",
      "airport",
      "aisle",
      "alarm",
      "album",
      "alcohol",
      "alert",
      "alien",
      "all",
      "alley",
      "allow",
      "almost",
      "alone",
      "alpha",
      "already",
      "also",
      "alter",
      "always",
      "amateur",
      "amazing",
      "among",
      "amount",
      "amused",
      "analyst",
      "anchor",
      "ancient",
      "anger",
      "angle",
      "angry",
      "animal",
      "ankle",
      "announce",
      "annual",
      "another",
      "answer",
      "antenna",
      "antique",
      "anxiety",
      "any",
      "apart",
      "apology",
      "appear",
      "apple",
      "approve",
      "april",
      "arch",
      "arctic",
      "area",
      "arena",
      "argue",
      "arm",
      "armed",
      "armor",
      "army",
      "around",
      "arrange",
      "arrest",
      "arrive",
      "arrow",
      "art",
      "artefact",
      "artist",
      "artwork",
      "ask",
      "aspect",
      "assault",
      "asset",
      "assist",
      "assume",
      "asthma",
      "athlete",
      "atom",
      "attack",
      "attend",
      "attitude",
      "attract",
      "auction",
      "audit",
      "august",
      "aunt",
      "author",
      "auto",
      "autumn",
      "average",
      "avocado",
      "avoid",
      "awake",
      "aware",
      "away",
      "awesome",
      "awful",
      "awkward",
      "axis",
      "baby",
      "bachelor",
      "bacon",
      "badge",
      "bag",
      "balance",
      "balcony",
      "ball",
      "bamboo",
      "banana",
      "banner",
      "bar",
      "barely",
      "bargain",
      "barrel",
      "base",
      "basic",
      "basket",
      "battle",
      "beach",
      "bean",
      "beauty",
      "because",
      "become",
      "beef",
      "before",
      "begin",
      "behave",
      "behind",
      "believe",
      "below",
      "belt",
      "bench",
      "benefit",
      "best",
      "betray",
      "better",
      "between",
      "beyond",
      "bicycle",
      "bid",
      "bike",
      "bind",
      "biology",
      "bird",
      "birth",
      "bitter",
      "black",
      "blade",
      "blame",
      "blanket",
      "blast",
      "bleak",
      "bless",
      "blind",
      "blood",
      "blossom",
      "blouse",
      "blue",
      "blur",
      "blush",
      "board",
      "boat",
      "body",
      "boil",
      "bomb",
      "bone",
      "bonus",
      "book",
      "boost",
      "border",
      "boring",
      "borrow",
      "boss",
      "bottom",
      "bounce",
      "box",
      "boy",
      "bracket",
      "brain",
      "brand",
      "brass",
      "brave",
      "bread",
      "breeze",
      "brick",
      "bridge",
      "brief",
      "bright",
      "bring",
      "brisk",
      "broccoli",
      "broken",
      "bronze",
      "broom",
      "brother",
      "brown",
      "brush",
      "bubble",
      "buddy",
      "budget",
      "buffalo",
      "build",
      "bulb",
      "bulk",
      "bullet",
      "bundle",
      "bunker",
      "burden",
      "burger",
      "burst",
      "bus",
      "business",
      "busy",
      "butter",
      "buyer",
      "buzz",
      "cabbage",
      "cabin",
      "cable",
      "cactus",
      "cage",
      "cake",
      "call",
      "calm",
      "camera",
      "camp",
      "can",
      "canal",
      "cancel",
      "candy",
      "cannon",
      "canoe",
      "canvas",
      "canyon",
      "capable",
      "capital",
      "captain",
      "car",
      "carbon",
      "card",
      "cargo",
      "carpet",
      "carry",
      "cart",
      "case",
      "cash",
      "casino",
      "castle",
      "casual",
      "cat",
      "catalog",
      "catch",
      "category",
      "cattle",
      "caught",
      "cause",
      "caution",
      "cave",
      "ceiling",
      "celery",
      "cement",
      "census",
      "century",
      "cereal",
      "certain",
      "chair",
      "chalk",
      "champion",
      "change",
      "chaos",
      "chapter",
      "charge",
      "chase",
      "chat",
      "cheap",
      "check",
      "cheese",
      "chef",
      "cherry",
      "chest",
      "chicken",
      "chief",
      "child",
      "chimney",
      "choice",
      "choose",
      "chronic",
      "chuckle",
      "chunk",
      "churn",
      "cigar",
      "cinnamon",
      "circle",
      "citizen",
      "city",
      "civil",
      "claim",
      "clap",
      "clarify",
      "claw",
      "clay",
      "clean",
      "clerk",
      "clever",
      "click",
      "client",
      "cliff",
      "climb",
      "clinic",
      "clip",
      "clock",
      "clog",
      "close",
      "cloth",
      "cloud",
      "clown",
      "club",
      "clump",
      "cluster",
      "clutch",
      "coach",
      "coast",
      "coconut",
      "code",
      "coffee",
      "coil",
      "coin",
      "collect",
      "color",
      "column",
      "combine",
      "come",
      "comfort",
      "comic",
      "common",
      "company",
      "concert",
      "conduct",
      "confirm",
      "congress",
      "connect",
      "consider",
      "control",
      "convince",
      "cook",
      "cool",
      "copper",
      "copy",
      "coral",
      "core",
      "corn",
      "correct",
      "cost",
      "cotton",
      "couch",
      "country",
      "couple",
      "course",
      "cousin",
      "cover",
      "coyote",
      "crack",
      "cradle",
      "craft",
      "cram",
      "crane",
      "crash",
      "crater",
      "crawl",
      "crazy",
      "cream",
      "credit",
      "creek",
      "crew",
      "cricket",
      "crime",
      "crisp",
      "critic",
      "crop",
      "cross",
      "crouch",
      "crowd",
      "crucial",
      "cruel",
      "cruise",
      "crumble",
      "crunch",
      "crush",
      "cry",
      "crystal",
      "cube",
      "culture",
      "cup",
      "cupboard",
      "curious",
      "current",
      "curtain",
      "curve",
      "cushion",
      "custom",
      "cute",
      "cycle",
      "dad",
      "damage",
      "damp",
      "dance",
      "danger",
      "daring",
      "dash",
      "daughter",
      "dawn",
      "day",
      "deal",
      "debate",
      "debris",
      "decade",
      "december",
      "decide",
      "decline",
      "decorate",
      "decrease",
      "deer",
      "defense",
      "define",
      "defy",
      "degree",
      "delay",
      "deliver",
      "demand",
      "demise",
      "denial",
      "dentist",
      "deny",
      "depart",
      "depend",
      "deposit",
      "depth",
      "deputy",
      "derive",
      "describe",
      "desert",
      "design",
      "desk",
      "despair",
      "destroy",
      "detail",
      "detect",
      "develop",
      "device",
      "devote",
      "diagram",
      "dial",
      "diamond",
      "diary",
      "dice",
      "diesel",
      "diet",
      "differ",
      "digital",
      "dignity",
      "dilemma",
      "dinner",
      "dinosaur",
      "direct",
      "dirt",
      "disagree",
      "discover",
      "disease",
      "dish",
      "dismiss",
      "disorder",
      "display",
      "distance",
      "divert",
      "divide",
      "divorce",
      "dizzy",
      "doctor",
      "document",
      "dog",
      "doll",
      "dolphin",
      "domain",
      "donate",
      "donkey",
      "donor",
      "door",
      "dose",
      "double",
      "dove",
      "draft",
      "dragon",
      "drama",
      "drastic",
      "draw",
      "dream",
      "dress",
      "drift",
      "drill",
      "drink",
      "drip",
      "drive",
      "drop",
      "drum",
      "dry",
      "duck",
      "dumb",
      "dune",
      "during",
      "dust",
      "dutch",
      "duty",
      "dwarf",
      "dynamic",
      "eager",
      "eagle",
      "early",
      "earn",
      "earth",
      "easily",
      "east",
      "easy",
      "echo",
      "ecology",
      "economy",
      "edge",
      "edit",
      "educate",
      "effort",
      "egg",
      "eight",
      "either",
      "elbow",
      "elder",
      "electric",
      "elegant",
      "element",
      "elephant",
      "elevator",
      "elite",
      "else",
      "embark",
      "embody",
      "embrace",
      "emerge",
      "emotion",
      "employ",
      "empower",
      "empty",
      "enable",
      "enact",
      "end",
      "endless",
      "endorse",
      "enemy",
      "energy",
      "enforce",
      "engage",
      "engine",
      "enhance",
      "enjoy",
      "enlist",
      "enough",
      "enrich",
      "enroll",
      "ensure",
      "enter",
      "entire",
      "entry",
      "envelope",
      "episode",
      "equal",
      "equip",
      "era",
      "erase",
      "erode",
      "erosion",
      "error",
      "erupt",
      "escape",
      "essay",
      "essence",
      "estate",
      "eternal",
      "ethics",
      "evidence",
      "evil",
      "evoke",
      "evolve",
      "exact",
      "example",
      "excess",
      "exchange",
      "excite",
      "exclude",
      "excuse",
      "execute",
      "exercise",
      "exhaust",
      "exhibit",
      "exile",
      "exist",
      "exit",
      "exotic",
      "expand",
      "expect",
      "expire",
      "explain",
      "expose",
      "express",
      "extend",
      "extra",
      "eye",
      "eyebrow",
      "fabric",
      "face",
      "faculty",
      "fade",
      "faint",
      "faith",
      "fall",
      "false",
      "fame",
      "family",
      "famous",
      "fan",
      "fancy",
      "fantasy",
      "farm",
      "fashion",
      "fat",
      "fatal",
      "father",
      "fatigue",
      "fault",
      "favorite",
      "feature",
      "february",
      "federal",
      "fee",
      "feed",
      "feel",
      "female",
      "fence",
      "festival",
      "fetch",
      "fever",
      "few",
      "fiber",
      "fiction",
      "field",
      "figure",
      "file",
      "film",
      "filter",
      "final",
      "find",
      "fine",
      "finger",
      "finish",
      "fire",
      "firm",
      "first",
      "fiscal",
      "fish",
      "fit",
      "fitness",
      "fix",
      "flag",
      "flame",
      "flash",
      "flat",
      "flavor",
      "flee",
      "flight",
      "flip",
      "float",
      "flock",
      "floor",
      "flower",
      "fluid",
      "flush",
      "fly",
      "foam",
      "focus",
      "fog",
      "foil",
      "fold",
      "follow",
      "food",
      "foot",
      "force",
      "forest",
      "forget",
      "fork",
      "fortune",
      "forum",
      "forward",
      "fossil",
      "foster",
      "found",
      "fox",
      "fragile",
      "frame",
      "frequent",
      "fresh",
      "friend",
      "fringe",
      "frog",
      "front",
      "frost",
      "frown",
      "frozen",
      "fruit",
      "fuel",
      "fun",
      "funny",
      "furnace",
      "fury",
      "future",
      "gadget",
      "gain",
      "galaxy",
      "gallery",
      "game",
      "gap",
      "garage",
      "garbage",
      "garden",
      "garlic",
      "garment",
      "gas",
      "gasp",
      "gate",
      "gather",
      "gauge",
      "gaze",
      "general",
      "genius",
      "genre",
      "gentle",
      "genuine",
      "gesture",
      "ghost",
      "giant",
      "gift",
      "giggle",
      "ginger",
      "giraffe",
      "girl",
      "give",
      "glad",
      "glance",
      "glare",
      "glass",
      "glide",
      "glimpse",
      "globe",
      "gloom",
      "glory",
      "glove",
      "glow",
      "glue",
      "goat",
      "goddess",
      "gold",
      "good",
      "goose",
      "gorilla",
      "gospel",
      "gossip",
      "govern",
      "gown",
      "grab",
      "grace",
      "grain",
      "grant",
      "grape",
      "grass",
      "gravity",
      "great",
      "green",
      "grid",
      "grief",
      "grit",
      "grocery",
      "group",
      "grow",
      "grunt",
      "guard",
      "guess",
      "guide",
      "guilt",
      "guitar",
      "gun",
      "gym",
      "habit",
      "hair",
      "half",
      "hammer",
      "hamster",
      "hand",
      "happy",
      "harbor",
      "hard",
      "harsh",
      "harvest",
      "hat",
      "have",
      "hawk",
      "hazard",
      "head",
      "health",
      "heart",
      "heavy",
      "hedgehog",
      "height",
      "hello",
      "helmet",
      "help",
      "hen",
      "hero",
      "hidden",
      "high",
      "hill",
      "hint",
      "hip",
      "hire",
      "history",
      "hobby",
      "hockey",
      "hold",
      "hole",
      "holiday",
      "hollow",
      "home",
      "honey",
      "hood",
      "hope",
      "horn",
      "horror",
      "horse",
      "hospital",
      "host",
      "hotel",
      "hour",
      "hover",
      "hub",
      "huge",
      "human",
      "humble",
      "humor",
      "hundred",
      "hungry",
      "hunt",
      "hurdle",
      "hurry",
      "hurt",
      "husband",
      "hybrid",
      "ice",
      "icon",
      "idea",
      "identify",
      "idle",
      "ignore",
      "ill",
      "illegal",
      "illness",
      "image",
      "imitate",
      "immense",
      "immune",
      "impact",
      "impose",
      "improve",
      "impulse",
      "inch",
      "include",
      "income",
      "increase",
      "index",
      "indicate",
      "indoor",
      "industry",
      "infant",
      "inflict",
      "inform",
      "inhale",
      "inherit",
      "initial",
      "inject",
      "injury",
      "inmate",
      "inner",
      "innocent",
      "input",
      "inquiry",
      "insane",
      "insect",
      "inside",
      "inspire",
      "install",
      "intact",
      "interest",
      "into",
      "invest",
      "invite",
      "involve",
      "iron",
      "island",
      "isolate",
      "issue",
      "item",
      "ivory",
      "jacket",
      "jaguar",
      "jar",
      "jazz",
      "jealous",
      "jeans",
      "jelly",
      "jewel",
      "job",
      "join",
      "joke",
      "journey",
      "joy",
      "judge",
      "juice",
      "jump",
      "jungle",
      "junior",
      "junk",
      "just",
      "kangaroo",
      "keen",
      "keep",
      "ketchup",
      "key",
      "kick",
      "kid",
      "kidney",
      "kind",
      "kingdom",
      "kiss",
      "kit",
      "kitchen",
      "kite",
      "kitten",
      "kiwi",
      "knee",
      "knife",
      "knock",
      "know",
      "lab",
      "label",
      "labor",
      "ladder",
      "lady",
      "lake",
      "lamp",
      "language",
      "laptop",
      "large",
      "later",
      "latin",
      "laugh",
      "laundry",
      "lava",
      "law",
      "lawn",
      "lawsuit",
      "layer",
      "lazy",
      "leader",
      "leaf",
      "learn",
      "leave",
      "lecture",
      "left",
      "leg",
      "legal",
      "legend",
      "leisure",
      "lemon",
      "lend",
      "length",
      "lens",
      "leopard",
      "lesson",
      "letter",
      "level",
      "liar",
      "liberty",
      "library",
      "license",
      "life",
      "lift",
      "light",
      "like",
      "limb",
      "limit",
      "link",
      "lion",
      "liquid",
      "list",
      "little",
      "live",
      "lizard",
      "load",
      "loan",
      "lobster",
      "local",
      "lock",
      "logic",
      "lonely",
      "long",
      "loop",
      "lottery",
      "loud",
      "lounge",
      "love",
      "loyal",
      "lucky",
      "luggage",
      "lumber",
      "lunar",
      "lunch",
      "luxury",
      "lyrics",
      "machine",
      "mad",
      "magic",
      "magnet",
      "maid",
      "mail",
      "main",
      "major",
      "make",
      "mammal",
      "man",
      "manage",
      "mandate",
      "mango",
      "mansion",
      "manual",
      "maple",
      "marble",
      "march",
      "margin",
      "marine",
      "market",
      "marriage",
      "mask",
      "mass",
      "master",
      "match",
      "material",
      "math",
      "matrix",
      "matter",
      "maximum",
      "maze",
      "meadow",
      "mean",
      "measure",
      "meat",
      "mechanic",
      "medal",
      "media",
      "melody",
      "melt",
      "member",
      "memory",
      "mention",
      "menu",
      "mercy",
      "merge",
      "merit",
      "merry",
      "mesh",
      "message",
      "metal",
      "method",
      "middle",
      "midnight",
      "milk",
      "million",
      "mimic",
      "mind",
      "minimum",
      "minor",
      "minute",
      "miracle",
      "mirror",
      "misery",
      "miss",
      "mistake",
      "mix",
      "mixed",
      "mixture",
      "mobile",
      "model",
      "modify",
      "mom",
      "moment",
      "monitor",
      "monkey",
      "monster",
      "month",
      "moon",
      "moral",
      "more",
      "morning",
      "mosquito",
      "mother",
      "motion",
      "motor",
      "mountain",
      "mouse",
      "move",
      "movie",
      "much",
      "muffin",
      "mule",
      "multiply",
      "muscle",
      "museum",
      "mushroom",
      "music",
      "must",
      "mutual",
      "myself",
      "mystery",
      "myth",
      "naive",
      "name",
      "napkin",
      "narrow",
      "nasty",
      "nation",
      "nature",
      "near",
      "neck",
      "need",
      "negative",
      "neglect",
      "neither",
      "nephew",
      "nerve",
      "nest",
      "net",
      "network",
      "neutral",
      "never",
      "news",
      "next",
      "nice",
      "night",
      "noble",
      "noise",
      "nominee",
      "noodle",
      "normal",
      "north",
      "nose",
      "notable",
      "note",
      "nothing",
      "notice",
      "novel",
      "now",
      "nuclear",
      "number",
      "nurse",
      "nut",
      "oak",
      "obey",
      "object",
      "oblige",
      "obscure",
      "observe",
      "obtain",
      "obvious",
      "occur",
      "ocean",
      "october",
      "odor",
      "off",
      "offer",
      "office",
      "often",
      "oil",
      "okay",
      "old",
      "olive",
      "olympic",
      "omit",
      "once",
      "one",
      "onion",
      "online",
      "only",
      "open",
      "opera",
      "opinion",
      "oppose",
      "option",
      "orange",
      "orbit",
      "orchard",
      "order",
      "ordinary",
      "organ",
      "orient",
      "original",
      "orphan",
      "ostrich",
      "other",
      "outdoor",
      "outer",
      "output",
      "outside",
      "oval",
      "oven",
      "over",
      "own",
      "owner",
      "oxygen",
      "oyster",
      "ozone",
      "pact",
      "paddle",
      "page",
      "pair",
      "palace",
      "palm",
      "panda",
      "panel",
      "panic",
      "panther",
      "paper",
      "parade",
      "parent",
      "park",
      "parrot",
      "party",
      "pass",
      "patch",
      "path",
      "patient",
      "patrol",
      "pattern",
      "pause",
      "pave",
      "payment",
      "peace",
      "peanut",
      "pear",
      "peasant",
      "pelican",
      "pen",
      "penalty",
      "pencil",
      "people",
      "pepper",
      "perfect",
      "permit",
      "person",
      "pet",
      "phone",
      "photo",
      "phrase",
      "physical",
      "piano",
      "picnic",
      "picture",
      "piece",
      "pig",
      "pigeon",
      "pill",
      "pilot",
      "pink",
      "pioneer",
      "pipe",
      "pistol",
      "pitch",
      "pizza",
      "place",
      "planet",
      "plastic",
      "plate",
      "play",
      "please",
      "pledge",
      "pluck",
      "plug",
      "plunge",
      "poem",
      "poet",
      "point",
      "polar",
      "pole",
      "police",
      "pond",
      "pony",
      "pool",
      "popular",
      "portion",
      "position",
      "possible",
      "post",
      "potato",
      "pottery",
      "poverty",
      "powder",
      "power",
      "practice",
      "praise",
      "predict",
      "prefer",
      "prepare",
      "present",
      "pretty",
      "prevent",
      "price",
      "pride",
      "primary",
      "print",
      "priority",
      "prison",
      "private",
      "prize",
      "problem",
      "process",
      "produce",
      "profit",
      "program",
      "project",
      "promote",
      "proof",
      "property",
      "prosper",
      "protect",
      "proud",
      "provide",
      "public",
      "pudding",
      "pull",
      "pulp",
      "pulse",
      "pumpkin",
      "punch",
      "pupil",
      "puppy",
      "purchase",
      "purity",
      "purpose",
      "purse",
      "push",
      "put",
      "puzzle",
      "pyramid",
      "quality",
      "quantum",
      "quarter",
      "question",
      "quick",
      "quit",
      "quiz",
      "quote",
      "rabbit",
      "raccoon",
      "race",
      "rack",
      "radar",
      "radio",
      "rail",
      "rain",
      "raise",
      "rally",
      "ramp",
      "ranch",
      "random",
      "range",
      "rapid",
      "rare",
      "rate",
      "rather",
      "raven",
      "raw",
      "razor",
      "ready",
      "real",
      "reason",
      "rebel",
      "rebuild",
      "recall",
      "receive",
      "recipe",
      "record",
      "recycle",
      "reduce",
      "reflect",
      "reform",
      "refuse",
      "region",
      "regret",
      "regular",
      "reject",
      "relax",
      "release",
      "relief",
      "rely",
      "remain",
      "remember",
      "remind",
      "remove",
      "render",
      "renew",
      "rent",
      "reopen",
      "repair",
      "repeat",
      "replace",
      "report",
      "require",
      "rescue",
      "resemble",
      "resist",
      "resource",
      "response",
      "result",
      "retire",
      "retreat",
      "return",
      "reunion",
      "reveal",
      "review",
      "reward",
      "rhythm",
      "rib",
      "ribbon",
      "rice",
      "rich",
      "ride",
      "ridge",
      "rifle",
      "right",
      "rigid",
      "ring",
      "riot",
      "ripple",
      "risk",
      "ritual",
      "rival",
      "river",
      "road",
      "roast",
      "robot",
      "robust",
      "rocket",
      "romance",
      "roof",
      "rookie",
      "room",
      "rose",
      "rotate",
      "rough",
      "round",
      "route",
      "royal",
      "rubber",
      "rude",
      "rug",
      "rule",
      "run",
      "runway",
      "rural",
      "sad",
      "saddle",
      "sadness",
      "safe",
      "sail",
      "salad",
      "salmon",
      "salon",
      "salt",
      "salute",
      "same",
      "sample",
      "sand",
      "satisfy",
      "satoshi",
      "sauce",
      "sausage",
      "save",
      "say",
      "scale",
      "scan",
      "scare",
      "scatter",
      "scene",
      "scheme",
      "school",
      "science",
      "scissors",
      "scorpion",
      "scout",
      "scrap",
      "screen",
      "script",
      "scrub",
      "sea",
      "search",
      "season",
      "seat",
      "second",
      "secret",
      "section",
      "security",
      "seed",
      "seek",
      "segment",
      "select",
      "sell",
      "seminar",
      "senior",
      "sense",
      "sentence",
      "series",
      "service",
      "session",
      "settle",
      "setup",
      "seven",
      "shadow",
      "shaft",
      "shallow",
      "share",
      "shed",
      "shell",
      "sheriff",
      "shield",
      "shift",
      "shine",
      "ship",
      "shiver",
      "shock",
      "shoe",
      "shoot",
      "shop",
      "short",
      "shoulder",
      "shove",
      "shrimp",
      "shrug",
      "shuffle",
      "shy",
      "sibling",
      "sick",
      "side",
      "siege",
      "sight",
      "sign",
      "silent",
      "silk",
      "silly",
      "silver",
      "similar",
      "simple",
      "since",
      "sing",
      "siren",
      "sister",
      "situate",
      "six",
      "size",
      "skate",
      "sketch",
      "ski",
      "skill",
      "skin",
      "skirt",
      "skull",
      "slab",
      "slam",
      "sleep",
      "slender",
      "slice",
      "slide",
      "slight",
      "slim",
      "slogan",
      "slot",
      "slow",
      "slush",
      "small",
      "smart",
      "smile",
      "smoke",
      "smooth",
      "snack",
      "snake",
      "snap",
      "sniff",
      "snow",
      "soap",
      "soccer",
      "social",
      "sock",
      "soda",
      "soft",
      "solar",
      "soldier",
      "solid",
      "solution",
      "solve",
      "someone",
      "song",
      "soon",
      "sorry",
      "sort",
      "soul",
      "sound",
      "soup",
      "source",
      "south",
      "space",
      "spare",
      "spatial",
      "spawn",
      "speak",
      "special",
      "speed",
      "spell",
      "spend",
      "sphere",
      "spice",
      "spider",
      "spike",
      "spin",
      "spirit",
      "split",
      "spoil",
      "sponsor",
      "spoon",
      "sport",
      "spot",
      "spray",
      "spread",
      "spring",
      "spy",
      "square",
      "squeeze",
      "squirrel",
      "stable",
      "stadium",
      "staff",
      "stage",
      "stairs",
      "stamp",
      "stand",
      "start",
      "state",
      "stay",
      "steak",
      "steel",
      "stem",
      "step",
      "stereo",
      "stick",
      "still",
      "sting",
      "stock",
      "stomach",
      "stone",
      "stool",
      "story",
      "stove",
      "strategy",
      "street",
      "strike",
      "strong",
      "struggle",
      "student",
      "stuff",
      "stumble",
      "style",
      "subject",
      "submit",
      "subway",
      "success",
      "such",
      "sudden",
      "suffer",
      "sugar",
      "suggest",
      "suit",
      "summer",
      "sun",
      "sunny",
      "sunset",
      "super",
      "supply",
      "supreme",
      "sure",
      "surface",
      "surge",
      "surprise",
      "surround",
      "survey",
      "suspect",
      "sustain",
      "swallow",
      "swamp",
      "swap",
      "swarm",
      "swear",
      "sweet",
      "swift",
      "swim",
      "swing",
      "switch",
      "sword",
      "symbol",
      "symptom",
      "syrup",
      "system",
      "table",
      "tackle",
      "tag",
      "tail",
      "talent",
      "talk",
      "tank",
      "tape",
      "target",
      "task",
      "taste",
      "tattoo",
      "taxi",
      "teach",
      "team",
      "tell",
      "ten",
      "tenant",
      "tennis",
      "tent",
      "term",
      "test",
      "text",
      "thank",
      "that",
      "theme",
      "then",
      "theory",
      "there",
      "they",
      "thing",
      "this",
      "thought",
      "three",
      "thrive",
      "throw",
      "thumb",
      "thunder",
      "ticket",
      "tide",
      "tiger",
      "tilt",
      "timber",
      "time",
      "tiny",
      "tip",
      "tired",
      "tissue",
      "title",
      "toast",
      "tobacco",
      "today",
      "toddler",
      "toe",
      "together",
      "toilet",
      "token",
      "tomato",
      "tomorrow",
      "tone",
      "tongue",
      "tonight",
      "tool",
      "tooth",
      "top",
      "topic",
      "topple",
      "torch",
      "tornado",
      "tortoise",
      "toss",
      "total",
      "tourist",
      "toward",
      "tower",
      "town",
      "toy",
      "track",
      "trade",
      "traffic",
      "tragic",
      "train",
      "transfer",
      "trap",
      "trash",
      "travel",
      "tray",
      "treat",
      "tree",
      "trend",
      "trial",
      "tribe",
      "trick",
      "trigger",
      "trim",
      "trip",
      "trophy",
      "trouble",
      "truck",
      "true",
      "truly",
      "trumpet",
      "trust",
      "truth",
      "try",
      "tube",
      "tuition",
      "tumble",
      "tuna",
      "tunnel",
      "turkey",
      "turn",
      "turtle",
      "twelve",
      "twenty",
      "twice",
      "twin",
      "twist",
      "two",
      "type",
      "typical",
      "ugly",
      "umbrella",
      "unable",
      "unaware",
      "uncle",
      "uncover",
      "under",
      "undo",
      "unfair",
      "unfold",
      "unhappy",
      "uniform",
      "unique",
      "unit",
      "universe",
      "unknown",
      "unlock",
      "until",
      "unusual",
      "unveil",
      "update",
      "upgrade",
      "uphold",
      "upon",
      "upper",
      "upset",
      "urban",
      "urge",
      "usage",
      "use",
      "used",
      "useful",
      "useless",
      "usual",
      "utility",
      "vacant",
      "vacuum",
      "vague",
      "valid",
      "valley",
      "valve",
      "van",
      "vanish",
      "vapor",
      "various",
      "vast",
      "vault",
      "vehicle",
      "velvet",
      "vendor",
      "venture",
      "venue",
      "verb",
      "verify",
      "version",
      "very",
      "vessel",
      "veteran",
      "viable",
      "vibrant",
      "vicious",
      "victory",
      "video",
      "view",
      "village",
      "vintage",
      "violin",
      "virtual",
      "virus",
      "visa",
      "visit",
      "visual",
      "vital",
      "vivid",
      "vocal",
      "voice",
      "void",
      "volcano",
      "volume",
      "vote",
      "voyage",
      "wage",
      "wagon",
      "wait",
      "walk",
      "wall",
      "walnut",
      "want",
      "warfare",
      "warm",
      "warrior",
      "wash",
      "wasp",
      "waste",
      "water",
      "wave",
      "way",
      "wealth",
      "weapon",
      "wear",
      "weasel",
      "weather",
      "web",
      "wedding",
      "weekend",
      "weird",
      "welcome",
      "west",
      "wet",
      "whale",
      "what",
      "wheat",
      "wheel",
      "when",
      "where",
      "whip",
      "whisper",
      "wide",
      "width",
      "wife",
      "wild",
      "will",
      "win",
      "window",
      "wine",
      "wing",
      "wink",
      "winner",
      "winter",
      "wire",
      "wisdom",
      "wise",
      "wish",
      "witness",
      "wolf",
      "woman",
      "wonder",
      "wood",
      "wool",
      "word",
      "work",
      "world",
      "worry",
      "worth",
      "wrap",
      "wreck",
      "wrestle",
      "wrist",
      "write",
      "wrong",
      "yard",
      "year",
      "yellow",
      "you",
      "young",
      "youth",
      "zebra",
      "zero",
      "zone",
      "zoo"
  ]
  
  },{}],134:[function(require,module,exports){
  module.exports=[
      "abaisser",
      "abandon",
      "abdiquer",
      "abeille",
      "abolir",
      "aborder",
      "aboutir",
      "aboyer",
      "abrasif",
      "abreuver",
      "abriter",
      "abroger",
      "abrupt",
      "absence",
      "absolu",
      "absurde",
      "abusif",
      "abyssal",
      "academie",
      "acajou",
      "acarien",
      "accabler",
      "accepter",
      "acclamer",
      "accolade",
      "accroche",
      "accuser",
      "acerbe",
      "achat",
      "acheter",
      "aciduler",
      "acier",
      "acompte",
      "acquerir",
      "acronyme",
      "acteur",
      "actif",
      "actuel",
      "adepte",
      "adequat",
      "adhesif",
      "adjectif",
      "adjuger",
      "admettre",
      "admirer",
      "adopter",
      "adorer",
      "adoucir",
      "adresse",
      "adroit",
      "adulte",
      "adverbe",
      "aerer",
      "aeronef",
      "affaire",
      "affecter",
      "affiche",
      "affreux",
      "affubler",
      "agacer",
      "agencer",
      "agile",
      "agiter",
      "agrafer",
      "agreable",
      "agrume",
      "aider",
      "aiguille",
      "ailier",
      "aimable",
      "aisance",
      "ajouter",
      "ajuster",
      "alarmer",
      "alchimie",
      "alerte",
      "algebre",
      "algue",
      "aliener",
      "aliment",
      "alleger",
      "alliage",
      "allouer",
      "allumer",
      "alourdir",
      "alpaga",
      "altesse",
      "alveole",
      "amateur",
      "ambigu",
      "ambre",
      "amenager",
      "amertume",
      "amidon",
      "amiral",
      "amorcer",
      "amour",
      "amovible",
      "amphibie",
      "ampleur",
      "amusant",
      "analyse",
      "anaphore",
      "anarchie",
      "anatomie",
      "ancien",
      "aneantir",
      "angle",
      "angoisse",
      "anguleux",
      "animal",
      "annexer",
      "annonce",
      "annuel",
      "anodin",
      "anomalie",
      "anonyme",
      "anormal",
      "antenne",
      "antidote",
      "anxieux",
      "apaiser",
      "aperitif",
      "aplanir",
      "apologie",
      "appareil",
      "appeler",
      "apporter",
      "appuyer",
      "aquarium",
      "aqueduc",
      "arbitre",
      "arbuste",
      "ardeur",
      "ardoise",
      "argent",
      "arlequin",
      "armature",
      "armement",
      "armoire",
      "armure",
      "arpenter",
      "arracher",
      "arriver",
      "arroser",
      "arsenic",
      "arteriel",
      "article",
      "aspect",
      "asphalte",
      "aspirer",
      "assaut",
      "asservir",
      "assiette",
      "associer",
      "assurer",
      "asticot",
      "astre",
      "astuce",
      "atelier",
      "atome",
      "atrium",
      "atroce",
      "attaque",
      "attentif",
      "attirer",
      "attraper",
      "aubaine",
      "auberge",
      "audace",
      "audible",
      "augurer",
      "aurore",
      "automne",
      "autruche",
      "avaler",
      "avancer",
      "avarice",
      "avenir",
      "averse",
      "aveugle",
      "aviateur",
      "avide",
      "avion",
      "aviser",
      "avoine",
      "avouer",
      "avril",
      "axial",
      "axiome",
      "badge",
      "bafouer",
      "bagage",
      "baguette",
      "baignade",
      "balancer",
      "balcon",
      "baleine",
      "balisage",
      "bambin",
      "bancaire",
      "bandage",
      "banlieue",
      "banniere",
      "banquier",
      "barbier",
      "baril",
      "baron",
      "barque",
      "barrage",
      "bassin",
      "bastion",
      "bataille",
      "bateau",
      "batterie",
      "baudrier",
      "bavarder",
      "belette",
      "belier",
      "belote",
      "benefice",
      "berceau",
      "berger",
      "berline",
      "bermuda",
      "besace",
      "besogne",
      "betail",
      "beurre",
      "biberon",
      "bicycle",
      "bidule",
      "bijou",
      "bilan",
      "bilingue",
      "billard",
      "binaire",
      "biologie",
      "biopsie",
      "biotype",
      "biscuit",
      "bison",
      "bistouri",
      "bitume",
      "bizarre",
      "blafard",
      "blague",
      "blanchir",
      "blessant",
      "blinder",
      "blond",
      "bloquer",
      "blouson",
      "bobard",
      "bobine",
      "boire",
      "boiser",
      "bolide",
      "bonbon",
      "bondir",
      "bonheur",
      "bonifier",
      "bonus",
      "bordure",
      "borne",
      "botte",
      "boucle",
      "boueux",
      "bougie",
      "boulon",
      "bouquin",
      "bourse",
      "boussole",
      "boutique",
      "boxeur",
      "branche",
      "brasier",
      "brave",
      "brebis",
      "breche",
      "breuvage",
      "bricoler",
      "brigade",
      "brillant",
      "brioche",
      "brique",
      "brochure",
      "broder",
      "bronzer",
      "brousse",
      "broyeur",
      "brume",
      "brusque",
      "brutal",
      "bruyant",
      "buffle",
      "buisson",
      "bulletin",
      "bureau",
      "burin",
      "bustier",
      "butiner",
      "butoir",
      "buvable",
      "buvette",
      "cabanon",
      "cabine",
      "cachette",
      "cadeau",
      "cadre",
      "cafeine",
      "caillou",
      "caisson",
      "calculer",
      "calepin",
      "calibre",
      "calmer",
      "calomnie",
      "calvaire",
      "camarade",
      "camera",
      "camion",
      "campagne",
      "canal",
      "caneton",
      "canon",
      "cantine",
      "canular",
      "capable",
      "caporal",
      "caprice",
      "capsule",
      "capter",
      "capuche",
      "carabine",
      "carbone",
      "caresser",
      "caribou",
      "carnage",
      "carotte",
      "carreau",
      "carton",
      "cascade",
      "casier",
      "casque",
      "cassure",
      "causer",
      "caution",
      "cavalier",
      "caverne",
      "caviar",
      "cedille",
      "ceinture",
      "celeste",
      "cellule",
      "cendrier",
      "censurer",
      "central",
      "cercle",
      "cerebral",
      "cerise",
      "cerner",
      "cerveau",
      "cesser",
      "chagrin",
      "chaise",
      "chaleur",
      "chambre",
      "chance",
      "chapitre",
      "charbon",
      "chasseur",
      "chaton",
      "chausson",
      "chavirer",
      "chemise",
      "chenille",
      "chequier",
      "chercher",
      "cheval",
      "chien",
      "chiffre",
      "chignon",
      "chimere",
      "chiot",
      "chlorure",
      "chocolat",
      "choisir",
      "chose",
      "chouette",
      "chrome",
      "chute",
      "cigare",
      "cigogne",
      "cimenter",
      "cinema",
      "cintrer",
      "circuler",
      "cirer",
      "cirque",
      "citerne",
      "citoyen",
      "citron",
      "civil",
      "clairon",
      "clameur",
      "claquer",
      "classe",
      "clavier",
      "client",
      "cligner",
      "climat",
      "clivage",
      "cloche",
      "clonage",
      "cloporte",
      "cobalt",
      "cobra",
      "cocasse",
      "cocotier",
      "coder",
      "codifier",
      "coffre",
      "cogner",
      "cohesion",
      "coiffer",
      "coincer",
      "colere",
      "colibri",
      "colline",
      "colmater",
      "colonel",
      "combat",
      "comedie",
      "commande",
      "compact",
      "concert",
      "conduire",
      "confier",
      "congeler",
      "connoter",
      "consonne",
      "contact",
      "convexe",
      "copain",
      "copie",
      "corail",
      "corbeau",
      "cordage",
      "corniche",
      "corpus",
      "correct",
      "cortege",
      "cosmique",
      "costume",
      "coton",
      "coude",
      "coupure",
      "courage",
      "couteau",
      "couvrir",
      "coyote",
      "crabe",
      "crainte",
      "cravate",
      "crayon",
      "creature",
      "crediter",
      "cremeux",
      "creuser",
      "crevette",
      "cribler",
      "crier",
      "cristal",
      "critere",
      "croire",
      "croquer",
      "crotale",
      "crucial",
      "cruel",
      "crypter",
      "cubique",
      "cueillir",
      "cuillere",
      "cuisine",
      "cuivre",
      "culminer",
      "cultiver",
      "cumuler",
      "cupide",
      "curatif",
      "curseur",
      "cyanure",
      "cycle",
      "cylindre",
      "cynique",
      "daigner",
      "damier",
      "danger",
      "danseur",
      "dauphin",
      "debattre",
      "debiter",
      "deborder",
      "debrider",
      "debutant",
      "decaler",
      "decembre",
      "dechirer",
      "decider",
      "declarer",
      "decorer",
      "decrire",
      "decupler",
      "dedale",
      "deductif",
      "deesse",
      "defensif",
      "defiler",
      "defrayer",
      "degager",
      "degivrer",
      "deglutir",
      "degrafer",
      "dejeuner",
      "delice",
      "deloger",
      "demander",
      "demeurer",
      "demolir",
      "denicher",
      "denouer",
      "dentelle",
      "denuder",
      "depart",
      "depenser",
      "dephaser",
      "deplacer",
      "deposer",
      "deranger",
      "derober",
      "desastre",
      "descente",
      "desert",
      "designer",
      "desobeir",
      "dessiner",
      "destrier",
      "detacher",
      "detester",
      "detourer",
      "detresse",
      "devancer",
      "devenir",
      "deviner",
      "devoir",
      "diable",
      "dialogue",
      "diamant",
      "dicter",
      "differer",
      "digerer",
      "digital",
      "digne",
      "diluer",
      "dimanche",
      "diminuer",
      "dioxyde",
      "directif",
      "diriger",
      "discuter",
      "disposer",
      "dissiper",
      "distance",
      "divertir",
      "diviser",
      "docile",
      "docteur",
      "dogme",
      "doigt",
      "domaine",
      "domicile",
      "dompter",
      "donateur",
      "donjon",
      "donner",
      "dopamine",
      "dortoir",
      "dorure",
      "dosage",
      "doseur",
      "dossier",
      "dotation",
      "douanier",
      "double",
      "douceur",
      "douter",
      "doyen",
      "dragon",
      "draper",
      "dresser",
      "dribbler",
      "droiture",
      "duperie",
      "duplexe",
      "durable",
      "durcir",
      "dynastie",
      "eblouir",
      "ecarter",
      "echarpe",
      "echelle",
      "eclairer",
      "eclipse",
      "eclore",
      "ecluse",
      "ecole",
      "economie",
      "ecorce",
      "ecouter",
      "ecraser",
      "ecremer",
      "ecrivain",
      "ecrou",
      "ecume",
      "ecureuil",
      "edifier",
      "eduquer",
      "effacer",
      "effectif",
      "effigie",
      "effort",
      "effrayer",
      "effusion",
      "egaliser",
      "egarer",
      "ejecter",
      "elaborer",
      "elargir",
      "electron",
      "elegant",
      "elephant",
      "eleve",
      "eligible",
      "elitisme",
      "eloge",
      "elucider",
      "eluder",
      "emballer",
      "embellir",
      "embryon",
      "emeraude",
      "emission",
      "emmener",
      "emotion",
      "emouvoir",
      "empereur",
      "employer",
      "emporter",
      "emprise",
      "emulsion",
      "encadrer",
      "enchere",
      "enclave",
      "encoche",
      "endiguer",
      "endosser",
      "endroit",
      "enduire",
      "energie",
      "enfance",
      "enfermer",
      "enfouir",
      "engager",
      "engin",
      "englober",
      "enigme",
      "enjamber",
      "enjeu",
      "enlever",
      "ennemi",
      "ennuyeux",
      "enrichir",
      "enrobage",
      "enseigne",
      "entasser",
      "entendre",
      "entier",
      "entourer",
      "entraver",
      "enumerer",
      "envahir",
      "enviable",
      "envoyer",
      "enzyme",
      "eolien",
      "epaissir",
      "epargne",
      "epatant",
      "epaule",
      "epicerie",
      "epidemie",
      "epier",
      "epilogue",
      "epine",
      "episode",
      "epitaphe",
      "epoque",
      "epreuve",
      "eprouver",
      "epuisant",
      "equerre",
      "equipe",
      "eriger",
      "erosion",
      "erreur",
      "eruption",
      "escalier",
      "espadon",
      "espece",
      "espiegle",
      "espoir",
      "esprit",
      "esquiver",
      "essayer",
      "essence",
      "essieu",
      "essorer",
      "estime",
      "estomac",
      "estrade",
      "etagere",
      "etaler",
      "etanche",
      "etatique",
      "eteindre",
      "etendoir",
      "eternel",
      "ethanol",
      "ethique",
      "ethnie",
      "etirer",
      "etoffer",
      "etoile",
      "etonnant",
      "etourdir",
      "etrange",
      "etroit",
      "etude",
      "euphorie",
      "evaluer",
      "evasion",
      "eventail",
      "evidence",
      "eviter",
      "evolutif",
      "evoquer",
      "exact",
      "exagerer",
      "exaucer",
      "exceller",
      "excitant",
      "exclusif",
      "excuse",
      "executer",
      "exemple",
      "exercer",
      "exhaler",
      "exhorter",
      "exigence",
      "exiler",
      "exister",
      "exotique",
      "expedier",
      "explorer",
      "exposer",
      "exprimer",
      "exquis",
      "extensif",
      "extraire",
      "exulter",
      "fable",
      "fabuleux",
      "facette",
      "facile",
      "facture",
      "faiblir",
      "falaise",
      "fameux",
      "famille",
      "farceur",
      "farfelu",
      "farine",
      "farouche",
      "fasciner",
      "fatal",
      "fatigue",
      "faucon",
      "fautif",
      "faveur",
      "favori",
      "febrile",
      "feconder",
      "federer",
      "felin",
      "femme",
      "femur",
      "fendoir",
      "feodal",
      "fermer",
      "feroce",
      "ferveur",
      "festival",
      "feuille",
      "feutre",
      "fevrier",
      "fiasco",
      "ficeler",
      "fictif",
      "fidele",
      "figure",
      "filature",
      "filetage",
      "filiere",
      "filleul",
      "filmer",
      "filou",
      "filtrer",
      "financer",
      "finir",
      "fiole",
      "firme",
      "fissure",
      "fixer",
      "flairer",
      "flamme",
      "flasque",
      "flatteur",
      "fleau",
      "fleche",
      "fleur",
      "flexion",
      "flocon",
      "flore",
      "fluctuer",
      "fluide",
      "fluvial",
      "folie",
      "fonderie",
      "fongible",
      "fontaine",
      "forcer",
      "forgeron",
      "formuler",
      "fortune",
      "fossile",
      "foudre",
      "fougere",
      "fouiller",
      "foulure",
      "fourmi",
      "fragile",
      "fraise",
      "franchir",
      "frapper",
      "frayeur",
      "fregate",
      "freiner",
      "frelon",
      "fremir",
      "frenesie",
      "frere",
      "friable",
      "friction",
      "frisson",
      "frivole",
      "froid",
      "fromage",
      "frontal",
      "frotter",
      "fruit",
      "fugitif",
      "fuite",
      "fureur",
      "furieux",
      "furtif",
      "fusion",
      "futur",
      "gagner",
      "galaxie",
      "galerie",
      "gambader",
      "garantir",
      "gardien",
      "garnir",
      "garrigue",
      "gazelle",
      "gazon",
      "geant",
      "gelatine",
      "gelule",
      "gendarme",
      "general",
      "genie",
      "genou",
      "gentil",
      "geologie",
      "geometre",
      "geranium",
      "germe",
      "gestuel",
      "geyser",
      "gibier",
      "gicler",
      "girafe",
      "givre",
      "glace",
      "glaive",
      "glisser",
      "globe",
      "gloire",
      "glorieux",
      "golfeur",
      "gomme",
      "gonfler",
      "gorge",
      "gorille",
      "goudron",
      "gouffre",
      "goulot",
      "goupille",
      "gourmand",
      "goutte",
      "graduel",
      "graffiti",
      "graine",
      "grand",
      "grappin",
      "gratuit",
      "gravir",
      "grenat",
      "griffure",
      "griller",
      "grimper",
      "grogner",
      "gronder",
      "grotte",
      "groupe",
      "gruger",
      "grutier",
      "gruyere",
      "guepard",
      "guerrier",
      "guide",
      "guimauve",
      "guitare",
      "gustatif",
      "gymnaste",
      "gyrostat",
      "habitude",
      "hachoir",
      "halte",
      "hameau",
      "hangar",
      "hanneton",
      "haricot",
      "harmonie",
      "harpon",
      "hasard",
      "helium",
      "hematome",
      "herbe",
      "herisson",
      "hermine",
      "heron",
      "hesiter",
      "heureux",
      "hiberner",
      "hibou",
      "hilarant",
      "histoire",
      "hiver",
      "homard",
      "hommage",
      "homogene",
      "honneur",
      "honorer",
      "honteux",
      "horde",
      "horizon",
      "horloge",
      "hormone",
      "horrible",
      "houleux",
      "housse",
      "hublot",
      "huileux",
      "humain",
      "humble",
      "humide",
      "humour",
      "hurler",
      "hydromel",
      "hygiene",
      "hymne",
      "hypnose",
      "idylle",
      "ignorer",
      "iguane",
      "illicite",
      "illusion",
      "image",
      "imbiber",
      "imiter",
      "immense",
      "immobile",
      "immuable",
      "impact",
      "imperial",
      "implorer",
      "imposer",
      "imprimer",
      "imputer",
      "incarner",
      "incendie",
      "incident",
      "incliner",
      "incolore",
      "indexer",
      "indice",
      "inductif",
      "inedit",
      "ineptie",
      "inexact",
      "infini",
      "infliger",
      "informer",
      "infusion",
      "ingerer",
      "inhaler",
      "inhiber",
      "injecter",
      "injure",
      "innocent",
      "inoculer",
      "inonder",
      "inscrire",
      "insecte",
      "insigne",
      "insolite",
      "inspirer",
      "instinct",
      "insulter",
      "intact",
      "intense",
      "intime",
      "intrigue",
      "intuitif",
      "inutile",
      "invasion",
      "inventer",
      "inviter",
      "invoquer",
      "ironique",
      "irradier",
      "irreel",
      "irriter",
      "isoler",
      "ivoire",
      "ivresse",
      "jaguar",
      "jaillir",
      "jambe",
      "janvier",
      "jardin",
      "jauger",
      "jaune",
      "javelot",
      "jetable",
      "jeton",
      "jeudi",
      "jeunesse",
      "joindre",
      "joncher",
      "jongler",
      "joueur",
      "jouissif",
      "journal",
      "jovial",
      "joyau",
      "joyeux",
      "jubiler",
      "jugement",
      "junior",
      "jupon",
      "juriste",
      "justice",
      "juteux",
      "juvenile",
      "kayak",
      "kimono",
      "kiosque",
      "label",
      "labial",
      "labourer",
      "lacerer",
      "lactose",
      "lagune",
      "laine",
      "laisser",
      "laitier",
      "lambeau",
      "lamelle",
      "lampe",
      "lanceur",
      "langage",
      "lanterne",
      "lapin",
      "largeur",
      "larme",
      "laurier",
      "lavabo",
      "lavoir",
      "lecture",
      "legal",
      "leger",
      "legume",
      "lessive",
      "lettre",
      "levier",
      "lexique",
      "lezard",
      "liasse",
      "liberer",
      "libre",
      "licence",
      "licorne",
      "liege",
      "lievre",
      "ligature",
      "ligoter",
      "ligue",
      "limer",
      "limite",
      "limonade",
      "limpide",
      "lineaire",
      "lingot",
      "lionceau",
      "liquide",
      "lisiere",
      "lister",
      "lithium",
      "litige",
      "littoral",
      "livreur",
      "logique",
      "lointain",
      "loisir",
      "lombric",
      "loterie",
      "louer",
      "lourd",
      "loutre",
      "louve",
      "loyal",
      "lubie",
      "lucide",
      "lucratif",
      "lueur",
      "lugubre",
      "luisant",
      "lumiere",
      "lunaire",
      "lundi",
      "luron",
      "lutter",
      "luxueux",
      "machine",
      "magasin",
      "magenta",
      "magique",
      "maigre",
      "maillon",
      "maintien",
      "mairie",
      "maison",
      "majorer",
      "malaxer",
      "malefice",
      "malheur",
      "malice",
      "mallette",
      "mammouth",
      "mandater",
      "maniable",
      "manquant",
      "manteau",
      "manuel",
      "marathon",
      "marbre",
      "marchand",
      "mardi",
      "maritime",
      "marqueur",
      "marron",
      "marteler",
      "mascotte",
      "massif",
      "materiel",
      "matiere",
      "matraque",
      "maudire",
      "maussade",
      "mauve",
      "maximal",
      "mechant",
      "meconnu",
      "medaille",
      "medecin",
      "mediter",
      "meduse",
      "meilleur",
      "melange",
      "melodie",
      "membre",
      "memoire",
      "menacer",
      "mener",
      "menhir",
      "mensonge",
      "mentor",
      "mercredi",
      "merite",
      "merle",
      "messager",
      "mesure",
      "metal",
      "meteore",
      "methode",
      "metier",
      "meuble",
      "miauler",
      "microbe",
      "miette",
      "mignon",
      "migrer",
      "milieu",
      "million",
      "mimique",
      "mince",
      "mineral",
      "minimal",
      "minorer",
      "minute",
      "miracle",
      "miroiter",
      "missile",
      "mixte",
      "mobile",
      "moderne",
      "moelleux",
      "mondial",
      "moniteur",
      "monnaie",
      "monotone",
      "monstre",
      "montagne",
      "monument",
      "moqueur",
      "morceau",
      "morsure",
      "mortier",
      "moteur",
      "motif",
      "mouche",
      "moufle",
      "moulin",
      "mousson",
      "mouton",
      "mouvant",
      "multiple",
      "munition",
      "muraille",
      "murene",
      "murmure",
      "muscle",
      "museum",
      "musicien",
      "mutation",
      "muter",
      "mutuel",
      "myriade",
      "myrtille",
      "mystere",
      "mythique",
      "nageur",
      "nappe",
      "narquois",
      "narrer",
      "natation",
      "nation",
      "nature",
      "naufrage",
      "nautique",
      "navire",
      "nebuleux",
      "nectar",
      "nefaste",
      "negation",
      "negliger",
      "negocier",
      "neige",
      "nerveux",
      "nettoyer",
      "neurone",
      "neutron",
      "neveu",
      "niche",
      "nickel",
      "nitrate",
      "niveau",
      "noble",
      "nocif",
      "nocturne",
      "noirceur",
      "noisette",
      "nomade",
      "nombreux",
      "nommer",
      "normatif",
      "notable",
      "notifier",
      "notoire",
      "nourrir",
      "nouveau",
      "novateur",
      "novembre",
      "novice",
      "nuage",
      "nuancer",
      "nuire",
      "nuisible",
      "numero",
      "nuptial",
      "nuque",
      "nutritif",
      "obeir",
      "objectif",
      "obliger",
      "obscur",
      "observer",
      "obstacle",
      "obtenir",
      "obturer",
      "occasion",
      "occuper",
      "ocean",
      "octobre",
      "octroyer",
      "octupler",
      "oculaire",
      "odeur",
      "odorant",
      "offenser",
      "officier",
      "offrir",
      "ogive",
      "oiseau",
      "oisillon",
      "olfactif",
      "olivier",
      "ombrage",
      "omettre",
      "onctueux",
      "onduler",
      "onereux",
      "onirique",
      "opale",
      "opaque",
      "operer",
      "opinion",
      "opportun",
      "opprimer",
      "opter",
      "optique",
      "orageux",
      "orange",
      "orbite",
      "ordonner",
      "oreille",
      "organe",
      "orgueil",
      "orifice",
      "ornement",
      "orque",
      "ortie",
      "osciller",
      "osmose",
      "ossature",
      "otarie",
      "ouragan",
      "ourson",
      "outil",
      "outrager",
      "ouvrage",
      "ovation",
      "oxyde",
      "oxygene",
      "ozone",
      "paisible",
      "palace",
      "palmares",
      "palourde",
      "palper",
      "panache",
      "panda",
      "pangolin",
      "paniquer",
      "panneau",
      "panorama",
      "pantalon",
      "papaye",
      "papier",
      "papoter",
      "papyrus",
      "paradoxe",
      "parcelle",
      "paresse",
      "parfumer",
      "parler",
      "parole",
      "parrain",
      "parsemer",
      "partager",
      "parure",
      "parvenir",
      "passion",
      "pasteque",
      "paternel",
      "patience",
      "patron",
      "pavillon",
      "pavoiser",
      "payer",
      "paysage",
      "peigne",
      "peintre",
      "pelage",
      "pelican",
      "pelle",
      "pelouse",
      "peluche",
      "pendule",
      "penetrer",
      "penible",
      "pensif",
      "penurie",
      "pepite",
      "peplum",
      "perdrix",
      "perforer",
      "periode",
      "permuter",
      "perplexe",
      "persil",
      "perte",
      "peser",
      "petale",
      "petit",
      "petrir",
      "peuple",
      "pharaon",
      "phobie",
      "phoque",
      "photon",
      "phrase",
      "physique",
      "piano",
      "pictural",
      "piece",
      "pierre",
      "pieuvre",
      "pilote",
      "pinceau",
      "pipette",
      "piquer",
      "pirogue",
      "piscine",
      "piston",
      "pivoter",
      "pixel",
      "pizza",
      "placard",
      "plafond",
      "plaisir",
      "planer",
      "plaque",
      "plastron",
      "plateau",
      "pleurer",
      "plexus",
      "pliage",
      "plomb",
      "plonger",
      "pluie",
      "plumage",
      "pochette",
      "poesie",
      "poete",
      "pointe",
      "poirier",
      "poisson",
      "poivre",
      "polaire",
      "policier",
      "pollen",
      "polygone",
      "pommade",
      "pompier",
      "ponctuel",
      "ponderer",
      "poney",
      "portique",
      "position",
      "posseder",
      "posture",
      "potager",
      "poteau",
      "potion",
      "pouce",
      "poulain",
      "poumon",
      "pourpre",
      "poussin",
      "pouvoir",
      "prairie",
      "pratique",
      "precieux",
      "predire",
      "prefixe",
      "prelude",
      "prenom",
      "presence",
      "pretexte",
      "prevoir",
      "primitif",
      "prince",
      "prison",
      "priver",
      "probleme",
      "proceder",
      "prodige",
      "profond",
      "progres",
      "proie",
      "projeter",
      "prologue",
      "promener",
      "propre",
      "prospere",
      "proteger",
      "prouesse",
      "proverbe",
      "prudence",
      "pruneau",
      "psychose",
      "public",
      "puceron",
      "puiser",
      "pulpe",
      "pulsar",
      "punaise",
      "punitif",
      "pupitre",
      "purifier",
      "puzzle",
      "pyramide",
      "quasar",
      "querelle",
      "question",
      "quietude",
      "quitter",
      "quotient",
      "racine",
      "raconter",
      "radieux",
      "ragondin",
      "raideur",
      "raisin",
      "ralentir",
      "rallonge",
      "ramasser",
      "rapide",
      "rasage",
      "ratisser",
      "ravager",
      "ravin",
      "rayonner",
      "reactif",
      "reagir",
      "realiser",
      "reanimer",
      "recevoir",
      "reciter",
      "reclamer",
      "recolter",
      "recruter",
      "reculer",
      "recycler",
      "rediger",
      "redouter",
      "refaire",
      "reflexe",
      "reformer",
      "refrain",
      "refuge",
      "regalien",
      "region",
      "reglage",
      "regulier",
      "reiterer",
      "rejeter",
      "rejouer",
      "relatif",
      "relever",
      "relief",
      "remarque",
      "remede",
      "remise",
      "remonter",
      "remplir",
      "remuer",
      "renard",
      "renfort",
      "renifler",
      "renoncer",
      "rentrer",
      "renvoi",
      "replier",
      "reporter",
      "reprise",
      "reptile",
      "requin",
      "reserve",
      "resineux",
      "resoudre",
      "respect",
      "rester",
      "resultat",
      "retablir",
      "retenir",
      "reticule",
      "retomber",
      "retracer",
      "reunion",
      "reussir",
      "revanche",
      "revivre",
      "revolte",
      "revulsif",
      "richesse",
      "rideau",
      "rieur",
      "rigide",
      "rigoler",
      "rincer",
      "riposter",
      "risible",
      "risque",
      "rituel",
      "rival",
      "riviere",
      "rocheux",
      "romance",
      "rompre",
      "ronce",
      "rondin",
      "roseau",
      "rosier",
      "rotatif",
      "rotor",
      "rotule",
      "rouge",
      "rouille",
      "rouleau",
      "routine",
      "royaume",
      "ruban",
      "rubis",
      "ruche",
      "ruelle",
      "rugueux",
      "ruiner",
      "ruisseau",
      "ruser",
      "rustique",
      "rythme",
      "sabler",
      "saboter",
      "sabre",
      "sacoche",
      "safari",
      "sagesse",
      "saisir",
      "salade",
      "salive",
      "salon",
      "saluer",
      "samedi",
      "sanction",
      "sanglier",
      "sarcasme",
      "sardine",
      "saturer",
      "saugrenu",
      "saumon",
      "sauter",
      "sauvage",
      "savant",
      "savonner",
      "scalpel",
      "scandale",
      "scelerat",
      "scenario",
      "sceptre",
      "schema",
      "science",
      "scinder",
      "score",
      "scrutin",
      "sculpter",
      "seance",
      "secable",
      "secher",
      "secouer",
      "secreter",
      "sedatif",
      "seduire",
      "seigneur",
      "sejour",
      "selectif",
      "semaine",
      "sembler",
      "semence",
      "seminal",
      "senateur",
      "sensible",
      "sentence",
      "separer",
      "sequence",
      "serein",
      "sergent",
      "serieux",
      "serrure",
      "serum",
      "service",
      "sesame",
      "sevir",
      "sevrage",
      "sextuple",
      "sideral",
      "siecle",
      "sieger",
      "siffler",
      "sigle",
      "signal",
      "silence",
      "silicium",
      "simple",
      "sincere",
      "sinistre",
      "siphon",
      "sirop",
      "sismique",
      "situer",
      "skier",
      "social",
      "socle",
      "sodium",
      "soigneux",
      "soldat",
      "soleil",
      "solitude",
      "soluble",
      "sombre",
      "sommeil",
      "somnoler",
      "sonde",
      "songeur",
      "sonnette",
      "sonore",
      "sorcier",
      "sortir",
      "sosie",
      "sottise",
      "soucieux",
      "soudure",
      "souffle",
      "soulever",
      "soupape",
      "source",
      "soutirer",
      "souvenir",
      "spacieux",
      "spatial",
      "special",
      "sphere",
      "spiral",
      "stable",
      "station",
      "sternum",
      "stimulus",
      "stipuler",
      "strict",
      "studieux",
      "stupeur",
      "styliste",
      "sublime",
      "substrat",
      "subtil",
      "subvenir",
      "succes",
      "sucre",
      "suffixe",
      "suggerer",
      "suiveur",
      "sulfate",
      "superbe",
      "supplier",
      "surface",
      "suricate",
      "surmener",
      "surprise",
      "sursaut",
      "survie",
      "suspect",
      "syllabe",
      "symbole",
      "symetrie",
      "synapse",
      "syntaxe",
      "systeme",
      "tabac",
      "tablier",
      "tactile",
      "tailler",
      "talent",
      "talisman",
      "talonner",
      "tambour",
      "tamiser",
      "tangible",
      "tapis",
      "taquiner",
      "tarder",
      "tarif",
      "tartine",
      "tasse",
      "tatami",
      "tatouage",
      "taupe",
      "taureau",
      "taxer",
      "temoin",
      "temporel",
      "tenaille",
      "tendre",
      "teneur",
      "tenir",
      "tension",
      "terminer",
      "terne",
      "terrible",
      "tetine",
      "texte",
      "theme",
      "theorie",
      "therapie",
      "thorax",
      "tibia",
      "tiede",
      "timide",
      "tirelire",
      "tiroir",
      "tissu",
      "titane",
      "titre",
      "tituber",
      "toboggan",
      "tolerant",
      "tomate",
      "tonique",
      "tonneau",
      "toponyme",
      "torche",
      "tordre",
      "tornade",
      "torpille",
      "torrent",
      "torse",
      "tortue",
      "totem",
      "toucher",
      "tournage",
      "tousser",
      "toxine",
      "traction",
      "trafic",
      "tragique",
      "trahir",
      "train",
      "trancher",
      "travail",
      "trefle",
      "tremper",
      "tresor",
      "treuil",
      "triage",
      "tribunal",
      "tricoter",
      "trilogie",
      "triomphe",
      "tripler",
      "triturer",
      "trivial",
      "trombone",
      "tronc",
      "tropical",
      "troupeau",
      "tuile",
      "tulipe",
      "tumulte",
      "tunnel",
      "turbine",
      "tuteur",
      "tutoyer",
      "tuyau",
      "tympan",
      "typhon",
      "typique",
      "tyran",
      "ubuesque",
      "ultime",
      "ultrason",
      "unanime",
      "unifier",
      "union",
      "unique",
      "unitaire",
      "univers",
      "uranium",
      "urbain",
      "urticant",
      "usage",
      "usine",
      "usuel",
      "usure",
      "utile",
      "utopie",
      "vacarme",
      "vaccin",
      "vagabond",
      "vague",
      "vaillant",
      "vaincre",
      "vaisseau",
      "valable",
      "valise",
      "vallon",
      "valve",
      "vampire",
      "vanille",
      "vapeur",
      "varier",
      "vaseux",
      "vassal",
      "vaste",
      "vecteur",
      "vedette",
      "vegetal",
      "vehicule",
      "veinard",
      "veloce",
      "vendredi",
      "venerer",
      "venger",
      "venimeux",
      "ventouse",
      "verdure",
      "verin",
      "vernir",
      "verrou",
      "verser",
      "vertu",
      "veston",
      "veteran",
      "vetuste",
      "vexant",
      "vexer",
      "viaduc",
      "viande",
      "victoire",
      "vidange",
      "video",
      "vignette",
      "vigueur",
      "vilain",
      "village",
      "vinaigre",
      "violon",
      "vipere",
      "virement",
      "virtuose",
      "virus",
      "visage",
      "viseur",
      "vision",
      "visqueux",
      "visuel",
      "vital",
      "vitesse",
      "viticole",
      "vitrine",
      "vivace",
      "vivipare",
      "vocation",
      "voguer",
      "voile",
      "voisin",
      "voiture",
      "volaille",
      "volcan",
      "voltiger",
      "volume",
      "vorace",
      "vortex",
      "voter",
      "vouloir",
      "voyage",
      "voyelle",
      "wagon",
      "xenon",
      "yacht",
      "zebre",
      "zenith",
      "zeste",
      "zoologie"
  ]
  
  },{}],135:[function(require,module,exports){
  module.exports=[
      "abaco",
      "abbaglio",
      "abbinato",
      "abete",
      "abisso",
      "abolire",
      "abrasivo",
      "abrogato",
      "accadere",
      "accenno",
      "accusato",
      "acetone",
      "achille",
      "acido",
      "acqua",
      "acre",
      "acrilico",
      "acrobata",
      "acuto",
      "adagio",
      "addebito",
      "addome",
      "adeguato",
      "aderire",
      "adipe",
      "adottare",
      "adulare",
      "affabile",
      "affetto",
      "affisso",
      "affranto",
      "aforisma",
      "afoso",
      "africano",
      "agave",
      "agente",
      "agevole",
      "aggancio",
      "agire",
      "agitare",
      "agonismo",
      "agricolo",
      "agrumeto",
      "aguzzo",
      "alabarda",
      "alato",
      "albatro",
      "alberato",
      "albo",
      "albume",
      "alce",
      "alcolico",
      "alettone",
      "alfa",
      "algebra",
      "aliante",
      "alibi",
      "alimento",
      "allagato",
      "allegro",
      "allievo",
      "allodola",
      "allusivo",
      "almeno",
      "alogeno",
      "alpaca",
      "alpestre",
      "altalena",
      "alterno",
      "alticcio",
      "altrove",
      "alunno",
      "alveolo",
      "alzare",
      "amalgama",
      "amanita",
      "amarena",
      "ambito",
      "ambrato",
      "ameba",
      "america",
      "ametista",
      "amico",
      "ammasso",
      "ammenda",
      "ammirare",
      "ammonito",
      "amore",
      "ampio",
      "ampliare",
      "amuleto",
      "anacardo",
      "anagrafe",
      "analista",
      "anarchia",
      "anatra",
      "anca",
      "ancella",
      "ancora",
      "andare",
      "andrea",
      "anello",
      "angelo",
      "angolare",
      "angusto",
      "anima",
      "annegare",
      "annidato",
      "anno",
      "annuncio",
      "anonimo",
      "anticipo",
      "anzi",
      "apatico",
      "apertura",
      "apode",
      "apparire",
      "appetito",
      "appoggio",
      "approdo",
      "appunto",
      "aprile",
      "arabica",
      "arachide",
      "aragosta",
      "araldica",
      "arancio",
      "aratura",
      "arazzo",
      "arbitro",
      "archivio",
      "ardito",
      "arenile",
      "argento",
      "argine",
      "arguto",
      "aria",
      "armonia",
      "arnese",
      "arredato",
      "arringa",
      "arrosto",
      "arsenico",
      "arso",
      "artefice",
      "arzillo",
      "asciutto",
      "ascolto",
      "asepsi",
      "asettico",
      "asfalto",
      "asino",
      "asola",
      "aspirato",
      "aspro",
      "assaggio",
      "asse",
      "assoluto",
      "assurdo",
      "asta",
      "astenuto",
      "astice",
      "astratto",
      "atavico",
      "ateismo",
      "atomico",
      "atono",
      "attesa",
      "attivare",
      "attorno",
      "attrito",
      "attuale",
      "ausilio",
      "austria",
      "autista",
      "autonomo",
      "autunno",
      "avanzato",
      "avere",
      "avvenire",
      "avviso",
      "avvolgere",
      "azione",
      "azoto",
      "azzimo",
      "azzurro",
      "babele",
      "baccano",
      "bacino",
      "baco",
      "badessa",
      "badilata",
      "bagnato",
      "baita",
      "balcone",
      "baldo",
      "balena",
      "ballata",
      "balzano",
      "bambino",
      "bandire",
      "baraonda",
      "barbaro",
      "barca",
      "baritono",
      "barlume",
      "barocco",
      "basilico",
      "basso",
      "batosta",
      "battuto",
      "baule",
      "bava",
      "bavosa",
      "becco",
      "beffa",
      "belgio",
      "belva",
      "benda",
      "benevole",
      "benigno",
      "benzina",
      "bere",
      "berlina",
      "beta",
      "bibita",
      "bici",
      "bidone",
      "bifido",
      "biga",
      "bilancia",
      "bimbo",
      "binocolo",
      "biologo",
      "bipede",
      "bipolare",
      "birbante",
      "birra",
      "biscotto",
      "bisesto",
      "bisnonno",
      "bisonte",
      "bisturi",
      "bizzarro",
      "blando",
      "blatta",
      "bollito",
      "bonifico",
      "bordo",
      "bosco",
      "botanico",
      "bottino",
      "bozzolo",
      "braccio",
      "bradipo",
      "brama",
      "branca",
      "bravura",
      "bretella",
      "brevetto",
      "brezza",
      "briglia",
      "brillante",
      "brindare",
      "broccolo",
      "brodo",
      "bronzina",
      "brullo",
      "bruno",
      "bubbone",
      "buca",
      "budino",
      "buffone",
      "buio",
      "bulbo",
      "buono",
      "burlone",
      "burrasca",
      "bussola",
      "busta",
      "cadetto",
      "caduco",
      "calamaro",
      "calcolo",
      "calesse",
      "calibro",
      "calmo",
      "caloria",
      "cambusa",
      "camerata",
      "camicia",
      "cammino",
      "camola",
      "campale",
      "canapa",
      "candela",
      "cane",
      "canino",
      "canotto",
      "cantina",
      "capace",
      "capello",
      "capitolo",
      "capogiro",
      "cappero",
      "capra",
      "capsula",
      "carapace",
      "carcassa",
      "cardo",
      "carisma",
      "carovana",
      "carretto",
      "cartolina",
      "casaccio",
      "cascata",
      "caserma",
      "caso",
      "cassone",
      "castello",
      "casuale",
      "catasta",
      "catena",
      "catrame",
      "cauto",
      "cavillo",
      "cedibile",
      "cedrata",
      "cefalo",
      "celebre",
      "cellulare",
      "cena",
      "cenone",
      "centesimo",
      "ceramica",
      "cercare",
      "certo",
      "cerume",
      "cervello",
      "cesoia",
      "cespo",
      "ceto",
      "chela",
      "chiaro",
      "chicca",
      "chiedere",
      "chimera",
      "china",
      "chirurgo",
      "chitarra",
      "ciao",
      "ciclismo",
      "cifrare",
      "cigno",
      "cilindro",
      "ciottolo",
      "circa",
      "cirrosi",
      "citrico",
      "cittadino",
      "ciuffo",
      "civetta",
      "civile",
      "classico",
      "clinica",
      "cloro",
      "cocco",
      "codardo",
      "codice",
      "coerente",
      "cognome",
      "collare",
      "colmato",
      "colore",
      "colposo",
      "coltivato",
      "colza",
      "coma",
      "cometa",
      "commando",
      "comodo",
      "computer",
      "comune",
      "conciso",
      "condurre",
      "conferma",
      "congelare",
      "coniuge",
      "connesso",
      "conoscere",
      "consumo",
      "continuo",
      "convegno",
      "coperto",
      "copione",
      "coppia",
      "copricapo",
      "corazza",
      "cordata",
      "coricato",
      "cornice",
      "corolla",
      "corpo",
      "corredo",
      "corsia",
      "cortese",
      "cosmico",
      "costante",
      "cottura",
      "covato",
      "cratere",
      "cravatta",
      "creato",
      "credere",
      "cremoso",
      "crescita",
      "creta",
      "criceto",
      "crinale",
      "crisi",
      "critico",
      "croce",
      "cronaca",
      "crostata",
      "cruciale",
      "crusca",
      "cucire",
      "cuculo",
      "cugino",
      "cullato",
      "cupola",
      "curatore",
      "cursore",
      "curvo",
      "cuscino",
      "custode",
      "dado",
      "daino",
      "dalmata",
      "damerino",
      "daniela",
      "dannoso",
      "danzare",
      "datato",
      "davanti",
      "davvero",
      "debutto",
      "decennio",
      "deciso",
      "declino",
      "decollo",
      "decreto",
      "dedicato",
      "definito",
      "deforme",
      "degno",
      "delegare",
      "delfino",
      "delirio",
      "delta",
      "demenza",
      "denotato",
      "dentro",
      "deposito",
      "derapata",
      "derivare",
      "deroga",
      "descritto",
      "deserto",
      "desiderio",
      "desumere",
      "detersivo",
      "devoto",
      "diametro",
      "dicembre",
      "diedro",
      "difeso",
      "diffuso",
      "digerire",
      "digitale",
      "diluvio",
      "dinamico",
      "dinnanzi",
      "dipinto",
      "diploma",
      "dipolo",
      "diradare",
      "dire",
      "dirotto",
      "dirupo",
      "disagio",
      "discreto",
      "disfare",
      "disgelo",
      "disposto",
      "distanza",
      "disumano",
      "dito",
      "divano",
      "divelto",
      "dividere",
      "divorato",
      "doblone",
      "docente",
      "doganale",
      "dogma",
      "dolce",
      "domato",
      "domenica",
      "dominare",
      "dondolo",
      "dono",
      "dormire",
      "dote",
      "dottore",
      "dovuto",
      "dozzina",
      "drago",
      "druido",
      "dubbio",
      "dubitare",
      "ducale",
      "duna",
      "duomo",
      "duplice",
      "duraturo",
      "ebano",
      "eccesso",
      "ecco",
      "eclissi",
      "economia",
      "edera",
      "edicola",
      "edile",
      "editoria",
      "educare",
      "egemonia",
      "egli",
      "egoismo",
      "egregio",
      "elaborato",
      "elargire",
      "elegante",
      "elencato",
      "eletto",
      "elevare",
      "elfico",
      "elica",
      "elmo",
      "elsa",
      "eluso",
      "emanato",
      "emblema",
      "emesso",
      "emiro",
      "emotivo",
      "emozione",
      "empirico",
      "emulo",
      "endemico",
      "enduro",
      "energia",
      "enfasi",
      "enoteca",
      "entrare",
      "enzima",
      "epatite",
      "epilogo",
      "episodio",
      "epocale",
      "eppure",
      "equatore",
      "erario",
      "erba",
      "erboso",
      "erede",
      "eremita",
      "erigere",
      "ermetico",
      "eroe",
      "erosivo",
      "errante",
      "esagono",
      "esame",
      "esanime",
      "esaudire",
      "esca",
      "esempio",
      "esercito",
      "esibito",
      "esigente",
      "esistere",
      "esito",
      "esofago",
      "esortato",
      "esoso",
      "espanso",
      "espresso",
      "essenza",
      "esso",
      "esteso",
      "estimare",
      "estonia",
      "estroso",
      "esultare",
      "etilico",
      "etnico",
      "etrusco",
      "etto",
      "euclideo",
      "europa",
      "evaso",
      "evidenza",
      "evitato",
      "evoluto",
      "evviva",
      "fabbrica",
      "faccenda",
      "fachiro",
      "falco",
      "famiglia",
      "fanale",
      "fanfara",
      "fango",
      "fantasma",
      "fare",
      "farfalla",
      "farinoso",
      "farmaco",
      "fascia",
      "fastoso",
      "fasullo",
      "faticare",
      "fato",
      "favoloso",
      "febbre",
      "fecola",
      "fede",
      "fegato",
      "felpa",
      "feltro",
      "femmina",
      "fendere",
      "fenomeno",
      "fermento",
      "ferro",
      "fertile",
      "fessura",
      "festivo",
      "fetta",
      "feudo",
      "fiaba",
      "fiducia",
      "fifa",
      "figurato",
      "filo",
      "finanza",
      "finestra",
      "finire",
      "fiore",
      "fiscale",
      "fisico",
      "fiume",
      "flacone",
      "flamenco",
      "flebo",
      "flemma",
      "florido",
      "fluente",
      "fluoro",
      "fobico",
      "focaccia",
      "focoso",
      "foderato",
      "foglio",
      "folata",
      "folclore",
      "folgore",
      "fondente",
      "fonetico",
      "fonia",
      "fontana",
      "forbito",
      "forchetta",
      "foresta",
      "formica",
      "fornaio",
      "foro",
      "fortezza",
      "forzare",
      "fosfato",
      "fosso",
      "fracasso",
      "frana",
      "frassino",
      "fratello",
      "freccetta",
      "frenata",
      "fresco",
      "frigo",
      "frollino",
      "fronde",
      "frugale",
      "frutta",
      "fucilata",
      "fucsia",
      "fuggente",
      "fulmine",
      "fulvo",
      "fumante",
      "fumetto",
      "fumoso",
      "fune",
      "funzione",
      "fuoco",
      "furbo",
      "furgone",
      "furore",
      "fuso",
      "futile",
      "gabbiano",
      "gaffe",
      "galateo",
      "gallina",
      "galoppo",
      "gambero",
      "gamma",
      "garanzia",
      "garbo",
      "garofano",
      "garzone",
      "gasdotto",
      "gasolio",
      "gastrico",
      "gatto",
      "gaudio",
      "gazebo",
      "gazzella",
      "geco",
      "gelatina",
      "gelso",
      "gemello",
      "gemmato",
      "gene",
      "genitore",
      "gennaio",
      "genotipo",
      "gergo",
      "ghepardo",
      "ghiaccio",
      "ghisa",
      "giallo",
      "gilda",
      "ginepro",
      "giocare",
      "gioiello",
      "giorno",
      "giove",
      "girato",
      "girone",
      "gittata",
      "giudizio",
      "giurato",
      "giusto",
      "globulo",
      "glutine",
      "gnomo",
      "gobba",
      "golf",
      "gomito",
      "gommone",
      "gonfio",
      "gonna",
      "governo",
      "gracile",
      "grado",
      "grafico",
      "grammo",
      "grande",
      "grattare",
      "gravoso",
      "grazia",
      "greca",
      "gregge",
      "grifone",
      "grigio",
      "grinza",
      "grotta",
      "gruppo",
      "guadagno",
      "guaio",
      "guanto",
      "guardare",
      "gufo",
      "guidare",
      "ibernato",
      "icona",
      "identico",
      "idillio",
      "idolo",
      "idra",
      "idrico",
      "idrogeno",
      "igiene",
      "ignaro",
      "ignorato",
      "ilare",
      "illeso",
      "illogico",
      "illudere",
      "imballo",
      "imbevuto",
      "imbocco",
      "imbuto",
      "immane",
      "immerso",
      "immolato",
      "impacco",
      "impeto",
      "impiego",
      "importo",
      "impronta",
      "inalare",
      "inarcare",
      "inattivo",
      "incanto",
      "incendio",
      "inchino",
      "incisivo",
      "incluso",
      "incontro",
      "incrocio",
      "incubo",
      "indagine",
      "india",
      "indole",
      "inedito",
      "infatti",
      "infilare",
      "inflitto",
      "ingaggio",
      "ingegno",
      "inglese",
      "ingordo",
      "ingrosso",
      "innesco",
      "inodore",
      "inoltrare",
      "inondato",
      "insano",
      "insetto",
      "insieme",
      "insonnia",
      "insulina",
      "intasato",
      "intero",
      "intonaco",
      "intuito",
      "inumidire",
      "invalido",
      "invece",
      "invito",
      "iperbole",
      "ipnotico",
      "ipotesi",
      "ippica",
      "iride",
      "irlanda",
      "ironico",
      "irrigato",
      "irrorare",
      "isolato",
      "isotopo",
      "isterico",
      "istituto",
      "istrice",
      "italia",
      "iterare",
      "labbro",
      "labirinto",
      "lacca",
      "lacerato",
      "lacrima",
      "lacuna",
      "laddove",
      "lago",
      "lampo",
      "lancetta",
      "lanterna",
      "lardoso",
      "larga",
      "laringe",
      "lastra",
      "latenza",
      "latino",
      "lattuga",
      "lavagna",
      "lavoro",
      "legale",
      "leggero",
      "lembo",
      "lentezza",
      "lenza",
      "leone",
      "lepre",
      "lesivo",
      "lessato",
      "lesto",
      "letterale",
      "leva",
      "levigato",
      "libero",
      "lido",
      "lievito",
      "lilla",
      "limatura",
      "limitare",
      "limpido",
      "lineare",
      "lingua",
      "liquido",
      "lira",
      "lirica",
      "lisca",
      "lite",
      "litigio",
      "livrea",
      "locanda",
      "lode",
      "logica",
      "lombare",
      "londra",
      "longevo",
      "loquace",
      "lorenzo",
      "loto",
      "lotteria",
      "luce",
      "lucidato",
      "lumaca",
      "luminoso",
      "lungo",
      "lupo",
      "luppolo",
      "lusinga",
      "lusso",
      "lutto",
      "macabro",
      "macchina",
      "macero",
      "macinato",
      "madama",
      "magico",
      "maglia",
      "magnete",
      "magro",
      "maiolica",
      "malafede",
      "malgrado",
      "malinteso",
      "malsano",
      "malto",
      "malumore",
      "mana",
      "mancia",
      "mandorla",
      "mangiare",
      "manifesto",
      "mannaro",
      "manovra",
      "mansarda",
      "mantide",
      "manubrio",
      "mappa",
      "maratona",
      "marcire",
      "maretta",
      "marmo",
      "marsupio",
      "maschera",
      "massaia",
      "mastino",
      "materasso",
      "matricola",
      "mattone",
      "maturo",
      "mazurca",
      "meandro",
      "meccanico",
      "mecenate",
      "medesimo",
      "meditare",
      "mega",
      "melassa",
      "melis",
      "melodia",
      "meninge",
      "meno",
      "mensola",
      "mercurio",
      "merenda",
      "merlo",
      "meschino",
      "mese",
      "messere",
      "mestolo",
      "metallo",
      "metodo",
      "mettere",
      "miagolare",
      "mica",
      "micelio",
      "michele",
      "microbo",
      "midollo",
      "miele",
      "migliore",
      "milano",
      "milite",
      "mimosa",
      "minerale",
      "mini",
      "minore",
      "mirino",
      "mirtillo",
      "miscela",
      "missiva",
      "misto",
      "misurare",
      "mitezza",
      "mitigare",
      "mitra",
      "mittente",
      "mnemonico",
      "modello",
      "modifica",
      "modulo",
      "mogano",
      "mogio",
      "mole",
      "molosso",
      "monastero",
      "monco",
      "mondina",
      "monetario",
      "monile",
      "monotono",
      "monsone",
      "montato",
      "monviso",
      "mora",
      "mordere",
      "morsicato",
      "mostro",
      "motivato",
      "motosega",
      "motto",
      "movenza",
      "movimento",
      "mozzo",
      "mucca",
      "mucosa",
      "muffa",
      "mughetto",
      "mugnaio",
      "mulatto",
      "mulinello",
      "multiplo",
      "mummia",
      "munto",
      "muovere",
      "murale",
      "musa",
      "muscolo",
      "musica",
      "mutevole",
      "muto",
      "nababbo",
      "nafta",
      "nanometro",
      "narciso",
      "narice",
      "narrato",
      "nascere",
      "nastrare",
      "naturale",
      "nautica",
      "naviglio",
      "nebulosa",
      "necrosi",
      "negativo",
      "negozio",
      "nemmeno",
      "neofita",
      "neretto",
      "nervo",
      "nessuno",
      "nettuno",
      "neutrale",
      "neve",
      "nevrotico",
      "nicchia",
      "ninfa",
      "nitido",
      "nobile",
      "nocivo",
      "nodo",
      "nome",
      "nomina",
      "nordico",
      "normale",
      "norvegese",
      "nostrano",
      "notare",
      "notizia",
      "notturno",
      "novella",
      "nucleo",
      "nulla",
      "numero",
      "nuovo",
      "nutrire",
      "nuvola",
      "nuziale",
      "oasi",
      "obbedire",
      "obbligo",
      "obelisco",
      "oblio",
      "obolo",
      "obsoleto",
      "occasione",
      "occhio",
      "occidente",
      "occorrere",
      "occultare",
      "ocra",
      "oculato",
      "odierno",
      "odorare",
      "offerta",
      "offrire",
      "offuscato",
      "oggetto",
      "oggi",
      "ognuno",
      "olandese",
      "olfatto",
      "oliato",
      "oliva",
      "ologramma",
      "oltre",
      "omaggio",
      "ombelico",
      "ombra",
      "omega",
      "omissione",
      "ondoso",
      "onere",
      "onice",
      "onnivoro",
      "onorevole",
      "onta",
      "operato",
      "opinione",
      "opposto",
      "oracolo",
      "orafo",
      "ordine",
      "orecchino",
      "orefice",
      "orfano",
      "organico",
      "origine",
      "orizzonte",
      "orma",
      "ormeggio",
      "ornativo",
      "orologio",
      "orrendo",
      "orribile",
      "ortensia",
      "ortica",
      "orzata",
      "orzo",
      "osare",
      "oscurare",
      "osmosi",
      "ospedale",
      "ospite",
      "ossa",
      "ossidare",
      "ostacolo",
      "oste",
      "otite",
      "otre",
      "ottagono",
      "ottimo",
      "ottobre",
      "ovale",
      "ovest",
      "ovino",
      "oviparo",
      "ovocito",
      "ovunque",
      "ovviare",
      "ozio",
      "pacchetto",
      "pace",
      "pacifico",
      "padella",
      "padrone",
      "paese",
      "paga",
      "pagina",
      "palazzina",
      "palesare",
      "pallido",
      "palo",
      "palude",
      "pandoro",
      "pannello",
      "paolo",
      "paonazzo",
      "paprica",
      "parabola",
      "parcella",
      "parere",
      "pargolo",
      "pari",
      "parlato",
      "parola",
      "partire",
      "parvenza",
      "parziale",
      "passivo",
      "pasticca",
      "patacca",
      "patologia",
      "pattume",
      "pavone",
      "peccato",
      "pedalare",
      "pedonale",
      "peggio",
      "peloso",
      "penare",
      "pendice",
      "penisola",
      "pennuto",
      "penombra",
      "pensare",
      "pentola",
      "pepe",
      "pepita",
      "perbene",
      "percorso",
      "perdonato",
      "perforare",
      "pergamena",
      "periodo",
      "permesso",
      "perno",
      "perplesso",
      "persuaso",
      "pertugio",
      "pervaso",
      "pesatore",
      "pesista",
      "peso",
      "pestifero",
      "petalo",
      "pettine",
      "petulante",
      "pezzo",
      "piacere",
      "pianta",
      "piattino",
      "piccino",
      "picozza",
      "piega",
      "pietra",
      "piffero",
      "pigiama",
      "pigolio",
      "pigro",
      "pila",
      "pilifero",
      "pillola",
      "pilota",
      "pimpante",
      "pineta",
      "pinna",
      "pinolo",
      "pioggia",
      "piombo",
      "piramide",
      "piretico",
      "pirite",
      "pirolisi",
      "pitone",
      "pizzico",
      "placebo",
      "planare",
      "plasma",
      "platano",
      "plenario",
      "pochezza",
      "poderoso",
      "podismo",
      "poesia",
      "poggiare",
      "polenta",
      "poligono",
      "pollice",
      "polmonite",
      "polpetta",
      "polso",
      "poltrona",
      "polvere",
      "pomice",
      "pomodoro",
      "ponte",
      "popoloso",
      "porfido",
      "poroso",
      "porpora",
      "porre",
      "portata",
      "posa",
      "positivo",
      "possesso",
      "postulato",
      "potassio",
      "potere",
      "pranzo",
      "prassi",
      "pratica",
      "precluso",
      "predica",
      "prefisso",
      "pregiato",
      "prelievo",
      "premere",
      "prenotare",
      "preparato",
      "presenza",
      "pretesto",
      "prevalso",
      "prima",
      "principe",
      "privato",
      "problema",
      "procura",
      "produrre",
      "profumo",
      "progetto",
      "prolunga",
      "promessa",
      "pronome",
      "proposta",
      "proroga",
      "proteso",
      "prova",
      "prudente",
      "prugna",
      "prurito",
      "psiche",
      "pubblico",
      "pudica",
      "pugilato",
      "pugno",
      "pulce",
      "pulito",
      "pulsante",
      "puntare",
      "pupazzo",
      "pupilla",
      "puro",
      "quadro",
      "qualcosa",
      "quasi",
      "querela",
      "quota",
      "raccolto",
      "raddoppio",
      "radicale",
      "radunato",
      "raffica",
      "ragazzo",
      "ragione",
      "ragno",
      "ramarro",
      "ramingo",
      "ramo",
      "randagio",
      "rantolare",
      "rapato",
      "rapina",
      "rappreso",
      "rasatura",
      "raschiato",
      "rasente",
      "rassegna",
      "rastrello",
      "rata",
      "ravveduto",
      "reale",
      "recepire",
      "recinto",
      "recluta",
      "recondito",
      "recupero",
      "reddito",
      "redimere",
      "regalato",
      "registro",
      "regola",
      "regresso",
      "relazione",
      "remare",
      "remoto",
      "renna",
      "replica",
      "reprimere",
      "reputare",
      "resa",
      "residente",
      "responso",
      "restauro",
      "rete",
      "retina",
      "retorica",
      "rettifica",
      "revocato",
      "riassunto",
      "ribadire",
      "ribelle",
      "ribrezzo",
      "ricarica",
      "ricco",
      "ricevere",
      "riciclato",
      "ricordo",
      "ricreduto",
      "ridicolo",
      "ridurre",
      "rifasare",
      "riflesso",
      "riforma",
      "rifugio",
      "rigare",
      "rigettato",
      "righello",
      "rilassato",
      "rilevato",
      "rimanere",
      "rimbalzo",
      "rimedio",
      "rimorchio",
      "rinascita",
      "rincaro",
      "rinforzo",
      "rinnovo",
      "rinomato",
      "rinsavito",
      "rintocco",
      "rinuncia",
      "rinvenire",
      "riparato",
      "ripetuto",
      "ripieno",
      "riportare",
      "ripresa",
      "ripulire",
      "risata",
      "rischio",
      "riserva",
      "risibile",
      "riso",
      "rispetto",
      "ristoro",
      "risultato",
      "risvolto",
      "ritardo",
      "ritegno",
      "ritmico",
      "ritrovo",
      "riunione",
      "riva",
      "riverso",
      "rivincita",
      "rivolto",
      "rizoma",
      "roba",
      "robotico",
      "robusto",
      "roccia",
      "roco",
      "rodaggio",
      "rodere",
      "roditore",
      "rogito",
      "rollio",
      "romantico",
      "rompere",
      "ronzio",
      "rosolare",
      "rospo",
      "rotante",
      "rotondo",
      "rotula",
      "rovescio",
      "rubizzo",
      "rubrica",
      "ruga",
      "rullino",
      "rumine",
      "rumoroso",
      "ruolo",
      "rupe",
      "russare",
      "rustico",
      "sabato",
      "sabbiare",
      "sabotato",
      "sagoma",
      "salasso",
      "saldatura",
      "salgemma",
      "salivare",
      "salmone",
      "salone",
      "saltare",
      "saluto",
      "salvo",
      "sapere",
      "sapido",
      "saporito",
      "saraceno",
      "sarcasmo",
      "sarto",
      "sassoso",
      "satellite",
      "satira",
      "satollo",
      "saturno",
      "savana",
      "savio",
      "saziato",
      "sbadiglio",
      "sbalzo",
      "sbancato",
      "sbarra",
      "sbattere",
      "sbavare",
      "sbendare",
      "sbirciare",
      "sbloccato",
      "sbocciato",
      "sbrinare",
      "sbruffone",
      "sbuffare",
      "scabroso",
      "scadenza",
      "scala",
      "scambiare",
      "scandalo",
      "scapola",
      "scarso",
      "scatenare",
      "scavato",
      "scelto",
      "scenico",
      "scettro",
      "scheda",
      "schiena",
      "sciarpa",
      "scienza",
      "scindere",
      "scippo",
      "sciroppo",
      "scivolo",
      "sclerare",
      "scodella",
      "scolpito",
      "scomparto",
      "sconforto",
      "scoprire",
      "scorta",
      "scossone",
      "scozzese",
      "scriba",
      "scrollare",
      "scrutinio",
      "scuderia",
      "scultore",
      "scuola",
      "scuro",
      "scusare",
      "sdebitare",
      "sdoganare",
      "seccatura",
      "secondo",
      "sedano",
      "seggiola",
      "segnalato",
      "segregato",
      "seguito",
      "selciato",
      "selettivo",
      "sella",
      "selvaggio",
      "semaforo",
      "sembrare",
      "seme",
      "seminato",
      "sempre",
      "senso",
      "sentire",
      "sepolto",
      "sequenza",
      "serata",
      "serbato",
      "sereno",
      "serio",
      "serpente",
      "serraglio",
      "servire",
      "sestina",
      "setola",
      "settimana",
      "sfacelo",
      "sfaldare",
      "sfamato",
      "sfarzoso",
      "sfaticato",
      "sfera",
      "sfida",
      "sfilato",
      "sfinge",
      "sfocato",
      "sfoderare",
      "sfogo",
      "sfoltire",
      "sforzato",
      "sfratto",
      "sfruttato",
      "sfuggito",
      "sfumare",
      "sfuso",
      "sgabello",
      "sgarbato",
      "sgonfiare",
      "sgorbio",
      "sgrassato",
      "sguardo",
      "sibilo",
      "siccome",
      "sierra",
      "sigla",
      "signore",
      "silenzio",
      "sillaba",
      "simbolo",
      "simpatico",
      "simulato",
      "sinfonia",
      "singolo",
      "sinistro",
      "sino",
      "sintesi",
      "sinusoide",
      "sipario",
      "sisma",
      "sistole",
      "situato",
      "slitta",
      "slogatura",
      "sloveno",
      "smarrito",
      "smemorato",
      "smentito",
      "smeraldo",
      "smilzo",
      "smontare",
      "smottato",
      "smussato",
      "snellire",
      "snervato",
      "snodo",
      "sobbalzo",
      "sobrio",
      "soccorso",
      "sociale",
      "sodale",
      "soffitto",
      "sogno",
      "soldato",
      "solenne",
      "solido",
      "sollazzo",
      "solo",
      "solubile",
      "solvente",
      "somatico",
      "somma",
      "sonda",
      "sonetto",
      "sonnifero",
      "sopire",
      "soppeso",
      "sopra",
      "sorgere",
      "sorpasso",
      "sorriso",
      "sorso",
      "sorteggio",
      "sorvolato",
      "sospiro",
      "sosta",
      "sottile",
      "spada",
      "spalla",
      "spargere",
      "spatola",
      "spavento",
      "spazzola",
      "specie",
      "spedire",
      "spegnere",
      "spelatura",
      "speranza",
      "spessore",
      "spettrale",
      "spezzato",
      "spia",
      "spigoloso",
      "spillato",
      "spinoso",
      "spirale",
      "splendido",
      "sportivo",
      "sposo",
      "spranga",
      "sprecare",
      "spronato",
      "spruzzo",
      "spuntino",
      "squillo",
      "sradicare",
      "srotolato",
      "stabile",
      "stacco",
      "staffa",
      "stagnare",
      "stampato",
      "stantio",
      "starnuto",
      "stasera",
      "statuto",
      "stelo",
      "steppa",
      "sterzo",
      "stiletto",
      "stima",
      "stirpe",
      "stivale",
      "stizzoso",
      "stonato",
      "storico",
      "strappo",
      "stregato",
      "stridulo",
      "strozzare",
      "strutto",
      "stuccare",
      "stufo",
      "stupendo",
      "subentro",
      "succoso",
      "sudore",
      "suggerito",
      "sugo",
      "sultano",
      "suonare",
      "superbo",
      "supporto",
      "surgelato",
      "surrogato",
      "sussurro",
      "sutura",
      "svagare",
      "svedese",
      "sveglio",
      "svelare",
      "svenuto",
      "svezia",
      "sviluppo",
      "svista",
      "svizzera",
      "svolta",
      "svuotare",
      "tabacco",
      "tabulato",
      "tacciare",
      "taciturno",
      "tale",
      "talismano",
      "tampone",
      "tannino",
      "tara",
      "tardivo",
      "targato",
      "tariffa",
      "tarpare",
      "tartaruga",
      "tasto",
      "tattico",
      "taverna",
      "tavolata",
      "tazza",
      "teca",
      "tecnico",
      "telefono",
      "temerario",
      "tempo",
      "temuto",
      "tendone",
      "tenero",
      "tensione",
      "tentacolo",
      "teorema",
      "terme",
      "terrazzo",
      "terzetto",
      "tesi",
      "tesserato",
      "testato",
      "tetro",
      "tettoia",
      "tifare",
      "tigella",
      "timbro",
      "tinto",
      "tipico",
      "tipografo",
      "tiraggio",
      "tiro",
      "titanio",
      "titolo",
      "titubante",
      "tizio",
      "tizzone",
      "toccare",
      "tollerare",
      "tolto",
      "tombola",
      "tomo",
      "tonfo",
      "tonsilla",
      "topazio",
      "topologia",
      "toppa",
      "torba",
      "tornare",
      "torrone",
      "tortora",
      "toscano",
      "tossire",
      "tostatura",
      "totano",
      "trabocco",
      "trachea",
      "trafila",
      "tragedia",
      "tralcio",
      "tramonto",
      "transito",
      "trapano",
      "trarre",
      "trasloco",
      "trattato",
      "trave",
      "treccia",
      "tremolio",
      "trespolo",
      "tributo",
      "tricheco",
      "trifoglio",
      "trillo",
      "trincea",
      "trio",
      "tristezza",
      "triturato",
      "trivella",
      "tromba",
      "trono",
      "troppo",
      "trottola",
      "trovare",
      "truccato",
      "tubatura",
      "tuffato",
      "tulipano",
      "tumulto",
      "tunisia",
      "turbare",
      "turchino",
      "tuta",
      "tutela",
      "ubicato",
      "uccello",
      "uccisore",
      "udire",
      "uditivo",
      "uffa",
      "ufficio",
      "uguale",
      "ulisse",
      "ultimato",
      "umano",
      "umile",
      "umorismo",
      "uncinetto",
      "ungere",
      "ungherese",
      "unicorno",
      "unificato",
      "unisono",
      "unitario",
      "unte",
      "uovo",
      "upupa",
      "uragano",
      "urgenza",
      "urlo",
      "usanza",
      "usato",
      "uscito",
      "usignolo",
      "usuraio",
      "utensile",
      "utilizzo",
      "utopia",
      "vacante",
      "vaccinato",
      "vagabondo",
      "vagliato",
      "valanga",
      "valgo",
      "valico",
      "valletta",
      "valoroso",
      "valutare",
      "valvola",
      "vampata",
      "vangare",
      "vanitoso",
      "vano",
      "vantaggio",
      "vanvera",
      "vapore",
      "varano",
      "varcato",
      "variante",
      "vasca",
      "vedetta",
      "vedova",
      "veduto",
      "vegetale",
      "veicolo",
      "velcro",
      "velina",
      "velluto",
      "veloce",
      "venato",
      "vendemmia",
      "vento",
      "verace",
      "verbale",
      "vergogna",
      "verifica",
      "vero",
      "verruca",
      "verticale",
      "vescica",
      "vessillo",
      "vestale",
      "veterano",
      "vetrina",
      "vetusto",
      "viandante",
      "vibrante",
      "vicenda",
      "vichingo",
      "vicinanza",
      "vidimare",
      "vigilia",
      "vigneto",
      "vigore",
      "vile",
      "villano",
      "vimini",
      "vincitore",
      "viola",
      "vipera",
      "virgola",
      "virologo",
      "virulento",
      "viscoso",
      "visione",
      "vispo",
      "vissuto",
      "visura",
      "vita",
      "vitello",
      "vittima",
      "vivanda",
      "vivido",
      "viziare",
      "voce",
      "voga",
      "volatile",
      "volere",
      "volpe",
      "voragine",
      "vulcano",
      "zampogna",
      "zanna",
      "zappato",
      "zattera",
      "zavorra",
      "zefiro",
      "zelante",
      "zelo",
      "zenzero",
      "zerbino",
      "zibetto",
      "zinco",
      "zircone",
      "zitto",
      "zolla",
      "zotico",
      "zucchero",
      "zufolo",
      "zulu",
      "zuppa"
  ]
  
  },{}],136:[function(require,module,exports){
  module.exports=[
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
  ]
  
  },{}],137:[function(require,module,exports){
  module.exports=[
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
  ]
  
  },{}],138:[function(require,module,exports){
  module.exports=[
      "abaco",
      "abdomen",
      "abeja",
      "abierto",
      "abogado",
      "abono",
      "aborto",
      "abrazo",
      "abrir",
      "abuelo",
      "abuso",
      "acabar",
      "academia",
      "acceso",
      "accion",
      "aceite",
      "acelga",
      "acento",
      "aceptar",
      "acido",
      "aclarar",
      "acne",
      "acoger",
      "acoso",
      "activo",
      "acto",
      "actriz",
      "actuar",
      "acudir",
      "acuerdo",
      "acusar",
      "adicto",
      "admitir",
      "adoptar",
      "adorno",
      "aduana",
      "adulto",
      "aereo",
      "afectar",
      "aficion",
      "afinar",
      "afirmar",
      "agil",
      "agitar",
      "agonia",
      "agosto",
      "agotar",
      "agregar",
      "agrio",
      "agua",
      "agudo",
      "aguila",
      "aguja",
      "ahogo",
      "ahorro",
      "aire",
      "aislar",
      "ajedrez",
      "ajeno",
      "ajuste",
      "alacran",
      "alambre",
      "alarma",
      "alba",
      "album",
      "alcalde",
      "aldea",
      "alegre",
      "alejar",
      "alerta",
      "aleta",
      "alfiler",
      "alga",
      "algodon",
      "aliado",
      "aliento",
      "alivio",
      "alma",
      "almeja",
      "almibar",
      "altar",
      "alteza",
      "altivo",
      "alto",
      "altura",
      "alumno",
      "alzar",
      "amable",
      "amante",
      "amapola",
      "amargo",
      "amasar",
      "ambar",
      "ambito",
      "ameno",
      "amigo",
      "amistad",
      "amor",
      "amparo",
      "amplio",
      "ancho",
      "anciano",
      "ancla",
      "andar",
      "anden",
      "anemia",
      "angulo",
      "anillo",
      "animo",
      "anis",
      "anotar",
      "antena",
      "antiguo",
      "antojo",
      "anual",
      "anular",
      "anuncio",
      "anadir",
      "anejo",
      "ano",
      "apagar",
      "aparato",
      "apetito",
      "apio",
      "aplicar",
      "apodo",
      "aporte",
      "apoyo",
      "aprender",
      "aprobar",
      "apuesta",
      "apuro",
      "arado",
      "arana",
      "arar",
      "arbitro",
      "arbol",
      "arbusto",
      "archivo",
      "arco",
      "arder",
      "ardilla",
      "arduo",
      "area",
      "arido",
      "aries",
      "armonia",
      "arnes",
      "aroma",
      "arpa",
      "arpon",
      "arreglo",
      "arroz",
      "arruga",
      "arte",
      "artista",
      "asa",
      "asado",
      "asalto",
      "ascenso",
      "asegurar",
      "aseo",
      "asesor",
      "asiento",
      "asilo",
      "asistir",
      "asno",
      "asombro",
      "aspero",
      "astilla",
      "astro",
      "astuto",
      "asumir",
      "asunto",
      "atajo",
      "ataque",
      "atar",
      "atento",
      "ateo",
      "atico",
      "atleta",
      "atomo",
      "atraer",
      "atroz",
      "atun",
      "audaz",
      "audio",
      "auge",
      "aula",
      "aumento",
      "ausente",
      "autor",
      "aval",
      "avance",
      "avaro",
      "ave",
      "avellana",
      "avena",
      "avestruz",
      "avion",
      "aviso",
      "ayer",
      "ayuda",
      "ayuno",
      "azafran",
      "azar",
      "azote",
      "azucar",
      "azufre",
      "azul",
      "baba",
      "babor",
      "bache",
      "bahia",
      "baile",
      "bajar",
      "balanza",
      "balcon",
      "balde",
      "bambu",
      "banco",
      "banda",
      "bano",
      "barba",
      "barco",
      "barniz",
      "barro",
      "bascula",
      "baston",
      "basura",
      "batalla",
      "bateria",
      "batir",
      "batuta",
      "baul",
      "bazar",
      "bebe",
      "bebida",
      "bello",
      "besar",
      "beso",
      "bestia",
      "bicho",
      "bien",
      "bingo",
      "blanco",
      "bloque",
      "blusa",
      "boa",
      "bobina",
      "bobo",
      "boca",
      "bocina",
      "boda",
      "bodega",
      "boina",
      "bola",
      "bolero",
      "bolsa",
      "bomba",
      "bondad",
      "bonito",
      "bono",
      "bonsai",
      "borde",
      "borrar",
      "bosque",
      "bote",
      "botin",
      "boveda",
      "bozal",
      "bravo",
      "brazo",
      "brecha",
      "breve",
      "brillo",
      "brinco",
      "brisa",
      "broca",
      "broma",
      "bronce",
      "brote",
      "bruja",
      "brusco",
      "bruto",
      "buceo",
      "bucle",
      "bueno",
      "buey",
      "bufanda",
      "bufon",
      "buho",
      "buitre",
      "bulto",
      "burbuja",
      "burla",
      "burro",
      "buscar",
      "butaca",
      "buzon",
      "caballo",
      "cabeza",
      "cabina",
      "cabra",
      "cacao",
      "cadaver",
      "cadena",
      "caer",
      "cafe",
      "caida",
      "caiman",
      "caja",
      "cajon",
      "cal",
      "calamar",
      "calcio",
      "caldo",
      "calidad",
      "calle",
      "calma",
      "calor",
      "calvo",
      "cama",
      "cambio",
      "camello",
      "camino",
      "campo",
      "cancer",
      "candil",
      "canela",
      "canguro",
      "canica",
      "canto",
      "cana",
      "canon",
      "caoba",
      "caos",
      "capaz",
      "capitan",
      "capote",
      "captar",
      "capucha",
      "cara",
      "carbon",
      "carcel",
      "careta",
      "carga",
      "carino",
      "carne",
      "carpeta",
      "carro",
      "carta",
      "casa",
      "casco",
      "casero",
      "caspa",
      "castor",
      "catorce",
      "catre",
      "caudal",
      "causa",
      "cazo",
      "cebolla",
      "ceder",
      "cedro",
      "celda",
      "celebre",
      "celoso",
      "celula",
      "cemento",
      "ceniza",
      "centro",
      "cerca",
      "cerdo",
      "cereza",
      "cero",
      "cerrar",
      "certeza",
      "cesped",
      "cetro",
      "chacal",
      "chaleco",
      "champu",
      "chancla",
      "chapa",
      "charla",
      "chico",
      "chiste",
      "chivo",
      "choque",
      "choza",
      "chuleta",
      "chupar",
      "ciclon",
      "ciego",
      "cielo",
      "cien",
      "cierto",
      "cifra",
      "cigarro",
      "cima",
      "cinco",
      "cine",
      "cinta",
      "cipres",
      "circo",
      "ciruela",
      "cisne",
      "cita",
      "ciudad",
      "clamor",
      "clan",
      "claro",
      "clase",
      "clave",
      "cliente",
      "clima",
      "clinica",
      "cobre",
      "coccion",
      "cochino",
      "cocina",
      "coco",
      "codigo",
      "codo",
      "cofre",
      "coger",
      "cohete",
      "cojin",
      "cojo",
      "cola",
      "colcha",
      "colegio",
      "colgar",
      "colina",
      "collar",
      "colmo",
      "columna",
      "combate",
      "comer",
      "comida",
      "comodo",
      "compra",
      "conde",
      "conejo",
      "conga",
      "conocer",
      "consejo",
      "contar",
      "copa",
      "copia",
      "corazon",
      "corbata",
      "corcho",
      "cordon",
      "corona",
      "correr",
      "coser",
      "cosmos",
      "costa",
      "craneo",
      "crater",
      "crear",
      "crecer",
      "creido",
      "crema",
      "cria",
      "crimen",
      "cripta",
      "crisis",
      "cromo",
      "cronica",
      "croqueta",
      "crudo",
      "cruz",
      "cuadro",
      "cuarto",
      "cuatro",
      "cubo",
      "cubrir",
      "cuchara",
      "cuello",
      "cuento",
      "cuerda",
      "cuesta",
      "cueva",
      "cuidar",
      "culebra",
      "culpa",
      "culto",
      "cumbre",
      "cumplir",
      "cuna",
      "cuneta",
      "cuota",
      "cupon",
      "cupula",
      "curar",
      "curioso",
      "curso",
      "curva",
      "cutis",
      "dama",
      "danza",
      "dar",
      "dardo",
      "datil",
      "deber",
      "debil",
      "decada",
      "decir",
      "dedo",
      "defensa",
      "definir",
      "dejar",
      "delfin",
      "delgado",
      "delito",
      "demora",
      "denso",
      "dental",
      "deporte",
      "derecho",
      "derrota",
      "desayuno",
      "deseo",
      "desfile",
      "desnudo",
      "destino",
      "desvio",
      "detalle",
      "detener",
      "deuda",
      "dia",
      "diablo",
      "diadema",
      "diamante",
      "diana",
      "diario",
      "dibujo",
      "dictar",
      "diente",
      "dieta",
      "diez",
      "dificil",
      "digno",
      "dilema",
      "diluir",
      "dinero",
      "directo",
      "dirigir",
      "disco",
      "diseno",
      "disfraz",
      "diva",
      "divino",
      "doble",
      "doce",
      "dolor",
      "domingo",
      "don",
      "donar",
      "dorado",
      "dormir",
      "dorso",
      "dos",
      "dosis",
      "dragon",
      "droga",
      "ducha",
      "duda",
      "duelo",
      "dueno",
      "dulce",
      "duo",
      "duque",
      "durar",
      "dureza",
      "duro",
      "ebano",
      "ebrio",
      "echar",
      "eco",
      "ecuador",
      "edad",
      "edicion",
      "edificio",
      "editor",
      "educar",
      "efecto",
      "eficaz",
      "eje",
      "ejemplo",
      "elefante",
      "elegir",
      "elemento",
      "elevar",
      "elipse",
      "elite",
      "elixir",
      "elogio",
      "eludir",
      "embudo",
      "emitir",
      "emocion",
      "empate",
      "empeno",
      "empleo",
      "empresa",
      "enano",
      "encargo",
      "enchufe",
      "encia",
      "enemigo",
      "enero",
      "enfado",
      "enfermo",
      "engano",
      "enigma",
      "enlace",
      "enorme",
      "enredo",
      "ensayo",
      "ensenar",
      "entero",
      "entrar",
      "envase",
      "envio",
      "epoca",
      "equipo",
      "erizo",
      "escala",
      "escena",
      "escolar",
      "escribir",
      "escudo",
      "esencia",
      "esfera",
      "esfuerzo",
      "espada",
      "espejo",
      "espia",
      "esposa",
      "espuma",
      "esqui",
      "estar",
      "este",
      "estilo",
      "estufa",
      "etapa",
      "eterno",
      "etica",
      "etnia",
      "evadir",
      "evaluar",
      "evento",
      "evitar",
      "exacto",
      "examen",
      "exceso",
      "excusa",
      "exento",
      "exigir",
      "exilio",
      "existir",
      "exito",
      "experto",
      "explicar",
      "exponer",
      "extremo",
      "fabrica",
      "fabula",
      "fachada",
      "facil",
      "factor",
      "faena",
      "faja",
      "falda",
      "fallo",
      "falso",
      "faltar",
      "fama",
      "familia",
      "famoso",
      "faraon",
      "farmacia",
      "farol",
      "farsa",
      "fase",
      "fatiga",
      "fauna",
      "favor",
      "fax",
      "febrero",
      "fecha",
      "feliz",
      "feo",
      "feria",
      "feroz",
      "fertil",
      "fervor",
      "festin",
      "fiable",
      "fianza",
      "fiar",
      "fibra",
      "ficcion",
      "ficha",
      "fideo",
      "fiebre",
      "fiel",
      "fiera",
      "fiesta",
      "figura",
      "fijar",
      "fijo",
      "fila",
      "filete",
      "filial",
      "filtro",
      "fin",
      "finca",
      "fingir",
      "finito",
      "firma",
      "flaco",
      "flauta",
      "flecha",
      "flor",
      "flota",
      "fluir",
      "flujo",
      "fluor",
      "fobia",
      "foca",
      "fogata",
      "fogon",
      "folio",
      "folleto",
      "fondo",
      "forma",
      "forro",
      "fortuna",
      "forzar",
      "fosa",
      "foto",
      "fracaso",
      "fragil",
      "franja",
      "frase",
      "fraude",
      "freir",
      "freno",
      "fresa",
      "frio",
      "frito",
      "fruta",
      "fuego",
      "fuente",
      "fuerza",
      "fuga",
      "fumar",
      "funcion",
      "funda",
      "furgon",
      "furia",
      "fusil",
      "futbol",
      "futuro",
      "gacela",
      "gafas",
      "gaita",
      "gajo",
      "gala",
      "galeria",
      "gallo",
      "gamba",
      "ganar",
      "gancho",
      "ganga",
      "ganso",
      "garaje",
      "garza",
      "gasolina",
      "gastar",
      "gato",
      "gavilan",
      "gemelo",
      "gemir",
      "gen",
      "genero",
      "genio",
      "gente",
      "geranio",
      "gerente",
      "germen",
      "gesto",
      "gigante",
      "gimnasio",
      "girar",
      "giro",
      "glaciar",
      "globo",
      "gloria",
      "gol",
      "golfo",
      "goloso",
      "golpe",
      "goma",
      "gordo",
      "gorila",
      "gorra",
      "gota",
      "goteo",
      "gozar",
      "grada",
      "grafico",
      "grano",
      "grasa",
      "gratis",
      "grave",
      "grieta",
      "grillo",
      "gripe",
      "gris",
      "grito",
      "grosor",
      "grua",
      "grueso",
      "grumo",
      "grupo",
      "guante",
      "guapo",
      "guardia",
      "guerra",
      "guia",
      "guino",
      "guion",
      "guiso",
      "guitarra",
      "gusano",
      "gustar",
      "haber",
      "habil",
      "hablar",
      "hacer",
      "hacha",
      "hada",
      "hallar",
      "hamaca",
      "harina",
      "haz",
      "hazana",
      "hebilla",
      "hebra",
      "hecho",
      "helado",
      "helio",
      "hembra",
      "herir",
      "hermano",
      "heroe",
      "hervir",
      "hielo",
      "hierro",
      "higado",
      "higiene",
      "hijo",
      "himno",
      "historia",
      "hocico",
      "hogar",
      "hoguera",
      "hoja",
      "hombre",
      "hongo",
      "honor",
      "honra",
      "hora",
      "hormiga",
      "horno",
      "hostil",
      "hoyo",
      "hueco",
      "huelga",
      "huerta",
      "hueso",
      "huevo",
      "huida",
      "huir",
      "humano",
      "humedo",
      "humilde",
      "humo",
      "hundir",
      "huracan",
      "hurto",
      "icono",
      "ideal",
      "idioma",
      "idolo",
      "iglesia",
      "iglu",
      "igual",
      "ilegal",
      "ilusion",
      "imagen",
      "iman",
      "imitar",
      "impar",
      "imperio",
      "imponer",
      "impulso",
      "incapaz",
      "indice",
      "inerte",
      "infiel",
      "informe",
      "ingenio",
      "inicio",
      "inmenso",
      "inmune",
      "innato",
      "insecto",
      "instante",
      "interes",
      "intimo",
      "intuir",
      "inutil",
      "invierno",
      "ira",
      "iris",
      "ironia",
      "isla",
      "islote",
      "jabali",
      "jabon",
      "jamon",
      "jarabe",
      "jardin",
      "jarra",
      "jaula",
      "jazmin",
      "jefe",
      "jeringa",
      "jinete",
      "jornada",
      "joroba",
      "joven",
      "joya",
      "juerga",
      "jueves",
      "juez",
      "jugador",
      "jugo",
      "juguete",
      "juicio",
      "junco",
      "jungla",
      "junio",
      "juntar",
      "jupiter",
      "jurar",
      "justo",
      "juvenil",
      "juzgar",
      "kilo",
      "koala",
      "labio",
      "lacio",
      "lacra",
      "lado",
      "ladron",
      "lagarto",
      "lagrima",
      "laguna",
      "laico",
      "lamer",
      "lamina",
      "lampara",
      "lana",
      "lancha",
      "langosta",
      "lanza",
      "lapiz",
      "largo",
      "larva",
      "lastima",
      "lata",
      "latex",
      "latir",
      "laurel",
      "lavar",
      "lazo",
      "leal",
      "leccion",
      "leche",
      "lector",
      "leer",
      "legion",
      "legumbre",
      "lejano",
      "lengua",
      "lento",
      "lena",
      "leon",
      "leopardo",
      "lesion",
      "letal",
      "letra",
      "leve",
      "leyenda",
      "libertad",
      "libro",
      "licor",
      "lider",
      "lidiar",
      "lienzo",
      "liga",
      "ligero",
      "lima",
      "limite",
      "limon",
      "limpio",
      "lince",
      "lindo",
      "linea",
      "lingote",
      "lino",
      "linterna",
      "liquido",
      "liso",
      "lista",
      "litera",
      "litio",
      "litro",
      "llaga",
      "llama",
      "llanto",
      "llave",
      "llegar",
      "llenar",
      "llevar",
      "llorar",
      "llover",
      "lluvia",
      "lobo",
      "locion",
      "loco",
      "locura",
      "logica",
      "logro",
      "lombriz",
      "lomo",
      "lonja",
      "lote",
      "lucha",
      "lucir",
      "lugar",
      "lujo",
      "luna",
      "lunes",
      "lupa",
      "lustro",
      "luto",
      "luz",
      "maceta",
      "macho",
      "madera",
      "madre",
      "maduro",
      "maestro",
      "mafia",
      "magia",
      "mago",
      "maiz",
      "maldad",
      "maleta",
      "malla",
      "malo",
      "mama",
      "mambo",
      "mamut",
      "manco",
      "mando",
      "manejar",
      "manga",
      "maniqui",
      "manjar",
      "mano",
      "manso",
      "manta",
      "manana",
      "mapa",
      "maquina",
      "mar",
      "marco",
      "marea",
      "marfil",
      "margen",
      "marido",
      "marmol",
      "marron",
      "martes",
      "marzo",
      "masa",
      "mascara",
      "masivo",
      "matar",
      "materia",
      "matiz",
      "matriz",
      "maximo",
      "mayor",
      "mazorca",
      "mecha",
      "medalla",
      "medio",
      "medula",
      "mejilla",
      "mejor",
      "melena",
      "melon",
      "memoria",
      "menor",
      "mensaje",
      "mente",
      "menu",
      "mercado",
      "merengue",
      "merito",
      "mes",
      "meson",
      "meta",
      "meter",
      "metodo",
      "metro",
      "mezcla",
      "miedo",
      "miel",
      "miembro",
      "miga",
      "mil",
      "milagro",
      "militar",
      "millon",
      "mimo",
      "mina",
      "minero",
      "minimo",
      "minuto",
      "miope",
      "mirar",
      "misa",
      "miseria",
      "misil",
      "mismo",
      "mitad",
      "mito",
      "mochila",
      "mocion",
      "moda",
      "modelo",
      "moho",
      "mojar",
      "molde",
      "moler",
      "molino",
      "momento",
      "momia",
      "monarca",
      "moneda",
      "monja",
      "monto",
      "mono",
      "morada",
      "morder",
      "moreno",
      "morir",
      "morro",
      "morsa",
      "mortal",
      "mosca",
      "mostrar",
      "motivo",
      "mover",
      "movil",
      "mozo",
      "mucho",
      "mudar",
      "mueble",
      "muela",
      "muerte",
      "muestra",
      "mugre",
      "mujer",
      "mula",
      "muleta",
      "multa",
      "mundo",
      "muneca",
      "mural",
      "muro",
      "musculo",
      "museo",
      "musgo",
      "musica",
      "muslo",
      "nacar",
      "nacion",
      "nadar",
      "naipe",
      "naranja",
      "nariz",
      "narrar",
      "nasal",
      "natal",
      "nativo",
      "natural",
      "nausea",
      "naval",
      "nave",
      "navidad",
      "necio",
      "nectar",
      "negar",
      "negocio",
      "negro",
      "neon",
      "nervio",
      "neto",
      "neutro",
      "nevar",
      "nevera",
      "nicho",
      "nido",
      "niebla",
      "nieto",
      "ninez",
      "nino",
      "nitido",
      "nivel",
      "nobleza",
      "noche",
      "nomina",
      "noria",
      "norma",
      "norte",
      "nota",
      "noticia",
      "novato",
      "novela",
      "novio",
      "nube",
      "nuca",
      "nucleo",
      "nudillo",
      "nudo",
      "nuera",
      "nueve",
      "nuez",
      "nulo",
      "numero",
      "nutria",
      "oasis",
      "obeso",
      "obispo",
      "objeto",
      "obra",
      "obrero",
      "observar",
      "obtener",
      "obvio",
      "oca",
      "ocaso",
      "oceano",
      "ochenta",
      "ocho",
      "ocio",
      "ocre",
      "octavo",
      "octubre",
      "oculto",
      "ocupar",
      "ocurrir",
      "odiar",
      "odio",
      "odisea",
      "oeste",
      "ofensa",
      "oferta",
      "oficio",
      "ofrecer",
      "ogro",
      "oido",
      "oir",
      "ojo",
      "ola",
      "oleada",
      "olfato",
      "olivo",
      "olla",
      "olmo",
      "olor",
      "olvido",
      "ombligo",
      "onda",
      "onza",
      "opaco",
      "opcion",
      "opera",
      "opinar",
      "oponer",
      "optar",
      "optica",
      "opuesto",
      "oracion",
      "orador",
      "oral",
      "orbita",
      "orca",
      "orden",
      "oreja",
      "organo",
      "orgia",
      "orgullo",
      "oriente",
      "origen",
      "orilla",
      "oro",
      "orquesta",
      "oruga",
      "osadia",
      "oscuro",
      "osezno",
      "oso",
      "ostra",
      "otono",
      "otro",
      "oveja",
      "ovulo",
      "oxido",
      "oxigeno",
      "oyente",
      "ozono",
      "pacto",
      "padre",
      "paella",
      "pagina",
      "pago",
      "pais",
      "pajaro",
      "palabra",
      "palco",
      "paleta",
      "palido",
      "palma",
      "paloma",
      "palpar",
      "pan",
      "panal",
      "panico",
      "pantera",
      "panuelo",
      "papa",
      "papel",
      "papilla",
      "paquete",
      "parar",
      "parcela",
      "pared",
      "parir",
      "paro",
      "parpado",
      "parque",
      "parrafo",
      "parte",
      "pasar",
      "paseo",
      "pasion",
      "paso",
      "pasta",
      "pata",
      "patio",
      "patria",
      "pausa",
      "pauta",
      "pavo",
      "payaso",
      "peaton",
      "pecado",
      "pecera",
      "pecho",
      "pedal",
      "pedir",
      "pegar",
      "peine",
      "pelar",
      "peldano",
      "pelea",
      "peligro",
      "pellejo",
      "pelo",
      "peluca",
      "pena",
      "pensar",
      "penon",
      "peon",
      "peor",
      "pepino",
      "pequeno",
      "pera",
      "percha",
      "perder",
      "pereza",
      "perfil",
      "perico",
      "perla",
      "permiso",
      "perro",
      "persona",
      "pesa",
      "pesca",
      "pesimo",
      "pestana",
      "petalo",
      "petroleo",
      "pez",
      "pezuna",
      "picar",
      "pichon",
      "pie",
      "piedra",
      "pierna",
      "pieza",
      "pijama",
      "pilar",
      "piloto",
      "pimienta",
      "pino",
      "pintor",
      "pinza",
      "pina",
      "piojo",
      "pipa",
      "pirata",
      "pisar",
      "piscina",
      "piso",
      "pista",
      "piton",
      "pizca",
      "placa",
      "plan",
      "plata",
      "playa",
      "plaza",
      "pleito",
      "pleno",
      "plomo",
      "pluma",
      "plural",
      "pobre",
      "poco",
      "poder",
      "podio",
      "poema",
      "poesia",
      "poeta",
      "polen",
      "policia",
      "pollo",
      "polvo",
      "pomada",
      "pomelo",
      "pomo",
      "pompa",
      "poner",
      "porcion",
      "portal",
      "posada",
      "poseer",
      "posible",
      "poste",
      "potencia",
      "potro",
      "pozo",
      "prado",
      "precoz",
      "pregunta",
      "premio",
      "prensa",
      "preso",
      "previo",
      "primo",
      "principe",
      "prision",
      "privar",
      "proa",
      "probar",
      "proceso",
      "producto",
      "proeza",
      "profesor",
      "programa",
      "prole",
      "promesa",
      "pronto",
      "propio",
      "proximo",
      "prueba",
      "publico",
      "puchero",
      "pudor",
      "pueblo",
      "puerta",
      "puesto",
      "pulga",
      "pulir",
      "pulmon",
      "pulpo",
      "pulso",
      "puma",
      "punto",
      "punal",
      "puno",
      "pupa",
      "pupila",
      "pure",
      "quedar",
      "queja",
      "quemar",
      "querer",
      "queso",
      "quieto",
      "quimica",
      "quince",
      "quitar",
      "rabano",
      "rabia",
      "rabo",
      "racion",
      "radical",
      "raiz",
      "rama",
      "rampa",
      "rancho",
      "rango",
      "rapaz",
      "rapido",
      "rapto",
      "rasgo",
      "raspa",
      "rato",
      "rayo",
      "raza",
      "razon",
      "reaccion",
      "realidad",
      "rebano",
      "rebote",
      "recaer",
      "receta",
      "rechazo",
      "recoger",
      "recreo",
      "recto",
      "recurso",
      "red",
      "redondo",
      "reducir",
      "reflejo",
      "reforma",
      "refran",
      "refugio",
      "regalo",
      "regir",
      "regla",
      "regreso",
      "rehen",
      "reino",
      "reir",
      "reja",
      "relato",
      "relevo",
      "relieve",
      "relleno",
      "reloj",
      "remar",
      "remedio",
      "remo",
      "rencor",
      "rendir",
      "renta",
      "reparto",
      "repetir",
      "reposo",
      "reptil",
      "res",
      "rescate",
      "resina",
      "respeto",
      "resto",
      "resumen",
      "retiro",
      "retorno",
      "retrato",
      "reunir",
      "reves",
      "revista",
      "rey",
      "rezar",
      "rico",
      "riego",
      "rienda",
      "riesgo",
      "rifa",
      "rigido",
      "rigor",
      "rincon",
      "rinon",
      "rio",
      "riqueza",
      "risa",
      "ritmo",
      "rito",
      "rizo",
      "roble",
      "roce",
      "rociar",
      "rodar",
      "rodeo",
      "rodilla",
      "roer",
      "rojizo",
      "rojo",
      "romero",
      "romper",
      "ron",
      "ronco",
      "ronda",
      "ropa",
      "ropero",
      "rosa",
      "rosca",
      "rostro",
      "rotar",
      "rubi",
      "rubor",
      "rudo",
      "rueda",
      "rugir",
      "ruido",
      "ruina",
      "ruleta",
      "rulo",
      "rumbo",
      "rumor",
      "ruptura",
      "ruta",
      "rutina",
      "sabado",
      "saber",
      "sabio",
      "sable",
      "sacar",
      "sagaz",
      "sagrado",
      "sala",
      "saldo",
      "salero",
      "salir",
      "salmon",
      "salon",
      "salsa",
      "salto",
      "salud",
      "salvar",
      "samba",
      "sancion",
      "sandia",
      "sanear",
      "sangre",
      "sanidad",
      "sano",
      "santo",
      "sapo",
      "saque",
      "sardina",
      "sarten",
      "sastre",
      "satan",
      "sauna",
      "saxofon",
      "seccion",
      "seco",
      "secreto",
      "secta",
      "sed",
      "seguir",
      "seis",
      "sello",
      "selva",
      "semana",
      "semilla",
      "senda",
      "sensor",
      "senal",
      "senor",
      "separar",
      "sepia",
      "sequia",
      "ser",
      "serie",
      "sermon",
      "servir",
      "sesenta",
      "sesion",
      "seta",
      "setenta",
      "severo",
      "sexo",
      "sexto",
      "sidra",
      "siesta",
      "siete",
      "siglo",
      "signo",
      "silaba",
      "silbar",
      "silencio",
      "silla",
      "simbolo",
      "simio",
      "sirena",
      "sistema",
      "sitio",
      "situar",
      "sobre",
      "socio",
      "sodio",
      "sol",
      "solapa",
      "soldado",
      "soledad",
      "solido",
      "soltar",
      "solucion",
      "sombra",
      "sondeo",
      "sonido",
      "sonoro",
      "sonrisa",
      "sopa",
      "soplar",
      "soporte",
      "sordo",
      "sorpresa",
      "sorteo",
      "sosten",
      "sotano",
      "suave",
      "subir",
      "suceso",
      "sudor",
      "suegra",
      "suelo",
      "sueno",
      "suerte",
      "sufrir",
      "sujeto",
      "sultan",
      "sumar",
      "superar",
      "suplir",
      "suponer",
      "supremo",
      "sur",
      "surco",
      "sureno",
      "surgir",
      "susto",
      "sutil",
      "tabaco",
      "tabique",
      "tabla",
      "tabu",
      "taco",
      "tacto",
      "tajo",
      "talar",
      "talco",
      "talento",
      "talla",
      "talon",
      "tamano",
      "tambor",
      "tango",
      "tanque",
      "tapa",
      "tapete",
      "tapia",
      "tapon",
      "taquilla",
      "tarde",
      "tarea",
      "tarifa",
      "tarjeta",
      "tarot",
      "tarro",
      "tarta",
      "tatuaje",
      "tauro",
      "taza",
      "tazon",
      "teatro",
      "techo",
      "tecla",
      "tecnica",
      "tejado",
      "tejer",
      "tejido",
      "tela",
      "telefono",
      "tema",
      "temor",
      "templo",
      "tenaz",
      "tender",
      "tener",
      "tenis",
      "tenso",
      "teoria",
      "terapia",
      "terco",
      "termino",
      "ternura",
      "terror",
      "tesis",
      "tesoro",
      "testigo",
      "tetera",
      "texto",
      "tez",
      "tibio",
      "tiburon",
      "tiempo",
      "tienda",
      "tierra",
      "tieso",
      "tigre",
      "tijera",
      "tilde",
      "timbre",
      "timido",
      "timo",
      "tinta",
      "tio",
      "tipico",
      "tipo",
      "tira",
      "tiron",
      "titan",
      "titere",
      "titulo",
      "tiza",
      "toalla",
      "tobillo",
      "tocar",
      "tocino",
      "todo",
      "toga",
      "toldo",
      "tomar",
      "tono",
      "tonto",
      "topar",
      "tope",
      "toque",
      "torax",
      "torero",
      "tormenta",
      "torneo",
      "toro",
      "torpedo",
      "torre",
      "torso",
      "tortuga",
      "tos",
      "tosco",
      "toser",
      "toxico",
      "trabajo",
      "tractor",
      "traer",
      "trafico",
      "trago",
      "traje",
      "tramo",
      "trance",
      "trato",
      "trauma",
      "trazar",
      "trebol",
      "tregua",
      "treinta",
      "tren",
      "trepar",
      "tres",
      "tribu",
      "trigo",
      "tripa",
      "triste",
      "triunfo",
      "trofeo",
      "trompa",
      "tronco",
      "tropa",
      "trote",
      "trozo",
      "truco",
      "trueno",
      "trufa",
      "tuberia",
      "tubo",
      "tuerto",
      "tumba",
      "tumor",
      "tunel",
      "tunica",
      "turbina",
      "turismo",
      "turno",
      "tutor",
      "ubicar",
      "ulcera",
      "umbral",
      "unidad",
      "unir",
      "universo",
      "uno",
      "untar",
      "una",
      "urbano",
      "urbe",
      "urgente",
      "urna",
      "usar",
      "usuario",
      "util",
      "utopia",
      "uva",
      "vaca",
      "vacio",
      "vacuna",
      "vagar",
      "vago",
      "vaina",
      "vajilla",
      "vale",
      "valido",
      "valle",
      "valor",
      "valvula",
      "vampiro",
      "vara",
      "variar",
      "varon",
      "vaso",
      "vecino",
      "vector",
      "vehiculo",
      "veinte",
      "vejez",
      "vela",
      "velero",
      "veloz",
      "vena",
      "vencer",
      "venda",
      "veneno",
      "vengar",
      "venir",
      "venta",
      "venus",
      "ver",
      "verano",
      "verbo",
      "verde",
      "vereda",
      "verja",
      "verso",
      "verter",
      "via",
      "viaje",
      "vibrar",
      "vicio",
      "victima",
      "vida",
      "video",
      "vidrio",
      "viejo",
      "viernes",
      "vigor",
      "vil",
      "villa",
      "vinagre",
      "vino",
      "vinedo",
      "violin",
      "viral",
      "virgo",
      "virtud",
      "visor",
      "vispera",
      "vista",
      "vitamina",
      "viudo",
      "vivaz",
      "vivero",
      "vivir",
      "vivo",
      "volcan",
      "volumen",
      "volver",
      "voraz",
      "votar",
      "voto",
      "voz",
      "vuelo",
      "vulgar",
      "yacer",
      "yate",
      "yegua",
      "yema",
      "yerno",
      "yeso",
      "yodo",
      "yoga",
      "yogur",
      "zafiro",
      "zanja",
      "zapato",
      "zarza",
      "zona",
      "zorro",
      "zumo",
      "zurdo"
  ]
  
  },{}],139:[function(require,module,exports){
  // Reference https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki
  // Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
  // NOTE: SIGHASH byte ignored AND restricted, truncate before use
  
  var Buffer = require('safe-buffer').Buffer
  
  function check (buffer) {
    if (buffer.length < 8) return false
    if (buffer.length > 72) return false
    if (buffer[0] !== 0x30) return false
    if (buffer[1] !== buffer.length - 2) return false
    if (buffer[2] !== 0x02) return false
  
    var lenR = buffer[3]
    if (lenR === 0) return false
    if (5 + lenR >= buffer.length) return false
    if (buffer[4 + lenR] !== 0x02) return false
  
    var lenS = buffer[5 + lenR]
    if (lenS === 0) return false
    if ((6 + lenR + lenS) !== buffer.length) return false
  
    if (buffer[4] & 0x80) return false
    if (lenR > 1 && (buffer[4] === 0x00) && !(buffer[5] & 0x80)) return false
  
    if (buffer[lenR + 6] & 0x80) return false
    if (lenS > 1 && (buffer[lenR + 6] === 0x00) && !(buffer[lenR + 7] & 0x80)) return false
    return true
  }
  
  function decode (buffer) {
    if (buffer.length < 8) throw new Error('DER sequence length is too short')
    if (buffer.length > 72) throw new Error('DER sequence length is too long')
    if (buffer[0] !== 0x30) throw new Error('Expected DER sequence')
    if (buffer[1] !== buffer.length - 2) throw new Error('DER sequence length is invalid')
    if (buffer[2] !== 0x02) throw new Error('Expected DER integer')
  
    var lenR = buffer[3]
    if (lenR === 0) throw new Error('R length is zero')
    if (5 + lenR >= buffer.length) throw new Error('R length is too long')
    if (buffer[4 + lenR] !== 0x02) throw new Error('Expected DER integer (2)')
  
    var lenS = buffer[5 + lenR]
    if (lenS === 0) throw new Error('S length is zero')
    if ((6 + lenR + lenS) !== buffer.length) throw new Error('S length is invalid')
  
    if (buffer[4] & 0x80) throw new Error('R value is negative')
    if (lenR > 1 && (buffer[4] === 0x00) && !(buffer[5] & 0x80)) throw new Error('R value excessively padded')
  
    if (buffer[lenR + 6] & 0x80) throw new Error('S value is negative')
    if (lenS > 1 && (buffer[lenR + 6] === 0x00) && !(buffer[lenR + 7] & 0x80)) throw new Error('S value excessively padded')
  
    // non-BIP66 - extract R, S values
    return {
      r: buffer.slice(4, 4 + lenR),
      s: buffer.slice(6 + lenR)
    }
  }
  
  /*
   * Expects r and s to be positive DER integers.
   *
   * The DER format uses the most significant bit as a sign bit (& 0x80).
   * If the significant bit is set AND the integer is positive, a 0x00 is prepended.
   *
   * Examples:
   *
   *      0 =>     0x00
   *      1 =>     0x01
   *     -1 =>     0xff
   *    127 =>     0x7f
   *   -127 =>     0x81
   *    128 =>   0x0080
   *   -128 =>     0x80
   *    255 =>   0x00ff
   *   -255 =>   0xff01
   *  16300 =>   0x3fac
   * -16300 =>   0xc054
   *  62300 => 0x00f35c
   * -62300 => 0xff0ca4
  */
  function encode (r, s) {
    var lenR = r.length
    var lenS = s.length
    if (lenR === 0) throw new Error('R length is zero')
    if (lenS === 0) throw new Error('S length is zero')
    if (lenR > 33) throw new Error('R length is too long')
    if (lenS > 33) throw new Error('S length is too long')
    if (r[0] & 0x80) throw new Error('R value is negative')
    if (s[0] & 0x80) throw new Error('S value is negative')
    if (lenR > 1 && (r[0] === 0x00) && !(r[1] & 0x80)) throw new Error('R value excessively padded')
    if (lenS > 1 && (s[0] === 0x00) && !(s[1] & 0x80)) throw new Error('S value excessively padded')
  
    var signature = Buffer.allocUnsafe(6 + lenR + lenS)
  
    // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
    signature[0] = 0x30
    signature[1] = signature.length - 2
    signature[2] = 0x02
    signature[3] = r.length
    r.copy(signature, 4)
    signature[4 + lenR] = 0x02
    signature[5 + lenR] = s.length
    s.copy(signature, 6 + lenR)
  
    return signature
  }
  
  module.exports = {
    check: check,
    decode: decode,
    encode: encode
  }
  
  },{"safe-buffer":281}],140:[function(require,module,exports){
  module.exports={
    "OP_FALSE": 0,
    "OP_0": 0,
    "OP_PUSHDATA1": 76,
    "OP_PUSHDATA2": 77,
    "OP_PUSHDATA4": 78,
    "OP_1NEGATE": 79,
    "OP_RESERVED": 80,
    "OP_TRUE": 81,
    "OP_1": 81,
    "OP_2": 82,
    "OP_3": 83,
    "OP_4": 84,
    "OP_5": 85,
    "OP_6": 86,
    "OP_7": 87,
    "OP_8": 88,
    "OP_9": 89,
    "OP_10": 90,
    "OP_11": 91,
    "OP_12": 92,
    "OP_13": 93,
    "OP_14": 94,
    "OP_15": 95,
    "OP_16": 96,
  
    "OP_NOP": 97,
    "OP_VER": 98,
    "OP_IF": 99,
    "OP_NOTIF": 100,
    "OP_VERIF": 101,
    "OP_VERNOTIF": 102,
    "OP_ELSE": 103,
    "OP_ENDIF": 104,
    "OP_VERIFY": 105,
    "OP_RETURN": 106,
  
    "OP_TOALTSTACK": 107,
    "OP_FROMALTSTACK": 108,
    "OP_2DROP": 109,
    "OP_2DUP": 110,
    "OP_3DUP": 111,
    "OP_2OVER": 112,
    "OP_2ROT": 113,
    "OP_2SWAP": 114,
    "OP_IFDUP": 115,
    "OP_DEPTH": 116,
    "OP_DROP": 117,
    "OP_DUP": 118,
    "OP_NIP": 119,
    "OP_OVER": 120,
    "OP_PICK": 121,
    "OP_ROLL": 122,
    "OP_ROT": 123,
    "OP_SWAP": 124,
    "OP_TUCK": 125,
  
    "OP_CAT": 126,
    "OP_SUBSTR": 127,
    "OP_LEFT": 128,
    "OP_RIGHT": 129,
    "OP_SIZE": 130,
  
    "OP_INVERT": 131,
    "OP_AND": 132,
    "OP_OR": 133,
    "OP_XOR": 134,
    "OP_EQUAL": 135,
    "OP_EQUALVERIFY": 136,
    "OP_RESERVED1": 137,
    "OP_RESERVED2": 138,
  
    "OP_1ADD": 139,
    "OP_1SUB": 140,
    "OP_2MUL": 141,
    "OP_2DIV": 142,
    "OP_NEGATE": 143,
    "OP_ABS": 144,
    "OP_NOT": 145,
    "OP_0NOTEQUAL": 146,
    "OP_ADD": 147,
    "OP_SUB": 148,
    "OP_MUL": 149,
    "OP_DIV": 150,
    "OP_MOD": 151,
    "OP_LSHIFT": 152,
    "OP_RSHIFT": 153,
  
    "OP_BOOLAND": 154,
    "OP_BOOLOR": 155,
    "OP_NUMEQUAL": 156,
    "OP_NUMEQUALVERIFY": 157,
    "OP_NUMNOTEQUAL": 158,
    "OP_LESSTHAN": 159,
    "OP_GREATERTHAN": 160,
    "OP_LESSTHANOREQUAL": 161,
    "OP_GREATERTHANOREQUAL": 162,
    "OP_MIN": 163,
    "OP_MAX": 164,
  
    "OP_WITHIN": 165,
  
    "OP_RIPEMD160": 166,
    "OP_SHA1": 167,
    "OP_SHA256": 168,
    "OP_HASH160": 169,
    "OP_HASH256": 170,
    "OP_CODESEPARATOR": 171,
    "OP_CHECKSIG": 172,
    "OP_CHECKSIGVERIFY": 173,
    "OP_CHECKMULTISIG": 174,
    "OP_CHECKMULTISIGVERIFY": 175,
  
    "OP_NOP1": 176,
    
    "OP_NOP2": 177,
    "OP_CHECKLOCKTIMEVERIFY": 177,
  
    "OP_NOP3": 178,
    "OP_CHECKSEQUENCEVERIFY": 178,
    
    "OP_NOP4": 179,
    "OP_NOP5": 180,
    "OP_NOP6": 181,
    "OP_NOP7": 182,
    "OP_NOP8": 183,
    "OP_NOP9": 184,
    "OP_NOP10": 185,
  
    "OP_PUBKEYHASH": 253,
    "OP_PUBKEY": 254,
    "OP_INVALIDOPCODE": 255
  }
  
  },{}],141:[function(require,module,exports){
  var OPS = require('./index.json')
  
  var map = {}
  for (var op in OPS) {
    var code = OPS[op]
    map[code] = op
  }
  
  module.exports = map
  
  },{"./index.json":140}],142:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const networks = require('./networks');
  const payments = require('./payments');
  const bscript = require('./script');
  const types = require('./types');
  const bech32 = require('bech32');
  const bs58check = require('bs58check');
  const typeforce = require('typeforce');
  function fromBase58Check(address) {
    const payload = bs58check.decode(address);
    // TODO: 4.0.0, move to "toOutputScript"
    if (payload.length < 21) throw new TypeError(address + ' is too short');
    if (payload.length > 21) throw new TypeError(address + ' is too long');
    const version = payload.readUInt8(0);
    const hash = payload.slice(1);
    return { version, hash };
  }
  exports.fromBase58Check = fromBase58Check;
  function fromBech32(address) {
    const result = bech32.decode(address);
    const data = bech32.fromWords(result.words.slice(1));
    return {
      version: result.words[0],
      prefix: result.prefix,
      data: Buffer.from(data),
    };
  }
  exports.fromBech32 = fromBech32;
  function toBase58Check(hash, version) {
    typeforce(types.tuple(types.Hash160bit, types.UInt8), arguments);
    const payload = Buffer.allocUnsafe(21);
    payload.writeUInt8(version, 0);
    hash.copy(payload, 1);
    return bs58check.encode(payload);
  }
  exports.toBase58Check = toBase58Check;
  function toBech32(data, version, prefix) {
    const words = bech32.toWords(data);
    words.unshift(version);
    return bech32.encode(prefix, words);
  }
  exports.toBech32 = toBech32;
  function fromOutputScript(output, network) {
    // TODO: Network
    network = network || networks.bitcoin;
    try {
      return payments.p2pkh({ output, network }).address;
    } catch (e) {}
    try {
      return payments.p2sh({ output, network }).address;
    } catch (e) {}
    try {
      return payments.p2wpkh({ output, network }).address;
    } catch (e) {}
    try {
      return payments.p2wsh({ output, network }).address;
    } catch (e) {}
    throw new Error(bscript.toASM(output) + ' has no matching Address');
  }
  exports.fromOutputScript = fromOutputScript;
  function toOutputScript(address, network) {
    network = network || networks.bitcoin;
    let decodeBase58;
    let decodeBech32;
    try {
      decodeBase58 = fromBase58Check(address);
    } catch (e) {}
    if (decodeBase58) {
      if (decodeBase58.version === network.pubKeyHash)
        return payments.p2pkh({ hash: decodeBase58.hash }).output;
      if (decodeBase58.version === network.scriptHash)
        return payments.p2sh({ hash: decodeBase58.hash }).output;
    } else {
      try {
        decodeBech32 = fromBech32(address);
      } catch (e) {}
      if (decodeBech32) {
        if (decodeBech32.prefix !== network.bech32)
          throw new Error(address + ' has an invalid prefix');
        if (decodeBech32.version === 0) {
          if (decodeBech32.data.length === 20)
            return payments.p2wpkh({ hash: decodeBech32.data }).output;
          if (decodeBech32.data.length === 32)
            return payments.p2wsh({ hash: decodeBech32.data }).output;
        }
      }
    }
    throw new Error(address + ' has no matching Script');
  }
  exports.toOutputScript = toOutputScript;
  
  }).call(this,require("buffer").Buffer)
  },{"./networks":149,"./payments":151,"./script":160,"./types":186,"bech32":102,"bs58check":191,"buffer":3,"typeforce":271}],143:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const bufferutils_1 = require('./bufferutils');
  const bcrypto = require('./crypto');
  const transaction_1 = require('./transaction');
  const types = require('./types');
  const fastMerkleRoot = require('merkle-lib/fastRoot');
  const typeforce = require('typeforce');
  const varuint = require('varuint-bitcoin');
  const errorMerkleNoTxes = new TypeError(
    'Cannot compute merkle root for zero transactions',
  );
  const errorWitnessNotSegwit = new TypeError(
    'Cannot compute witness commit for non-segwit block',
  );
  class Block {
    constructor() {
      this.version = 1;
      this.prevHash = undefined;
      this.merkleRoot = undefined;
      this.timestamp = 0;
      this.witnessCommit = undefined;
      this.bits = 0;
      this.nonce = 0;
      this.transactions = undefined;
    }
    static fromBuffer(buffer) {
      if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');
      let offset = 0;
      const readSlice = n => {
        offset += n;
        return buffer.slice(offset - n, offset);
      };
      const readUInt32 = () => {
        const i = buffer.readUInt32LE(offset);
        offset += 4;
        return i;
      };
      const readInt32 = () => {
        const i = buffer.readInt32LE(offset);
        offset += 4;
        return i;
      };
      const block = new Block();
      block.version = readInt32();
      block.prevHash = readSlice(32);
      block.merkleRoot = readSlice(32);
      block.timestamp = readUInt32();
      block.bits = readUInt32();
      block.nonce = readUInt32();
      if (buffer.length === 80) return block;
      const readVarInt = () => {
        const vi = varuint.decode(buffer, offset);
        offset += varuint.decode.bytes;
        return vi;
      };
      const readTransaction = () => {
        const tx = transaction_1.Transaction.fromBuffer(
          buffer.slice(offset),
          true,
        );
        offset += tx.byteLength();
        return tx;
      };
      const nTransactions = readVarInt();
      block.transactions = [];
      for (let i = 0; i < nTransactions; ++i) {
        const tx = readTransaction();
        block.transactions.push(tx);
      }
      const witnessCommit = block.getWitnessCommit();
      // This Block contains a witness commit
      if (witnessCommit) block.witnessCommit = witnessCommit;
      return block;
    }
    static fromHex(hex) {
      return Block.fromBuffer(Buffer.from(hex, 'hex'));
    }
    static calculateTarget(bits) {
      const exponent = ((bits & 0xff000000) >> 24) - 3;
      const mantissa = bits & 0x007fffff;
      const target = Buffer.alloc(32, 0);
      target.writeUIntBE(mantissa, 29 - exponent, 3);
      return target;
    }
    static calculateMerkleRoot(transactions, forWitness) {
      typeforce([{ getHash: types.Function }], transactions);
      if (transactions.length === 0) throw errorMerkleNoTxes;
      if (forWitness && !txesHaveWitnessCommit(transactions))
        throw errorWitnessNotSegwit;
      const hashes = transactions.map(transaction =>
        transaction.getHash(forWitness),
      );
      const rootHash = fastMerkleRoot(hashes, bcrypto.hash256);
      return forWitness
        ? bcrypto.hash256(
            Buffer.concat([rootHash, transactions[0].ins[0].witness[0]]),
          )
        : rootHash;
    }
    getWitnessCommit() {
      if (!txesHaveWitnessCommit(this.transactions)) return null;
      // The merkle root for the witness data is in an OP_RETURN output.
      // There is no rule for the index of the output, so use filter to find it.
      // The root is prepended with 0xaa21a9ed so check for 0x6a24aa21a9ed
      // If multiple commits are found, the output with highest index is assumed.
      const witnessCommits = this.transactions[0].outs
        .filter(out =>
          out.script.slice(0, 6).equals(Buffer.from('6a24aa21a9ed', 'hex')),
        )
        .map(out => out.script.slice(6, 38));
      if (witnessCommits.length === 0) return null;
      // Use the commit with the highest output (should only be one though)
      const result = witnessCommits[witnessCommits.length - 1];
      if (!(result instanceof Buffer && result.length === 32)) return null;
      return result;
    }
    hasWitnessCommit() {
      if (
        this.witnessCommit instanceof Buffer &&
        this.witnessCommit.length === 32
      )
        return true;
      if (this.getWitnessCommit() !== null) return true;
      return false;
    }
    hasWitness() {
      return anyTxHasWitness(this.transactions);
    }
    weight() {
      const base = this.byteLength(false, false);
      const total = this.byteLength(false, true);
      return base * 3 + total;
    }
    byteLength(headersOnly, allowWitness = true) {
      if (headersOnly || !this.transactions) return 80;
      return (
        80 +
        varuint.encodingLength(this.transactions.length) +
        this.transactions.reduce((a, x) => a + x.byteLength(allowWitness), 0)
      );
    }
    getHash() {
      return bcrypto.hash256(this.toBuffer(true));
    }
    getId() {
      return bufferutils_1.reverseBuffer(this.getHash()).toString('hex');
    }
    getUTCDate() {
      const date = new Date(0); // epoch
      date.setUTCSeconds(this.timestamp);
      return date;
    }
    // TODO: buffer, offset compatibility
    toBuffer(headersOnly) {
      const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));
      let offset = 0;
      const writeSlice = slice => {
        slice.copy(buffer, offset);
        offset += slice.length;
      };
      const writeInt32 = i => {
        buffer.writeInt32LE(i, offset);
        offset += 4;
      };
      const writeUInt32 = i => {
        buffer.writeUInt32LE(i, offset);
        offset += 4;
      };
      writeInt32(this.version);
      writeSlice(this.prevHash);
      writeSlice(this.merkleRoot);
      writeUInt32(this.timestamp);
      writeUInt32(this.bits);
      writeUInt32(this.nonce);
      if (headersOnly || !this.transactions) return buffer;
      varuint.encode(this.transactions.length, buffer, offset);
      offset += varuint.encode.bytes;
      this.transactions.forEach(tx => {
        const txSize = tx.byteLength(); // TODO: extract from toBuffer?
        tx.toBuffer(buffer, offset);
        offset += txSize;
      });
      return buffer;
    }
    toHex(headersOnly) {
      return this.toBuffer(headersOnly).toString('hex');
    }
    checkTxRoots() {
      // If the Block has segwit transactions but no witness commit,
      // there's no way it can be valid, so fail the check.
      const hasWitnessCommit = this.hasWitnessCommit();
      if (!hasWitnessCommit && this.hasWitness()) return false;
      return (
        this.__checkMerkleRoot() &&
        (hasWitnessCommit ? this.__checkWitnessCommit() : true)
      );
    }
    checkProofOfWork() {
      const hash = bufferutils_1.reverseBuffer(this.getHash());
      const target = Block.calculateTarget(this.bits);
      return hash.compare(target) <= 0;
    }
    __checkMerkleRoot() {
      if (!this.transactions) throw errorMerkleNoTxes;
      const actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);
      return this.merkleRoot.compare(actualMerkleRoot) === 0;
    }
    __checkWitnessCommit() {
      if (!this.transactions) throw errorMerkleNoTxes;
      if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;
      const actualWitnessCommit = Block.calculateMerkleRoot(
        this.transactions,
        true,
      );
      return this.witnessCommit.compare(actualWitnessCommit) === 0;
    }
  }
  exports.Block = Block;
  function txesHaveWitnessCommit(transactions) {
    return (
      transactions instanceof Array &&
      transactions[0] &&
      transactions[0].ins &&
      transactions[0].ins instanceof Array &&
      transactions[0].ins[0] &&
      transactions[0].ins[0].witness &&
      transactions[0].ins[0].witness instanceof Array &&
      transactions[0].ins[0].witness.length > 0
    );
  }
  function anyTxHasWitness(transactions) {
    return (
      transactions instanceof Array &&
      transactions.some(
        tx =>
          typeof tx === 'object' &&
          tx.ins instanceof Array &&
          tx.ins.some(
            input =>
              typeof input === 'object' &&
              input.witness instanceof Array &&
              input.witness.length > 0,
          ),
      )
    );
  }
  
  }).call(this,require("buffer").Buffer)
  },{"./bufferutils":144,"./crypto":146,"./transaction":184,"./types":186,"buffer":3,"merkle-lib/fastRoot":241,"typeforce":271,"varuint-bitcoin":273}],144:[function(require,module,exports){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  // https://github.com/feross/buffer/blob/master/index.js#L1127
  function verifuint(value, max) {
    if (typeof value !== 'number')
      throw new Error('cannot write a non-number as a number');
    if (value < 0)
      throw new Error('specified a negative value for writing an unsigned value');
    if (value > max) throw new Error('RangeError: value out of range');
    if (Math.floor(value) !== value)
      throw new Error('value has a fractional component');
  }
  function readUInt64LE(buffer, offset) {
    const a = buffer.readUInt32LE(offset);
    let b = buffer.readUInt32LE(offset + 4);
    b *= 0x100000000;
    verifuint(b + a, 0x001fffffffffffff);
    return b + a;
  }
  exports.readUInt64LE = readUInt64LE;
  function writeUInt64LE(buffer, value, offset) {
    verifuint(value, 0x001fffffffffffff);
    buffer.writeInt32LE(value & -1, offset);
    buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);
    return offset + 8;
  }
  exports.writeUInt64LE = writeUInt64LE;
  function reverseBuffer(buffer) {
    if (buffer.length < 1) return buffer;
    let j = buffer.length - 1;
    let tmp = 0;
    for (let i = 0; i < buffer.length / 2; i++) {
      tmp = buffer[i];
      buffer[i] = buffer[j];
      buffer[j] = tmp;
      j--;
    }
    return buffer;
  }
  exports.reverseBuffer = reverseBuffer;
  
  },{}],145:[function(require,module,exports){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const script_1 = require('./script');
  const multisig = require('./templates/multisig');
  const nullData = require('./templates/nulldata');
  const pubKey = require('./templates/pubkey');
  const pubKeyHash = require('./templates/pubkeyhash');
  const scriptHash = require('./templates/scripthash');
  const witnessCommitment = require('./templates/witnesscommitment');
  const witnessPubKeyHash = require('./templates/witnesspubkeyhash');
  const witnessScriptHash = require('./templates/witnessscripthash');
  const types = {
    P2MS: 'multisig',
    NONSTANDARD: 'nonstandard',
    NULLDATA: 'nulldata',
    P2PK: 'pubkey',
    P2PKH: 'pubkeyhash',
    P2SH: 'scripthash',
    P2WPKH: 'witnesspubkeyhash',
    P2WSH: 'witnessscripthash',
    WITNESS_COMMITMENT: 'witnesscommitment',
  };
  exports.types = types;
  function classifyOutput(script) {
    if (witnessPubKeyHash.output.check(script)) return types.P2WPKH;
    if (witnessScriptHash.output.check(script)) return types.P2WSH;
    if (pubKeyHash.output.check(script)) return types.P2PKH;
    if (scriptHash.output.check(script)) return types.P2SH;
    // XXX: optimization, below functions .decompile before use
    const chunks = script_1.decompile(script);
    if (!chunks) throw new TypeError('Invalid script');
    if (multisig.output.check(chunks)) return types.P2MS;
    if (pubKey.output.check(chunks)) return types.P2PK;
    if (witnessCommitment.output.check(chunks)) return types.WITNESS_COMMITMENT;
    if (nullData.output.check(chunks)) return types.NULLDATA;
    return types.NONSTANDARD;
  }
  exports.output = classifyOutput;
  function classifyInput(script, allowIncomplete) {
    // XXX: optimization, below functions .decompile before use
    const chunks = script_1.decompile(script);
    if (!chunks) throw new TypeError('Invalid script');
    if (pubKeyHash.input.check(chunks)) return types.P2PKH;
    if (scriptHash.input.check(chunks, allowIncomplete)) return types.P2SH;
    if (multisig.input.check(chunks, allowIncomplete)) return types.P2MS;
    if (pubKey.input.check(chunks)) return types.P2PK;
    return types.NONSTANDARD;
  }
  exports.input = classifyInput;
  function classifyWitness(script, allowIncomplete) {
    // XXX: optimization, below functions .decompile before use
    const chunks = script_1.decompile(script);
    if (!chunks) throw new TypeError('Invalid script');
    if (witnessPubKeyHash.input.check(chunks)) return types.P2WPKH;
    if (witnessScriptHash.input.check(chunks, allowIncomplete))
      return types.P2WSH;
    return types.NONSTANDARD;
  }
  exports.witness = classifyWitness;
  
  },{"./script":160,"./templates/multisig":163,"./templates/nulldata":166,"./templates/pubkey":167,"./templates/pubkeyhash":170,"./templates/scripthash":173,"./templates/witnesscommitment":176,"./templates/witnesspubkeyhash":178,"./templates/witnessscripthash":181}],146:[function(require,module,exports){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const createHash = require('create-hash');
  function ripemd160(buffer) {
    try {
      return createHash('rmd160')
        .update(buffer)
        .digest();
    } catch (err) {
      return createHash('ripemd160')
        .update(buffer)
        .digest();
    }
  }
  exports.ripemd160 = ripemd160;
  function sha1(buffer) {
    return createHash('sha1')
      .update(buffer)
      .digest();
  }
  exports.sha1 = sha1;
  function sha256(buffer) {
    return createHash('sha256')
      .update(buffer)
      .digest();
  }
  exports.sha256 = sha256;
  function hash160(buffer) {
    return ripemd160(sha256(buffer));
  }
  exports.hash160 = hash160;
  function hash256(buffer) {
    return sha256(sha256(buffer));
  }
  exports.hash256 = hash256;
  
  },{"create-hash":193}],147:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const NETWORKS = require('./networks');
  const types = require('./types');
  const ecc = require('tiny-secp256k1');
  const randomBytes = require('randombytes');
  const typeforce = require('typeforce');
  const wif = require('wif');
  const isOptions = typeforce.maybe(
    typeforce.compile({
      compressed: types.maybe(types.Boolean),
      network: types.maybe(types.Network),
    }),
  );
  class ECPair {
    constructor(__D, __Q, options) {
      this.__D = __D;
      this.__Q = __Q;
      this.lowR = false;
      if (options === undefined) options = {};
      this.compressed =
        options.compressed === undefined ? true : options.compressed;
      this.network = options.network || NETWORKS.bitcoin;
      if (__Q !== undefined) this.__Q = ecc.pointCompress(__Q, this.compressed);
    }
    get privateKey() {
      return this.__D;
    }
    get publicKey() {
      if (!this.__Q) this.__Q = ecc.pointFromScalar(this.__D, this.compressed);
      return this.__Q;
    }
    toWIF() {
      if (!this.__D) throw new Error('Missing private key');
      return wif.encode(this.network.wif, this.__D, this.compressed);
    }
    sign(hash, lowR) {
      if (!this.__D) throw new Error('Missing private key');
      if (lowR === undefined) lowR = this.lowR;
      if (lowR === false) {
        return ecc.sign(hash, this.__D);
      } else {
        let sig = ecc.sign(hash, this.__D);
        const extraData = Buffer.alloc(32, 0);
        let counter = 0;
        // if first try is lowR, skip the loop
        // for second try and on, add extra entropy counting up
        while (sig[0] > 0x7f) {
          counter++;
          extraData.writeUIntLE(counter, 0, 6);
          sig = ecc.signWithEntropy(hash, this.__D, extraData);
        }
        return sig;
      }
    }
    verify(hash, signature) {
      return ecc.verify(hash, this.publicKey, signature);
    }
  }
  function fromPrivateKey(buffer, options) {
    typeforce(types.Buffer256bit, buffer);
    if (!ecc.isPrivate(buffer))
      throw new TypeError('Private key not in range [1, n)');
    typeforce(isOptions, options);
    return new ECPair(buffer, undefined, options);
  }
  exports.fromPrivateKey = fromPrivateKey;
  function fromPublicKey(buffer, options) {
    typeforce(ecc.isPoint, buffer);
    typeforce(isOptions, options);
    return new ECPair(undefined, buffer, options);
  }
  exports.fromPublicKey = fromPublicKey;
  function fromWIF(wifString, network) {
    const decoded = wif.decode(wifString);
    const version = decoded.version;
    // list of networks?
    if (types.Array(network)) {
      network = network
        .filter(x => {
          return version === x.wif;
        })
        .pop();
      if (!network) throw new Error('Unknown network version');
      // otherwise, assume a network object (or default to bitcoin)
    } else {
      network = network || NETWORKS.bitcoin;
      if (version !== network.wif) throw new Error('Invalid network version');
    }
    return fromPrivateKey(decoded.privateKey, {
      compressed: decoded.compressed,
      network: network,
    });
  }
  exports.fromWIF = fromWIF;
  function makeRandom(options) {
    typeforce(isOptions, options);
    if (options === undefined) options = {};
    const rng = options.rng || randomBytes;
    let d;
    do {
      d = rng(32);
      typeforce(types.Buffer256bit, d);
    } while (!ecc.isPrivate(d));
    return fromPrivateKey(d, options);
  }
  exports.makeRandom = makeRandom;
  
  }).call(this,require("buffer").Buffer)
  },{"./networks":149,"./types":186,"buffer":3,"randombytes":251,"tiny-secp256k1":266,"typeforce":271,"wif":274}],148:[function(require,module,exports){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const bip32 = require('bip32');
  exports.bip32 = bip32;
  const address = require('./address');
  exports.address = address;
  const crypto = require('./crypto');
  exports.crypto = crypto;
  const ECPair = require('./ecpair');
  exports.ECPair = ECPair;
  const networks = require('./networks');
  exports.networks = networks;
  const payments = require('./payments');
  exports.payments = payments;
  const script = require('./script');
  exports.script = script;
  var block_1 = require('./block');
  exports.Block = block_1.Block;
  var psbt_1 = require('./psbt');
  exports.Psbt = psbt_1.Psbt;
  var script_1 = require('./script');
  exports.opcodes = script_1.OPS;
  var transaction_1 = require('./transaction');
  exports.Transaction = transaction_1.Transaction;
  var transaction_builder_1 = require('./transaction_builder');
  exports.TransactionBuilder = transaction_builder_1.TransactionBuilder;
  
  },{"./address":142,"./block":143,"./crypto":146,"./ecpair":147,"./networks":149,"./payments":151,"./psbt":159,"./script":160,"./transaction":184,"./transaction_builder":185,"bip32":128}],149:[function(require,module,exports){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  exports.bitcoin = {
    messagePrefix: '\x18Bitcoin Signed Message:\n',
    bech32: 'bc',
    bip32: {
      public: 0x0488b21e,
      private: 0x0488ade4,
    },
    pubKeyHash: 0x00,
    scriptHash: 0x05,
    wif: 0x80,
  };
  exports.regtest = {
    messagePrefix: '\x18Bitcoin Signed Message:\n',
    bech32: 'bcrt',
    bip32: {
      public: 0x043587cf,
      private: 0x04358394,
    },
    pubKeyHash: 0x6f,
    scriptHash: 0xc4,
    wif: 0xef,
  };
  exports.testnet = {
    messagePrefix: '\x18Bitcoin Signed Message:\n',
    bech32: 'tb',
    bip32: {
      public: 0x043587cf,
      private: 0x04358394,
    },
    pubKeyHash: 0x6f,
    scriptHash: 0xc4,
    wif: 0xef,
  };
  
  },{}],150:[function(require,module,exports){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const networks_1 = require('../networks');
  const bscript = require('../script');
  const lazy = require('./lazy');
  const typef = require('typeforce');
  const OPS = bscript.OPS;
  function stacksEqual(a, b) {
    if (a.length !== b.length) return false;
    return a.every((x, i) => {
      return x.equals(b[i]);
    });
  }
  // output: OP_RETURN ...
  function p2data(a, opts) {
    if (!a.data && !a.output) throw new TypeError('Not enough data');
    opts = Object.assign({ validate: true }, opts || {});
    typef(
      {
        network: typef.maybe(typef.Object),
        output: typef.maybe(typef.Buffer),
        data: typef.maybe(typef.arrayOf(typef.Buffer)),
      },
      a,
    );
    const network = a.network || networks_1.bitcoin;
    const o = { name: 'embed', network };
    lazy.prop(o, 'output', () => {
      if (!a.data) return;
      return bscript.compile([OPS.OP_RETURN].concat(a.data));
    });
    lazy.prop(o, 'data', () => {
      if (!a.output) return;
      return bscript.decompile(a.output).slice(1);
    });
    // extended validation
    if (opts.validate) {
      if (a.output) {
        const chunks = bscript.decompile(a.output);
        if (chunks[0] !== OPS.OP_RETURN) throw new TypeError('Output is invalid');
        if (!chunks.slice(1).every(typef.Buffer))
          throw new TypeError('Output is invalid');
        if (a.data && !stacksEqual(a.data, o.data))
          throw new TypeError('Data mismatch');
      }
    }
    return Object.assign(o, a);
  }
  exports.p2data = p2data;
  
  },{"../networks":149,"../script":160,"./lazy":152,"typeforce":271}],151:[function(require,module,exports){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const embed_1 = require('./embed');
  exports.embed = embed_1.p2data;
  const p2ms_1 = require('./p2ms');
  exports.p2ms = p2ms_1.p2ms;
  const p2pk_1 = require('./p2pk');
  exports.p2pk = p2pk_1.p2pk;
  const p2pkh_1 = require('./p2pkh');
  exports.p2pkh = p2pkh_1.p2pkh;
  const p2sh_1 = require('./p2sh');
  exports.p2sh = p2sh_1.p2sh;
  const p2wpkh_1 = require('./p2wpkh');
  exports.p2wpkh = p2wpkh_1.p2wpkh;
  const p2wsh_1 = require('./p2wsh');
  exports.p2wsh = p2wsh_1.p2wsh;
  // TODO
  // witness commitment
  
  },{"./embed":150,"./p2ms":153,"./p2pk":154,"./p2pkh":155,"./p2sh":156,"./p2wpkh":157,"./p2wsh":158}],152:[function(require,module,exports){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  function prop(object, name, f) {
    Object.defineProperty(object, name, {
      configurable: true,
      enumerable: true,
      get() {
        const _value = f.call(this);
        this[name] = _value;
        return _value;
      },
      set(_value) {
        Object.defineProperty(this, name, {
          configurable: true,
          enumerable: true,
          value: _value,
          writable: true,
        });
      },
    });
  }
  exports.prop = prop;
  function value(f) {
    let _value;
    return () => {
      if (_value !== undefined) return _value;
      _value = f();
      return _value;
    };
  }
  exports.value = value;
  
  },{}],153:[function(require,module,exports){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const networks_1 = require('../networks');
  const bscript = require('../script');
  const lazy = require('./lazy');
  const OPS = bscript.OPS;
  const typef = require('typeforce');
  const ecc = require('tiny-secp256k1');
  const OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1
  function stacksEqual(a, b) {
    if (a.length !== b.length) return false;
    return a.every((x, i) => {
      return x.equals(b[i]);
    });
  }
  // input: OP_0 [signatures ...]
  // output: m [pubKeys ...] n OP_CHECKMULTISIG
  function p2ms(a, opts) {
    if (
      !a.input &&
      !a.output &&
      !(a.pubkeys && a.m !== undefined) &&
      !a.signatures
    )
      throw new TypeError('Not enough data');
    opts = Object.assign({ validate: true }, opts || {});
    function isAcceptableSignature(x) {
      return (
        bscript.isCanonicalScriptSignature(x) ||
        (opts.allowIncomplete && x === OPS.OP_0) !== undefined
      );
    }
    typef(
      {
        network: typef.maybe(typef.Object),
        m: typef.maybe(typef.Number),
        n: typef.maybe(typef.Number),
        output: typef.maybe(typef.Buffer),
        pubkeys: typef.maybe(typef.arrayOf(ecc.isPoint)),
        signatures: typef.maybe(typef.arrayOf(isAcceptableSignature)),
        input: typef.maybe(typef.Buffer),
      },
      a,
    );
    const network = a.network || networks_1.bitcoin;
    const o = { network };
    let chunks = [];
    let decoded = false;
    function decode(output) {
      if (decoded) return;
      decoded = true;
      chunks = bscript.decompile(output);
      o.m = chunks[0] - OP_INT_BASE;
      o.n = chunks[chunks.length - 2] - OP_INT_BASE;
      o.pubkeys = chunks.slice(1, -2);
    }
    lazy.prop(o, 'output', () => {
      if (!a.m) return;
      if (!o.n) return;
      if (!a.pubkeys) return;
      return bscript.compile(
        [].concat(
          OP_INT_BASE + a.m,
          a.pubkeys,
          OP_INT_BASE + o.n,
          OPS.OP_CHECKMULTISIG,
        ),
      );
    });
    lazy.prop(o, 'm', () => {
      if (!o.output) return;
      decode(o.output);
      return o.m;
    });
    lazy.prop(o, 'n', () => {
      if (!o.pubkeys) return;
      return o.pubkeys.length;
    });
    lazy.prop(o, 'pubkeys', () => {
      if (!a.output) return;
      decode(a.output);
      return o.pubkeys;
    });
    lazy.prop(o, 'signatures', () => {
      if (!a.input) return;
      return bscript.decompile(a.input).slice(1);
    });
    lazy.prop(o, 'input', () => {
      if (!a.signatures) return;
      return bscript.compile([OPS.OP_0].concat(a.signatures));
    });
    lazy.prop(o, 'witness', () => {
      if (!o.input) return;
      return [];
    });
    lazy.prop(o, 'name', () => {
      if (!o.m || !o.n) return;
      return `p2ms(${o.m} of ${o.n})`;
    });
    // extended validation
    if (opts.validate) {
      if (a.output) {
        decode(a.output);
        if (!typef.Number(chunks[0])) throw new TypeError('Output is invalid');
        if (!typef.Number(chunks[chunks.length - 2]))
          throw new TypeError('Output is invalid');
        if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG)
          throw new TypeError('Output is invalid');
        if (o.m <= 0 || o.n > 16 || o.m > o.n || o.n !== chunks.length - 3)
          throw new TypeError('Output is invalid');
        if (!o.pubkeys.every(x => ecc.isPoint(x)))
          throw new TypeError('Output is invalid');
        if (a.m !== undefined && a.m !== o.m) throw new TypeError('m mismatch');
        if (a.n !== undefined && a.n !== o.n) throw new TypeError('n mismatch');
        if (a.pubkeys && !stacksEqual(a.pubkeys, o.pubkeys))
          throw new TypeError('Pubkeys mismatch');
      }
      if (a.pubkeys) {
        if (a.n !== undefined && a.n !== a.pubkeys.length)
          throw new TypeError('Pubkey count mismatch');
        o.n = a.pubkeys.length;
        if (o.n < o.m) throw new TypeError('Pubkey count cannot be less than m');
      }
      if (a.signatures) {
        if (a.signatures.length < o.m)
          throw new TypeError('Not enough signatures provided');
        if (a.signatures.length > o.m)
          throw new TypeError('Too many signatures provided');
      }
      if (a.input) {
        if (a.input[0] !== OPS.OP_0) throw new TypeError('Input is invalid');
        if (
          o.signatures.length === 0 ||
          !o.signatures.every(isAcceptableSignature)
        )
          throw new TypeError('Input has invalid signature(s)');
        if (a.signatures && !stacksEqual(a.signatures, o.signatures))
          throw new TypeError('Signature mismatch');
        if (a.m !== undefined && a.m !== a.signatures.length)
          throw new TypeError('Signature count mismatch');
      }
    }
    return Object.assign(o, a);
  }
  exports.p2ms = p2ms;
  
  },{"../networks":149,"../script":160,"./lazy":152,"tiny-secp256k1":266,"typeforce":271}],154:[function(require,module,exports){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const networks_1 = require('../networks');
  const bscript = require('../script');
  const lazy = require('./lazy');
  const typef = require('typeforce');
  const OPS = bscript.OPS;
  const ecc = require('tiny-secp256k1');
  // input: {signature}
  // output: {pubKey} OP_CHECKSIG
  function p2pk(a, opts) {
    if (!a.input && !a.output && !a.pubkey && !a.input && !a.signature)
      throw new TypeError('Not enough data');
    opts = Object.assign({ validate: true }, opts || {});
    typef(
      {
        network: typef.maybe(typef.Object),
        output: typef.maybe(typef.Buffer),
        pubkey: typef.maybe(ecc.isPoint),
        signature: typef.maybe(bscript.isCanonicalScriptSignature),
        input: typef.maybe(typef.Buffer),
      },
      a,
    );
    const _chunks = lazy.value(() => {
      return bscript.decompile(a.input);
    });
    const network = a.network || networks_1.bitcoin;
    const o = { name: 'p2pk', network };
    lazy.prop(o, 'output', () => {
      if (!a.pubkey) return;
      return bscript.compile([a.pubkey, OPS.OP_CHECKSIG]);
    });
    lazy.prop(o, 'pubkey', () => {
      if (!a.output) return;
      return a.output.slice(1, -1);
    });
    lazy.prop(o, 'signature', () => {
      if (!a.input) return;
      return _chunks()[0];
    });
    lazy.prop(o, 'input', () => {
      if (!a.signature) return;
      return bscript.compile([a.signature]);
    });
    lazy.prop(o, 'witness', () => {
      if (!o.input) return;
      return [];
    });
    // extended validation
    if (opts.validate) {
      if (a.output) {
        if (a.output[a.output.length - 1] !== OPS.OP_CHECKSIG)
          throw new TypeError('Output is invalid');
        if (!ecc.isPoint(o.pubkey))
          throw new TypeError('Output pubkey is invalid');
        if (a.pubkey && !a.pubkey.equals(o.pubkey))
          throw new TypeError('Pubkey mismatch');
      }
      if (a.signature) {
        if (a.input && !a.input.equals(o.input))
          throw new TypeError('Signature mismatch');
      }
      if (a.input) {
        if (_chunks().length !== 1) throw new TypeError('Input is invalid');
        if (!bscript.isCanonicalScriptSignature(o.signature))
          throw new TypeError('Input has invalid signature');
      }
    }
    return Object.assign(o, a);
  }
  exports.p2pk = p2pk;
  
  },{"../networks":149,"../script":160,"./lazy":152,"tiny-secp256k1":266,"typeforce":271}],155:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const bcrypto = require('../crypto');
  const networks_1 = require('../networks');
  const bscript = require('../script');
  const lazy = require('./lazy');
  const typef = require('typeforce');
  const OPS = bscript.OPS;
  const ecc = require('tiny-secp256k1');
  const bs58check = require('bs58check');
  // input: {signature} {pubkey}
  // output: OP_DUP OP_HASH160 {hash160(pubkey)} OP_EQUALVERIFY OP_CHECKSIG
  function p2pkh(a, opts) {
    if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input)
      throw new TypeError('Not enough data');
    opts = Object.assign({ validate: true }, opts || {});
    typef(
      {
        network: typef.maybe(typef.Object),
        address: typef.maybe(typef.String),
        hash: typef.maybe(typef.BufferN(20)),
        output: typef.maybe(typef.BufferN(25)),
        pubkey: typef.maybe(ecc.isPoint),
        signature: typef.maybe(bscript.isCanonicalScriptSignature),
        input: typef.maybe(typef.Buffer),
      },
      a,
    );
    const _address = lazy.value(() => {
      const payload = bs58check.decode(a.address);
      const version = payload.readUInt8(0);
      const hash = payload.slice(1);
      return { version, hash };
    });
    const _chunks = lazy.value(() => {
      return bscript.decompile(a.input);
    });
    const network = a.network || networks_1.bitcoin;
    const o = { name: 'p2pkh', network };
    lazy.prop(o, 'address', () => {
      if (!o.hash) return;
      const payload = Buffer.allocUnsafe(21);
      payload.writeUInt8(network.pubKeyHash, 0);
      o.hash.copy(payload, 1);
      return bs58check.encode(payload);
    });
    lazy.prop(o, 'hash', () => {
      if (a.output) return a.output.slice(3, 23);
      if (a.address) return _address().hash;
      if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);
    });
    lazy.prop(o, 'output', () => {
      if (!o.hash) return;
      return bscript.compile([
        OPS.OP_DUP,
        OPS.OP_HASH160,
        o.hash,
        OPS.OP_EQUALVERIFY,
        OPS.OP_CHECKSIG,
      ]);
    });
    lazy.prop(o, 'pubkey', () => {
      if (!a.input) return;
      return _chunks()[1];
    });
    lazy.prop(o, 'signature', () => {
      if (!a.input) return;
      return _chunks()[0];
    });
    lazy.prop(o, 'input', () => {
      if (!a.pubkey) return;
      if (!a.signature) return;
      return bscript.compile([a.signature, a.pubkey]);
    });
    lazy.prop(o, 'witness', () => {
      if (!o.input) return;
      return [];
    });
    // extended validation
    if (opts.validate) {
      let hash = Buffer.from([]);
      if (a.address) {
        if (_address().version !== network.pubKeyHash)
          throw new TypeError('Invalid version or Network mismatch');
        if (_address().hash.length !== 20) throw new TypeError('Invalid address');
        hash = _address().hash;
      }
      if (a.hash) {
        if (hash.length > 0 && !hash.equals(a.hash))
          throw new TypeError('Hash mismatch');
        else hash = a.hash;
      }
      if (a.output) {
        if (
          a.output.length !== 25 ||
          a.output[0] !== OPS.OP_DUP ||
          a.output[1] !== OPS.OP_HASH160 ||
          a.output[2] !== 0x14 ||
          a.output[23] !== OPS.OP_EQUALVERIFY ||
          a.output[24] !== OPS.OP_CHECKSIG
        )
          throw new TypeError('Output is invalid');
        const hash2 = a.output.slice(3, 23);
        if (hash.length > 0 && !hash.equals(hash2))
          throw new TypeError('Hash mismatch');
        else hash = hash2;
      }
      if (a.pubkey) {
        const pkh = bcrypto.hash160(a.pubkey);
        if (hash.length > 0 && !hash.equals(pkh))
          throw new TypeError('Hash mismatch');
        else hash = pkh;
      }
      if (a.input) {
        const chunks = _chunks();
        if (chunks.length !== 2) throw new TypeError('Input is invalid');
        if (!bscript.isCanonicalScriptSignature(chunks[0]))
          throw new TypeError('Input has invalid signature');
        if (!ecc.isPoint(chunks[1]))
          throw new TypeError('Input has invalid pubkey');
        if (a.signature && !a.signature.equals(chunks[0]))
          throw new TypeError('Signature mismatch');
        if (a.pubkey && !a.pubkey.equals(chunks[1]))
          throw new TypeError('Pubkey mismatch');
        const pkh = bcrypto.hash160(chunks[1]);
        if (hash.length > 0 && !hash.equals(pkh))
          throw new TypeError('Hash mismatch');
      }
    }
    return Object.assign(o, a);
  }
  exports.p2pkh = p2pkh;
  
  }).call(this,require("buffer").Buffer)
  },{"../crypto":146,"../networks":149,"../script":160,"./lazy":152,"bs58check":191,"buffer":3,"tiny-secp256k1":266,"typeforce":271}],156:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const bcrypto = require('../crypto');
  const networks_1 = require('../networks');
  const bscript = require('../script');
  const lazy = require('./lazy');
  const typef = require('typeforce');
  const OPS = bscript.OPS;
  const bs58check = require('bs58check');
  function stacksEqual(a, b) {
    if (a.length !== b.length) return false;
    return a.every((x, i) => {
      return x.equals(b[i]);
    });
  }
  // input: [redeemScriptSig ...] {redeemScript}
  // witness: <?>
  // output: OP_HASH160 {hash160(redeemScript)} OP_EQUAL
  function p2sh(a, opts) {
    if (!a.address && !a.hash && !a.output && !a.redeem && !a.input)
      throw new TypeError('Not enough data');
    opts = Object.assign({ validate: true }, opts || {});
    typef(
      {
        network: typef.maybe(typef.Object),
        address: typef.maybe(typef.String),
        hash: typef.maybe(typef.BufferN(20)),
        output: typef.maybe(typef.BufferN(23)),
        redeem: typef.maybe({
          network: typef.maybe(typef.Object),
          output: typef.maybe(typef.Buffer),
          input: typef.maybe(typef.Buffer),
          witness: typef.maybe(typef.arrayOf(typef.Buffer)),
        }),
        input: typef.maybe(typef.Buffer),
        witness: typef.maybe(typef.arrayOf(typef.Buffer)),
      },
      a,
    );
    let network = a.network;
    if (!network) {
      network = (a.redeem && a.redeem.network) || networks_1.bitcoin;
    }
    const o = { network };
    const _address = lazy.value(() => {
      const payload = bs58check.decode(a.address);
      const version = payload.readUInt8(0);
      const hash = payload.slice(1);
      return { version, hash };
    });
    const _chunks = lazy.value(() => {
      return bscript.decompile(a.input);
    });
    const _redeem = lazy.value(() => {
      const chunks = _chunks();
      return {
        network,
        output: chunks[chunks.length - 1],
        input: bscript.compile(chunks.slice(0, -1)),
        witness: a.witness || [],
      };
    });
    // output dependents
    lazy.prop(o, 'address', () => {
      if (!o.hash) return;
      const payload = Buffer.allocUnsafe(21);
      payload.writeUInt8(o.network.scriptHash, 0);
      o.hash.copy(payload, 1);
      return bs58check.encode(payload);
    });
    lazy.prop(o, 'hash', () => {
      // in order of least effort
      if (a.output) return a.output.slice(2, 22);
      if (a.address) return _address().hash;
      if (o.redeem && o.redeem.output) return bcrypto.hash160(o.redeem.output);
    });
    lazy.prop(o, 'output', () => {
      if (!o.hash) return;
      return bscript.compile([OPS.OP_HASH160, o.hash, OPS.OP_EQUAL]);
    });
    // input dependents
    lazy.prop(o, 'redeem', () => {
      if (!a.input) return;
      return _redeem();
    });
    lazy.prop(o, 'input', () => {
      if (!a.redeem || !a.redeem.input || !a.redeem.output) return;
      return bscript.compile(
        [].concat(bscript.decompile(a.redeem.input), a.redeem.output),
      );
    });
    lazy.prop(o, 'witness', () => {
      if (o.redeem && o.redeem.witness) return o.redeem.witness;
      if (o.input) return [];
    });
    lazy.prop(o, 'name', () => {
      const nameParts = ['p2sh'];
      if (o.redeem !== undefined) nameParts.push(o.redeem.name);
      return nameParts.join('-');
    });
    if (opts.validate) {
      let hash = Buffer.from([]);
      if (a.address) {
        if (_address().version !== network.scriptHash)
          throw new TypeError('Invalid version or Network mismatch');
        if (_address().hash.length !== 20) throw new TypeError('Invalid address');
        hash = _address().hash;
      }
      if (a.hash) {
        if (hash.length > 0 && !hash.equals(a.hash))
          throw new TypeError('Hash mismatch');
        else hash = a.hash;
      }
      if (a.output) {
        if (
          a.output.length !== 23 ||
          a.output[0] !== OPS.OP_HASH160 ||
          a.output[1] !== 0x14 ||
          a.output[22] !== OPS.OP_EQUAL
        )
          throw new TypeError('Output is invalid');
        const hash2 = a.output.slice(2, 22);
        if (hash.length > 0 && !hash.equals(hash2))
          throw new TypeError('Hash mismatch');
        else hash = hash2;
      }
      // inlined to prevent 'no-inner-declarations' failing
      const checkRedeem = redeem => {
        // is the redeem output empty/invalid?
        if (redeem.output) {
          const decompile = bscript.decompile(redeem.output);
          if (!decompile || decompile.length < 1)
            throw new TypeError('Redeem.output too short');
          // match hash against other sources
          const hash2 = bcrypto.hash160(redeem.output);
          if (hash.length > 0 && !hash.equals(hash2))
            throw new TypeError('Hash mismatch');
          else hash = hash2;
        }
        if (redeem.input) {
          const hasInput = redeem.input.length > 0;
          const hasWitness = redeem.witness && redeem.witness.length > 0;
          if (!hasInput && !hasWitness) throw new TypeError('Empty input');
          if (hasInput && hasWitness)
            throw new TypeError('Input and witness provided');
          if (hasInput) {
            const richunks = bscript.decompile(redeem.input);
            if (!bscript.isPushOnly(richunks))
              throw new TypeError('Non push-only scriptSig');
          }
        }
      };
      if (a.input) {
        const chunks = _chunks();
        if (!chunks || chunks.length < 1) throw new TypeError('Input too short');
        if (!Buffer.isBuffer(_redeem().output))
          throw new TypeError('Input is invalid');
        checkRedeem(_redeem());
      }
      if (a.redeem) {
        if (a.redeem.network && a.redeem.network !== network)
          throw new TypeError('Network mismatch');
        if (a.input) {
          const redeem = _redeem();
          if (a.redeem.output && !a.redeem.output.equals(redeem.output))
            throw new TypeError('Redeem.output mismatch');
          if (a.redeem.input && !a.redeem.input.equals(redeem.input))
            throw new TypeError('Redeem.input mismatch');
        }
        checkRedeem(a.redeem);
      }
      if (a.witness) {
        if (
          a.redeem &&
          a.redeem.witness &&
          !stacksEqual(a.redeem.witness, a.witness)
        )
          throw new TypeError('Witness and redeem.witness mismatch');
      }
    }
    return Object.assign(o, a);
  }
  exports.p2sh = p2sh;
  
  }).call(this,require("buffer").Buffer)
  },{"../crypto":146,"../networks":149,"../script":160,"./lazy":152,"bs58check":191,"buffer":3,"typeforce":271}],157:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const bcrypto = require('../crypto');
  const networks_1 = require('../networks');
  const bscript = require('../script');
  const lazy = require('./lazy');
  const typef = require('typeforce');
  const OPS = bscript.OPS;
  const ecc = require('tiny-secp256k1');
  const bech32 = require('bech32');
  const EMPTY_BUFFER = Buffer.alloc(0);
  // witness: {signature} {pubKey}
  // input: <>
  // output: OP_0 {pubKeyHash}
  function p2wpkh(a, opts) {
    if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness)
      throw new TypeError('Not enough data');
    opts = Object.assign({ validate: true }, opts || {});
    typef(
      {
        address: typef.maybe(typef.String),
        hash: typef.maybe(typef.BufferN(20)),
        input: typef.maybe(typef.BufferN(0)),
        network: typef.maybe(typef.Object),
        output: typef.maybe(typef.BufferN(22)),
        pubkey: typef.maybe(ecc.isPoint),
        signature: typef.maybe(bscript.isCanonicalScriptSignature),
        witness: typef.maybe(typef.arrayOf(typef.Buffer)),
      },
      a,
    );
    const _address = lazy.value(() => {
      const result = bech32.decode(a.address);
      const version = result.words.shift();
      const data = bech32.fromWords(result.words);
      return {
        version,
        prefix: result.prefix,
        data: Buffer.from(data),
      };
    });
    const network = a.network || networks_1.bitcoin;
    const o = { name: 'p2wpkh', network };
    lazy.prop(o, 'address', () => {
      if (!o.hash) return;
      const words = bech32.toWords(o.hash);
      words.unshift(0x00);
      return bech32.encode(network.bech32, words);
    });
    lazy.prop(o, 'hash', () => {
      if (a.output) return a.output.slice(2, 22);
      if (a.address) return _address().data;
      if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);
    });
    lazy.prop(o, 'output', () => {
      if (!o.hash) return;
      return bscript.compile([OPS.OP_0, o.hash]);
    });
    lazy.prop(o, 'pubkey', () => {
      if (a.pubkey) return a.pubkey;
      if (!a.witness) return;
      return a.witness[1];
    });
    lazy.prop(o, 'signature', () => {
      if (!a.witness) return;
      return a.witness[0];
    });
    lazy.prop(o, 'input', () => {
      if (!o.witness) return;
      return EMPTY_BUFFER;
    });
    lazy.prop(o, 'witness', () => {
      if (!a.pubkey) return;
      if (!a.signature) return;
      return [a.signature, a.pubkey];
    });
    // extended validation
    if (opts.validate) {
      let hash = Buffer.from([]);
      if (a.address) {
        if (network && network.bech32 !== _address().prefix)
          throw new TypeError('Invalid prefix or Network mismatch');
        if (_address().version !== 0x00)
          throw new TypeError('Invalid address version');
        if (_address().data.length !== 20)
          throw new TypeError('Invalid address data');
        hash = _address().data;
      }
      if (a.hash) {
        if (hash.length > 0 && !hash.equals(a.hash))
          throw new TypeError('Hash mismatch');
        else hash = a.hash;
      }
      if (a.output) {
        if (
          a.output.length !== 22 ||
          a.output[0] !== OPS.OP_0 ||
          a.output[1] !== 0x14
        )
          throw new TypeError('Output is invalid');
        if (hash.length > 0 && !hash.equals(a.output.slice(2)))
          throw new TypeError('Hash mismatch');
        else hash = a.output.slice(2);
      }
      if (a.pubkey) {
        const pkh = bcrypto.hash160(a.pubkey);
        if (hash.length > 0 && !hash.equals(pkh))
          throw new TypeError('Hash mismatch');
        else hash = pkh;
      }
      if (a.witness) {
        if (a.witness.length !== 2) throw new TypeError('Witness is invalid');
        if (!bscript.isCanonicalScriptSignature(a.witness[0]))
          throw new TypeError('Witness has invalid signature');
        if (!ecc.isPoint(a.witness[1]))
          throw new TypeError('Witness has invalid pubkey');
        if (a.signature && !a.signature.equals(a.witness[0]))
          throw new TypeError('Signature mismatch');
        if (a.pubkey && !a.pubkey.equals(a.witness[1]))
          throw new TypeError('Pubkey mismatch');
        const pkh = bcrypto.hash160(a.witness[1]);
        if (hash.length > 0 && !hash.equals(pkh))
          throw new TypeError('Hash mismatch');
      }
    }
    return Object.assign(o, a);
  }
  exports.p2wpkh = p2wpkh;
  
  }).call(this,require("buffer").Buffer)
  },{"../crypto":146,"../networks":149,"../script":160,"./lazy":152,"bech32":102,"buffer":3,"tiny-secp256k1":266,"typeforce":271}],158:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const bcrypto = require('../crypto');
  const networks_1 = require('../networks');
  const bscript = require('../script');
  const lazy = require('./lazy');
  const typef = require('typeforce');
  const OPS = bscript.OPS;
  const bech32 = require('bech32');
  const EMPTY_BUFFER = Buffer.alloc(0);
  function stacksEqual(a, b) {
    if (a.length !== b.length) return false;
    return a.every((x, i) => {
      return x.equals(b[i]);
    });
  }
  // input: <>
  // witness: [redeemScriptSig ...] {redeemScript}
  // output: OP_0 {sha256(redeemScript)}
  function p2wsh(a, opts) {
    if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness)
      throw new TypeError('Not enough data');
    opts = Object.assign({ validate: true }, opts || {});
    typef(
      {
        network: typef.maybe(typef.Object),
        address: typef.maybe(typef.String),
        hash: typef.maybe(typef.BufferN(32)),
        output: typef.maybe(typef.BufferN(34)),
        redeem: typef.maybe({
          input: typef.maybe(typef.Buffer),
          network: typef.maybe(typef.Object),
          output: typef.maybe(typef.Buffer),
          witness: typef.maybe(typef.arrayOf(typef.Buffer)),
        }),
        input: typef.maybe(typef.BufferN(0)),
        witness: typef.maybe(typef.arrayOf(typef.Buffer)),
      },
      a,
    );
    const _address = lazy.value(() => {
      const result = bech32.decode(a.address);
      const version = result.words.shift();
      const data = bech32.fromWords(result.words);
      return {
        version,
        prefix: result.prefix,
        data: Buffer.from(data),
      };
    });
    const _rchunks = lazy.value(() => {
      return bscript.decompile(a.redeem.input);
    });
    let network = a.network;
    if (!network) {
      network = (a.redeem && a.redeem.network) || networks_1.bitcoin;
    }
    const o = { network };
    lazy.prop(o, 'address', () => {
      if (!o.hash) return;
      const words = bech32.toWords(o.hash);
      words.unshift(0x00);
      return bech32.encode(network.bech32, words);
    });
    lazy.prop(o, 'hash', () => {
      if (a.output) return a.output.slice(2);
      if (a.address) return _address().data;
      if (o.redeem && o.redeem.output) return bcrypto.sha256(o.redeem.output);
    });
    lazy.prop(o, 'output', () => {
      if (!o.hash) return;
      return bscript.compile([OPS.OP_0, o.hash]);
    });
    lazy.prop(o, 'redeem', () => {
      if (!a.witness) return;
      return {
        output: a.witness[a.witness.length - 1],
        input: EMPTY_BUFFER,
        witness: a.witness.slice(0, -1),
      };
    });
    lazy.prop(o, 'input', () => {
      if (!o.witness) return;
      return EMPTY_BUFFER;
    });
    lazy.prop(o, 'witness', () => {
      // transform redeem input to witness stack?
      if (
        a.redeem &&
        a.redeem.input &&
        a.redeem.input.length > 0 &&
        a.redeem.output &&
        a.redeem.output.length > 0
      ) {
        const stack = bscript.toStack(_rchunks());
        // assign, and blank the existing input
        o.redeem = Object.assign({ witness: stack }, a.redeem);
        o.redeem.input = EMPTY_BUFFER;
        return [].concat(stack, a.redeem.output);
      }
      if (!a.redeem) return;
      if (!a.redeem.output) return;
      if (!a.redeem.witness) return;
      return [].concat(a.redeem.witness, a.redeem.output);
    });
    lazy.prop(o, 'name', () => {
      const nameParts = ['p2wsh'];
      if (o.redeem !== undefined) nameParts.push(o.redeem.name);
      return nameParts.join('-');
    });
    // extended validation
    if (opts.validate) {
      let hash = Buffer.from([]);
      if (a.address) {
        if (_address().prefix !== network.bech32)
          throw new TypeError('Invalid prefix or Network mismatch');
        if (_address().version !== 0x00)
          throw new TypeError('Invalid address version');
        if (_address().data.length !== 32)
          throw new TypeError('Invalid address data');
        hash = _address().data;
      }
      if (a.hash) {
        if (hash.length > 0 && !hash.equals(a.hash))
          throw new TypeError('Hash mismatch');
        else hash = a.hash;
      }
      if (a.output) {
        if (
          a.output.length !== 34 ||
          a.output[0] !== OPS.OP_0 ||
          a.output[1] !== 0x20
        )
          throw new TypeError('Output is invalid');
        const hash2 = a.output.slice(2);
        if (hash.length > 0 && !hash.equals(hash2))
          throw new TypeError('Hash mismatch');
        else hash = hash2;
      }
      if (a.redeem) {
        if (a.redeem.network && a.redeem.network !== network)
          throw new TypeError('Network mismatch');
        // is there two redeem sources?
        if (
          a.redeem.input &&
          a.redeem.input.length > 0 &&
          a.redeem.witness &&
          a.redeem.witness.length > 0
        )
          throw new TypeError('Ambiguous witness source');
        // is the redeem output non-empty?
        if (a.redeem.output) {
          if (bscript.decompile(a.redeem.output).length === 0)
            throw new TypeError('Redeem.output is invalid');
          // match hash against other sources
          const hash2 = bcrypto.sha256(a.redeem.output);
          if (hash.length > 0 && !hash.equals(hash2))
            throw new TypeError('Hash mismatch');
          else hash = hash2;
        }
        if (a.redeem.input && !bscript.isPushOnly(_rchunks()))
          throw new TypeError('Non push-only scriptSig');
        if (
          a.witness &&
          a.redeem.witness &&
          !stacksEqual(a.witness, a.redeem.witness)
        )
          throw new TypeError('Witness and redeem.witness mismatch');
      }
      if (a.witness) {
        if (
          a.redeem &&
          a.redeem.output &&
          !a.redeem.output.equals(a.witness[a.witness.length - 1])
        )
          throw new TypeError('Witness and redeem.output mismatch');
      }
    }
    return Object.assign(o, a);
  }
  exports.p2wsh = p2wsh;
  
  }).call(this,require("buffer").Buffer)
  },{"../crypto":146,"../networks":149,"../script":160,"./lazy":152,"bech32":102,"buffer":3,"typeforce":271}],159:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const bip174_1 = require('bip174');
  const varuint = require('bip174/src/lib/converter/varint');
  const utils_1 = require('bip174/src/lib/utils');
  const address_1 = require('./address');
  const bufferutils_1 = require('./bufferutils');
  const crypto_1 = require('./crypto');
  const ecpair_1 = require('./ecpair');
  const networks_1 = require('./networks');
  const payments = require('./payments');
  const bscript = require('./script');
  const transaction_1 = require('./transaction');
  /**
   * These are the default arguments for a Psbt instance.
   */
  const DEFAULT_OPTS = {
    /**
     * A bitcoinjs Network object. This is only used if you pass an `address`
     * parameter to addOutput. Otherwise it is not needed and can be left default.
     */
    network: networks_1.bitcoin,
    /**
     * When extractTransaction is called, the fee rate is checked.
     * THIS IS NOT TO BE RELIED ON.
     * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
     */
    maximumFeeRate: 5000,
  };
  /**
   * Psbt class can parse and generate a PSBT binary based off of the BIP174.
   * There are 6 roles that this class fulfills. (Explained in BIP174)
   *
   * Creator: This can be done with `new Psbt()`
   * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,
   *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to
   *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,
   *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`
   *   addInput requires hash: Buffer | string; and index: number; as attributes
   *   and can also include any attributes that are used in updateInput method.
   *   addOutput requires script: Buffer; and value: number; and likewise can include
   *   data for updateOutput.
   *   For a list of what attributes should be what types. Check the bip174 library.
   *   Also, check the integration tests for some examples of usage.
   * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input
   *   information for your pubkey or pubkeyhash, and only sign inputs where it finds
   *   your info. Or you can explicitly sign a specific input with signInput and
   *   signInputAsync. For the async methods you can create a SignerAsync object
   *   and use something like a hardware wallet to sign with. (You must implement this)
   * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`
   *   the psbt calling combine will always have precedence when a conflict occurs.
   *   Combine checks if the internal bitcoin transaction is the same, so be sure that
   *   all sequences, version, locktime, etc. are the same before combining.
   * Input Finalizer: This role is fairly important. Not only does it need to construct
   *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.
   *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`
   *   Running any finalize method will delete any data in the input(s) that are no longer
   *   needed due to the finalized scripts containing the information.
   * Transaction Extractor: This role will perform some checks before returning a
   *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.
   */
  class Psbt {
    constructor(opts = {}, data = new bip174_1.Psbt(new PsbtTransaction())) {
      this.data = data;
      // set defaults
      this.opts = Object.assign({}, DEFAULT_OPTS, opts);
      this.__CACHE = {
        __NON_WITNESS_UTXO_TX_CACHE: [],
        __NON_WITNESS_UTXO_BUF_CACHE: [],
        __TX_IN_CACHE: {},
        __TX: this.data.globalMap.unsignedTx.tx,
      };
      if (this.data.inputs.length === 0) this.setVersion(2);
      // Make data hidden when enumerating
      const dpew = (obj, attr, enumerable, writable) =>
        Object.defineProperty(obj, attr, {
          enumerable,
          writable,
        });
      dpew(this, '__CACHE', false, true);
      dpew(this, 'opts', false, true);
    }
    static fromBase64(data, opts = {}) {
      const buffer = Buffer.from(data, 'base64');
      return this.fromBuffer(buffer, opts);
    }
    static fromHex(data, opts = {}) {
      const buffer = Buffer.from(data, 'hex');
      return this.fromBuffer(buffer, opts);
    }
    static fromBuffer(buffer, opts = {}) {
      const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);
      const psbt = new Psbt(opts, psbtBase);
      checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);
      return psbt;
    }
    get inputCount() {
      return this.data.inputs.length;
    }
    combine(...those) {
      this.data.combine(...those.map(o => o.data));
      return this;
    }
    clone() {
      // TODO: more efficient cloning
      const res = Psbt.fromBuffer(this.data.toBuffer());
      res.opts = JSON.parse(JSON.stringify(this.opts));
      return res;
    }
    setMaximumFeeRate(satoshiPerByte) {
      check32Bit(satoshiPerByte); // 42.9 BTC per byte IS excessive... so throw
      this.opts.maximumFeeRate = satoshiPerByte;
    }
    setVersion(version) {
      check32Bit(version);
      checkInputsForPartialSig(this.data.inputs, 'setVersion');
      const c = this.__CACHE;
      c.__TX.version = version;
      c.__EXTRACTED_TX = undefined;
      return this;
    }
    setLocktime(locktime) {
      check32Bit(locktime);
      checkInputsForPartialSig(this.data.inputs, 'setLocktime');
      const c = this.__CACHE;
      c.__TX.locktime = locktime;
      c.__EXTRACTED_TX = undefined;
      return this;
    }
    setInputSequence(inputIndex, sequence) {
      check32Bit(sequence);
      checkInputsForPartialSig(this.data.inputs, 'setInputSequence');
      const c = this.__CACHE;
      if (c.__TX.ins.length <= inputIndex) {
        throw new Error('Input index too high');
      }
      c.__TX.ins[inputIndex].sequence = sequence;
      c.__EXTRACTED_TX = undefined;
      return this;
    }
    addInputs(inputDatas) {
      inputDatas.forEach(inputData => this.addInput(inputData));
      return this;
    }
    addInput(inputData) {
      if (
        arguments.length > 1 ||
        !inputData ||
        inputData.hash === undefined ||
        inputData.index === undefined
      ) {
        throw new Error(
          `Invalid arguments for Psbt.addInput. ` +
            `Requires single object with at least [hash] and [index]`,
        );
      }
      checkInputsForPartialSig(this.data.inputs, 'addInput');
      const c = this.__CACHE;
      this.data.addInput(inputData);
      const txIn = c.__TX.ins[c.__TX.ins.length - 1];
      checkTxInputCache(c, txIn);
      const inputIndex = this.data.inputs.length - 1;
      const input = this.data.inputs[inputIndex];
      if (input.nonWitnessUtxo) {
        addNonWitnessTxCache(this.__CACHE, input, inputIndex);
      }
      c.__FEE = undefined;
      c.__FEE_RATE = undefined;
      c.__EXTRACTED_TX = undefined;
      return this;
    }
    addOutputs(outputDatas) {
      outputDatas.forEach(outputData => this.addOutput(outputData));
      return this;
    }
    addOutput(outputData) {
      if (
        arguments.length > 1 ||
        !outputData ||
        outputData.value === undefined ||
        (outputData.address === undefined && outputData.script === undefined)
      ) {
        throw new Error(
          `Invalid arguments for Psbt.addOutput. ` +
            `Requires single object with at least [script or address] and [value]`,
        );
      }
      checkInputsForPartialSig(this.data.inputs, 'addOutput');
      const { address } = outputData;
      if (typeof address === 'string') {
        const { network } = this.opts;
        const script = address_1.toOutputScript(address, network);
        outputData = Object.assign(outputData, { script });
      }
      const c = this.__CACHE;
      this.data.addOutput(outputData);
      c.__FEE = undefined;
      c.__FEE_RATE = undefined;
      c.__EXTRACTED_TX = undefined;
      return this;
    }
    extractTransaction(disableFeeCheck) {
      if (!this.data.inputs.every(isFinalized)) throw new Error('Not finalized');
      const c = this.__CACHE;
      if (!disableFeeCheck) {
        checkFees(this, c, this.opts);
      }
      if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;
      const tx = c.__TX.clone();
      inputFinalizeGetAmts(this.data.inputs, tx, c, true);
      return tx;
    }
    getFeeRate() {
      return getTxCacheValue(
        '__FEE_RATE',
        'fee rate',
        this.data.inputs,
        this.__CACHE,
      );
    }
    getFee() {
      return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);
    }
    finalizeAllInputs() {
      utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one
      range(this.data.inputs.length).forEach(idx => this.finalizeInput(idx));
      return this;
    }
    finalizeInput(inputIndex, finalScriptsFunc = getFinalScripts) {
      const input = utils_1.checkForInput(this.data.inputs, inputIndex);
      const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(
        inputIndex,
        input,
        this.__CACHE,
      );
      if (!script) throw new Error(`No script found for input #${inputIndex}`);
      checkPartialSigSighashes(input);
      const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(
        inputIndex,
        input,
        script,
        isSegwit,
        isP2SH,
        isP2WSH,
      );
      if (finalScriptSig) this.data.updateInput(inputIndex, { finalScriptSig });
      if (finalScriptWitness)
        this.data.updateInput(inputIndex, { finalScriptWitness });
      if (!finalScriptSig && !finalScriptWitness)
        throw new Error(`Unknown error finalizing input #${inputIndex}`);
      this.data.clearFinalizedInput(inputIndex);
      return this;
    }
    validateSignaturesOfAllInputs() {
      utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one
      const results = range(this.data.inputs.length).map(idx =>
        this.validateSignaturesOfInput(idx),
      );
      return results.reduce((final, res) => res === true && final, true);
    }
    validateSignaturesOfInput(inputIndex, pubkey) {
      const input = this.data.inputs[inputIndex];
      const partialSig = (input || {}).partialSig;
      if (!input || !partialSig || partialSig.length < 1)
        throw new Error('No signatures to validate');
      const mySigs = pubkey
        ? partialSig.filter(sig => sig.pubkey.equals(pubkey))
        : partialSig;
      if (mySigs.length < 1) throw new Error('No signatures for this pubkey');
      const results = [];
      let hashCache;
      let scriptCache;
      let sighashCache;
      for (const pSig of mySigs) {
        const sig = bscript.signature.decode(pSig.signature);
        const { hash, script } =
          sighashCache !== sig.hashType
            ? getHashForSig(
                inputIndex,
                Object.assign({}, input, { sighashType: sig.hashType }),
                this.__CACHE,
              )
            : { hash: hashCache, script: scriptCache };
        sighashCache = sig.hashType;
        hashCache = hash;
        scriptCache = script;
        checkScriptForPubkey(pSig.pubkey, script, 'verify');
        const keypair = ecpair_1.fromPublicKey(pSig.pubkey);
        results.push(keypair.verify(hash, sig.signature));
      }
      return results.every(res => res === true);
    }
    signAllInputsHD(
      hdKeyPair,
      sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
    ) {
      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
        throw new Error('Need HDSigner to sign input');
      }
      const results = [];
      for (const i of range(this.data.inputs.length)) {
        try {
          this.signInputHD(i, hdKeyPair, sighashTypes);
          results.push(true);
        } catch (err) {
          results.push(false);
        }
      }
      if (results.every(v => v === false)) {
        throw new Error('No inputs were signed');
      }
      return this;
    }
    signAllInputsHDAsync(
      hdKeyPair,
      sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
    ) {
      return new Promise((resolve, reject) => {
        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
          return reject(new Error('Need HDSigner to sign input'));
        }
        const results = [];
        const promises = [];
        for (const i of range(this.data.inputs.length)) {
          promises.push(
            this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(
              () => {
                results.push(true);
              },
              () => {
                results.push(false);
              },
            ),
          );
        }
        return Promise.all(promises).then(() => {
          if (results.every(v => v === false)) {
            return reject(new Error('No inputs were signed'));
          }
          resolve();
        });
      });
    }
    signInputHD(
      inputIndex,
      hdKeyPair,
      sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
    ) {
      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
        throw new Error('Need HDSigner to sign input');
      }
      const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
      signers.forEach(signer => this.signInput(inputIndex, signer, sighashTypes));
      return this;
    }
    signInputHDAsync(
      inputIndex,
      hdKeyPair,
      sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
    ) {
      return new Promise((resolve, reject) => {
        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
          return reject(new Error('Need HDSigner to sign input'));
        }
        const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
        const promises = signers.map(signer =>
          this.signInputAsync(inputIndex, signer, sighashTypes),
        );
        return Promise.all(promises)
          .then(() => {
            resolve();
          })
          .catch(reject);
      });
    }
    signAllInputs(
      keyPair,
      sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
    ) {
      if (!keyPair || !keyPair.publicKey)
        throw new Error('Need Signer to sign input');
      // TODO: Add a pubkey/pubkeyhash cache to each input
      // as input information is added, then eventually
      // optimize this method.
      const results = [];
      for (const i of range(this.data.inputs.length)) {
        try {
          this.signInput(i, keyPair, sighashTypes);
          results.push(true);
        } catch (err) {
          results.push(false);
        }
      }
      if (results.every(v => v === false)) {
        throw new Error('No inputs were signed');
      }
      return this;
    }
    signAllInputsAsync(
      keyPair,
      sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
    ) {
      return new Promise((resolve, reject) => {
        if (!keyPair || !keyPair.publicKey)
          return reject(new Error('Need Signer to sign input'));
        // TODO: Add a pubkey/pubkeyhash cache to each input
        // as input information is added, then eventually
        // optimize this method.
        const results = [];
        const promises = [];
        for (const [i] of this.data.inputs.entries()) {
          promises.push(
            this.signInputAsync(i, keyPair, sighashTypes).then(
              () => {
                results.push(true);
              },
              () => {
                results.push(false);
              },
            ),
          );
        }
        return Promise.all(promises).then(() => {
          if (results.every(v => v === false)) {
            return reject(new Error('No inputs were signed'));
          }
          resolve();
        });
      });
    }
    signInput(
      inputIndex,
      keyPair,
      sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
    ) {
      if (!keyPair || !keyPair.publicKey)
        throw new Error('Need Signer to sign input');
      const { hash, sighashType } = getHashAndSighashType(
        this.data.inputs,
        inputIndex,
        keyPair.publicKey,
        this.__CACHE,
        sighashTypes,
      );
      const partialSig = [
        {
          pubkey: keyPair.publicKey,
          signature: bscript.signature.encode(keyPair.sign(hash), sighashType),
        },
      ];
      this.data.updateInput(inputIndex, { partialSig });
      return this;
    }
    signInputAsync(
      inputIndex,
      keyPair,
      sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
    ) {
      return new Promise((resolve, reject) => {
        if (!keyPair || !keyPair.publicKey)
          return reject(new Error('Need Signer to sign input'));
        const { hash, sighashType } = getHashAndSighashType(
          this.data.inputs,
          inputIndex,
          keyPair.publicKey,
          this.__CACHE,
          sighashTypes,
        );
        Promise.resolve(keyPair.sign(hash)).then(signature => {
          const partialSig = [
            {
              pubkey: keyPair.publicKey,
              signature: bscript.signature.encode(signature, sighashType),
            },
          ];
          this.data.updateInput(inputIndex, { partialSig });
          resolve();
        });
      });
    }
    toBuffer() {
      return this.data.toBuffer();
    }
    toHex() {
      return this.data.toHex();
    }
    toBase64() {
      return this.data.toBase64();
    }
    updateGlobal(updateData) {
      this.data.updateGlobal(updateData);
      return this;
    }
    updateInput(inputIndex, updateData) {
      this.data.updateInput(inputIndex, updateData);
      if (updateData.nonWitnessUtxo) {
        addNonWitnessTxCache(
          this.__CACHE,
          this.data.inputs[inputIndex],
          inputIndex,
        );
      }
      return this;
    }
    updateOutput(outputIndex, updateData) {
      this.data.updateOutput(outputIndex, updateData);
      return this;
    }
    addUnknownKeyValToGlobal(keyVal) {
      this.data.addUnknownKeyValToGlobal(keyVal);
      return this;
    }
    addUnknownKeyValToInput(inputIndex, keyVal) {
      this.data.addUnknownKeyValToInput(inputIndex, keyVal);
      return this;
    }
    addUnknownKeyValToOutput(outputIndex, keyVal) {
      this.data.addUnknownKeyValToOutput(outputIndex, keyVal);
      return this;
    }
    clearFinalizedInput(inputIndex) {
      this.data.clearFinalizedInput(inputIndex);
      return this;
    }
  }
  exports.Psbt = Psbt;
  /**
   * This function is needed to pass to the bip174 base class's fromBuffer.
   * It takes the "transaction buffer" portion of the psbt buffer and returns a
   * Transaction (From the bip174 library) interface.
   */
  const transactionFromBuffer = buffer => new PsbtTransaction(buffer);
  /**
   * This class implements the Transaction interface from bip174 library.
   * It contains a bitcoinjs-lib Transaction object.
   */
  class PsbtTransaction {
    constructor(buffer = Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
      this.tx = transaction_1.Transaction.fromBuffer(buffer);
      checkTxEmpty(this.tx);
      Object.defineProperty(this, 'tx', {
        enumerable: false,
        writable: true,
      });
    }
    getInputOutputCounts() {
      return {
        inputCount: this.tx.ins.length,
        outputCount: this.tx.outs.length,
      };
    }
    addInput(input) {
      if (
        input.hash === undefined ||
        input.index === undefined ||
        (!Buffer.isBuffer(input.hash) && typeof input.hash !== 'string') ||
        typeof input.index !== 'number'
      ) {
        throw new Error('Error adding input.');
      }
      const hash =
        typeof input.hash === 'string'
          ? bufferutils_1.reverseBuffer(Buffer.from(input.hash, 'hex'))
          : input.hash;
      this.tx.addInput(hash, input.index, input.sequence);
    }
    addOutput(output) {
      if (
        output.script === undefined ||
        output.value === undefined ||
        !Buffer.isBuffer(output.script) ||
        typeof output.value !== 'number'
      ) {
        throw new Error('Error adding output.');
      }
      this.tx.addOutput(output.script, output.value);
    }
    toBuffer() {
      return this.tx.toBuffer();
    }
  }
  function canFinalize(input, script, scriptType) {
    switch (scriptType) {
      case 'pubkey':
      case 'pubkeyhash':
      case 'witnesspubkeyhash':
        return hasSigs(1, input.partialSig);
      case 'multisig':
        const p2ms = payments.p2ms({ output: script });
        return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);
      default:
        return false;
    }
  }
  function hasSigs(neededSigs, partialSig, pubkeys) {
    if (!partialSig) return false;
    let sigs;
    if (pubkeys) {
      sigs = pubkeys
        .map(pkey => {
          const pubkey = ecpair_1.fromPublicKey(pkey, { compressed: true })
            .publicKey;
          return partialSig.find(pSig => pSig.pubkey.equals(pubkey));
        })
        .filter(v => !!v);
    } else {
      sigs = partialSig;
    }
    if (sigs.length > neededSigs) throw new Error('Too many signatures');
    return sigs.length === neededSigs;
  }
  function isFinalized(input) {
    return !!input.finalScriptSig || !!input.finalScriptWitness;
  }
  function isPaymentFactory(payment) {
    return script => {
      try {
        payment({ output: script });
        return true;
      } catch (err) {
        return false;
      }
    };
  }
  const isP2MS = isPaymentFactory(payments.p2ms);
  const isP2PK = isPaymentFactory(payments.p2pk);
  const isP2PKH = isPaymentFactory(payments.p2pkh);
  const isP2WPKH = isPaymentFactory(payments.p2wpkh);
  const isP2WSHScript = isPaymentFactory(payments.p2wsh);
  function check32Bit(num) {
    if (
      typeof num !== 'number' ||
      num !== Math.floor(num) ||
      num > 0xffffffff ||
      num < 0
    ) {
      throw new Error('Invalid 32 bit integer');
    }
  }
  function checkFees(psbt, cache, opts) {
    const feeRate = cache.__FEE_RATE || psbt.getFeeRate();
    const vsize = cache.__EXTRACTED_TX.virtualSize();
    const satoshis = feeRate * vsize;
    if (feeRate >= opts.maximumFeeRate) {
      throw new Error(
        `Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in ` +
          `fees, which is ${feeRate} satoshi per byte for a transaction ` +
          `with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per ` +
          `byte). Use setMaximumFeeRate method to raise your threshold, or ` +
          `pass true to the first arg of extractTransaction.`,
      );
    }
  }
  function checkInputsForPartialSig(inputs, action) {
    inputs.forEach(input => {
      let throws = false;
      let pSigs = [];
      if ((input.partialSig || []).length === 0) {
        if (!input.finalScriptSig && !input.finalScriptWitness) return;
        pSigs = getPsigsFromInputFinalScripts(input);
      } else {
        pSigs = input.partialSig;
      }
      pSigs.forEach(pSig => {
        const { hashType } = bscript.signature.decode(pSig.signature);
        const whitelist = [];
        const isAnyoneCanPay =
          hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;
        if (isAnyoneCanPay) whitelist.push('addInput');
        const hashMod = hashType & 0x1f;
        switch (hashMod) {
          case transaction_1.Transaction.SIGHASH_ALL:
            break;
          case transaction_1.Transaction.SIGHASH_SINGLE:
          case transaction_1.Transaction.SIGHASH_NONE:
            whitelist.push('addOutput');
            whitelist.push('setInputSequence');
            break;
        }
        if (whitelist.indexOf(action) === -1) {
          throws = true;
        }
      });
      if (throws) {
        throw new Error('Can not modify transaction, signatures exist.');
      }
    });
  }
  function checkPartialSigSighashes(input) {
    if (!input.sighashType || !input.partialSig) return;
    const { partialSig, sighashType } = input;
    partialSig.forEach(pSig => {
      const { hashType } = bscript.signature.decode(pSig.signature);
      if (sighashType !== hashType) {
        throw new Error('Signature sighash does not match input sighash type');
      }
    });
  }
  function checkScriptForPubkey(pubkey, script, action) {
    const pubkeyHash = crypto_1.hash160(pubkey);
    const decompiled = bscript.decompile(script);
    if (decompiled === null) throw new Error('Unknown script error');
    const hasKey = decompiled.some(element => {
      if (typeof element === 'number') return false;
      return element.equals(pubkey) || element.equals(pubkeyHash);
    });
    if (!hasKey) {
      throw new Error(
        `Can not ${action} for this input with the key ${pubkey.toString('hex')}`,
      );
    }
  }
  function checkTxEmpty(tx) {
    const isEmpty = tx.ins.every(
      input =>
        input.script &&
        input.script.length === 0 &&
        input.witness &&
        input.witness.length === 0,
    );
    if (!isEmpty) {
      throw new Error('Format Error: Transaction ScriptSigs are not empty');
    }
  }
  function checkTxForDupeIns(tx, cache) {
    tx.ins.forEach(input => {
      checkTxInputCache(cache, input);
    });
  }
  function checkTxInputCache(cache, input) {
    const key =
      bufferutils_1.reverseBuffer(Buffer.from(input.hash)).toString('hex') +
      ':' +
      input.index;
    if (cache.__TX_IN_CACHE[key]) throw new Error('Duplicate input detected.');
    cache.__TX_IN_CACHE[key] = 1;
  }
  function scriptCheckerFactory(payment, paymentScriptName) {
    return (inputIndex, scriptPubKey, redeemScript) => {
      const redeemScriptOutput = payment({
        redeem: { output: redeemScript },
      }).output;
      if (!scriptPubKey.equals(redeemScriptOutput)) {
        throw new Error(
          `${paymentScriptName} for input #${inputIndex} doesn't match the scriptPubKey in the prevout`,
        );
      }
    };
  }
  const checkRedeemScript = scriptCheckerFactory(payments.p2sh, 'Redeem script');
  const checkWitnessScript = scriptCheckerFactory(
    payments.p2wsh,
    'Witness script',
  );
  function getTxCacheValue(key, name, inputs, c) {
    if (!inputs.every(isFinalized))
      throw new Error(`PSBT must be finalized to calculate ${name}`);
    if (key === '__FEE_RATE' && c.__FEE_RATE) return c.__FEE_RATE;
    if (key === '__FEE' && c.__FEE) return c.__FEE;
    let tx;
    let mustFinalize = true;
    if (c.__EXTRACTED_TX) {
      tx = c.__EXTRACTED_TX;
      mustFinalize = false;
    } else {
      tx = c.__TX.clone();
    }
    inputFinalizeGetAmts(inputs, tx, c, mustFinalize);
    if (key === '__FEE_RATE') return c.__FEE_RATE;
    else if (key === '__FEE') return c.__FEE;
  }
  function getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {
    const scriptType = classifyScript(script);
    if (!canFinalize(input, script, scriptType))
      throw new Error(`Can not finalize input #${inputIndex}`);
    return prepareFinalScripts(
      script,
      scriptType,
      input.partialSig,
      isSegwit,
      isP2SH,
      isP2WSH,
    );
  }
  function prepareFinalScripts(
    script,
    scriptType,
    partialSig,
    isSegwit,
    isP2SH,
    isP2WSH,
  ) {
    let finalScriptSig;
    let finalScriptWitness;
    // Wow, the payments API is very handy
    const payment = getPayment(script, scriptType, partialSig);
    const p2wsh = !isP2WSH ? null : payments.p2wsh({ redeem: payment });
    const p2sh = !isP2SH ? null : payments.p2sh({ redeem: p2wsh || payment });
    if (isSegwit) {
      if (p2wsh) {
        finalScriptWitness = witnessStackToScriptWitness(p2wsh.witness);
      } else {
        finalScriptWitness = witnessStackToScriptWitness(payment.witness);
      }
      if (p2sh) {
        finalScriptSig = p2sh.input;
      }
    } else {
      if (p2sh) {
        finalScriptSig = p2sh.input;
      } else {
        finalScriptSig = payment.input;
      }
    }
    return {
      finalScriptSig,
      finalScriptWitness,
    };
  }
  function getHashAndSighashType(
    inputs,
    inputIndex,
    pubkey,
    cache,
    sighashTypes,
  ) {
    const input = utils_1.checkForInput(inputs, inputIndex);
    const { hash, sighashType, script } = getHashForSig(
      inputIndex,
      input,
      cache,
      sighashTypes,
    );
    checkScriptForPubkey(pubkey, script, 'sign');
    return {
      hash,
      sighashType,
    };
  }
  function getHashForSig(inputIndex, input, cache, sighashTypes) {
    const unsignedTx = cache.__TX;
    const sighashType =
      input.sighashType || transaction_1.Transaction.SIGHASH_ALL;
    if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {
      const str = sighashTypeToString(sighashType);
      throw new Error(
        `Sighash type is not allowed. Retry the sign method passing the ` +
          `sighashTypes array of whitelisted types. Sighash type: ${str}`,
      );
    }
    let hash;
    let script;
    if (input.nonWitnessUtxo) {
      const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
        cache,
        input,
        inputIndex,
      );
      const prevoutHash = unsignedTx.ins[inputIndex].hash;
      const utxoHash = nonWitnessUtxoTx.getHash();
      // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout
      if (!prevoutHash.equals(utxoHash)) {
        throw new Error(
          `Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`,
        );
      }
      const prevoutIndex = unsignedTx.ins[inputIndex].index;
      const prevout = nonWitnessUtxoTx.outs[prevoutIndex];
      if (input.redeemScript) {
        // If a redeemScript is provided, the scriptPubKey must be for that redeemScript
        checkRedeemScript(inputIndex, prevout.script, input.redeemScript);
        script = input.redeemScript;
      } else {
        script = prevout.script;
      }
      if (isP2WSHScript(script)) {
        if (!input.witnessScript)
          throw new Error('Segwit input needs witnessScript if not P2WPKH');
        checkWitnessScript(inputIndex, script, input.witnessScript);
        hash = unsignedTx.hashForWitnessV0(
          inputIndex,
          input.witnessScript,
          prevout.value,
          sighashType,
        );
        script = input.witnessScript;
      } else if (isP2WPKH(script)) {
        // P2WPKH uses the P2PKH template for prevoutScript when signing
        const signingScript = payments.p2pkh({ hash: script.slice(2) }).output;
        hash = unsignedTx.hashForWitnessV0(
          inputIndex,
          signingScript,
          prevout.value,
          sighashType,
        );
      } else {
        hash = unsignedTx.hashForSignature(inputIndex, script, sighashType);
      }
    } else if (input.witnessUtxo) {
      let _script; // so we don't shadow the `let script` above
      if (input.redeemScript) {
        // If a redeemScript is provided, the scriptPubKey must be for that redeemScript
        checkRedeemScript(
          inputIndex,
          input.witnessUtxo.script,
          input.redeemScript,
        );
        _script = input.redeemScript;
      } else {
        _script = input.witnessUtxo.script;
      }
      if (isP2WPKH(_script)) {
        // P2WPKH uses the P2PKH template for prevoutScript when signing
        const signingScript = payments.p2pkh({ hash: _script.slice(2) }).output;
        hash = unsignedTx.hashForWitnessV0(
          inputIndex,
          signingScript,
          input.witnessUtxo.value,
          sighashType,
        );
        script = _script;
      } else if (isP2WSHScript(_script)) {
        if (!input.witnessScript)
          throw new Error('Segwit input needs witnessScript if not P2WPKH');
        checkWitnessScript(inputIndex, _script, input.witnessScript);
        hash = unsignedTx.hashForWitnessV0(
          inputIndex,
          input.witnessScript,
          input.witnessUtxo.value,
          sighashType,
        );
        // want to make sure the script we return is the actual meaningful script
        script = input.witnessScript;
      } else {
        throw new Error(
          `Input #${inputIndex} has witnessUtxo but non-segwit script: ` +
            `${_script.toString('hex')}`,
        );
      }
    } else {
      throw new Error('Need a Utxo input item for signing');
    }
    return {
      script,
      sighashType,
      hash,
    };
  }
  function getPayment(script, scriptType, partialSig) {
    let payment;
    switch (scriptType) {
      case 'multisig':
        const sigs = getSortedSigs(script, partialSig);
        payment = payments.p2ms({
          output: script,
          signatures: sigs,
        });
        break;
      case 'pubkey':
        payment = payments.p2pk({
          output: script,
          signature: partialSig[0].signature,
        });
        break;
      case 'pubkeyhash':
        payment = payments.p2pkh({
          output: script,
          pubkey: partialSig[0].pubkey,
          signature: partialSig[0].signature,
        });
        break;
      case 'witnesspubkeyhash':
        payment = payments.p2wpkh({
          output: script,
          pubkey: partialSig[0].pubkey,
          signature: partialSig[0].signature,
        });
        break;
    }
    return payment;
  }
  function getPsigsFromInputFinalScripts(input) {
    const scriptItems = !input.finalScriptSig
      ? []
      : bscript.decompile(input.finalScriptSig) || [];
    const witnessItems = !input.finalScriptWitness
      ? []
      : bscript.decompile(input.finalScriptWitness) || [];
    return scriptItems
      .concat(witnessItems)
      .filter(item => {
        return Buffer.isBuffer(item) && bscript.isCanonicalScriptSignature(item);
      })
      .map(sig => ({ signature: sig }));
  }
  function getScriptFromInput(inputIndex, input, cache) {
    const unsignedTx = cache.__TX;
    const res = {
      script: null,
      isSegwit: false,
      isP2SH: false,
      isP2WSH: false,
    };
    res.isP2SH = !!input.redeemScript;
    res.isP2WSH = !!input.witnessScript;
    if (input.witnessScript) {
      res.script = input.witnessScript;
    } else if (input.redeemScript) {
      res.script = input.redeemScript;
    } else {
      if (input.nonWitnessUtxo) {
        const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
          cache,
          input,
          inputIndex,
        );
        const prevoutIndex = unsignedTx.ins[inputIndex].index;
        res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;
      } else if (input.witnessUtxo) {
        res.script = input.witnessUtxo.script;
      }
    }
    if (input.witnessScript || isP2WPKH(res.script)) {
      res.isSegwit = true;
    }
    return res;
  }
  function getSignersFromHD(inputIndex, inputs, hdKeyPair) {
    const input = utils_1.checkForInput(inputs, inputIndex);
    if (!input.bip32Derivation || input.bip32Derivation.length === 0) {
      throw new Error('Need bip32Derivation to sign with HD');
    }
    const myDerivations = input.bip32Derivation
      .map(bipDv => {
        if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {
          return bipDv;
        } else {
          return;
        }
      })
      .filter(v => !!v);
    if (myDerivations.length === 0) {
      throw new Error(
        'Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint',
      );
    }
    const signers = myDerivations.map(bipDv => {
      const node = hdKeyPair.derivePath(bipDv.path);
      if (!bipDv.pubkey.equals(node.publicKey)) {
        throw new Error('pubkey did not match bip32Derivation');
      }
      return node;
    });
    return signers;
  }
  function getSortedSigs(script, partialSig) {
    const p2ms = payments.p2ms({ output: script });
    // for each pubkey in order of p2ms script
    return p2ms.pubkeys
      .map(pk => {
        // filter partialSig array by pubkey being equal
        return (
          partialSig.filter(ps => {
            return ps.pubkey.equals(pk);
          })[0] || {}
        ).signature;
        // Any pubkey without a match will return undefined
        // this last filter removes all the undefined items in the array.
      })
      .filter(v => !!v);
  }
  function scriptWitnessToWitnessStack(buffer) {
    let offset = 0;
    function readSlice(n) {
      offset += n;
      return buffer.slice(offset - n, offset);
    }
    function readVarInt() {
      const vi = varuint.decode(buffer, offset);
      offset += varuint.decode.bytes;
      return vi;
    }
    function readVarSlice() {
      return readSlice(readVarInt());
    }
    function readVector() {
      const count = readVarInt();
      const vector = [];
      for (let i = 0; i < count; i++) vector.push(readVarSlice());
      return vector;
    }
    return readVector();
  }
  function sighashTypeToString(sighashType) {
    let text =
      sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY
        ? 'SIGHASH_ANYONECANPAY | '
        : '';
    const sigMod = sighashType & 0x1f;
    switch (sigMod) {
      case transaction_1.Transaction.SIGHASH_ALL:
        text += 'SIGHASH_ALL';
        break;
      case transaction_1.Transaction.SIGHASH_SINGLE:
        text += 'SIGHASH_SINGLE';
        break;
      case transaction_1.Transaction.SIGHASH_NONE:
        text += 'SIGHASH_NONE';
        break;
    }
    return text;
  }
  function witnessStackToScriptWitness(witness) {
    let buffer = Buffer.allocUnsafe(0);
    function writeSlice(slice) {
      buffer = Buffer.concat([buffer, Buffer.from(slice)]);
    }
    function writeVarInt(i) {
      const currentLen = buffer.length;
      const varintLen = varuint.encodingLength(i);
      buffer = Buffer.concat([buffer, Buffer.allocUnsafe(varintLen)]);
      varuint.encode(i, buffer, currentLen);
    }
    function writeVarSlice(slice) {
      writeVarInt(slice.length);
      writeSlice(slice);
    }
    function writeVector(vector) {
      writeVarInt(vector.length);
      vector.forEach(writeVarSlice);
    }
    writeVector(witness);
    return buffer;
  }
  function addNonWitnessTxCache(cache, input, inputIndex) {
    cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;
    const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);
    cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;
    const self = cache;
    const selfIndex = inputIndex;
    delete input.nonWitnessUtxo;
    Object.defineProperty(input, 'nonWitnessUtxo', {
      enumerable: true,
      get() {
        const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];
        const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];
        if (buf !== undefined) {
          return buf;
        } else {
          const newBuf = txCache.toBuffer();
          self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;
          return newBuf;
        }
      },
      set(data) {
        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;
      },
    });
  }
  function inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {
    let inputAmount = 0;
    inputs.forEach((input, idx) => {
      if (mustFinalize && input.finalScriptSig)
        tx.ins[idx].script = input.finalScriptSig;
      if (mustFinalize && input.finalScriptWitness) {
        tx.ins[idx].witness = scriptWitnessToWitnessStack(
          input.finalScriptWitness,
        );
      }
      if (input.witnessUtxo) {
        inputAmount += input.witnessUtxo.value;
      } else if (input.nonWitnessUtxo) {
        const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);
        const vout = tx.ins[idx].index;
        const out = nwTx.outs[vout];
        inputAmount += out.value;
      }
    });
    const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0);
    const fee = inputAmount - outputAmount;
    if (fee < 0) {
      throw new Error('Outputs are spending more than Inputs');
    }
    const bytes = tx.virtualSize();
    cache.__FEE = fee;
    cache.__EXTRACTED_TX = tx;
    cache.__FEE_RATE = Math.floor(fee / bytes);
  }
  function nonWitnessUtxoTxFromCache(cache, input, inputIndex) {
    const c = cache.__NON_WITNESS_UTXO_TX_CACHE;
    if (!c[inputIndex]) {
      addNonWitnessTxCache(cache, input, inputIndex);
    }
    return c[inputIndex];
  }
  function classifyScript(script) {
    if (isP2WPKH(script)) return 'witnesspubkeyhash';
    if (isP2PKH(script)) return 'pubkeyhash';
    if (isP2MS(script)) return 'multisig';
    if (isP2PK(script)) return 'pubkey';
    return 'nonstandard';
  }
  function range(n) {
    return [...Array(n).keys()];
  }
  
  }).call(this,require("buffer").Buffer)
  },{"./address":142,"./bufferutils":144,"./crypto":146,"./ecpair":147,"./networks":149,"./payments":151,"./script":160,"./transaction":184,"bip174":123,"bip174/src/lib/converter/varint":119,"bip174/src/lib/utils":125,"buffer":3}],160:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const scriptNumber = require('./script_number');
  const scriptSignature = require('./script_signature');
  const types = require('./types');
  const bip66 = require('bip66');
  const ecc = require('tiny-secp256k1');
  const pushdata = require('pushdata-bitcoin');
  const typeforce = require('typeforce');
  exports.OPS = require('bitcoin-ops');
  const REVERSE_OPS = require('bitcoin-ops/map');
  const OP_INT_BASE = exports.OPS.OP_RESERVED; // OP_1 - 1
  function isOPInt(value) {
    return (
      types.Number(value) &&
      (value === exports.OPS.OP_0 ||
        (value >= exports.OPS.OP_1 && value <= exports.OPS.OP_16) ||
        value === exports.OPS.OP_1NEGATE)
    );
  }
  function isPushOnlyChunk(value) {
    return types.Buffer(value) || isOPInt(value);
  }
  function isPushOnly(value) {
    return types.Array(value) && value.every(isPushOnlyChunk);
  }
  exports.isPushOnly = isPushOnly;
  function asMinimalOP(buffer) {
    if (buffer.length === 0) return exports.OPS.OP_0;
    if (buffer.length !== 1) return;
    if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];
    if (buffer[0] === 0x81) return exports.OPS.OP_1NEGATE;
  }
  function chunksIsBuffer(buf) {
    return Buffer.isBuffer(buf);
  }
  function chunksIsArray(buf) {
    return types.Array(buf);
  }
  function singleChunkIsBuffer(buf) {
    return Buffer.isBuffer(buf);
  }
  function compile(chunks) {
    // TODO: remove me
    if (chunksIsBuffer(chunks)) return chunks;
    typeforce(types.Array, chunks);
    const bufferSize = chunks.reduce((accum, chunk) => {
      // data chunk
      if (singleChunkIsBuffer(chunk)) {
        // adhere to BIP62.3, minimal push policy
        if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {
          return accum + 1;
        }
        return accum + pushdata.encodingLength(chunk.length) + chunk.length;
      }
      // opcode
      return accum + 1;
    }, 0.0);
    const buffer = Buffer.allocUnsafe(bufferSize);
    let offset = 0;
    chunks.forEach(chunk => {
      // data chunk
      if (singleChunkIsBuffer(chunk)) {
        // adhere to BIP62.3, minimal push policy
        const opcode = asMinimalOP(chunk);
        if (opcode !== undefined) {
          buffer.writeUInt8(opcode, offset);
          offset += 1;
          return;
        }
        offset += pushdata.encode(buffer, chunk.length, offset);
        chunk.copy(buffer, offset);
        offset += chunk.length;
        // opcode
      } else {
        buffer.writeUInt8(chunk, offset);
        offset += 1;
      }
    });
    if (offset !== buffer.length) throw new Error('Could not decode chunks');
    return buffer;
  }
  exports.compile = compile;
  function decompile(buffer) {
    // TODO: remove me
    if (chunksIsArray(buffer)) return buffer;
    typeforce(types.Buffer, buffer);
    const chunks = [];
    let i = 0;
    while (i < buffer.length) {
      const opcode = buffer[i];
      // data chunk
      if (opcode > exports.OPS.OP_0 && opcode <= exports.OPS.OP_PUSHDATA4) {
        const d = pushdata.decode(buffer, i);
        // did reading a pushDataInt fail?
        if (d === null) return null;
        i += d.size;
        // attempt to read too much data?
        if (i + d.number > buffer.length) return null;
        const data = buffer.slice(i, i + d.number);
        i += d.number;
        // decompile minimally
        const op = asMinimalOP(data);
        if (op !== undefined) {
          chunks.push(op);
        } else {
          chunks.push(data);
        }
        // opcode
      } else {
        chunks.push(opcode);
        i += 1;
      }
    }
    return chunks;
  }
  exports.decompile = decompile;
  function toASM(chunks) {
    if (chunksIsBuffer(chunks)) {
      chunks = decompile(chunks);
    }
    return chunks
      .map(chunk => {
        // data?
        if (singleChunkIsBuffer(chunk)) {
          const op = asMinimalOP(chunk);
          if (op === undefined) return chunk.toString('hex');
          chunk = op;
        }
        // opcode!
        return REVERSE_OPS[chunk];
      })
      .join(' ');
  }
  exports.toASM = toASM;
  function fromASM(asm) {
    typeforce(types.String, asm);
    return compile(
      asm.split(' ').map(chunkStr => {
        // opcode?
        if (exports.OPS[chunkStr] !== undefined) return exports.OPS[chunkStr];
        typeforce(types.Hex, chunkStr);
        // data!
        return Buffer.from(chunkStr, 'hex');
      }),
    );
  }
  exports.fromASM = fromASM;
  function toStack(chunks) {
    chunks = decompile(chunks);
    typeforce(isPushOnly, chunks);
    return chunks.map(op => {
      if (singleChunkIsBuffer(op)) return op;
      if (op === exports.OPS.OP_0) return Buffer.allocUnsafe(0);
      return scriptNumber.encode(op - OP_INT_BASE);
    });
  }
  exports.toStack = toStack;
  function isCanonicalPubKey(buffer) {
    return ecc.isPoint(buffer);
  }
  exports.isCanonicalPubKey = isCanonicalPubKey;
  function isDefinedHashType(hashType) {
    const hashTypeMod = hashType & ~0x80;
    // return hashTypeMod > SIGHASH_ALL && hashTypeMod < SIGHASH_SINGLE
    return hashTypeMod > 0x00 && hashTypeMod < 0x04;
  }
  exports.isDefinedHashType = isDefinedHashType;
  function isCanonicalScriptSignature(buffer) {
    if (!Buffer.isBuffer(buffer)) return false;
    if (!isDefinedHashType(buffer[buffer.length - 1])) return false;
    return bip66.check(buffer.slice(0, -1));
  }
  exports.isCanonicalScriptSignature = isCanonicalScriptSignature;
  // tslint:disable-next-line variable-name
  exports.number = scriptNumber;
  exports.signature = scriptSignature;
  
  }).call(this,require("buffer").Buffer)
  },{"./script_number":161,"./script_signature":162,"./types":186,"bip66":139,"bitcoin-ops":140,"bitcoin-ops/map":141,"buffer":3,"pushdata-bitcoin":249,"tiny-secp256k1":266,"typeforce":271}],161:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  function decode(buffer, maxLength, minimal) {
    maxLength = maxLength || 4;
    minimal = minimal === undefined ? true : minimal;
    const length = buffer.length;
    if (length === 0) return 0;
    if (length > maxLength) throw new TypeError('Script number overflow');
    if (minimal) {
      if ((buffer[length - 1] & 0x7f) === 0) {
        if (length <= 1 || (buffer[length - 2] & 0x80) === 0)
          throw new Error('Non-minimally encoded script number');
      }
    }
    // 40-bit
    if (length === 5) {
      const a = buffer.readUInt32LE(0);
      const b = buffer.readUInt8(4);
      if (b & 0x80) return -((b & ~0x80) * 0x100000000 + a);
      return b * 0x100000000 + a;
    }
    // 32-bit / 24-bit / 16-bit / 8-bit
    let result = 0;
    for (let i = 0; i < length; ++i) {
      result |= buffer[i] << (8 * i);
    }
    if (buffer[length - 1] & 0x80)
      return -(result & ~(0x80 << (8 * (length - 1))));
    return result;
  }
  exports.decode = decode;
  function scriptNumSize(i) {
    return i > 0x7fffffff
      ? 5
      : i > 0x7fffff
      ? 4
      : i > 0x7fff
      ? 3
      : i > 0x7f
      ? 2
      : i > 0x00
      ? 1
      : 0;
  }
  function encode(_number) {
    let value = Math.abs(_number);
    const size = scriptNumSize(value);
    const buffer = Buffer.allocUnsafe(size);
    const negative = _number < 0;
    for (let i = 0; i < size; ++i) {
      buffer.writeUInt8(value & 0xff, i);
      value >>= 8;
    }
    if (buffer[size - 1] & 0x80) {
      buffer.writeUInt8(negative ? 0x80 : 0x00, size - 1);
    } else if (negative) {
      buffer[size - 1] |= 0x80;
    }
    return buffer;
  }
  exports.encode = encode;
  
  }).call(this,require("buffer").Buffer)
  },{"buffer":3}],162:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const types = require('./types');
  const bip66 = require('bip66');
  const typeforce = require('typeforce');
  const ZERO = Buffer.alloc(1, 0);
  function toDER(x) {
    let i = 0;
    while (x[i] === 0) ++i;
    if (i === x.length) return ZERO;
    x = x.slice(i);
    if (x[0] & 0x80) return Buffer.concat([ZERO, x], 1 + x.length);
    return x;
  }
  function fromDER(x) {
    if (x[0] === 0x00) x = x.slice(1);
    const buffer = Buffer.alloc(32, 0);
    const bstart = Math.max(0, 32 - x.length);
    x.copy(buffer, bstart);
    return buffer;
  }
  // BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)
  function decode(buffer) {
    const hashType = buffer.readUInt8(buffer.length - 1);
    const hashTypeMod = hashType & ~0x80;
    if (hashTypeMod <= 0 || hashTypeMod >= 4)
      throw new Error('Invalid hashType ' + hashType);
    const decoded = bip66.decode(buffer.slice(0, -1));
    const r = fromDER(decoded.r);
    const s = fromDER(decoded.s);
    const signature = Buffer.concat([r, s], 64);
    return { signature, hashType };
  }
  exports.decode = decode;
  function encode(signature, hashType) {
    typeforce(
      {
        signature: types.BufferN(64),
        hashType: types.UInt8,
      },
      { signature, hashType },
    );
    const hashTypeMod = hashType & ~0x80;
    if (hashTypeMod <= 0 || hashTypeMod >= 4)
      throw new Error('Invalid hashType ' + hashType);
    const hashTypeBuffer = Buffer.allocUnsafe(1);
    hashTypeBuffer.writeUInt8(hashType, 0);
    const r = toDER(signature.slice(0, 32));
    const s = toDER(signature.slice(32, 64));
    return Buffer.concat([bip66.encode(r, s), hashTypeBuffer]);
  }
  exports.encode = encode;
  
  }).call(this,require("buffer").Buffer)
  },{"./types":186,"bip66":139,"buffer":3,"typeforce":271}],163:[function(require,module,exports){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const input = require('./input');
  exports.input = input;
  const output = require('./output');
  exports.output = output;
  
  },{"./input":164,"./output":165}],164:[function(require,module,exports){
  'use strict';
  // OP_0 [signatures ...]
  Object.defineProperty(exports, '__esModule', { value: true });
  const bscript = require('../../script');
  const script_1 = require('../../script');
  function partialSignature(value) {
    return (
      value === script_1.OPS.OP_0 || bscript.isCanonicalScriptSignature(value)
    );
  }
  function check(script, allowIncomplete) {
    const chunks = bscript.decompile(script);
    if (chunks.length < 2) return false;
    if (chunks[0] !== script_1.OPS.OP_0) return false;
    if (allowIncomplete) {
      return chunks.slice(1).every(partialSignature);
    }
    return chunks.slice(1).every(bscript.isCanonicalScriptSignature);
  }
  exports.check = check;
  check.toJSON = () => {
    return 'multisig input';
  };
  
  },{"../../script":160}],165:[function(require,module,exports){
  'use strict';
  // m [pubKeys ...] n OP_CHECKMULTISIG
  Object.defineProperty(exports, '__esModule', { value: true });
  const bscript = require('../../script');
  const script_1 = require('../../script');
  const types = require('../../types');
  const OP_INT_BASE = script_1.OPS.OP_RESERVED; // OP_1 - 1
  function check(script, allowIncomplete) {
    const chunks = bscript.decompile(script);
    if (chunks.length < 4) return false;
    if (chunks[chunks.length - 1] !== script_1.OPS.OP_CHECKMULTISIG) return false;
    if (!types.Number(chunks[0])) return false;
    if (!types.Number(chunks[chunks.length - 2])) return false;
    const m = chunks[0] - OP_INT_BASE;
    const n = chunks[chunks.length - 2] - OP_INT_BASE;
    if (m <= 0) return false;
    if (n > 16) return false;
    if (m > n) return false;
    if (n !== chunks.length - 3) return false;
    if (allowIncomplete) return true;
    const keys = chunks.slice(1, -2);
    return keys.every(bscript.isCanonicalPubKey);
  }
  exports.check = check;
  check.toJSON = () => {
    return 'multi-sig output';
  };
  
  },{"../../script":160,"../../types":186}],166:[function(require,module,exports){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  // OP_RETURN {data}
  const bscript = require('../script');
  const OPS = bscript.OPS;
  function check(script) {
    const buffer = bscript.compile(script);
    return buffer.length > 1 && buffer[0] === OPS.OP_RETURN;
  }
  exports.check = check;
  check.toJSON = () => {
    return 'null data output';
  };
  const output = { check };
  exports.output = output;
  
  },{"../script":160}],167:[function(require,module,exports){
  arguments[4][163][0].apply(exports,arguments)
  },{"./input":168,"./output":169,"dup":163}],168:[function(require,module,exports){
  'use strict';
  // {signature}
  Object.defineProperty(exports, '__esModule', { value: true });
  const bscript = require('../../script');
  function check(script) {
    const chunks = bscript.decompile(script);
    return chunks.length === 1 && bscript.isCanonicalScriptSignature(chunks[0]);
  }
  exports.check = check;
  check.toJSON = () => {
    return 'pubKey input';
  };
  
  },{"../../script":160}],169:[function(require,module,exports){
  'use strict';
  // {pubKey} OP_CHECKSIG
  Object.defineProperty(exports, '__esModule', { value: true });
  const bscript = require('../../script');
  const script_1 = require('../../script');
  function check(script) {
    const chunks = bscript.decompile(script);
    return (
      chunks.length === 2 &&
      bscript.isCanonicalPubKey(chunks[0]) &&
      chunks[1] === script_1.OPS.OP_CHECKSIG
    );
  }
  exports.check = check;
  check.toJSON = () => {
    return 'pubKey output';
  };
  
  },{"../../script":160}],170:[function(require,module,exports){
  arguments[4][163][0].apply(exports,arguments)
  },{"./input":171,"./output":172,"dup":163}],171:[function(require,module,exports){
  'use strict';
  // {signature} {pubKey}
  Object.defineProperty(exports, '__esModule', { value: true });
  const bscript = require('../../script');
  function check(script) {
    const chunks = bscript.decompile(script);
    return (
      chunks.length === 2 &&
      bscript.isCanonicalScriptSignature(chunks[0]) &&
      bscript.isCanonicalPubKey(chunks[1])
    );
  }
  exports.check = check;
  check.toJSON = () => {
    return 'pubKeyHash input';
  };
  
  },{"../../script":160}],172:[function(require,module,exports){
  'use strict';
  // OP_DUP OP_HASH160 {pubKeyHash} OP_EQUALVERIFY OP_CHECKSIG
  Object.defineProperty(exports, '__esModule', { value: true });
  const bscript = require('../../script');
  const script_1 = require('../../script');
  function check(script) {
    const buffer = bscript.compile(script);
    return (
      buffer.length === 25 &&
      buffer[0] === script_1.OPS.OP_DUP &&
      buffer[1] === script_1.OPS.OP_HASH160 &&
      buffer[2] === 0x14 &&
      buffer[23] === script_1.OPS.OP_EQUALVERIFY &&
      buffer[24] === script_1.OPS.OP_CHECKSIG
    );
  }
  exports.check = check;
  check.toJSON = () => {
    return 'pubKeyHash output';
  };
  
  },{"../../script":160}],173:[function(require,module,exports){
  arguments[4][163][0].apply(exports,arguments)
  },{"./input":174,"./output":175,"dup":163}],174:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  // <scriptSig> {serialized scriptPubKey script}
  Object.defineProperty(exports, '__esModule', { value: true });
  const bscript = require('../../script');
  const p2ms = require('../multisig');
  const p2pk = require('../pubkey');
  const p2pkh = require('../pubkeyhash');
  const p2wpkho = require('../witnesspubkeyhash/output');
  const p2wsho = require('../witnessscripthash/output');
  function check(script, allowIncomplete) {
    const chunks = bscript.decompile(script);
    if (chunks.length < 1) return false;
    const lastChunk = chunks[chunks.length - 1];
    if (!Buffer.isBuffer(lastChunk)) return false;
    const scriptSigChunks = bscript.decompile(
      bscript.compile(chunks.slice(0, -1)),
    );
    const redeemScriptChunks = bscript.decompile(lastChunk);
    // is redeemScript a valid script?
    if (!redeemScriptChunks) return false;
    // is redeemScriptSig push only?
    if (!bscript.isPushOnly(scriptSigChunks)) return false;
    // is witness?
    if (chunks.length === 1) {
      return (
        p2wsho.check(redeemScriptChunks) || p2wpkho.check(redeemScriptChunks)
      );
    }
    // match types
    if (
      p2pkh.input.check(scriptSigChunks) &&
      p2pkh.output.check(redeemScriptChunks)
    )
      return true;
    if (
      p2ms.input.check(scriptSigChunks, allowIncomplete) &&
      p2ms.output.check(redeemScriptChunks)
    )
      return true;
    if (
      p2pk.input.check(scriptSigChunks) &&
      p2pk.output.check(redeemScriptChunks)
    )
      return true;
    return false;
  }
  exports.check = check;
  check.toJSON = () => {
    return 'scriptHash input';
  };
  
  }).call(this,{"isBuffer":require("C:/Users/Johnny/AppData/Roaming/npm/node_modules/browserify/node_modules/is-buffer/index.js")})
  },{"../../script":160,"../multisig":163,"../pubkey":167,"../pubkeyhash":170,"../witnesspubkeyhash/output":180,"../witnessscripthash/output":183,"C:/Users/Johnny/AppData/Roaming/npm/node_modules/browserify/node_modules/is-buffer/index.js":8}],175:[function(require,module,exports){
  'use strict';
  // OP_HASH160 {scriptHash} OP_EQUAL
  Object.defineProperty(exports, '__esModule', { value: true });
  const bscript = require('../../script');
  const script_1 = require('../../script');
  function check(script) {
    const buffer = bscript.compile(script);
    return (
      buffer.length === 23 &&
      buffer[0] === script_1.OPS.OP_HASH160 &&
      buffer[1] === 0x14 &&
      buffer[22] === script_1.OPS.OP_EQUAL
    );
  }
  exports.check = check;
  check.toJSON = () => {
    return 'scriptHash output';
  };
  
  },{"../../script":160}],176:[function(require,module,exports){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const output = require('./output');
  exports.output = output;
  
  },{"./output":177}],177:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  // OP_RETURN {aa21a9ed} {commitment}
  Object.defineProperty(exports, '__esModule', { value: true });
  const bscript = require('../../script');
  const script_1 = require('../../script');
  const types = require('../../types');
  const typeforce = require('typeforce');
  const HEADER = Buffer.from('aa21a9ed', 'hex');
  function check(script) {
    const buffer = bscript.compile(script);
    return (
      buffer.length > 37 &&
      buffer[0] === script_1.OPS.OP_RETURN &&
      buffer[1] === 0x24 &&
      buffer.slice(2, 6).equals(HEADER)
    );
  }
  exports.check = check;
  check.toJSON = () => {
    return 'Witness commitment output';
  };
  function encode(commitment) {
    typeforce(types.Hash256bit, commitment);
    const buffer = Buffer.allocUnsafe(36);
    HEADER.copy(buffer, 0);
    commitment.copy(buffer, 4);
    return bscript.compile([script_1.OPS.OP_RETURN, buffer]);
  }
  exports.encode = encode;
  function decode(buffer) {
    typeforce(check, buffer);
    return bscript.decompile(buffer)[1].slice(4, 36);
  }
  exports.decode = decode;
  
  }).call(this,require("buffer").Buffer)
  },{"../../script":160,"../../types":186,"buffer":3,"typeforce":271}],178:[function(require,module,exports){
  arguments[4][163][0].apply(exports,arguments)
  },{"./input":179,"./output":180,"dup":163}],179:[function(require,module,exports){
  'use strict';
  // {signature} {pubKey}
  Object.defineProperty(exports, '__esModule', { value: true });
  const bscript = require('../../script');
  function isCompressedCanonicalPubKey(pubKey) {
    return bscript.isCanonicalPubKey(pubKey) && pubKey.length === 33;
  }
  function check(script) {
    const chunks = bscript.decompile(script);
    return (
      chunks.length === 2 &&
      bscript.isCanonicalScriptSignature(chunks[0]) &&
      isCompressedCanonicalPubKey(chunks[1])
    );
  }
  exports.check = check;
  check.toJSON = () => {
    return 'witnessPubKeyHash input';
  };
  
  },{"../../script":160}],180:[function(require,module,exports){
  'use strict';
  // OP_0 {pubKeyHash}
  Object.defineProperty(exports, '__esModule', { value: true });
  const bscript = require('../../script');
  const script_1 = require('../../script');
  function check(script) {
    const buffer = bscript.compile(script);
    return (
      buffer.length === 22 &&
      buffer[0] === script_1.OPS.OP_0 &&
      buffer[1] === 0x14
    );
  }
  exports.check = check;
  check.toJSON = () => {
    return 'Witness pubKeyHash output';
  };
  
  },{"../../script":160}],181:[function(require,module,exports){
  arguments[4][163][0].apply(exports,arguments)
  },{"./input":182,"./output":183,"dup":163}],182:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  // <scriptSig> {serialized scriptPubKey script}
  Object.defineProperty(exports, '__esModule', { value: true });
  const bscript = require('../../script');
  const typeforce = require('typeforce');
  const p2ms = require('../multisig');
  const p2pk = require('../pubkey');
  const p2pkh = require('../pubkeyhash');
  function check(chunks, allowIncomplete) {
    typeforce(typeforce.Array, chunks);
    if (chunks.length < 1) return false;
    const witnessScript = chunks[chunks.length - 1];
    if (!Buffer.isBuffer(witnessScript)) return false;
    const witnessScriptChunks = bscript.decompile(witnessScript);
    // is witnessScript a valid script?
    if (!witnessScriptChunks || witnessScriptChunks.length === 0) return false;
    const witnessRawScriptSig = bscript.compile(chunks.slice(0, -1));
    // match types
    if (
      p2pkh.input.check(witnessRawScriptSig) &&
      p2pkh.output.check(witnessScriptChunks)
    )
      return true;
    if (
      p2ms.input.check(witnessRawScriptSig, allowIncomplete) &&
      p2ms.output.check(witnessScriptChunks)
    )
      return true;
    if (
      p2pk.input.check(witnessRawScriptSig) &&
      p2pk.output.check(witnessScriptChunks)
    )
      return true;
    return false;
  }
  exports.check = check;
  check.toJSON = () => {
    return 'witnessScriptHash input';
  };
  
  }).call(this,{"isBuffer":require("C:/Users/Johnny/AppData/Roaming/npm/node_modules/browserify/node_modules/is-buffer/index.js")})
  },{"../../script":160,"../multisig":163,"../pubkey":167,"../pubkeyhash":170,"C:/Users/Johnny/AppData/Roaming/npm/node_modules/browserify/node_modules/is-buffer/index.js":8,"typeforce":271}],183:[function(require,module,exports){
  'use strict';
  // OP_0 {scriptHash}
  Object.defineProperty(exports, '__esModule', { value: true });
  const bscript = require('../../script');
  const script_1 = require('../../script');
  function check(script) {
    const buffer = bscript.compile(script);
    return (
      buffer.length === 34 &&
      buffer[0] === script_1.OPS.OP_0 &&
      buffer[1] === 0x20
    );
  }
  exports.check = check;
  check.toJSON = () => {
    return 'Witness scriptHash output';
  };
  
  },{"../../script":160}],184:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const bufferutils = require('./bufferutils');
  const bufferutils_1 = require('./bufferutils');
  const bcrypto = require('./crypto');
  const bscript = require('./script');
  const script_1 = require('./script');
  const types = require('./types');
  const typeforce = require('typeforce');
  const varuint = require('varuint-bitcoin');
  function varSliceSize(someScript) {
    const length = someScript.length;
    return varuint.encodingLength(length) + length;
  }
  function vectorSize(someVector) {
    const length = someVector.length;
    return (
      varuint.encodingLength(length) +
      someVector.reduce((sum, witness) => {
        return sum + varSliceSize(witness);
      }, 0)
    );
  }
  const EMPTY_SCRIPT = Buffer.allocUnsafe(0);
  const EMPTY_WITNESS = [];
  const ZERO = Buffer.from(
    '0000000000000000000000000000000000000000000000000000000000000000',
    'hex',
  );
  const ONE = Buffer.from(
    '0000000000000000000000000000000000000000000000000000000000000001',
    'hex',
  );
  const VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex');
  const BLANK_OUTPUT = {
    script: EMPTY_SCRIPT,
    valueBuffer: VALUE_UINT64_MAX,
  };
  function isOutput(out) {
    return out.value !== undefined;
  }
  class Transaction {
    constructor() {
      this.version = 1;
      this.locktime = 0;
      this.ins = [];
      this.outs = [];
    }
    static fromBuffer(buffer, _NO_STRICT) {
      let offset = 0;
      function readSlice(n) {
        offset += n;
        return buffer.slice(offset - n, offset);
      }
      function readUInt32() {
        const i = buffer.readUInt32LE(offset);
        offset += 4;
        return i;
      }
      function readInt32() {
        const i = buffer.readInt32LE(offset);
        offset += 4;
        return i;
      }
      function readUInt64() {
        const i = bufferutils.readUInt64LE(buffer, offset);
        offset += 8;
        return i;
      }
      function readVarInt() {
        const vi = varuint.decode(buffer, offset);
        offset += varuint.decode.bytes;
        return vi;
      }
      function readVarSlice() {
        return readSlice(readVarInt());
      }
      function readVector() {
        const count = readVarInt();
        const vector = [];
        for (let i = 0; i < count; i++) vector.push(readVarSlice());
        return vector;
      }
      const tx = new Transaction();
      tx.version = readInt32();
      const marker = buffer.readUInt8(offset);
      const flag = buffer.readUInt8(offset + 1);
      let hasWitnesses = false;
      if (
        marker === Transaction.ADVANCED_TRANSACTION_MARKER &&
        flag === Transaction.ADVANCED_TRANSACTION_FLAG
      ) {
        offset += 2;
        hasWitnesses = true;
      }
      const vinLen = readVarInt();
      for (let i = 0; i < vinLen; ++i) {
        tx.ins.push({
          hash: readSlice(32),
          index: readUInt32(),
          script: readVarSlice(),
          sequence: readUInt32(),
          witness: EMPTY_WITNESS,
        });
      }
      const voutLen = readVarInt();
      for (let i = 0; i < voutLen; ++i) {
        tx.outs.push({
          value: readUInt64(),
          script: readVarSlice(),
        });
      }
      if (hasWitnesses) {
        for (let i = 0; i < vinLen; ++i) {
          tx.ins[i].witness = readVector();
        }
        // was this pointless?
        if (!tx.hasWitnesses())
          throw new Error('Transaction has superfluous witness data');
      }
      tx.locktime = readUInt32();
      if (_NO_STRICT) return tx;
      if (offset !== buffer.length)
        throw new Error('Transaction has unexpected data');
      return tx;
    }
    static fromHex(hex) {
      return Transaction.fromBuffer(Buffer.from(hex, 'hex'), false);
    }
    static isCoinbaseHash(buffer) {
      typeforce(types.Hash256bit, buffer);
      for (let i = 0; i < 32; ++i) {
        if (buffer[i] !== 0) return false;
      }
      return true;
    }
    isCoinbase() {
      return (
        this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash)
      );
    }
    addInput(hash, index, sequence, scriptSig) {
      typeforce(
        types.tuple(
          types.Hash256bit,
          types.UInt32,
          types.maybe(types.UInt32),
          types.maybe(types.Buffer),
        ),
        arguments,
      );
      if (types.Null(sequence)) {
        sequence = Transaction.DEFAULT_SEQUENCE;
      }
      // Add the input and return the input's index
      return (
        this.ins.push({
          hash,
          index,
          script: scriptSig || EMPTY_SCRIPT,
          sequence: sequence,
          witness: EMPTY_WITNESS,
        }) - 1
      );
    }
    addOutput(scriptPubKey, value) {
      typeforce(types.tuple(types.Buffer, types.Satoshi), arguments);
      // Add the output and return the output's index
      return (
        this.outs.push({
          script: scriptPubKey,
          value,
        }) - 1
      );
    }
    hasWitnesses() {
      return this.ins.some(x => {
        return x.witness.length !== 0;
      });
    }
    weight() {
      const base = this.byteLength(false);
      const total = this.byteLength(true);
      return base * 3 + total;
    }
    virtualSize() {
      return Math.ceil(this.weight() / 4);
    }
    byteLength(_ALLOW_WITNESS = true) {
      const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
      return (
        (hasWitnesses ? 10 : 8) +
        varuint.encodingLength(this.ins.length) +
        varuint.encodingLength(this.outs.length) +
        this.ins.reduce((sum, input) => {
          return sum + 40 + varSliceSize(input.script);
        }, 0) +
        this.outs.reduce((sum, output) => {
          return sum + 8 + varSliceSize(output.script);
        }, 0) +
        (hasWitnesses
          ? this.ins.reduce((sum, input) => {
              return sum + vectorSize(input.witness);
            }, 0)
          : 0)
      );
    }
    clone() {
      const newTx = new Transaction();
      newTx.version = this.version;
      newTx.locktime = this.locktime;
      newTx.ins = this.ins.map(txIn => {
        return {
          hash: txIn.hash,
          index: txIn.index,
          script: txIn.script,
          sequence: txIn.sequence,
          witness: txIn.witness,
        };
      });
      newTx.outs = this.outs.map(txOut => {
        return {
          script: txOut.script,
          value: txOut.value,
        };
      });
      return newTx;
    }
    /**
     * Hash transaction for signing a specific input.
     *
     * Bitcoin uses a different hash for each signed transaction input.
     * This method copies the transaction, makes the necessary changes based on the
     * hashType, and then hashes the result.
     * This hash can then be used to sign the provided transaction input.
     */
    hashForSignature(inIndex, prevOutScript, hashType) {
      typeforce(
        types.tuple(types.UInt32, types.Buffer, /* types.UInt8 */ types.Number),
        arguments,
      );
      // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29
      if (inIndex >= this.ins.length) return ONE;
      // ignore OP_CODESEPARATOR
      const ourScript = bscript.compile(
        bscript.decompile(prevOutScript).filter(x => {
          return x !== script_1.OPS.OP_CODESEPARATOR;
        }),
      );
      const txTmp = this.clone();
      // SIGHASH_NONE: ignore all outputs? (wildcard payee)
      if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {
        txTmp.outs = [];
        // ignore sequence numbers (except at inIndex)
        txTmp.ins.forEach((input, i) => {
          if (i === inIndex) return;
          input.sequence = 0;
        });
        // SIGHASH_SINGLE: ignore all outputs, except at the same index?
      } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {
        // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60
        if (inIndex >= this.outs.length) return ONE;
        // truncate outputs after
        txTmp.outs.length = inIndex + 1;
        // "blank" outputs before
        for (let i = 0; i < inIndex; i++) {
          txTmp.outs[i] = BLANK_OUTPUT;
        }
        // ignore sequence numbers (except at inIndex)
        txTmp.ins.forEach((input, y) => {
          if (y === inIndex) return;
          input.sequence = 0;
        });
      }
      // SIGHASH_ANYONECANPAY: ignore inputs entirely?
      if (hashType & Transaction.SIGHASH_ANYONECANPAY) {
        txTmp.ins = [txTmp.ins[inIndex]];
        txTmp.ins[0].script = ourScript;
        // SIGHASH_ALL: only ignore input scripts
      } else {
        // "blank" others input scripts
        txTmp.ins.forEach(input => {
          input.script = EMPTY_SCRIPT;
        });
        txTmp.ins[inIndex].script = ourScript;
      }
      // serialize and hash
      const buffer = Buffer.allocUnsafe(txTmp.byteLength(false) + 4);
      buffer.writeInt32LE(hashType, buffer.length - 4);
      txTmp.__toBuffer(buffer, 0, false);
      return bcrypto.hash256(buffer);
    }
    hashForWitnessV0(inIndex, prevOutScript, value, hashType) {
      typeforce(
        types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32),
        arguments,
      );
      let tbuffer = Buffer.from([]);
      let toffset = 0;
      function writeSlice(slice) {
        toffset += slice.copy(tbuffer, toffset);
      }
      function writeUInt32(i) {
        toffset = tbuffer.writeUInt32LE(i, toffset);
      }
      function writeUInt64(i) {
        toffset = bufferutils.writeUInt64LE(tbuffer, i, toffset);
      }
      function writeVarInt(i) {
        varuint.encode(i, tbuffer, toffset);
        toffset += varuint.encode.bytes;
      }
      function writeVarSlice(slice) {
        writeVarInt(slice.length);
        writeSlice(slice);
      }
      let hashOutputs = ZERO;
      let hashPrevouts = ZERO;
      let hashSequence = ZERO;
      if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {
        tbuffer = Buffer.allocUnsafe(36 * this.ins.length);
        toffset = 0;
        this.ins.forEach(txIn => {
          writeSlice(txIn.hash);
          writeUInt32(txIn.index);
        });
        hashPrevouts = bcrypto.hash256(tbuffer);
      }
      if (
        !(hashType & Transaction.SIGHASH_ANYONECANPAY) &&
        (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&
        (hashType & 0x1f) !== Transaction.SIGHASH_NONE
      ) {
        tbuffer = Buffer.allocUnsafe(4 * this.ins.length);
        toffset = 0;
        this.ins.forEach(txIn => {
          writeUInt32(txIn.sequence);
        });
        hashSequence = bcrypto.hash256(tbuffer);
      }
      if (
        (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&
        (hashType & 0x1f) !== Transaction.SIGHASH_NONE
      ) {
        const txOutsSize = this.outs.reduce((sum, output) => {
          return sum + 8 + varSliceSize(output.script);
        }, 0);
        tbuffer = Buffer.allocUnsafe(txOutsSize);
        toffset = 0;
        this.outs.forEach(out => {
          writeUInt64(out.value);
          writeVarSlice(out.script);
        });
        hashOutputs = bcrypto.hash256(tbuffer);
      } else if (
        (hashType & 0x1f) === Transaction.SIGHASH_SINGLE &&
        inIndex < this.outs.length
      ) {
        const output = this.outs[inIndex];
        tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));
        toffset = 0;
        writeUInt64(output.value);
        writeVarSlice(output.script);
        hashOutputs = bcrypto.hash256(tbuffer);
      }
      tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));
      toffset = 0;
      const input = this.ins[inIndex];
      writeUInt32(this.version);
      writeSlice(hashPrevouts);
      writeSlice(hashSequence);
      writeSlice(input.hash);
      writeUInt32(input.index);
      writeVarSlice(prevOutScript);
      writeUInt64(value);
      writeUInt32(input.sequence);
      writeSlice(hashOutputs);
      writeUInt32(this.locktime);
      writeUInt32(hashType);
      return bcrypto.hash256(tbuffer);
    }
    getHash(forWitness) {
      // wtxid for coinbase is always 32 bytes of 0x00
      if (forWitness && this.isCoinbase()) return Buffer.alloc(32, 0);
      return bcrypto.hash256(this.__toBuffer(undefined, undefined, forWitness));
    }
    getId() {
      // transaction hash's are displayed in reverse order
      return bufferutils_1.reverseBuffer(this.getHash(false)).toString('hex');
    }
    toBuffer(buffer, initialOffset) {
      return this.__toBuffer(buffer, initialOffset, true);
    }
    toHex() {
      return this.toBuffer(undefined, undefined).toString('hex');
    }
    setInputScript(index, scriptSig) {
      typeforce(types.tuple(types.Number, types.Buffer), arguments);
      this.ins[index].script = scriptSig;
    }
    setWitness(index, witness) {
      typeforce(types.tuple(types.Number, [types.Buffer]), arguments);
      this.ins[index].witness = witness;
    }
    __toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {
      if (!buffer) buffer = Buffer.allocUnsafe(this.byteLength(_ALLOW_WITNESS));
      let offset = initialOffset || 0;
      function writeSlice(slice) {
        offset += slice.copy(buffer, offset);
      }
      function writeUInt8(i) {
        offset = buffer.writeUInt8(i, offset);
      }
      function writeUInt32(i) {
        offset = buffer.writeUInt32LE(i, offset);
      }
      function writeInt32(i) {
        offset = buffer.writeInt32LE(i, offset);
      }
      function writeUInt64(i) {
        offset = bufferutils.writeUInt64LE(buffer, i, offset);
      }
      function writeVarInt(i) {
        varuint.encode(i, buffer, offset);
        offset += varuint.encode.bytes;
      }
      function writeVarSlice(slice) {
        writeVarInt(slice.length);
        writeSlice(slice);
      }
      function writeVector(vector) {
        writeVarInt(vector.length);
        vector.forEach(writeVarSlice);
      }
      writeInt32(this.version);
      const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
      if (hasWitnesses) {
        writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);
        writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);
      }
      writeVarInt(this.ins.length);
      this.ins.forEach(txIn => {
        writeSlice(txIn.hash);
        writeUInt32(txIn.index);
        writeVarSlice(txIn.script);
        writeUInt32(txIn.sequence);
      });
      writeVarInt(this.outs.length);
      this.outs.forEach(txOut => {
        if (isOutput(txOut)) {
          writeUInt64(txOut.value);
        } else {
          writeSlice(txOut.valueBuffer);
        }
        writeVarSlice(txOut.script);
      });
      if (hasWitnesses) {
        this.ins.forEach(input => {
          writeVector(input.witness);
        });
      }
      writeUInt32(this.locktime);
      // avoid slicing unless necessary
      if (initialOffset !== undefined) return buffer.slice(initialOffset, offset);
      return buffer;
    }
  }
  Transaction.DEFAULT_SEQUENCE = 0xffffffff;
  Transaction.SIGHASH_ALL = 0x01;
  Transaction.SIGHASH_NONE = 0x02;
  Transaction.SIGHASH_SINGLE = 0x03;
  Transaction.SIGHASH_ANYONECANPAY = 0x80;
  Transaction.ADVANCED_TRANSACTION_MARKER = 0x00;
  Transaction.ADVANCED_TRANSACTION_FLAG = 0x01;
  exports.Transaction = Transaction;
  
  }).call(this,require("buffer").Buffer)
  },{"./bufferutils":144,"./crypto":146,"./script":160,"./types":186,"buffer":3,"typeforce":271,"varuint-bitcoin":273}],185:[function(require,module,exports){
  (function (Buffer){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const baddress = require('./address');
  const bufferutils_1 = require('./bufferutils');
  const classify = require('./classify');
  const bcrypto = require('./crypto');
  const ECPair = require('./ecpair');
  const networks = require('./networks');
  const payments = require('./payments');
  const bscript = require('./script');
  const script_1 = require('./script');
  const transaction_1 = require('./transaction');
  const types = require('./types');
  const typeforce = require('typeforce');
  const SCRIPT_TYPES = classify.types;
  const PREVOUT_TYPES = new Set([
    // Raw
    'p2pkh',
    'p2pk',
    'p2wpkh',
    'p2ms',
    // P2SH wrapped
    'p2sh-p2pkh',
    'p2sh-p2pk',
    'p2sh-p2wpkh',
    'p2sh-p2ms',
    // P2WSH wrapped
    'p2wsh-p2pkh',
    'p2wsh-p2pk',
    'p2wsh-p2ms',
    // P2SH-P2WSH wrapper
    'p2sh-p2wsh-p2pkh',
    'p2sh-p2wsh-p2pk',
    'p2sh-p2wsh-p2ms',
  ]);
  function tfMessage(type, value, message) {
    try {
      typeforce(type, value);
    } catch (err) {
      throw new Error(message);
    }
  }
  function txIsString(tx) {
    return typeof tx === 'string' || tx instanceof String;
  }
  function txIsTransaction(tx) {
    return tx instanceof transaction_1.Transaction;
  }
  class TransactionBuilder {
    // WARNING: maximumFeeRate is __NOT__ to be relied on,
    //          it's just another potential safety mechanism (safety in-depth)
    constructor(network = networks.bitcoin, maximumFeeRate = 2500) {
      this.network = network;
      this.maximumFeeRate = maximumFeeRate;
      this.__PREV_TX_SET = {};
      this.__INPUTS = [];
      this.__TX = new transaction_1.Transaction();
      this.__TX.version = 2;
      this.__USE_LOW_R = false;
      console.warn(
        'Deprecation Warning: TransactionBuilder will be removed in the future. ' +
          '(v6.x.x or later) Please use the Psbt class instead. Examples of usage ' +
          'are available in the transactions-psbt.js integration test file on our ' +
          'Github. A high level explanation is available in the psbt.ts and psbt.js ' +
          'files as well.',
      );
    }
    static fromTransaction(transaction, network) {
      const txb = new TransactionBuilder(network);
      // Copy transaction fields
      txb.setVersion(transaction.version);
      txb.setLockTime(transaction.locktime);
      // Copy outputs (done first to avoid signature invalidation)
      transaction.outs.forEach(txOut => {
        txb.addOutput(txOut.script, txOut.value);
      });
      // Copy inputs
      transaction.ins.forEach(txIn => {
        txb.__addInputUnsafe(txIn.hash, txIn.index, {
          sequence: txIn.sequence,
          script: txIn.script,
          witness: txIn.witness,
        });
      });
      // fix some things not possible through the public API
      txb.__INPUTS.forEach((input, i) => {
        fixMultisigOrder(input, transaction, i);
      });
      return txb;
    }
    setLowR(setting) {
      typeforce(typeforce.maybe(typeforce.Boolean), setting);
      if (setting === undefined) {
        setting = true;
      }
      this.__USE_LOW_R = setting;
      return setting;
    }
    setLockTime(locktime) {
      typeforce(types.UInt32, locktime);
      // if any signatures exist, throw
      if (
        this.__INPUTS.some(input => {
          if (!input.signatures) return false;
          return input.signatures.some(s => s !== undefined);
        })
      ) {
        throw new Error('No, this would invalidate signatures');
      }
      this.__TX.locktime = locktime;
    }
    setVersion(version) {
      typeforce(types.UInt32, version);
      // XXX: this might eventually become more complex depending on what the versions represent
      this.__TX.version = version;
    }
    addInput(txHash, vout, sequence, prevOutScript) {
      if (!this.__canModifyInputs()) {
        throw new Error('No, this would invalidate signatures');
      }
      let value;
      // is it a hex string?
      if (txIsString(txHash)) {
        // transaction hashs's are displayed in reverse order, un-reverse it
        txHash = bufferutils_1.reverseBuffer(Buffer.from(txHash, 'hex'));
        // is it a Transaction object?
      } else if (txIsTransaction(txHash)) {
        const txOut = txHash.outs[vout];
        prevOutScript = txOut.script;
        value = txOut.value;
        txHash = txHash.getHash(false);
      }
      return this.__addInputUnsafe(txHash, vout, {
        sequence,
        prevOutScript,
        value,
      });
    }
    addOutput(scriptPubKey, value) {
      if (!this.__canModifyOutputs()) {
        throw new Error('No, this would invalidate signatures');
      }
      // Attempt to get a script if it's a base58 or bech32 address string
      if (typeof scriptPubKey === 'string') {
        scriptPubKey = baddress.toOutputScript(scriptPubKey, this.network);
      }
      return this.__TX.addOutput(scriptPubKey, value);
    }
    build() {
      return this.__build(false);
    }
    buildIncomplete() {
      return this.__build(true);
    }
    sign(
      signParams,
      keyPair,
      redeemScript,
      hashType,
      witnessValue,
      witnessScript,
    ) {
      trySign(
        getSigningData(
          this.network,
          this.__INPUTS,
          this.__needsOutputs.bind(this),
          this.__TX,
          signParams,
          keyPair,
          redeemScript,
          hashType,
          witnessValue,
          witnessScript,
          this.__USE_LOW_R,
        ),
      );
    }
    __addInputUnsafe(txHash, vout, options) {
      if (transaction_1.Transaction.isCoinbaseHash(txHash)) {
        throw new Error('coinbase inputs not supported');
      }
      const prevTxOut = txHash.toString('hex') + ':' + vout;
      if (this.__PREV_TX_SET[prevTxOut] !== undefined)
        throw new Error('Duplicate TxOut: ' + prevTxOut);
      let input = {};
      // derive what we can from the scriptSig
      if (options.script !== undefined) {
        input = expandInput(options.script, options.witness || []);
      }
      // if an input value was given, retain it
      if (options.value !== undefined) {
        input.value = options.value;
      }
      // derive what we can from the previous transactions output script
      if (!input.prevOutScript && options.prevOutScript) {
        let prevOutType;
        if (!input.pubkeys && !input.signatures) {
          const expanded = expandOutput(options.prevOutScript);
          if (expanded.pubkeys) {
            input.pubkeys = expanded.pubkeys;
            input.signatures = expanded.signatures;
          }
          prevOutType = expanded.type;
        }
        input.prevOutScript = options.prevOutScript;
        input.prevOutType = prevOutType || classify.output(options.prevOutScript);
      }
      const vin = this.__TX.addInput(
        txHash,
        vout,
        options.sequence,
        options.scriptSig,
      );
      this.__INPUTS[vin] = input;
      this.__PREV_TX_SET[prevTxOut] = true;
      return vin;
    }
    __build(allowIncomplete) {
      if (!allowIncomplete) {
        if (!this.__TX.ins.length) throw new Error('Transaction has no inputs');
        if (!this.__TX.outs.length) throw new Error('Transaction has no outputs');
      }
      const tx = this.__TX.clone();
      // create script signatures from inputs
      this.__INPUTS.forEach((input, i) => {
        if (!input.prevOutType && !allowIncomplete)
          throw new Error('Transaction is not complete');
        const result = build(input.prevOutType, input, allowIncomplete);
        if (!result) {
          if (!allowIncomplete && input.prevOutType === SCRIPT_TYPES.NONSTANDARD)
            throw new Error('Unknown input type');
          if (!allowIncomplete) throw new Error('Not enough information');
          return;
        }
        tx.setInputScript(i, result.input);
        tx.setWitness(i, result.witness);
      });
      if (!allowIncomplete) {
        // do not rely on this, its merely a last resort
        if (this.__overMaximumFees(tx.virtualSize())) {
          throw new Error('Transaction has absurd fees');
        }
      }
      return tx;
    }
    __canModifyInputs() {
      return this.__INPUTS.every(input => {
        if (!input.signatures) return true;
        return input.signatures.every(signature => {
          if (!signature) return true;
          const hashType = signatureHashType(signature);
          // if SIGHASH_ANYONECANPAY is set, signatures would not
          // be invalidated by more inputs
          return (
            (hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY) !== 0
          );
        });
      });
    }
    __needsOutputs(signingHashType) {
      if (signingHashType === transaction_1.Transaction.SIGHASH_ALL) {
        return this.__TX.outs.length === 0;
      }
      // if inputs are being signed with SIGHASH_NONE, we don't strictly need outputs
      // .build() will fail, but .buildIncomplete() is OK
      return (
        this.__TX.outs.length === 0 &&
        this.__INPUTS.some(input => {
          if (!input.signatures) return false;
          return input.signatures.some(signature => {
            if (!signature) return false; // no signature, no issue
            const hashType = signatureHashType(signature);
            if (hashType & transaction_1.Transaction.SIGHASH_NONE) return false; // SIGHASH_NONE doesn't care about outputs
            return true; // SIGHASH_* does care
          });
        })
      );
    }
    __canModifyOutputs() {
      const nInputs = this.__TX.ins.length;
      const nOutputs = this.__TX.outs.length;
      return this.__INPUTS.every(input => {
        if (input.signatures === undefined) return true;
        return input.signatures.every(signature => {
          if (!signature) return true;
          const hashType = signatureHashType(signature);
          const hashTypeMod = hashType & 0x1f;
          if (hashTypeMod === transaction_1.Transaction.SIGHASH_NONE) return true;
          if (hashTypeMod === transaction_1.Transaction.SIGHASH_SINGLE) {
            // if SIGHASH_SINGLE is set, and nInputs > nOutputs
            // some signatures would be invalidated by the addition
            // of more outputs
            return nInputs <= nOutputs;
          }
          return false;
        });
      });
    }
    __overMaximumFees(bytes) {
      // not all inputs will have .value defined
      const incoming = this.__INPUTS.reduce((a, x) => a + (x.value >>> 0), 0);
      // but all outputs do, and if we have any input value
      // we can immediately determine if the outputs are too small
      const outgoing = this.__TX.outs.reduce((a, x) => a + x.value, 0);
      const fee = incoming - outgoing;
      const feeRate = fee / bytes;
      return feeRate > this.maximumFeeRate;
    }
  }
  exports.TransactionBuilder = TransactionBuilder;
  function expandInput(scriptSig, witnessStack, type, scriptPubKey) {
    if (scriptSig.length === 0 && witnessStack.length === 0) return {};
    if (!type) {
      let ssType = classify.input(scriptSig, true);
      let wsType = classify.witness(witnessStack, true);
      if (ssType === SCRIPT_TYPES.NONSTANDARD) ssType = undefined;
      if (wsType === SCRIPT_TYPES.NONSTANDARD) wsType = undefined;
      type = ssType || wsType;
    }
    switch (type) {
      case SCRIPT_TYPES.P2WPKH: {
        const { output, pubkey, signature } = payments.p2wpkh({
          witness: witnessStack,
        });
        return {
          prevOutScript: output,
          prevOutType: SCRIPT_TYPES.P2WPKH,
          pubkeys: [pubkey],
          signatures: [signature],
        };
      }
      case SCRIPT_TYPES.P2PKH: {
        const { output, pubkey, signature } = payments.p2pkh({
          input: scriptSig,
        });
        return {
          prevOutScript: output,
          prevOutType: SCRIPT_TYPES.P2PKH,
          pubkeys: [pubkey],
          signatures: [signature],
        };
      }
      case SCRIPT_TYPES.P2PK: {
        const { signature } = payments.p2pk({ input: scriptSig });
        return {
          prevOutType: SCRIPT_TYPES.P2PK,
          pubkeys: [undefined],
          signatures: [signature],
        };
      }
      case SCRIPT_TYPES.P2MS: {
        const { m, pubkeys, signatures } = payments.p2ms(
          {
            input: scriptSig,
            output: scriptPubKey,
          },
          { allowIncomplete: true },
        );
        return {
          prevOutType: SCRIPT_TYPES.P2MS,
          pubkeys,
          signatures,
          maxSignatures: m,
        };
      }
    }
    if (type === SCRIPT_TYPES.P2SH) {
      const { output, redeem } = payments.p2sh({
        input: scriptSig,
        witness: witnessStack,
      });
      const outputType = classify.output(redeem.output);
      const expanded = expandInput(
        redeem.input,
        redeem.witness,
        outputType,
        redeem.output,
      );
      if (!expanded.prevOutType) return {};
      return {
        prevOutScript: output,
        prevOutType: SCRIPT_TYPES.P2SH,
        redeemScript: redeem.output,
        redeemScriptType: expanded.prevOutType,
        witnessScript: expanded.witnessScript,
        witnessScriptType: expanded.witnessScriptType,
        pubkeys: expanded.pubkeys,
        signatures: expanded.signatures,
      };
    }
    if (type === SCRIPT_TYPES.P2WSH) {
      const { output, redeem } = payments.p2wsh({
        input: scriptSig,
        witness: witnessStack,
      });
      const outputType = classify.output(redeem.output);
      let expanded;
      if (outputType === SCRIPT_TYPES.P2WPKH) {
        expanded = expandInput(redeem.input, redeem.witness, outputType);
      } else {
        expanded = expandInput(
          bscript.compile(redeem.witness),
          [],
          outputType,
          redeem.output,
        );
      }
      if (!expanded.prevOutType) return {};
      return {
        prevOutScript: output,
        prevOutType: SCRIPT_TYPES.P2WSH,
        witnessScript: redeem.output,
        witnessScriptType: expanded.prevOutType,
        pubkeys: expanded.pubkeys,
        signatures: expanded.signatures,
      };
    }
    return {
      prevOutType: SCRIPT_TYPES.NONSTANDARD,
      prevOutScript: scriptSig,
    };
  }
  // could be done in expandInput, but requires the original Transaction for hashForSignature
  function fixMultisigOrder(input, transaction, vin) {
    if (input.redeemScriptType !== SCRIPT_TYPES.P2MS || !input.redeemScript)
      return;
    if (input.pubkeys.length === input.signatures.length) return;
    const unmatched = input.signatures.concat();
    input.signatures = input.pubkeys.map(pubKey => {
      const keyPair = ECPair.fromPublicKey(pubKey);
      let match;
      // check for a signature
      unmatched.some((signature, i) => {
        // skip if undefined || OP_0
        if (!signature) return false;
        // TODO: avoid O(n) hashForSignature
        const parsed = bscript.signature.decode(signature);
        const hash = transaction.hashForSignature(
          vin,
          input.redeemScript,
          parsed.hashType,
        );
        // skip if signature does not match pubKey
        if (!keyPair.verify(hash, parsed.signature)) return false;
        // remove matched signature from unmatched
        unmatched[i] = undefined;
        match = signature;
        return true;
      });
      return match;
    });
  }
  function expandOutput(script, ourPubKey) {
    typeforce(types.Buffer, script);
    const type = classify.output(script);
    switch (type) {
      case SCRIPT_TYPES.P2PKH: {
        if (!ourPubKey) return { type };
        // does our hash160(pubKey) match the output scripts?
        const pkh1 = payments.p2pkh({ output: script }).hash;
        const pkh2 = bcrypto.hash160(ourPubKey);
        if (!pkh1.equals(pkh2)) return { type };
        return {
          type,
          pubkeys: [ourPubKey],
          signatures: [undefined],
        };
      }
      case SCRIPT_TYPES.P2WPKH: {
        if (!ourPubKey) return { type };
        // does our hash160(pubKey) match the output scripts?
        const wpkh1 = payments.p2wpkh({ output: script }).hash;
        const wpkh2 = bcrypto.hash160(ourPubKey);
        if (!wpkh1.equals(wpkh2)) return { type };
        return {
          type,
          pubkeys: [ourPubKey],
          signatures: [undefined],
        };
      }
      case SCRIPT_TYPES.P2PK: {
        const p2pk = payments.p2pk({ output: script });
        return {
          type,
          pubkeys: [p2pk.pubkey],
          signatures: [undefined],
        };
      }
      case SCRIPT_TYPES.P2MS: {
        const p2ms = payments.p2ms({ output: script });
        return {
          type,
          pubkeys: p2ms.pubkeys,
          signatures: p2ms.pubkeys.map(() => undefined),
          maxSignatures: p2ms.m,
        };
      }
    }
    return { type };
  }
  function prepareInput(input, ourPubKey, redeemScript, witnessScript) {
    if (redeemScript && witnessScript) {
      const p2wsh = payments.p2wsh({
        redeem: { output: witnessScript },
      });
      const p2wshAlt = payments.p2wsh({ output: redeemScript });
      const p2sh = payments.p2sh({ redeem: { output: redeemScript } });
      const p2shAlt = payments.p2sh({ redeem: p2wsh });
      // enforces P2SH(P2WSH(...))
      if (!p2wsh.hash.equals(p2wshAlt.hash))
        throw new Error('Witness script inconsistent with prevOutScript');
      if (!p2sh.hash.equals(p2shAlt.hash))
        throw new Error('Redeem script inconsistent with prevOutScript');
      const expanded = expandOutput(p2wsh.redeem.output, ourPubKey);
      if (!expanded.pubkeys)
        throw new Error(
          expanded.type +
            ' not supported as witnessScript (' +
            bscript.toASM(witnessScript) +
            ')',
        );
      if (input.signatures && input.signatures.some(x => x !== undefined)) {
        expanded.signatures = input.signatures;
      }
      const signScript = witnessScript;
      if (expanded.type === SCRIPT_TYPES.P2WPKH)
        throw new Error('P2SH(P2WSH(P2WPKH)) is a consensus failure');
      return {
        redeemScript,
        redeemScriptType: SCRIPT_TYPES.P2WSH,
        witnessScript,
        witnessScriptType: expanded.type,
        prevOutType: SCRIPT_TYPES.P2SH,
        prevOutScript: p2sh.output,
        hasWitness: true,
        signScript,
        signType: expanded.type,
        pubkeys: expanded.pubkeys,
        signatures: expanded.signatures,
        maxSignatures: expanded.maxSignatures,
      };
    }
    if (redeemScript) {
      const p2sh = payments.p2sh({ redeem: { output: redeemScript } });
      if (input.prevOutScript) {
        let p2shAlt;
        try {
          p2shAlt = payments.p2sh({ output: input.prevOutScript });
        } catch (e) {
          throw new Error('PrevOutScript must be P2SH');
        }
        if (!p2sh.hash.equals(p2shAlt.hash))
          throw new Error('Redeem script inconsistent with prevOutScript');
      }
      const expanded = expandOutput(p2sh.redeem.output, ourPubKey);
      if (!expanded.pubkeys)
        throw new Error(
          expanded.type +
            ' not supported as redeemScript (' +
            bscript.toASM(redeemScript) +
            ')',
        );
      if (input.signatures && input.signatures.some(x => x !== undefined)) {
        expanded.signatures = input.signatures;
      }
      let signScript = redeemScript;
      if (expanded.type === SCRIPT_TYPES.P2WPKH) {
        signScript = payments.p2pkh({ pubkey: expanded.pubkeys[0] }).output;
      }
      return {
        redeemScript,
        redeemScriptType: expanded.type,
        prevOutType: SCRIPT_TYPES.P2SH,
        prevOutScript: p2sh.output,
        hasWitness: expanded.type === SCRIPT_TYPES.P2WPKH,
        signScript,
        signType: expanded.type,
        pubkeys: expanded.pubkeys,
        signatures: expanded.signatures,
        maxSignatures: expanded.maxSignatures,
      };
    }
    if (witnessScript) {
      const p2wsh = payments.p2wsh({ redeem: { output: witnessScript } });
      if (input.prevOutScript) {
        const p2wshAlt = payments.p2wsh({ output: input.prevOutScript });
        if (!p2wsh.hash.equals(p2wshAlt.hash))
          throw new Error('Witness script inconsistent with prevOutScript');
      }
      const expanded = expandOutput(p2wsh.redeem.output, ourPubKey);
      if (!expanded.pubkeys)
        throw new Error(
          expanded.type +
            ' not supported as witnessScript (' +
            bscript.toASM(witnessScript) +
            ')',
        );
      if (input.signatures && input.signatures.some(x => x !== undefined)) {
        expanded.signatures = input.signatures;
      }
      const signScript = witnessScript;
      if (expanded.type === SCRIPT_TYPES.P2WPKH)
        throw new Error('P2WSH(P2WPKH) is a consensus failure');
      return {
        witnessScript,
        witnessScriptType: expanded.type,
        prevOutType: SCRIPT_TYPES.P2WSH,
        prevOutScript: p2wsh.output,
        hasWitness: true,
        signScript,
        signType: expanded.type,
        pubkeys: expanded.pubkeys,
        signatures: expanded.signatures,
        maxSignatures: expanded.maxSignatures,
      };
    }
    if (input.prevOutType && input.prevOutScript) {
      // embedded scripts are not possible without extra information
      if (input.prevOutType === SCRIPT_TYPES.P2SH)
        throw new Error(
          'PrevOutScript is ' + input.prevOutType + ', requires redeemScript',
        );
      if (input.prevOutType === SCRIPT_TYPES.P2WSH)
        throw new Error(
          'PrevOutScript is ' + input.prevOutType + ', requires witnessScript',
        );
      if (!input.prevOutScript) throw new Error('PrevOutScript is missing');
      const expanded = expandOutput(input.prevOutScript, ourPubKey);
      if (!expanded.pubkeys)
        throw new Error(
          expanded.type +
            ' not supported (' +
            bscript.toASM(input.prevOutScript) +
            ')',
        );
      if (input.signatures && input.signatures.some(x => x !== undefined)) {
        expanded.signatures = input.signatures;
      }
      let signScript = input.prevOutScript;
      if (expanded.type === SCRIPT_TYPES.P2WPKH) {
        signScript = payments.p2pkh({ pubkey: expanded.pubkeys[0] }).output;
      }
      return {
        prevOutType: expanded.type,
        prevOutScript: input.prevOutScript,
        hasWitness: expanded.type === SCRIPT_TYPES.P2WPKH,
        signScript,
        signType: expanded.type,
        pubkeys: expanded.pubkeys,
        signatures: expanded.signatures,
        maxSignatures: expanded.maxSignatures,
      };
    }
    const prevOutScript = payments.p2pkh({ pubkey: ourPubKey }).output;
    return {
      prevOutType: SCRIPT_TYPES.P2PKH,
      prevOutScript,
      hasWitness: false,
      signScript: prevOutScript,
      signType: SCRIPT_TYPES.P2PKH,
      pubkeys: [ourPubKey],
      signatures: [undefined],
    };
  }
  function build(type, input, allowIncomplete) {
    const pubkeys = input.pubkeys || [];
    let signatures = input.signatures || [];
    switch (type) {
      case SCRIPT_TYPES.P2PKH: {
        if (pubkeys.length === 0) break;
        if (signatures.length === 0) break;
        return payments.p2pkh({ pubkey: pubkeys[0], signature: signatures[0] });
      }
      case SCRIPT_TYPES.P2WPKH: {
        if (pubkeys.length === 0) break;
        if (signatures.length === 0) break;
        return payments.p2wpkh({ pubkey: pubkeys[0], signature: signatures[0] });
      }
      case SCRIPT_TYPES.P2PK: {
        if (pubkeys.length === 0) break;
        if (signatures.length === 0) break;
        return payments.p2pk({ signature: signatures[0] });
      }
      case SCRIPT_TYPES.P2MS: {
        const m = input.maxSignatures;
        if (allowIncomplete) {
          signatures = signatures.map(x => x || script_1.OPS.OP_0);
        } else {
          signatures = signatures.filter(x => x);
        }
        // if the transaction is not not complete (complete), or if signatures.length === m, validate
        // otherwise, the number of OP_0's may be >= m, so don't validate (boo)
        const validate = !allowIncomplete || m === signatures.length;
        return payments.p2ms(
          { m, pubkeys, signatures },
          { allowIncomplete, validate },
        );
      }
      case SCRIPT_TYPES.P2SH: {
        const redeem = build(input.redeemScriptType, input, allowIncomplete);
        if (!redeem) return;
        return payments.p2sh({
          redeem: {
            output: redeem.output || input.redeemScript,
            input: redeem.input,
            witness: redeem.witness,
          },
        });
      }
      case SCRIPT_TYPES.P2WSH: {
        const redeem = build(input.witnessScriptType, input, allowIncomplete);
        if (!redeem) return;
        return payments.p2wsh({
          redeem: {
            output: input.witnessScript,
            input: redeem.input,
            witness: redeem.witness,
          },
        });
      }
    }
  }
  function canSign(input) {
    return (
      input.signScript !== undefined &&
      input.signType !== undefined &&
      input.pubkeys !== undefined &&
      input.signatures !== undefined &&
      input.signatures.length === input.pubkeys.length &&
      input.pubkeys.length > 0 &&
      (input.hasWitness === false || input.value !== undefined)
    );
  }
  function signatureHashType(buffer) {
    return buffer.readUInt8(buffer.length - 1);
  }
  function checkSignArgs(inputs, signParams) {
    if (!PREVOUT_TYPES.has(signParams.prevOutScriptType)) {
      throw new TypeError(
        `Unknown prevOutScriptType "${signParams.prevOutScriptType}"`,
      );
    }
    tfMessage(
      typeforce.Number,
      signParams.vin,
      `sign must include vin parameter as Number (input index)`,
    );
    tfMessage(
      types.Signer,
      signParams.keyPair,
      `sign must include keyPair parameter as Signer interface`,
    );
    tfMessage(
      typeforce.maybe(typeforce.Number),
      signParams.hashType,
      `sign hashType parameter must be a number`,
    );
    const prevOutType = (inputs[signParams.vin] || []).prevOutType;
    const posType = signParams.prevOutScriptType;
    switch (posType) {
      case 'p2pkh':
        if (prevOutType && prevOutType !== 'pubkeyhash') {
          throw new TypeError(
            `input #${signParams.vin} is not of type p2pkh: ${prevOutType}`,
          );
        }
        tfMessage(
          typeforce.value(undefined),
          signParams.witnessScript,
          `${posType} requires NO witnessScript`,
        );
        tfMessage(
          typeforce.value(undefined),
          signParams.redeemScript,
          `${posType} requires NO redeemScript`,
        );
        tfMessage(
          typeforce.value(undefined),
          signParams.witnessValue,
          `${posType} requires NO witnessValue`,
        );
        break;
      case 'p2pk':
        if (prevOutType && prevOutType !== 'pubkey') {
          throw new TypeError(
            `input #${signParams.vin} is not of type p2pk: ${prevOutType}`,
          );
        }
        tfMessage(
          typeforce.value(undefined),
          signParams.witnessScript,
          `${posType} requires NO witnessScript`,
        );
        tfMessage(
          typeforce.value(undefined),
          signParams.redeemScript,
          `${posType} requires NO redeemScript`,
        );
        tfMessage(
          typeforce.value(undefined),
          signParams.witnessValue,
          `${posType} requires NO witnessValue`,
        );
        break;
      case 'p2wpkh':
        if (prevOutType && prevOutType !== 'witnesspubkeyhash') {
          throw new TypeError(
            `input #${signParams.vin} is not of type p2wpkh: ${prevOutType}`,
          );
        }
        tfMessage(
          typeforce.value(undefined),
          signParams.witnessScript,
          `${posType} requires NO witnessScript`,
        );
        tfMessage(
          typeforce.value(undefined),
          signParams.redeemScript,
          `${posType} requires NO redeemScript`,
        );
        tfMessage(
          types.Satoshi,
          signParams.witnessValue,
          `${posType} requires witnessValue`,
        );
        break;
      case 'p2ms':
        if (prevOutType && prevOutType !== 'multisig') {
          throw new TypeError(
            `input #${signParams.vin} is not of type p2ms: ${prevOutType}`,
          );
        }
        tfMessage(
          typeforce.value(undefined),
          signParams.witnessScript,
          `${posType} requires NO witnessScript`,
        );
        tfMessage(
          typeforce.value(undefined),
          signParams.redeemScript,
          `${posType} requires NO redeemScript`,
        );
        tfMessage(
          typeforce.value(undefined),
          signParams.witnessValue,
          `${posType} requires NO witnessValue`,
        );
        break;
      case 'p2sh-p2wpkh':
        if (prevOutType && prevOutType !== 'scripthash') {
          throw new TypeError(
            `input #${signParams.vin} is not of type p2sh-p2wpkh: ${prevOutType}`,
          );
        }
        tfMessage(
          typeforce.value(undefined),
          signParams.witnessScript,
          `${posType} requires NO witnessScript`,
        );
        tfMessage(
          typeforce.Buffer,
          signParams.redeemScript,
          `${posType} requires redeemScript`,
        );
        tfMessage(
          types.Satoshi,
          signParams.witnessValue,
          `${posType} requires witnessValue`,
        );
        break;
      case 'p2sh-p2ms':
      case 'p2sh-p2pk':
      case 'p2sh-p2pkh':
        if (prevOutType && prevOutType !== 'scripthash') {
          throw new TypeError(
            `input #${signParams.vin} is not of type ${posType}: ${prevOutType}`,
          );
        }
        tfMessage(
          typeforce.value(undefined),
          signParams.witnessScript,
          `${posType} requires NO witnessScript`,
        );
        tfMessage(
          typeforce.Buffer,
          signParams.redeemScript,
          `${posType} requires redeemScript`,
        );
        tfMessage(
          typeforce.value(undefined),
          signParams.witnessValue,
          `${posType} requires NO witnessValue`,
        );
        break;
      case 'p2wsh-p2ms':
      case 'p2wsh-p2pk':
      case 'p2wsh-p2pkh':
        if (prevOutType && prevOutType !== 'witnessscripthash') {
          throw new TypeError(
            `input #${signParams.vin} is not of type ${posType}: ${prevOutType}`,
          );
        }
        tfMessage(
          typeforce.Buffer,
          signParams.witnessScript,
          `${posType} requires witnessScript`,
        );
        tfMessage(
          typeforce.value(undefined),
          signParams.redeemScript,
          `${posType} requires NO redeemScript`,
        );
        tfMessage(
          types.Satoshi,
          signParams.witnessValue,
          `${posType} requires witnessValue`,
        );
        break;
      case 'p2sh-p2wsh-p2ms':
      case 'p2sh-p2wsh-p2pk':
      case 'p2sh-p2wsh-p2pkh':
        if (prevOutType && prevOutType !== 'scripthash') {
          throw new TypeError(
            `input #${signParams.vin} is not of type ${posType}: ${prevOutType}`,
          );
        }
        tfMessage(
          typeforce.Buffer,
          signParams.witnessScript,
          `${posType} requires witnessScript`,
        );
        tfMessage(
          typeforce.Buffer,
          signParams.redeemScript,
          `${posType} requires witnessScript`,
        );
        tfMessage(
          types.Satoshi,
          signParams.witnessValue,
          `${posType} requires witnessScript`,
        );
        break;
    }
  }
  function trySign({
    input,
    ourPubKey,
    keyPair,
    signatureHash,
    hashType,
    useLowR,
  }) {
    // enforce in order signing of public keys
    let signed = false;
    for (const [i, pubKey] of input.pubkeys.entries()) {
      if (!ourPubKey.equals(pubKey)) continue;
      if (input.signatures[i]) throw new Error('Signature already exists');
      // TODO: add tests
      if (ourPubKey.length !== 33 && input.hasWitness) {
        throw new Error(
          'BIP143 rejects uncompressed public keys in P2WPKH or P2WSH',
        );
      }
      const signature = keyPair.sign(signatureHash, useLowR);
      input.signatures[i] = bscript.signature.encode(signature, hashType);
      signed = true;
    }
    if (!signed) throw new Error('Key pair cannot sign for this input');
  }
  function getSigningData(
    network,
    inputs,
    needsOutputs,
    tx,
    signParams,
    keyPair,
    redeemScript,
    hashType,
    witnessValue,
    witnessScript,
    useLowR,
  ) {
    let vin;
    if (typeof signParams === 'number') {
      console.warn(
        'DEPRECATED: TransactionBuilder sign method arguments ' +
          'will change in v6, please use the TxbSignArg interface',
      );
      vin = signParams;
    } else if (typeof signParams === 'object') {
      checkSignArgs(inputs, signParams);
      ({
        vin,
        keyPair,
        redeemScript,
        hashType,
        witnessValue,
        witnessScript,
      } = signParams);
    } else {
      throw new TypeError(
        'TransactionBuilder sign first arg must be TxbSignArg or number',
      );
    }
    if (keyPair === undefined) {
      throw new Error('sign requires keypair');
    }
    // TODO: remove keyPair.network matching in 4.0.0
    if (keyPair.network && keyPair.network !== network)
      throw new TypeError('Inconsistent network');
    if (!inputs[vin]) throw new Error('No input at index: ' + vin);
    hashType = hashType || transaction_1.Transaction.SIGHASH_ALL;
    if (needsOutputs(hashType)) throw new Error('Transaction needs outputs');
    const input = inputs[vin];
    // if redeemScript was previously provided, enforce consistency
    if (
      input.redeemScript !== undefined &&
      redeemScript &&
      !input.redeemScript.equals(redeemScript)
    ) {
      throw new Error('Inconsistent redeemScript');
    }
    const ourPubKey =
      keyPair.publicKey || (keyPair.getPublicKey && keyPair.getPublicKey());
    if (!canSign(input)) {
      if (witnessValue !== undefined) {
        if (input.value !== undefined && input.value !== witnessValue)
          throw new Error('Input did not match witnessValue');
        typeforce(types.Satoshi, witnessValue);
        input.value = witnessValue;
      }
      if (!canSign(input)) {
        const prepared = prepareInput(
          input,
          ourPubKey,
          redeemScript,
          witnessScript,
        );
        // updates inline
        Object.assign(input, prepared);
      }
      if (!canSign(input)) throw Error(input.prevOutType + ' not supported');
    }
    // ready to sign
    let signatureHash;
    if (input.hasWitness) {
      signatureHash = tx.hashForWitnessV0(
        vin,
        input.signScript,
        input.value,
        hashType,
      );
    } else {
      signatureHash = tx.hashForSignature(vin, input.signScript, hashType);
    }
    return {
      input,
      ourPubKey,
      keyPair,
      signatureHash,
      hashType,
      useLowR: !!useLowR,
    };
  }
  
  }).call(this,require("buffer").Buffer)
  },{"./address":142,"./bufferutils":144,"./classify":145,"./crypto":146,"./ecpair":147,"./networks":149,"./payments":151,"./script":160,"./transaction":184,"./types":186,"buffer":3,"typeforce":271}],186:[function(require,module,exports){
  'use strict';
  Object.defineProperty(exports, '__esModule', { value: true });
  const typeforce = require('typeforce');
  const UINT31_MAX = Math.pow(2, 31) - 1;
  function UInt31(value) {
    return typeforce.UInt32(value) && value <= UINT31_MAX;
  }
  exports.UInt31 = UInt31;
  function BIP32Path(value) {
    return typeforce.String(value) && !!value.match(/^(m\/)?(\d+'?\/)*\d+'?$/);
  }
  exports.BIP32Path = BIP32Path;
  BIP32Path.toJSON = () => {
    return 'BIP32 derivation path';
  };
  function Signer(obj) {
    return (
      (typeforce.Buffer(obj.publicKey) ||
        typeof obj.getPublicKey === 'function') &&
      typeof obj.sign === 'function'
    );
  }
  exports.Signer = Signer;
  const SATOSHI_MAX = 21 * 1e14;
  function Satoshi(value) {
    return typeforce.UInt53(value) && value <= SATOSHI_MAX;
  }
  exports.Satoshi = Satoshi;
  // external dependent types
  exports.ECPoint = typeforce.quacksLike('Point');
  // exposed, external API
  exports.Network = typeforce.compile({
    messagePrefix: typeforce.oneOf(typeforce.Buffer, typeforce.String),
    bip32: {
      public: typeforce.UInt32,
      private: typeforce.UInt32,
    },
    pubKeyHash: typeforce.UInt8,
    scriptHash: typeforce.UInt8,
    wif: typeforce.UInt8,
  });
  exports.Buffer256bit = typeforce.BufferN(32);
  exports.Hash160bit = typeforce.BufferN(20);
  exports.Hash256bit = typeforce.BufferN(32);
  exports.Number = typeforce.Number; // tslint:disable-line variable-name
  exports.Array = typeforce.Array;
  exports.Boolean = typeforce.Boolean; // tslint:disable-line variable-name
  exports.String = typeforce.String; // tslint:disable-line variable-name
  exports.Buffer = typeforce.Buffer;
  exports.Hex = typeforce.Hex;
  exports.maybe = typeforce.maybe;
  exports.tuple = typeforce.tuple;
  exports.UInt8 = typeforce.UInt8;
  exports.UInt32 = typeforce.UInt32;
  exports.Function = typeforce.Function;
  exports.BufferN = typeforce.BufferN;
  exports.Null = typeforce.Null;
  exports.oneOf = typeforce.oneOf;
  
  },{"typeforce":271}],187:[function(require,module,exports){
  (function (module, exports) {
    'use strict';
  
    // Utils
    function assert (val, msg) {
      if (!val) throw new Error(msg || 'Assertion failed');
    }
  
    // Could use `inherits` module, but don't want to move from single file
    // architecture yet.
    function inherits (ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  
    // BN
  
    function BN (number, base, endian) {
      if (BN.isBN(number)) {
        return number;
      }
  
      this.negative = 0;
      this.words = null;
      this.length = 0;
  
      // Reduction context
      this.red = null;
  
      if (number !== null) {
        if (base === 'le' || base === 'be') {
          endian = base;
          base = 10;
        }
  
        this._init(number || 0, base || 10, endian || 'be');
      }
    }
    if (typeof module === 'object') {
      module.exports = BN;
    } else {
      exports.BN = BN;
    }
  
    BN.BN = BN;
    BN.wordSize = 26;
  
    var Buffer;
    try {
      Buffer = require('buffer').Buffer;
    } catch (e) {
    }
  
    BN.isBN = function isBN (num) {
      if (num instanceof BN) {
        return true;
      }
  
      return num !== null && typeof num === 'object' &&
        num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };
  
    BN.max = function max (left, right) {
      if (left.cmp(right) > 0) return left;
      return right;
    };
  
    BN.min = function min (left, right) {
      if (left.cmp(right) < 0) return left;
      return right;
    };
  
    BN.prototype._init = function init (number, base, endian) {
      if (typeof number === 'number') {
        return this._initNumber(number, base, endian);
      }
  
      if (typeof number === 'object') {
        return this._initArray(number, base, endian);
      }
  
      if (base === 'hex') {
        base = 16;
      }
      assert(base === (base | 0) && base >= 2 && base <= 36);
  
      number = number.toString().replace(/\s+/g, '');
      var start = 0;
      if (number[0] === '-') {
        start++;
      }
  
      if (base === 16) {
        this._parseHex(number, start);
      } else {
        this._parseBase(number, base, start);
      }
  
      if (number[0] === '-') {
        this.negative = 1;
      }
  
      this.strip();
  
      if (endian !== 'le') return;
  
      this._initArray(this.toArray(), base, endian);
    };
  
    BN.prototype._initNumber = function _initNumber (number, base, endian) {
      if (number < 0) {
        this.negative = 1;
        number = -number;
      }
      if (number < 0x4000000) {
        this.words = [ number & 0x3ffffff ];
        this.length = 1;
      } else if (number < 0x10000000000000) {
        this.words = [
          number & 0x3ffffff,
          (number / 0x4000000) & 0x3ffffff
        ];
        this.length = 2;
      } else {
        assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
        this.words = [
          number & 0x3ffffff,
          (number / 0x4000000) & 0x3ffffff,
          1
        ];
        this.length = 3;
      }
  
      if (endian !== 'le') return;
  
      // Reverse the bytes
      this._initArray(this.toArray(), base, endian);
    };
  
    BN.prototype._initArray = function _initArray (number, base, endian) {
      // Perhaps a Uint8Array
      assert(typeof number.length === 'number');
      if (number.length <= 0) {
        this.words = [ 0 ];
        this.length = 1;
        return this;
      }
  
      this.length = Math.ceil(number.length / 3);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
  
      var j, w;
      var off = 0;
      if (endian === 'be') {
        for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
          w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
          this.words[j] |= (w << off) & 0x3ffffff;
          this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === 'le') {
        for (i = 0, j = 0; i < number.length; i += 3) {
          w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
          this.words[j] |= (w << off) & 0x3ffffff;
          this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }
      return this.strip();
    };
  
    function parseHex (str, start, end) {
      var r = 0;
      var len = Math.min(str.length, end);
      for (var i = start; i < len; i++) {
        var c = str.charCodeAt(i) - 48;
  
        r <<= 4;
  
        // 'a' - 'f'
        if (c >= 49 && c <= 54) {
          r |= c - 49 + 0xa;
  
        // 'A' - 'F'
        } else if (c >= 17 && c <= 22) {
          r |= c - 17 + 0xa;
  
        // '0' - '9'
        } else {
          r |= c & 0xf;
        }
      }
      return r;
    }
  
    BN.prototype._parseHex = function _parseHex (number, start) {
      // Create possibly bigger array to ensure that it fits the number
      this.length = Math.ceil((number.length - start) / 6);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
  
      var j, w;
      // Scan 24-bit chunks and add them to the number
      var off = 0;
      for (i = number.length - 6, j = 0; i >= start; i -= 6) {
        w = parseHex(number, i, i + 6);
        this.words[j] |= (w << off) & 0x3ffffff;
        // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
        this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
      if (i + 6 !== start) {
        w = parseHex(number, start, i + 6);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
      }
      this.strip();
    };
  
    function parseBase (str, start, end, mul) {
      var r = 0;
      var len = Math.min(str.length, end);
      for (var i = start; i < len; i++) {
        var c = str.charCodeAt(i) - 48;
  
        r *= mul;
  
        // 'a'
        if (c >= 49) {
          r += c - 49 + 0xa;
  
        // 'A'
        } else if (c >= 17) {
          r += c - 17 + 0xa;
  
        // '0' - '9'
        } else {
          r += c;
        }
      }
      return r;
    }
  
    BN.prototype._parseBase = function _parseBase (number, base, start) {
      // Initialize as zero
      this.words = [ 0 ];
      this.length = 1;
  
      // Find length of limb in base
      for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
        limbLen++;
      }
      limbLen--;
      limbPow = (limbPow / base) | 0;
  
      var total = number.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
  
      var word = 0;
      for (var i = start; i < end; i += limbLen) {
        word = parseBase(number, i, i + limbLen, base);
  
        this.imuln(limbPow);
        if (this.words[0] + word < 0x4000000) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
  
      if (mod !== 0) {
        var pow = 1;
        word = parseBase(number, i, number.length, base);
  
        for (i = 0; i < mod; i++) {
          pow *= base;
        }
  
        this.imuln(pow);
        if (this.words[0] + word < 0x4000000) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
    };
  
    BN.prototype.copy = function copy (dest) {
      dest.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        dest.words[i] = this.words[i];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
  
    BN.prototype.clone = function clone () {
      var r = new BN(null);
      this.copy(r);
      return r;
    };
  
    BN.prototype._expand = function _expand (size) {
      while (this.length < size) {
        this.words[this.length++] = 0;
      }
      return this;
    };
  
    // Remove leading `0` from `this`
    BN.prototype.strip = function strip () {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
  
    BN.prototype._normSign = function _normSign () {
      // -0 = 0
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
  
    BN.prototype.inspect = function inspect () {
      return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
    };
  
    /*
  
    var zeros = [];
    var groupSizes = [];
    var groupBases = [];
  
    var s = '';
    var i = -1;
    while (++i < BN.wordSize) {
      zeros[i] = s;
      s += '0';
    }
    groupSizes[0] = 0;
    groupSizes[1] = 0;
    groupBases[0] = 0;
    groupBases[1] = 0;
    var base = 2 - 1;
    while (++base < 36 + 1) {
      var groupSize = 0;
      var groupBase = 1;
      while (groupBase < (1 << BN.wordSize) / base) {
        groupBase *= base;
        groupSize += 1;
      }
      groupSizes[base] = groupSize;
      groupBases[base] = groupBase;
    }
  
    */
  
    var zeros = [
      '',
      '0',
      '00',
      '000',
      '0000',
      '00000',
      '000000',
      '0000000',
      '00000000',
      '000000000',
      '0000000000',
      '00000000000',
      '000000000000',
      '0000000000000',
      '00000000000000',
      '000000000000000',
      '0000000000000000',
      '00000000000000000',
      '000000000000000000',
      '0000000000000000000',
      '00000000000000000000',
      '000000000000000000000',
      '0000000000000000000000',
      '00000000000000000000000',
      '000000000000000000000000',
      '0000000000000000000000000'
    ];
  
    var groupSizes = [
      0, 0,
      25, 16, 12, 11, 10, 9, 8,
      8, 7, 7, 7, 7, 6, 6,
      6, 6, 6, 6, 6, 5, 5,
      5, 5, 5, 5, 5, 5, 5,
      5, 5, 5, 5, 5, 5, 5
    ];
  
    var groupBases = [
      0, 0,
      33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
      43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
      16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
      6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
      24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
    ];
  
    BN.prototype.toString = function toString (base, padding) {
      base = base || 10;
      padding = padding | 0 || 1;
  
      var out;
      if (base === 16 || base === 'hex') {
        out = '';
        var off = 0;
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = this.words[i];
          var word = (((w << off) | carry) & 0xffffff).toString(16);
          carry = (w >>> (24 - off)) & 0xffffff;
          if (carry !== 0 || i !== this.length - 1) {
            out = zeros[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
          off += 2;
          if (off >= 26) {
            off -= 26;
            i--;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding !== 0) {
          out = '0' + out;
        }
        if (this.negative !== 0) {
          out = '-' + out;
        }
        return out;
      }
  
      if (base === (base | 0) && base >= 2 && base <= 36) {
        // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
        var groupSize = groupSizes[base];
        // var groupBase = Math.pow(base, groupSize);
        var groupBase = groupBases[base];
        out = '';
        var c = this.clone();
        c.negative = 0;
        while (!c.isZero()) {
          var r = c.modn(groupBase).toString(base);
          c = c.idivn(groupBase);
  
          if (!c.isZero()) {
            out = zeros[groupSize - r.length] + r + out;
          } else {
            out = r + out;
          }
        }
        if (this.isZero()) {
          out = '0' + out;
        }
        while (out.length % padding !== 0) {
          out = '0' + out;
        }
        if (this.negative !== 0) {
          out = '-' + out;
        }
        return out;
      }
  
      assert(false, 'Base should be between 2 and 36');
    };
  
    BN.prototype.toNumber = function toNumber () {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 0x4000000;
      } else if (this.length === 3 && this.words[2] === 0x01) {
        // NOTE: at this stage it is known that the top bit is set
        ret += 0x10000000000000 + (this.words[1] * 0x4000000);
      } else if (this.length > 2) {
        assert(false, 'Number can only safely store up to 53 bits');
      }
      return (this.negative !== 0) ? -ret : ret;
    };
  
    BN.prototype.toJSON = function toJSON () {
      return this.toString(16);
    };
  
    BN.prototype.toBuffer = function toBuffer (endian, length) {
      assert(typeof Buffer !== 'undefined');
      return this.toArrayLike(Buffer, endian, length);
    };
  
    BN.prototype.toArray = function toArray (endian, length) {
      return this.toArrayLike(Array, endian, length);
    };
  
    BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
      var byteLength = this.byteLength();
      var reqLength = length || Math.max(1, byteLength);
      assert(byteLength <= reqLength, 'byte array longer than desired length');
      assert(reqLength > 0, 'Requested array length <= 0');
  
      this.strip();
      var littleEndian = endian === 'le';
      var res = new ArrayType(reqLength);
  
      var b, i;
      var q = this.clone();
      if (!littleEndian) {
        // Assume big-endian
        for (i = 0; i < reqLength - byteLength; i++) {
          res[i] = 0;
        }
  
        for (i = 0; !q.isZero(); i++) {
          b = q.andln(0xff);
          q.iushrn(8);
  
          res[reqLength - i - 1] = b;
        }
      } else {
        for (i = 0; !q.isZero(); i++) {
          b = q.andln(0xff);
          q.iushrn(8);
  
          res[i] = b;
        }
  
        for (; i < reqLength; i++) {
          res[i] = 0;
        }
      }
  
      return res;
    };
  
    if (Math.clz32) {
      BN.prototype._countBits = function _countBits (w) {
        return 32 - Math.clz32(w);
      };
    } else {
      BN.prototype._countBits = function _countBits (w) {
        var t = w;
        var r = 0;
        if (t >= 0x1000) {
          r += 13;
          t >>>= 13;
        }
        if (t >= 0x40) {
          r += 7;
          t >>>= 7;
        }
        if (t >= 0x8) {
          r += 4;
          t >>>= 4;
        }
        if (t >= 0x02) {
          r += 2;
          t >>>= 2;
        }
        return r + t;
      };
    }
  
    BN.prototype._zeroBits = function _zeroBits (w) {
      // Short-cut
      if (w === 0) return 26;
  
      var t = w;
      var r = 0;
      if ((t & 0x1fff) === 0) {
        r += 13;
        t >>>= 13;
      }
      if ((t & 0x7f) === 0) {
        r += 7;
        t >>>= 7;
      }
      if ((t & 0xf) === 0) {
        r += 4;
        t >>>= 4;
      }
      if ((t & 0x3) === 0) {
        r += 2;
        t >>>= 2;
      }
      if ((t & 0x1) === 0) {
        r++;
      }
      return r;
    };
  
    // Return number of used bits in a BN
    BN.prototype.bitLength = function bitLength () {
      var w = this.words[this.length - 1];
      var hi = this._countBits(w);
      return (this.length - 1) * 26 + hi;
    };
  
    function toBitArray (num) {
      var w = new Array(num.bitLength());
  
      for (var bit = 0; bit < w.length; bit++) {
        var off = (bit / 26) | 0;
        var wbit = bit % 26;
  
        w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
      }
  
      return w;
    }
  
    // Number of trailing zero bits
    BN.prototype.zeroBits = function zeroBits () {
      if (this.isZero()) return 0;
  
      var r = 0;
      for (var i = 0; i < this.length; i++) {
        var b = this._zeroBits(this.words[i]);
        r += b;
        if (b !== 26) break;
      }
      return r;
    };
  
    BN.prototype.byteLength = function byteLength () {
      return Math.ceil(this.bitLength() / 8);
    };
  
    BN.prototype.toTwos = function toTwos (width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
  
    BN.prototype.fromTwos = function fromTwos (width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
  
    BN.prototype.isNeg = function isNeg () {
      return this.negative !== 0;
    };
  
    // Return negative clone of `this`
    BN.prototype.neg = function neg () {
      return this.clone().ineg();
    };
  
    BN.prototype.ineg = function ineg () {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
  
      return this;
    };
  
    // Or `num` with `this` in-place
    BN.prototype.iuor = function iuor (num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
  
      for (var i = 0; i < num.length; i++) {
        this.words[i] = this.words[i] | num.words[i];
      }
  
      return this.strip();
    };
  
    BN.prototype.ior = function ior (num) {
      assert((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
  
    // Or `num` with `this`
    BN.prototype.or = function or (num) {
      if (this.length > num.length) return this.clone().ior(num);
      return num.clone().ior(this);
    };
  
    BN.prototype.uor = function uor (num) {
      if (this.length > num.length) return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
  
    // And `num` with `this` in-place
    BN.prototype.iuand = function iuand (num) {
      // b = min-length(num, this)
      var b;
      if (this.length > num.length) {
        b = num;
      } else {
        b = this;
      }
  
      for (var i = 0; i < b.length; i++) {
        this.words[i] = this.words[i] & num.words[i];
      }
  
      this.length = b.length;
  
      return this.strip();
    };
  
    BN.prototype.iand = function iand (num) {
      assert((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
  
    // And `num` with `this`
    BN.prototype.and = function and (num) {
      if (this.length > num.length) return this.clone().iand(num);
      return num.clone().iand(this);
    };
  
    BN.prototype.uand = function uand (num) {
      if (this.length > num.length) return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
  
    // Xor `num` with `this` in-place
    BN.prototype.iuxor = function iuxor (num) {
      // a.length > b.length
      var a;
      var b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
  
      for (var i = 0; i < b.length; i++) {
        this.words[i] = a.words[i] ^ b.words[i];
      }
  
      if (this !== a) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
  
      this.length = a.length;
  
      return this.strip();
    };
  
    BN.prototype.ixor = function ixor (num) {
      assert((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
  
    // Xor `num` with `this`
    BN.prototype.xor = function xor (num) {
      if (this.length > num.length) return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
  
    BN.prototype.uxor = function uxor (num) {
      if (this.length > num.length) return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
  
    // Not ``this`` with ``width`` bitwidth
    BN.prototype.inotn = function inotn (width) {
      assert(typeof width === 'number' && width >= 0);
  
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
  
      // Extend the buffer with leading zeroes
      this._expand(bytesNeeded);
  
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
  
      // Handle complete words
      for (var i = 0; i < bytesNeeded; i++) {
        this.words[i] = ~this.words[i] & 0x3ffffff;
      }
  
      // Handle the residue
      if (bitsLeft > 0) {
        this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
      }
  
      // And remove leading zeroes
      return this.strip();
    };
  
    BN.prototype.notn = function notn (width) {
      return this.clone().inotn(width);
    };
  
    // Set `bit` of `this`
    BN.prototype.setn = function setn (bit, val) {
      assert(typeof bit === 'number' && bit >= 0);
  
      var off = (bit / 26) | 0;
      var wbit = bit % 26;
  
      this._expand(off + 1);
  
      if (val) {
        this.words[off] = this.words[off] | (1 << wbit);
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
  
      return this.strip();
    };
  
    // Add `num` to `this` in-place
    BN.prototype.iadd = function iadd (num) {
      var r;
  
      // negative + positive
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
  
      // positive + negative
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r = this.isub(num);
        num.negative = 1;
        return r._normSign();
      }
  
      // a.length > b.length
      var a, b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
  
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
        this.words[i] = r & 0x3ffffff;
        carry = r >>> 26;
      }
      for (; carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        this.words[i] = r & 0x3ffffff;
        carry = r >>> 26;
      }
  
      this.length = a.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      // Copy the rest of the words
      } else if (a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
  
      return this;
    };
  
    // Add `num` to `this`
    BN.prototype.add = function add (num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
  
      if (this.length > num.length) return this.clone().iadd(num);
  
      return num.clone().iadd(this);
    };
  
    // Subtract `num` from `this` in-place
    BN.prototype.isub = function isub (num) {
      // this - (-num) = this + num
      if (num.negative !== 0) {
        num.negative = 0;
        var r = this.iadd(num);
        num.negative = 1;
        return r._normSign();
  
      // -this - num = -(this + num)
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
  
      // At this point both numbers are positive
      var cmp = this.cmp(num);
  
      // Optimization - zeroify
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
  
      // a > b
      var a, b;
      if (cmp > 0) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
  
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 0x3ffffff;
      }
      for (; carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 0x3ffffff;
      }
  
      // Copy rest of the words
      if (carry === 0 && i < a.length && a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
  
      this.length = Math.max(this.length, i);
  
      if (a !== this) {
        this.negative = 1;
      }
  
      return this.strip();
    };
  
    // Subtract `num` from `this`
    BN.prototype.sub = function sub (num) {
      return this.clone().isub(num);
    };
  
    function smallMulTo (self, num, out) {
      out.negative = num.negative ^ self.negative;
      var len = (self.length + num.length) | 0;
      out.length = len;
      len = (len - 1) | 0;
  
      // Peel one iteration (compiler can't do it, because of code complexity)
      var a = self.words[0] | 0;
      var b = num.words[0] | 0;
      var r = a * b;
  
      var lo = r & 0x3ffffff;
      var carry = (r / 0x4000000) | 0;
      out.words[0] = lo;
  
      for (var k = 1; k < len; k++) {
        // Sum all words with the same `i + j = k` and accumulate `ncarry`,
        // note that ncarry could be >= 0x3ffffff
        var ncarry = carry >>> 26;
        var rword = carry & 0x3ffffff;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
          var i = (k - j) | 0;
          a = self.words[i] | 0;
          b = num.words[j] | 0;
          r = a * b + rword;
          ncarry += (r / 0x4000000) | 0;
          rword = r & 0x3ffffff;
        }
        out.words[k] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k] = carry | 0;
      } else {
        out.length--;
      }
  
      return out.strip();
    }
  
    // TODO(indutny): it may be reasonable to omit it for users who don't need
    // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
    // multiplication (like elliptic secp256k1).
    var comb10MulTo = function comb10MulTo (self, num, out) {
      var a = self.words;
      var b = num.words;
      var o = out.words;
      var c = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a[0] | 0;
      var al0 = a0 & 0x1fff;
      var ah0 = a0 >>> 13;
      var a1 = a[1] | 0;
      var al1 = a1 & 0x1fff;
      var ah1 = a1 >>> 13;
      var a2 = a[2] | 0;
      var al2 = a2 & 0x1fff;
      var ah2 = a2 >>> 13;
      var a3 = a[3] | 0;
      var al3 = a3 & 0x1fff;
      var ah3 = a3 >>> 13;
      var a4 = a[4] | 0;
      var al4 = a4 & 0x1fff;
      var ah4 = a4 >>> 13;
      var a5 = a[5] | 0;
      var al5 = a5 & 0x1fff;
      var ah5 = a5 >>> 13;
      var a6 = a[6] | 0;
      var al6 = a6 & 0x1fff;
      var ah6 = a6 >>> 13;
      var a7 = a[7] | 0;
      var al7 = a7 & 0x1fff;
      var ah7 = a7 >>> 13;
      var a8 = a[8] | 0;
      var al8 = a8 & 0x1fff;
      var ah8 = a8 >>> 13;
      var a9 = a[9] | 0;
      var al9 = a9 & 0x1fff;
      var ah9 = a9 >>> 13;
      var b0 = b[0] | 0;
      var bl0 = b0 & 0x1fff;
      var bh0 = b0 >>> 13;
      var b1 = b[1] | 0;
      var bl1 = b1 & 0x1fff;
      var bh1 = b1 >>> 13;
      var b2 = b[2] | 0;
      var bl2 = b2 & 0x1fff;
      var bh2 = b2 >>> 13;
      var b3 = b[3] | 0;
      var bl3 = b3 & 0x1fff;
      var bh3 = b3 >>> 13;
      var b4 = b[4] | 0;
      var bl4 = b4 & 0x1fff;
      var bh4 = b4 >>> 13;
      var b5 = b[5] | 0;
      var bl5 = b5 & 0x1fff;
      var bh5 = b5 >>> 13;
      var b6 = b[6] | 0;
      var bl6 = b6 & 0x1fff;
      var bh6 = b6 >>> 13;
      var b7 = b[7] | 0;
      var bl7 = b7 & 0x1fff;
      var bh7 = b7 >>> 13;
      var b8 = b[8] | 0;
      var bl8 = b8 & 0x1fff;
      var bh8 = b8 >>> 13;
      var b9 = b[9] | 0;
      var bl9 = b9 & 0x1fff;
      var bh9 = b9 >>> 13;
  
      out.negative = self.negative ^ num.negative;
      out.length = 19;
      /* k = 0 */
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = (mid + Math.imul(ah0, bl0)) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
      w0 &= 0x3ffffff;
      /* k = 1 */
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = (mid + Math.imul(ah1, bl0)) | 0;
      hi = Math.imul(ah1, bh0);
      lo = (lo + Math.imul(al0, bl1)) | 0;
      mid = (mid + Math.imul(al0, bh1)) | 0;
      mid = (mid + Math.imul(ah0, bl1)) | 0;
      hi = (hi + Math.imul(ah0, bh1)) | 0;
      var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
      w1 &= 0x3ffffff;
      /* k = 2 */
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = (mid + Math.imul(ah2, bl0)) | 0;
      hi = Math.imul(ah2, bh0);
      lo = (lo + Math.imul(al1, bl1)) | 0;
      mid = (mid + Math.imul(al1, bh1)) | 0;
      mid = (mid + Math.imul(ah1, bl1)) | 0;
      hi = (hi + Math.imul(ah1, bh1)) | 0;
      lo = (lo + Math.imul(al0, bl2)) | 0;
      mid = (mid + Math.imul(al0, bh2)) | 0;
      mid = (mid + Math.imul(ah0, bl2)) | 0;
      hi = (hi + Math.imul(ah0, bh2)) | 0;
      var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
      w2 &= 0x3ffffff;
      /* k = 3 */
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = (mid + Math.imul(ah3, bl0)) | 0;
      hi = Math.imul(ah3, bh0);
      lo = (lo + Math.imul(al2, bl1)) | 0;
      mid = (mid + Math.imul(al2, bh1)) | 0;
      mid = (mid + Math.imul(ah2, bl1)) | 0;
      hi = (hi + Math.imul(ah2, bh1)) | 0;
      lo = (lo + Math.imul(al1, bl2)) | 0;
      mid = (mid + Math.imul(al1, bh2)) | 0;
      mid = (mid + Math.imul(ah1, bl2)) | 0;
      hi = (hi + Math.imul(ah1, bh2)) | 0;
      lo = (lo + Math.imul(al0, bl3)) | 0;
      mid = (mid + Math.imul(al0, bh3)) | 0;
      mid = (mid + Math.imul(ah0, bl3)) | 0;
      hi = (hi + Math.imul(ah0, bh3)) | 0;
      var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
      w3 &= 0x3ffffff;
      /* k = 4 */
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = (mid + Math.imul(ah4, bl0)) | 0;
      hi = Math.imul(ah4, bh0);
      lo = (lo + Math.imul(al3, bl1)) | 0;
      mid = (mid + Math.imul(al3, bh1)) | 0;
      mid = (mid + Math.imul(ah3, bl1)) | 0;
      hi = (hi + Math.imul(ah3, bh1)) | 0;
      lo = (lo + Math.imul(al2, bl2)) | 0;
      mid = (mid + Math.imul(al2, bh2)) | 0;
      mid = (mid + Math.imul(ah2, bl2)) | 0;
      hi = (hi + Math.imul(ah2, bh2)) | 0;
      lo = (lo + Math.imul(al1, bl3)) | 0;
      mid = (mid + Math.imul(al1, bh3)) | 0;
      mid = (mid + Math.imul(ah1, bl3)) | 0;
      hi = (hi + Math.imul(ah1, bh3)) | 0;
      lo = (lo + Math.imul(al0, bl4)) | 0;
      mid = (mid + Math.imul(al0, bh4)) | 0;
      mid = (mid + Math.imul(ah0, bl4)) | 0;
      hi = (hi + Math.imul(ah0, bh4)) | 0;
      var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
      w4 &= 0x3ffffff;
      /* k = 5 */
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = (mid + Math.imul(ah5, bl0)) | 0;
      hi = Math.imul(ah5, bh0);
      lo = (lo + Math.imul(al4, bl1)) | 0;
      mid = (mid + Math.imul(al4, bh1)) | 0;
      mid = (mid + Math.imul(ah4, bl1)) | 0;
      hi = (hi + Math.imul(ah4, bh1)) | 0;
      lo = (lo + Math.imul(al3, bl2)) | 0;
      mid = (mid + Math.imul(al3, bh2)) | 0;
      mid = (mid + Math.imul(ah3, bl2)) | 0;
      hi = (hi + Math.imul(ah3, bh2)) | 0;
      lo = (lo + Math.imul(al2, bl3)) | 0;
      mid = (mid + Math.imul(al2, bh3)) | 0;
      mid = (mid + Math.imul(ah2, bl3)) | 0;
      hi = (hi + Math.imul(ah2, bh3)) | 0;
      lo = (lo + Math.imul(al1, bl4)) | 0;
      mid = (mid + Math.imul(al1, bh4)) | 0;
      mid = (mid + Math.imul(ah1, bl4)) | 0;
      hi = (hi + Math.imul(ah1, bh4)) | 0;
      lo = (lo + Math.imul(al0, bl5)) | 0;
      mid = (mid + Math.imul(al0, bh5)) | 0;
      mid = (mid + Math.imul(ah0, bl5)) | 0;
      hi = (hi + Math.imul(ah0, bh5)) | 0;
      var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
      w5 &= 0x3ffffff;
      /* k = 6 */
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = (mid + Math.imul(ah6, bl0)) | 0;
      hi = Math.imul(ah6, bh0);
      lo = (lo + Math.imul(al5, bl1)) | 0;
      mid = (mid + Math.imul(al5, bh1)) | 0;
      mid = (mid + Math.imul(ah5, bl1)) | 0;
      hi = (hi + Math.imul(ah5, bh1)) | 0;
      lo = (lo + Math.imul(al4, bl2)) | 0;
      mid = (mid + Math.imul(al4, bh2)) | 0;
      mid = (mid + Math.imul(ah4, bl2)) | 0;
      hi = (hi + Math.imul(ah4, bh2)) | 0;
      lo = (lo + Math.imul(al3, bl3)) | 0;
      mid = (mid + Math.imul(al3, bh3)) | 0;
      mid = (mid + Math.imul(ah3, bl3)) | 0;
      hi = (hi + Math.imul(ah3, bh3)) | 0;
      lo = (lo + Math.imul(al2, bl4)) | 0;
      mid = (mid + Math.imul(al2, bh4)) | 0;
      mid = (mid + Math.imul(ah2, bl4)) | 0;
      hi = (hi + Math.imul(ah2, bh4)) | 0;
      lo = (lo + Math.imul(al1, bl5)) | 0;
      mid = (mid + Math.imul(al1, bh5)) | 0;
      mid = (mid + Math.imul(ah1, bl5)) | 0;
      hi = (hi + Math.imul(ah1, bh5)) | 0;
      lo = (lo + Math.imul(al0, bl6)) | 0;
      mid = (mid + Math.imul(al0, bh6)) | 0;
      mid = (mid + Math.imul(ah0, bl6)) | 0;
      hi = (hi + Math.imul(ah0, bh6)) | 0;
      var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
      w6 &= 0x3ffffff;
      /* k = 7 */
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = (mid + Math.imul(ah7, bl0)) | 0;
      hi = Math.imul(ah7, bh0);
      lo = (lo + Math.imul(al6, bl1)) | 0;
      mid = (mid + Math.imul(al6, bh1)) | 0;
      mid = (mid + Math.imul(ah6, bl1)) | 0;
      hi = (hi + Math.imul(ah6, bh1)) | 0;
      lo = (lo + Math.imul(al5, bl2)) | 0;
      mid = (mid + Math.imul(al5, bh2)) | 0;
      mid = (mid + Math.imul(ah5, bl2)) | 0;
      hi = (hi + Math.imul(ah5, bh2)) | 0;
      lo = (lo + Math.imul(al4, bl3)) | 0;
      mid = (mid + Math.imul(al4, bh3)) | 0;
      mid = (mid + Math.imul(ah4, bl3)) | 0;
      hi = (hi + Math.imul(ah4, bh3)) | 0;
      lo = (lo + Math.imul(al3, bl4)) | 0;
      mid = (mid + Math.imul(al3, bh4)) | 0;
      mid = (mid + Math.imul(ah3, bl4)) | 0;
      hi = (hi + Math.imul(ah3, bh4)) | 0;
      lo = (lo + Math.imul(al2, bl5)) | 0;
      mid = (mid + Math.imul(al2, bh5)) | 0;
      mid = (mid + Math.imul(ah2, bl5)) | 0;
      hi = (hi + Math.imul(ah2, bh5)) | 0;
      lo = (lo + Math.imul(al1, bl6)) | 0;
      mid = (mid + Math.imul(al1, bh6)) | 0;
      mid = (mid + Math.imul(ah1, bl6)) | 0;
      hi = (hi + Math.imul(ah1, bh6)) | 0;
      lo = (lo + Math.imul(al0, bl7)) | 0;
      mid = (mid + Math.imul(al0, bh7)) | 0;
      mid = (mid + Math.imul(ah0, bl7)) | 0;
      hi = (hi + Math.imul(ah0, bh7)) | 0;
      var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
      w7 &= 0x3ffffff;
      /* k = 8 */
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = (mid + Math.imul(ah8, bl0)) | 0;
      hi = Math.imul(ah8, bh0);
      lo = (lo + Math.imul(al7, bl1)) | 0;
      mid = (mid + Math.imul(al7, bh1)) | 0;
      mid = (mid + Math.imul(ah7, bl1)) | 0;
      hi = (hi + Math.imul(ah7, bh1)) | 0;
      lo = (lo + Math.imul(al6, bl2)) | 0;
      mid = (mid + Math.imul(al6, bh2)) | 0;
      mid = (mid + Math.imul(ah6, bl2)) | 0;
      hi = (hi + Math.imul(ah6, bh2)) | 0;
      lo = (lo + Math.imul(al5, bl3)) | 0;
      mid = (mid + Math.imul(al5, bh3)) | 0;
      mid = (mid + Math.imul(ah5, bl3)) | 0;
      hi = (hi + Math.imul(ah5, bh3)) | 0;
      lo = (lo + Math.imul(al4, bl4)) | 0;
      mid = (mid + Math.imul(al4, bh4)) | 0;
      mid = (mid + Math.imul(ah4, bl4)) | 0;
      hi = (hi + Math.imul(ah4, bh4)) | 0;
      lo = (lo + Math.imul(al3, bl5)) | 0;
      mid = (mid + Math.imul(al3, bh5)) | 0;
      mid = (mid + Math.imul(ah3, bl5)) | 0;
      hi = (hi + Math.imul(ah3, bh5)) | 0;
      lo = (lo + Math.imul(al2, bl6)) | 0;
      mid = (mid + Math.imul(al2, bh6)) | 0;
      mid = (mid + Math.imul(ah2, bl6)) | 0;
      hi = (hi + Math.imul(ah2, bh6)) | 0;
      lo = (lo + Math.imul(al1, bl7)) | 0;
      mid = (mid + Math.imul(al1, bh7)) | 0;
      mid = (mid + Math.imul(ah1, bl7)) | 0;
      hi = (hi + Math.imul(ah1, bh7)) | 0;
      lo = (lo + Math.imul(al0, bl8)) | 0;
      mid = (mid + Math.imul(al0, bh8)) | 0;
      mid = (mid + Math.imul(ah0, bl8)) | 0;
      hi = (hi + Math.imul(ah0, bh8)) | 0;
      var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
      w8 &= 0x3ffffff;
      /* k = 9 */
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = (mid + Math.imul(ah9, bl0)) | 0;
      hi = Math.imul(ah9, bh0);
      lo = (lo + Math.imul(al8, bl1)) | 0;
      mid = (mid + Math.imul(al8, bh1)) | 0;
      mid = (mid + Math.imul(ah8, bl1)) | 0;
      hi = (hi + Math.imul(ah8, bh1)) | 0;
      lo = (lo + Math.imul(al7, bl2)) | 0;
      mid = (mid + Math.imul(al7, bh2)) | 0;
      mid = (mid + Math.imul(ah7, bl2)) | 0;
      hi = (hi + Math.imul(ah7, bh2)) | 0;
      lo = (lo + Math.imul(al6, bl3)) | 0;
      mid = (mid + Math.imul(al6, bh3)) | 0;
      mid = (mid + Math.imul(ah6, bl3)) | 0;
      hi = (hi + Math.imul(ah6, bh3)) | 0;
      lo = (lo + Math.imul(al5, bl4)) | 0;
      mid = (mid + Math.imul(al5, bh4)) | 0;
      mid = (mid + Math.imul(ah5, bl4)) | 0;
      hi = (hi + Math.imul(ah5, bh4)) | 0;
      lo = (lo + Math.imul(al4, bl5)) | 0;
      mid = (mid + Math.imul(al4, bh5)) | 0;
      mid = (mid + Math.imul(ah4, bl5)) | 0;
      hi = (hi + Math.imul(ah4, bh5)) | 0;
      lo = (lo + Math.imul(al3, bl6)) | 0;
      mid = (mid + Math.imul(al3, bh6)) | 0;
      mid = (mid + Math.imul(ah3, bl6)) | 0;
      hi = (hi + Math.imul(ah3, bh6)) | 0;
      lo = (lo + Math.imul(al2, bl7)) | 0;
      mid = (mid + Math.imul(al2, bh7)) | 0;
      mid = (mid + Math.imul(ah2, bl7)) | 0;
      hi = (hi + Math.imul(ah2, bh7)) | 0;
      lo = (lo + Math.imul(al1, bl8)) | 0;
      mid = (mid + Math.imul(al1, bh8)) | 0;
      mid = (mid + Math.imul(ah1, bl8)) | 0;
      hi = (hi + Math.imul(ah1, bh8)) | 0;
      lo = (lo + Math.imul(al0, bl9)) | 0;
      mid = (mid + Math.imul(al0, bh9)) | 0;
      mid = (mid + Math.imul(ah0, bl9)) | 0;
      hi = (hi + Math.imul(ah0, bh9)) | 0;
      var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
      w9 &= 0x3ffffff;
      /* k = 10 */
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = (mid + Math.imul(ah9, bl1)) | 0;
      hi = Math.imul(ah9, bh1);
      lo = (lo + Math.imul(al8, bl2)) | 0;
      mid = (mid + Math.imul(al8, bh2)) | 0;
      mid = (mid + Math.imul(ah8, bl2)) | 0;
      hi = (hi + Math.imul(ah8, bh2)) | 0;
      lo = (lo + Math.imul(al7, bl3)) | 0;
      mid = (mid + Math.imul(al7, bh3)) | 0;
      mid = (mid + Math.imul(ah7, bl3)) | 0;
      hi = (hi + Math.imul(ah7, bh3)) | 0;
      lo = (lo + Math.imul(al6, bl4)) | 0;
      mid = (mid + Math.imul(al6, bh4)) | 0;
      mid = (mid + Math.imul(ah6, bl4)) | 0;
      hi = (hi + Math.imul(ah6, bh4)) | 0;
      lo = (lo + Math.imul(al5, bl5)) | 0;
      mid = (mid + Math.imul(al5, bh5)) | 0;
      mid = (mid + Math.imul(ah5, bl5)) | 0;
      hi = (hi + Math.imul(ah5, bh5)) | 0;
      lo = (lo + Math.imul(al4, bl6)) | 0;
      mid = (mid + Math.imul(al4, bh6)) | 0;
      mid = (mid + Math.imul(ah4, bl6)) | 0;
      hi = (hi + Math.imul(ah4, bh6)) | 0;
      lo = (lo + Math.imul(al3, bl7)) | 0;
      mid = (mid + Math.imul(al3, bh7)) | 0;
      mid = (mid + Math.imul(ah3, bl7)) | 0;
      hi = (hi + Math.imul(ah3, bh7)) | 0;
      lo = (lo + Math.imul(al2, bl8)) | 0;
      mid = (mid + Math.imul(al2, bh8)) | 0;
      mid = (mid + Math.imul(ah2, bl8)) | 0;
      hi = (hi + Math.imul(ah2, bh8)) | 0;
      lo = (lo + Math.imul(al1, bl9)) | 0;
      mid = (mid + Math.imul(al1, bh9)) | 0;
      mid = (mid + Math.imul(ah1, bl9)) | 0;
      hi = (hi + Math.imul(ah1, bh9)) | 0;
      var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
      w10 &= 0x3ffffff;
      /* k = 11 */
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = (mid + Math.imul(ah9, bl2)) | 0;
      hi = Math.imul(ah9, bh2);
      lo = (lo + Math.imul(al8, bl3)) | 0;
      mid = (mid + Math.imul(al8, bh3)) | 0;
      mid = (mid + Math.imul(ah8, bl3)) | 0;
      hi = (hi + Math.imul(ah8, bh3)) | 0;
      lo = (lo + Math.imul(al7, bl4)) | 0;
      mid = (mid + Math.imul(al7, bh4)) | 0;
      mid = (mid + Math.imul(ah7, bl4)) | 0;
      hi = (hi + Math.imul(ah7, bh4)) | 0;
      lo = (lo + Math.imul(al6, bl5)) | 0;
      mid = (mid + Math.imul(al6, bh5)) | 0;
      mid = (mid + Math.imul(ah6, bl5)) | 0;
      hi = (hi + Math.imul(ah6, bh5)) | 0;
      lo = (lo + Math.imul(al5, bl6)) | 0;
      mid = (mid + Math.imul(al5, bh6)) | 0;
      mid = (mid + Math.imul(ah5, bl6)) | 0;
      hi = (hi + Math.imul(ah5, bh6)) | 0;
      lo = (lo + Math.imul(al4, bl7)) | 0;
      mid = (mid + Math.imul(al4, bh7)) | 0;
      mid = (mid + Math.imul(ah4, bl7)) | 0;
      hi = (hi + Math.imul(ah4, bh7)) | 0;
      lo = (lo + Math.imul(al3, bl8)) | 0;
      mid = (mid + Math.imul(al3, bh8)) | 0;
      mid = (mid + Math.imul(ah3, bl8)) | 0;
      hi = (hi + Math.imul(ah3, bh8)) | 0;
      lo = (lo + Math.imul(al2, bl9)) | 0;
      mid = (mid + Math.imul(al2, bh9)) | 0;
      mid = (mid + Math.imul(ah2, bl9)) | 0;
      hi = (hi + Math.imul(ah2, bh9)) | 0;
      var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
      w11 &= 0x3ffffff;
      /* k = 12 */
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = (mid + Math.imul(ah9, bl3)) | 0;
      hi = Math.imul(ah9, bh3);
      lo = (lo + Math.imul(al8, bl4)) | 0;
      mid = (mid + Math.imul(al8, bh4)) | 0;
      mid = (mid + Math.imul(ah8, bl4)) | 0;
      hi = (hi + Math.imul(ah8, bh4)) | 0;
      lo = (lo + Math.imul(al7, bl5)) | 0;
      mid = (mid + Math.imul(al7, bh5)) | 0;
      mid = (mid + Math.imul(ah7, bl5)) | 0;
      hi = (hi + Math.imul(ah7, bh5)) | 0;
      lo = (lo + Math.imul(al6, bl6)) | 0;
      mid = (mid + Math.imul(al6, bh6)) | 0;
      mid = (mid + Math.imul(ah6, bl6)) | 0;
      hi = (hi + Math.imul(ah6, bh6)) | 0;
      lo = (lo + Math.imul(al5, bl7)) | 0;
      mid = (mid + Math.imul(al5, bh7)) | 0;
      mid = (mid + Math.imul(ah5, bl7)) | 0;
      hi = (hi + Math.imul(ah5, bh7)) | 0;
      lo = (lo + Math.imul(al4, bl8)) | 0;
      mid = (mid + Math.imul(al4, bh8)) | 0;
      mid = (mid + Math.imul(ah4, bl8)) | 0;
      hi = (hi + Math.imul(ah4, bh8)) | 0;
      lo = (lo + Math.imul(al3, bl9)) | 0;
      mid = (mid + Math.imul(al3, bh9)) | 0;
      mid = (mid + Math.imul(ah3, bl9)) | 0;
      hi = (hi + Math.imul(ah3, bh9)) | 0;
      var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
      w12 &= 0x3ffffff;
      /* k = 13 */
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = (mid + Math.imul(ah9, bl4)) | 0;
      hi = Math.imul(ah9, bh4);
      lo = (lo + Math.imul(al8, bl5)) | 0;
      mid = (mid + Math.imul(al8, bh5)) | 0;
      mid = (mid + Math.imul(ah8, bl5)) | 0;
      hi = (hi + Math.imul(ah8, bh5)) | 0;
      lo = (lo + Math.imul(al7, bl6)) | 0;
      mid = (mid + Math.imul(al7, bh6)) | 0;
      mid = (mid + Math.imul(ah7, bl6)) | 0;
      hi = (hi + Math.imul(ah7, bh6)) | 0;
      lo = (lo + Math.imul(al6, bl7)) | 0;
      mid = (mid + Math.imul(al6, bh7)) | 0;
      mid = (mid + Math.imul(ah6, bl7)) | 0;
      hi = (hi + Math.imul(ah6, bh7)) | 0;
      lo = (lo + Math.imul(al5, bl8)) | 0;
      mid = (mid + Math.imul(al5, bh8)) | 0;
      mid = (mid + Math.imul(ah5, bl8)) | 0;
      hi = (hi + Math.imul(ah5, bh8)) | 0;
      lo = (lo + Math.imul(al4, bl9)) | 0;
      mid = (mid + Math.imul(al4, bh9)) | 0;
      mid = (mid + Math.imul(ah4, bl9)) | 0;
      hi = (hi + Math.imul(ah4, bh9)) | 0;
      var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
      w13 &= 0x3ffffff;
      /* k = 14 */
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = (mid + Math.imul(ah9, bl5)) | 0;
      hi = Math.imul(ah9, bh5);
      lo = (lo + Math.imul(al8, bl6)) | 0;
      mid = (mid + Math.imul(al8, bh6)) | 0;
      mid = (mid + Math.imul(ah8, bl6)) | 0;
      hi = (hi + Math.imul(ah8, bh6)) | 0;
      lo = (lo + Math.imul(al7, bl7)) | 0;
      mid = (mid + Math.imul(al7, bh7)) | 0;
      mid = (mid + Math.imul(ah7, bl7)) | 0;
      hi = (hi + Math.imul(ah7, bh7)) | 0;
      lo = (lo + Math.imul(al6, bl8)) | 0;
      mid = (mid + Math.imul(al6, bh8)) | 0;
      mid = (mid + Math.imul(ah6, bl8)) | 0;
      hi = (hi + Math.imul(ah6, bh8)) | 0;
      lo = (lo + Math.imul(al5, bl9)) | 0;
      mid = (mid + Math.imul(al5, bh9)) | 0;
      mid = (mid + Math.imul(ah5, bl9)) | 0;
      hi = (hi + Math.imul(ah5, bh9)) | 0;
      var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
      w14 &= 0x3ffffff;
      /* k = 15 */
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = (mid + Math.imul(ah9, bl6)) | 0;
      hi = Math.imul(ah9, bh6);
      lo = (lo + Math.imul(al8, bl7)) | 0;
      mid = (mid + Math.imul(al8, bh7)) | 0;
      mid = (mid + Math.imul(ah8, bl7)) | 0;
      hi = (hi + Math.imul(ah8, bh7)) | 0;
      lo = (lo + Math.imul(al7, bl8)) | 0;
      mid = (mid + Math.imul(al7, bh8)) | 0;
      mid = (mid + Math.imul(ah7, bl8)) | 0;
      hi = (hi + Math.imul(ah7, bh8)) | 0;
      lo = (lo + Math.imul(al6, bl9)) | 0;
      mid = (mid + Math.imul(al6, bh9)) | 0;
      mid = (mid + Math.imul(ah6, bl9)) | 0;
      hi = (hi + Math.imul(ah6, bh9)) | 0;
      var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
      w15 &= 0x3ffffff;
      /* k = 16 */
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = (mid + Math.imul(ah9, bl7)) | 0;
      hi = Math.imul(ah9, bh7);
      lo = (lo + Math.imul(al8, bl8)) | 0;
      mid = (mid + Math.imul(al8, bh8)) | 0;
      mid = (mid + Math.imul(ah8, bl8)) | 0;
      hi = (hi + Math.imul(ah8, bh8)) | 0;
      lo = (lo + Math.imul(al7, bl9)) | 0;
      mid = (mid + Math.imul(al7, bh9)) | 0;
      mid = (mid + Math.imul(ah7, bl9)) | 0;
      hi = (hi + Math.imul(ah7, bh9)) | 0;
      var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
      w16 &= 0x3ffffff;
      /* k = 17 */
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = (mid + Math.imul(ah9, bl8)) | 0;
      hi = Math.imul(ah9, bh8);
      lo = (lo + Math.imul(al8, bl9)) | 0;
      mid = (mid + Math.imul(al8, bh9)) | 0;
      mid = (mid + Math.imul(ah8, bl9)) | 0;
      hi = (hi + Math.imul(ah8, bh9)) | 0;
      var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
      w17 &= 0x3ffffff;
      /* k = 18 */
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = (mid + Math.imul(ah9, bl9)) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
      w18 &= 0x3ffffff;
      o[0] = w0;
      o[1] = w1;
      o[2] = w2;
      o[3] = w3;
      o[4] = w4;
      o[5] = w5;
      o[6] = w6;
      o[7] = w7;
      o[8] = w8;
      o[9] = w9;
      o[10] = w10;
      o[11] = w11;
      o[12] = w12;
      o[13] = w13;
      o[14] = w14;
      o[15] = w15;
      o[16] = w16;
      o[17] = w17;
      o[18] = w18;
      if (c !== 0) {
        o[19] = c;
        out.length++;
      }
      return out;
    };
  
    // Polyfill comb
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
  
    function bigMulTo (self, num, out) {
      out.negative = num.negative ^ self.negative;
      out.length = self.length + num.length;
  
      var carry = 0;
      var hncarry = 0;
      for (var k = 0; k < out.length - 1; k++) {
        // Sum all words with the same `i + j = k` and accumulate `ncarry`,
        // note that ncarry could be >= 0x3ffffff
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 0x3ffffff;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
          var i = k - j;
          var a = self.words[i] | 0;
          var b = num.words[j] | 0;
          var r = a * b;
  
          var lo = r & 0x3ffffff;
          ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
          lo = (lo + rword) | 0;
          rword = lo & 0x3ffffff;
          ncarry = (ncarry + (lo >>> 26)) | 0;
  
          hncarry += ncarry >>> 26;
          ncarry &= 0x3ffffff;
        }
        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }
  
      return out.strip();
    }
  
    function jumboMulTo (self, num, out) {
      var fftm = new FFTM();
      return fftm.mulp(self, num, out);
    }
  
    BN.prototype.mulTo = function mulTo (num, out) {
      var res;
      var len = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len < 63) {
        res = smallMulTo(this, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
  
      return res;
    };
  
    // Cooley-Tukey algorithm for FFT
    // slightly revisited to rely on looping instead of recursion
  
    function FFTM (x, y) {
      this.x = x;
      this.y = y;
    }
  
    FFTM.prototype.makeRBT = function makeRBT (N) {
      var t = new Array(N);
      var l = BN.prototype._countBits(N) - 1;
      for (var i = 0; i < N; i++) {
        t[i] = this.revBin(i, l, N);
      }
  
      return t;
    };
  
    // Returns binary-reversed representation of `x`
    FFTM.prototype.revBin = function revBin (x, l, N) {
      if (x === 0 || x === N - 1) return x;
  
      var rb = 0;
      for (var i = 0; i < l; i++) {
        rb |= (x & 1) << (l - i - 1);
        x >>= 1;
      }
  
      return rb;
    };
  
    // Performs "tweedling" phase, therefore 'emulating'
    // behaviour of the recursive algorithm
    FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
      for (var i = 0; i < N; i++) {
        rtws[i] = rws[rbt[i]];
        itws[i] = iws[rbt[i]];
      }
    };
  
    FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
      this.permute(rbt, rws, iws, rtws, itws, N);
  
      for (var s = 1; s < N; s <<= 1) {
        var l = s << 1;
  
        var rtwdf = Math.cos(2 * Math.PI / l);
        var itwdf = Math.sin(2 * Math.PI / l);
  
        for (var p = 0; p < N; p += l) {
          var rtwdf_ = rtwdf;
          var itwdf_ = itwdf;
  
          for (var j = 0; j < s; j++) {
            var re = rtws[p + j];
            var ie = itws[p + j];
  
            var ro = rtws[p + j + s];
            var io = itws[p + j + s];
  
            var rx = rtwdf_ * ro - itwdf_ * io;
  
            io = rtwdf_ * io + itwdf_ * ro;
            ro = rx;
  
            rtws[p + j] = re + ro;
            itws[p + j] = ie + io;
  
            rtws[p + j + s] = re - ro;
            itws[p + j + s] = ie - io;
  
            /* jshint maxdepth : false */
            if (j !== l) {
              rx = rtwdf * rtwdf_ - itwdf * itwdf_;
  
              itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
              rtwdf_ = rx;
            }
          }
        }
      }
    };
  
    FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
      var N = Math.max(m, n) | 1;
      var odd = N & 1;
      var i = 0;
      for (N = N / 2 | 0; N; N = N >>> 1) {
        i++;
      }
  
      return 1 << i + 1 + odd;
    };
  
    FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
      if (N <= 1) return;
  
      for (var i = 0; i < N / 2; i++) {
        var t = rws[i];
  
        rws[i] = rws[N - i - 1];
        rws[N - i - 1] = t;
  
        t = iws[i];
  
        iws[i] = -iws[N - i - 1];
        iws[N - i - 1] = -t;
      }
    };
  
    FFTM.prototype.normalize13b = function normalize13b (ws, N) {
      var carry = 0;
      for (var i = 0; i < N / 2; i++) {
        var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
          Math.round(ws[2 * i] / N) +
          carry;
  
        ws[i] = w & 0x3ffffff;
  
        if (w < 0x4000000) {
          carry = 0;
        } else {
          carry = w / 0x4000000 | 0;
        }
      }
  
      return ws;
    };
  
    FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
      var carry = 0;
      for (var i = 0; i < len; i++) {
        carry = carry + (ws[i] | 0);
  
        rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
        rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
      }
  
      // Pad with zeroes
      for (i = 2 * len; i < N; ++i) {
        rws[i] = 0;
      }
  
      assert(carry === 0);
      assert((carry & ~0x1fff) === 0);
    };
  
    FFTM.prototype.stub = function stub (N) {
      var ph = new Array(N);
      for (var i = 0; i < N; i++) {
        ph[i] = 0;
      }
  
      return ph;
    };
  
    FFTM.prototype.mulp = function mulp (x, y, out) {
      var N = 2 * this.guessLen13b(x.length, y.length);
  
      var rbt = this.makeRBT(N);
  
      var _ = this.stub(N);
  
      var rws = new Array(N);
      var rwst = new Array(N);
      var iwst = new Array(N);
  
      var nrws = new Array(N);
      var nrwst = new Array(N);
      var niwst = new Array(N);
  
      var rmws = out.words;
      rmws.length = N;
  
      this.convert13b(x.words, x.length, rws, N);
      this.convert13b(y.words, y.length, nrws, N);
  
      this.transform(rws, _, rwst, iwst, N, rbt);
      this.transform(nrws, _, nrwst, niwst, N, rbt);
  
      for (var i = 0; i < N; i++) {
        var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
        iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
        rwst[i] = rx;
      }
  
      this.conjugate(rwst, iwst, N);
      this.transform(rwst, iwst, rmws, _, N, rbt);
      this.conjugate(rmws, _, N);
      this.normalize13b(rmws, N);
  
      out.negative = x.negative ^ y.negative;
      out.length = x.length + y.length;
      return out.strip();
    };
  
    // Multiply `this` by `num`
    BN.prototype.mul = function mul (num) {
      var out = new BN(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
  
    // Multiply employing FFT
    BN.prototype.mulf = function mulf (num) {
      var out = new BN(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
  
    // In-place Multiplication
    BN.prototype.imul = function imul (num) {
      return this.clone().mulTo(num, this);
    };
  
    BN.prototype.imuln = function imuln (num) {
      assert(typeof num === 'number');
      assert(num < 0x4000000);
  
      // Carry
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = (this.words[i] | 0) * num;
        var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
        carry >>= 26;
        carry += (w / 0x4000000) | 0;
        // NOTE: lo is 27bit maximum
        carry += lo >>> 26;
        this.words[i] = lo & 0x3ffffff;
      }
  
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
  
      return this;
    };
  
    BN.prototype.muln = function muln (num) {
      return this.clone().imuln(num);
    };
  
    // `this` * `this`
    BN.prototype.sqr = function sqr () {
      return this.mul(this);
    };
  
    // `this` * `this` in-place
    BN.prototype.isqr = function isqr () {
      return this.imul(this.clone());
    };
  
    // Math.pow(`this`, `num`)
    BN.prototype.pow = function pow (num) {
      var w = toBitArray(num);
      if (w.length === 0) return new BN(1);
  
      // Skip leading zeroes
      var res = this;
      for (var i = 0; i < w.length; i++, res = res.sqr()) {
        if (w[i] !== 0) break;
      }
  
      if (++i < w.length) {
        for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
          if (w[i] === 0) continue;
  
          res = res.mul(q);
        }
      }
  
      return res;
    };
  
    // Shift-left in-place
    BN.prototype.iushln = function iushln (bits) {
      assert(typeof bits === 'number' && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
      var i;
  
      if (r !== 0) {
        var carry = 0;
  
        for (i = 0; i < this.length; i++) {
          var newCarry = this.words[i] & carryMask;
          var c = ((this.words[i] | 0) - newCarry) << r;
          this.words[i] = c | carry;
          carry = newCarry >>> (26 - r);
        }
  
        if (carry) {
          this.words[i] = carry;
          this.length++;
        }
      }
  
      if (s !== 0) {
        for (i = this.length - 1; i >= 0; i--) {
          this.words[i + s] = this.words[i];
        }
  
        for (i = 0; i < s; i++) {
          this.words[i] = 0;
        }
  
        this.length += s;
      }
  
      return this.strip();
    };
  
    BN.prototype.ishln = function ishln (bits) {
      // TODO(indutny): implement me
      assert(this.negative === 0);
      return this.iushln(bits);
    };
  
    // Shift-right in-place
    // NOTE: `hint` is a lowest bit before trailing zeroes
    // NOTE: if `extended` is present - it will be filled with destroyed bits
    BN.prototype.iushrn = function iushrn (bits, hint, extended) {
      assert(typeof bits === 'number' && bits >= 0);
      var h;
      if (hint) {
        h = (hint - (hint % 26)) / 26;
      } else {
        h = 0;
      }
  
      var r = bits % 26;
      var s = Math.min((bits - r) / 26, this.length);
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      var maskedWords = extended;
  
      h -= s;
      h = Math.max(0, h);
  
      // Extended mode, copy masked part
      if (maskedWords) {
        for (var i = 0; i < s; i++) {
          maskedWords.words[i] = this.words[i];
        }
        maskedWords.length = s;
      }
  
      if (s === 0) {
        // No-op, we should not move anything at all
      } else if (this.length > s) {
        this.length -= s;
        for (i = 0; i < this.length; i++) {
          this.words[i] = this.words[i + s];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
  
      var carry = 0;
      for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
        var word = this.words[i] | 0;
        this.words[i] = (carry << (26 - r)) | (word >>> r);
        carry = word & mask;
      }
  
      // Push carried bits as a mask
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
  
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
  
      return this.strip();
    };
  
    BN.prototype.ishrn = function ishrn (bits, hint, extended) {
      // TODO(indutny): implement me
      assert(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
  
    // Shift-left
    BN.prototype.shln = function shln (bits) {
      return this.clone().ishln(bits);
    };
  
    BN.prototype.ushln = function ushln (bits) {
      return this.clone().iushln(bits);
    };
  
    // Shift-right
    BN.prototype.shrn = function shrn (bits) {
      return this.clone().ishrn(bits);
    };
  
    BN.prototype.ushrn = function ushrn (bits) {
      return this.clone().iushrn(bits);
    };
  
    // Test if n bit is set
    BN.prototype.testn = function testn (bit) {
      assert(typeof bit === 'number' && bit >= 0);
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
  
      // Fast case: bit is much higher than all existing words
      if (this.length <= s) return false;
  
      // Check bit and return
      var w = this.words[s];
  
      return !!(w & q);
    };
  
    // Return only lowers bits of number (in-place)
    BN.prototype.imaskn = function imaskn (bits) {
      assert(typeof bits === 'number' && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
  
      assert(this.negative === 0, 'imaskn works only with positive numbers');
  
      if (this.length <= s) {
        return this;
      }
  
      if (r !== 0) {
        s++;
      }
      this.length = Math.min(s, this.length);
  
      if (r !== 0) {
        var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
        this.words[this.length - 1] &= mask;
      }
  
      return this.strip();
    };
  
    // Return only lowers bits of number
    BN.prototype.maskn = function maskn (bits) {
      return this.clone().imaskn(bits);
    };
  
    // Add plain number `num` to `this`
    BN.prototype.iaddn = function iaddn (num) {
      assert(typeof num === 'number');
      assert(num < 0x4000000);
      if (num < 0) return this.isubn(-num);
  
      // Possible sign change
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) < num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
  
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
  
      // Add without checks
      return this._iaddn(num);
    };
  
    BN.prototype._iaddn = function _iaddn (num) {
      this.words[0] += num;
  
      // Carry
      for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
        this.words[i] -= 0x4000000;
        if (i === this.length - 1) {
          this.words[i + 1] = 1;
        } else {
          this.words[i + 1]++;
        }
      }
      this.length = Math.max(this.length, i + 1);
  
      return this;
    };
  
    // Subtract plain number `num` from `this`
    BN.prototype.isubn = function isubn (num) {
      assert(typeof num === 'number');
      assert(num < 0x4000000);
      if (num < 0) return this.iaddn(-num);
  
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
  
      this.words[0] -= num;
  
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        // Carry
        for (var i = 0; i < this.length && this.words[i] < 0; i++) {
          this.words[i] += 0x4000000;
          this.words[i + 1] -= 1;
        }
      }
  
      return this.strip();
    };
  
    BN.prototype.addn = function addn (num) {
      return this.clone().iaddn(num);
    };
  
    BN.prototype.subn = function subn (num) {
      return this.clone().isubn(num);
    };
  
    BN.prototype.iabs = function iabs () {
      this.negative = 0;
  
      return this;
    };
  
    BN.prototype.abs = function abs () {
      return this.clone().iabs();
    };
  
    BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
      var len = num.length + shift;
      var i;
  
      this._expand(len);
  
      var w;
      var carry = 0;
      for (i = 0; i < num.length; i++) {
        w = (this.words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul;
        w -= right & 0x3ffffff;
        carry = (w >> 26) - ((right / 0x4000000) | 0);
        this.words[i + shift] = w & 0x3ffffff;
      }
      for (; i < this.length - shift; i++) {
        w = (this.words[i + shift] | 0) + carry;
        carry = w >> 26;
        this.words[i + shift] = w & 0x3ffffff;
      }
  
      if (carry === 0) return this.strip();
  
      // Subtraction overflow
      assert(carry === -1);
      carry = 0;
      for (i = 0; i < this.length; i++) {
        w = -(this.words[i] | 0) + carry;
        carry = w >> 26;
        this.words[i] = w & 0x3ffffff;
      }
      this.negative = 1;
  
      return this.strip();
    };
  
    BN.prototype._wordDiv = function _wordDiv (num, mode) {
      var shift = this.length - num.length;
  
      var a = this.clone();
      var b = num;
  
      // Normalize
      var bhi = b.words[b.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b = b.ushln(shift);
        a.iushln(shift);
        bhi = b.words[b.length - 1] | 0;
      }
  
      // Initialize quotient
      var m = a.length - b.length;
      var q;
  
      if (mode !== 'mod') {
        q = new BN(null);
        q.length = m + 1;
        q.words = new Array(q.length);
        for (var i = 0; i < q.length; i++) {
          q.words[i] = 0;
        }
      }
  
      var diff = a.clone()._ishlnsubmul(b, 1, m);
      if (diff.negative === 0) {
        a = diff;
        if (q) {
          q.words[m] = 1;
        }
      }
  
      for (var j = m - 1; j >= 0; j--) {
        var qj = (a.words[b.length + j] | 0) * 0x4000000 +
          (a.words[b.length + j - 1] | 0);
  
        // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
        // (0x7ffffff)
        qj = Math.min((qj / bhi) | 0, 0x3ffffff);
  
        a._ishlnsubmul(b, qj, j);
        while (a.negative !== 0) {
          qj--;
          a.negative = 0;
          a._ishlnsubmul(b, 1, j);
          if (!a.isZero()) {
            a.negative ^= 1;
          }
        }
        if (q) {
          q.words[j] = qj;
        }
      }
      if (q) {
        q.strip();
      }
      a.strip();
  
      // Denormalize
      if (mode !== 'div' && shift !== 0) {
        a.iushrn(shift);
      }
  
      return {
        div: q || null,
        mod: a
      };
    };
  
    // NOTE: 1) `mode` can be set to `mod` to request mod only,
    //       to `div` to request div only, or be absent to
    //       request both div & mod
    //       2) `positive` is true if unsigned mod is requested
    BN.prototype.divmod = function divmod (num, mode, positive) {
      assert(!num.isZero());
  
      if (this.isZero()) {
        return {
          div: new BN(0),
          mod: new BN(0)
        };
      }
  
      var div, mod, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
  
        if (mode !== 'mod') {
          div = res.div.neg();
        }
  
        if (mode !== 'div') {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }
  
        return {
          div: div,
          mod: mod
        };
      }
  
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
  
        if (mode !== 'mod') {
          div = res.div.neg();
        }
  
        return {
          div: div,
          mod: res.mod
        };
      }
  
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
  
        if (mode !== 'div') {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }
  
        return {
          div: res.div,
          mod: mod
        };
      }
  
      // Both numbers are positive at this point
  
      // Strip both numbers to approximate shift value
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN(0),
          mod: this
        };
      }
  
      // Very short reduction
      if (num.length === 1) {
        if (mode === 'div') {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
  
        if (mode === 'mod') {
          return {
            div: null,
            mod: new BN(this.modn(num.words[0]))
          };
        }
  
        return {
          div: this.divn(num.words[0]),
          mod: new BN(this.modn(num.words[0]))
        };
      }
  
      return this._wordDiv(num, mode);
    };
  
    // Find `this` / `num`
    BN.prototype.div = function div (num) {
      return this.divmod(num, 'div', false).div;
    };
  
    // Find `this` % `num`
    BN.prototype.mod = function mod (num) {
      return this.divmod(num, 'mod', false).mod;
    };
  
    BN.prototype.umod = function umod (num) {
      return this.divmod(num, 'mod', true).mod;
    };
  
    // Find Round(`this` / `num`)
    BN.prototype.divRound = function divRound (num) {
      var dm = this.divmod(num);
  
      // Fast case - exact division
      if (dm.mod.isZero()) return dm.div;
  
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
  
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half);
  
      // Round down
      if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
  
      // Round up
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
  
    BN.prototype.modn = function modn (num) {
      assert(num <= 0x3ffffff);
      var p = (1 << 26) % num;
  
      var acc = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        acc = (p * acc + (this.words[i] | 0)) % num;
      }
  
      return acc;
    };
  
    // In-place division by number
    BN.prototype.idivn = function idivn (num) {
      assert(num <= 0x3ffffff);
  
      var carry = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var w = (this.words[i] | 0) + carry * 0x4000000;
        this.words[i] = (w / num) | 0;
        carry = w % num;
      }
  
      return this.strip();
    };
  
    BN.prototype.divn = function divn (num) {
      return this.clone().idivn(num);
    };
  
    BN.prototype.egcd = function egcd (p) {
      assert(p.negative === 0);
      assert(!p.isZero());
  
      var x = this;
      var y = p.clone();
  
      if (x.negative !== 0) {
        x = x.umod(p);
      } else {
        x = x.clone();
      }
  
      // A * x + B * y = x
      var A = new BN(1);
      var B = new BN(0);
  
      // C * x + D * y = y
      var C = new BN(0);
      var D = new BN(1);
  
      var g = 0;
  
      while (x.isEven() && y.isEven()) {
        x.iushrn(1);
        y.iushrn(1);
        ++g;
      }
  
      var yp = y.clone();
      var xp = x.clone();
  
      while (!x.isZero()) {
        for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
        if (i > 0) {
          x.iushrn(i);
          while (i-- > 0) {
            if (A.isOdd() || B.isOdd()) {
              A.iadd(yp);
              B.isub(xp);
            }
  
            A.iushrn(1);
            B.iushrn(1);
          }
        }
  
        for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
        if (j > 0) {
          y.iushrn(j);
          while (j-- > 0) {
            if (C.isOdd() || D.isOdd()) {
              C.iadd(yp);
              D.isub(xp);
            }
  
            C.iushrn(1);
            D.iushrn(1);
          }
        }
  
        if (x.cmp(y) >= 0) {
          x.isub(y);
          A.isub(C);
          B.isub(D);
        } else {
          y.isub(x);
          C.isub(A);
          D.isub(B);
        }
      }
  
      return {
        a: C,
        b: D,
        gcd: y.iushln(g)
      };
    };
  
    // This is reduced incarnation of the binary EEA
    // above, designated to invert members of the
    // _prime_ fields F(p) at a maximal speed
    BN.prototype._invmp = function _invmp (p) {
      assert(p.negative === 0);
      assert(!p.isZero());
  
      var a = this;
      var b = p.clone();
  
      if (a.negative !== 0) {
        a = a.umod(p);
      } else {
        a = a.clone();
      }
  
      var x1 = new BN(1);
      var x2 = new BN(0);
  
      var delta = b.clone();
  
      while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
        for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
        if (i > 0) {
          a.iushrn(i);
          while (i-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
  
            x1.iushrn(1);
          }
        }
  
        for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
        if (j > 0) {
          b.iushrn(j);
          while (j-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
  
            x2.iushrn(1);
          }
        }
  
        if (a.cmp(b) >= 0) {
          a.isub(b);
          x1.isub(x2);
        } else {
          b.isub(a);
          x2.isub(x1);
        }
      }
  
      var res;
      if (a.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
  
      if (res.cmpn(0) < 0) {
        res.iadd(p);
      }
  
      return res;
    };
  
    BN.prototype.gcd = function gcd (num) {
      if (this.isZero()) return num.abs();
      if (num.isZero()) return this.abs();
  
      var a = this.clone();
      var b = num.clone();
      a.negative = 0;
      b.negative = 0;
  
      // Remove common factor of two
      for (var shift = 0; a.isEven() && b.isEven(); shift++) {
        a.iushrn(1);
        b.iushrn(1);
      }
  
      do {
        while (a.isEven()) {
          a.iushrn(1);
        }
        while (b.isEven()) {
          b.iushrn(1);
        }
  
        var r = a.cmp(b);
        if (r < 0) {
          // Swap `a` and `b` to make `a` always bigger than `b`
          var t = a;
          a = b;
          b = t;
        } else if (r === 0 || b.cmpn(1) === 0) {
          break;
        }
  
        a.isub(b);
      } while (true);
  
      return b.iushln(shift);
    };
  
    // Invert number in the field F(num)
    BN.prototype.invm = function invm (num) {
      return this.egcd(num).a.umod(num);
    };
  
    BN.prototype.isEven = function isEven () {
      return (this.words[0] & 1) === 0;
    };
  
    BN.prototype.isOdd = function isOdd () {
      return (this.words[0] & 1) === 1;
    };
  
    // And first word and num
    BN.prototype.andln = function andln (num) {
      return this.words[0] & num;
    };
  
    // Increment at the bit position in-line
    BN.prototype.bincn = function bincn (bit) {
      assert(typeof bit === 'number');
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
  
      // Fast case: bit is much higher than all existing words
      if (this.length <= s) {
        this._expand(s + 1);
        this.words[s] |= q;
        return this;
      }
  
      // Add bit and propagate, if needed
      var carry = q;
      for (var i = s; carry !== 0 && i < this.length; i++) {
        var w = this.words[i] | 0;
        w += carry;
        carry = w >>> 26;
        w &= 0x3ffffff;
        this.words[i] = w;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
  
    BN.prototype.isZero = function isZero () {
      return this.length === 1 && this.words[0] === 0;
    };
  
    BN.prototype.cmpn = function cmpn (num) {
      var negative = num < 0;
  
      if (this.negative !== 0 && !negative) return -1;
      if (this.negative === 0 && negative) return 1;
  
      this.strip();
  
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
  
        assert(num <= 0x3ffffff, 'Number is too big');
  
        var w = this.words[0] | 0;
        res = w === num ? 0 : w < num ? -1 : 1;
      }
      if (this.negative !== 0) return -res | 0;
      return res;
    };
  
    // Compare two numbers and return:
    // 1 - if `this` > `num`
    // 0 - if `this` == `num`
    // -1 - if `this` < `num`
    BN.prototype.cmp = function cmp (num) {
      if (this.negative !== 0 && num.negative === 0) return -1;
      if (this.negative === 0 && num.negative !== 0) return 1;
  
      var res = this.ucmp(num);
      if (this.negative !== 0) return -res | 0;
      return res;
    };
  
    // Unsigned comparison
    BN.prototype.ucmp = function ucmp (num) {
      // At this point both numbers have the same sign
      if (this.length > num.length) return 1;
      if (this.length < num.length) return -1;
  
      var res = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var a = this.words[i] | 0;
        var b = num.words[i] | 0;
  
        if (a === b) continue;
        if (a < b) {
          res = -1;
        } else if (a > b) {
          res = 1;
        }
        break;
      }
      return res;
    };
  
    BN.prototype.gtn = function gtn (num) {
      return this.cmpn(num) === 1;
    };
  
    BN.prototype.gt = function gt (num) {
      return this.cmp(num) === 1;
    };
  
    BN.prototype.gten = function gten (num) {
      return this.cmpn(num) >= 0;
    };
  
    BN.prototype.gte = function gte (num) {
      return this.cmp(num) >= 0;
    };
  
    BN.prototype.ltn = function ltn (num) {
      return this.cmpn(num) === -1;
    };
  
    BN.prototype.lt = function lt (num) {
      return this.cmp(num) === -1;
    };
  
    BN.prototype.lten = function lten (num) {
      return this.cmpn(num) <= 0;
    };
  
    BN.prototype.lte = function lte (num) {
      return this.cmp(num) <= 0;
    };
  
    BN.prototype.eqn = function eqn (num) {
      return this.cmpn(num) === 0;
    };
  
    BN.prototype.eq = function eq (num) {
      return this.cmp(num) === 0;
    };
  
    //
    // A reduce context, could be using montgomery or something better, depending
    // on the `m` itself.
    //
    BN.red = function red (num) {
      return new Red(num);
    };
  
    BN.prototype.toRed = function toRed (ctx) {
      assert(!this.red, 'Already a number in reduction context');
      assert(this.negative === 0, 'red works only with positives');
      return ctx.convertTo(this)._forceRed(ctx);
    };
  
    BN.prototype.fromRed = function fromRed () {
      assert(this.red, 'fromRed works only with numbers in reduction context');
      return this.red.convertFrom(this);
    };
  
    BN.prototype._forceRed = function _forceRed (ctx) {
      this.red = ctx;
      return this;
    };
  
    BN.prototype.forceRed = function forceRed (ctx) {
      assert(!this.red, 'Already a number in reduction context');
      return this._forceRed(ctx);
    };
  
    BN.prototype.redAdd = function redAdd (num) {
      assert(this.red, 'redAdd works only with red numbers');
      return this.red.add(this, num);
    };
  
    BN.prototype.redIAdd = function redIAdd (num) {
      assert(this.red, 'redIAdd works only with red numbers');
      return this.red.iadd(this, num);
    };
  
    BN.prototype.redSub = function redSub (num) {
      assert(this.red, 'redSub works only with red numbers');
      return this.red.sub(this, num);
    };
  
    BN.prototype.redISub = function redISub (num) {
      assert(this.red, 'redISub works only with red numbers');
      return this.red.isub(this, num);
    };
  
    BN.prototype.redShl = function redShl (num) {
      assert(this.red, 'redShl works only with red numbers');
      return this.red.shl(this, num);
    };
  
    BN.prototype.redMul = function redMul (num) {
      assert(this.red, 'redMul works only with red numbers');
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
  
    BN.prototype.redIMul = function redIMul (num) {
      assert(this.red, 'redMul works only with red numbers');
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
  
    BN.prototype.redSqr = function redSqr () {
      assert(this.red, 'redSqr works only with red numbers');
      this.red._verify1(this);
      return this.red.sqr(this);
    };
  
    BN.prototype.redISqr = function redISqr () {
      assert(this.red, 'redISqr works only with red numbers');
      this.red._verify1(this);
      return this.red.isqr(this);
    };
  
    // Square root over p
    BN.prototype.redSqrt = function redSqrt () {
      assert(this.red, 'redSqrt works only with red numbers');
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
  
    BN.prototype.redInvm = function redInvm () {
      assert(this.red, 'redInvm works only with red numbers');
      this.red._verify1(this);
      return this.red.invm(this);
    };
  
    // Return negative clone of `this` % `red modulo`
    BN.prototype.redNeg = function redNeg () {
      assert(this.red, 'redNeg works only with red numbers');
      this.red._verify1(this);
      return this.red.neg(this);
    };
  
    BN.prototype.redPow = function redPow (num) {
      assert(this.red && !num.red, 'redPow(normalNum)');
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
  
    // Prime numbers with efficient reduction
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
  
    // Pseudo-Mersenne prime
    function MPrime (name, p) {
      // P = 2 ^ N - K
      this.name = name;
      this.p = new BN(p, 16);
      this.n = this.p.bitLength();
      this.k = new BN(1).iushln(this.n).isub(this.p);
  
      this.tmp = this._tmp();
    }
  
    MPrime.prototype._tmp = function _tmp () {
      var tmp = new BN(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
  
    MPrime.prototype.ireduce = function ireduce (num) {
      // Assumes that `num` is less than `P^2`
      // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
      var r = num;
      var rlen;
  
      do {
        this.split(r, this.tmp);
        r = this.imulK(r);
        r = r.iadd(this.tmp);
        rlen = r.bitLength();
      } while (rlen > this.n);
  
      var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
      if (cmp === 0) {
        r.words[0] = 0;
        r.length = 1;
      } else if (cmp > 0) {
        r.isub(this.p);
      } else {
        r.strip();
      }
  
      return r;
    };
  
    MPrime.prototype.split = function split (input, out) {
      input.iushrn(this.n, 0, out);
    };
  
    MPrime.prototype.imulK = function imulK (num) {
      return num.imul(this.k);
    };
  
    function K256 () {
      MPrime.call(
        this,
        'k256',
        'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
    }
    inherits(K256, MPrime);
  
    K256.prototype.split = function split (input, output) {
      // 256 = 9 * 26 + 22
      var mask = 0x3fffff;
  
      var outLen = Math.min(input.length, 9);
      for (var i = 0; i < outLen; i++) {
        output.words[i] = input.words[i];
      }
      output.length = outLen;
  
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
  
      // Shift by 9 limbs
      var prev = input.words[9];
      output.words[output.length++] = prev & mask;
  
      for (i = 10; i < input.length; i++) {
        var next = input.words[i] | 0;
        input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
        prev = next;
      }
      prev >>>= 22;
      input.words[i - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
  
    K256.prototype.imulK = function imulK (num) {
      // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
  
      // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
      var lo = 0;
      for (var i = 0; i < num.length; i++) {
        var w = num.words[i] | 0;
        lo += w * 0x3d1;
        num.words[i] = lo & 0x3ffffff;
        lo = w * 0x40 + ((lo / 0x4000000) | 0);
      }
  
      // Fast length reduction
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
  
    function P224 () {
      MPrime.call(
        this,
        'p224',
        'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
    }
    inherits(P224, MPrime);
  
    function P192 () {
      MPrime.call(
        this,
        'p192',
        'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
    }
    inherits(P192, MPrime);
  
    function P25519 () {
      // 2 ^ 255 - 19
      MPrime.call(
        this,
        '25519',
        '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
    }
    inherits(P25519, MPrime);
  
    P25519.prototype.imulK = function imulK (num) {
      // K = 0x13
      var carry = 0;
      for (var i = 0; i < num.length; i++) {
        var hi = (num.words[i] | 0) * 0x13 + carry;
        var lo = hi & 0x3ffffff;
        hi >>>= 26;
  
        num.words[i] = lo;
        carry = hi;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
  
    // Exported mostly for testing purposes, use plain name instead
    BN._prime = function prime (name) {
      // Cached version of prime
      if (primes[name]) return primes[name];
  
      var prime;
      if (name === 'k256') {
        prime = new K256();
      } else if (name === 'p224') {
        prime = new P224();
      } else if (name === 'p192') {
        prime = new P192();
      } else if (name === 'p25519') {
        prime = new P25519();
      } else {
        throw new Error('Unknown prime ' + name);
      }
      primes[name] = prime;
  
      return prime;
    };
  
    //
    // Base reduction engine
    //
    function Red (m) {
      if (typeof m === 'string') {
        var prime = BN._prime(m);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert(m.gtn(1), 'modulus must be greater than 1');
        this.m = m;
        this.prime = null;
      }
    }
  
    Red.prototype._verify1 = function _verify1 (a) {
      assert(a.negative === 0, 'red works only with positives');
      assert(a.red, 'red works only with red numbers');
    };
  
    Red.prototype._verify2 = function _verify2 (a, b) {
      assert((a.negative | b.negative) === 0, 'red works only with positives');
      assert(a.red && a.red === b.red,
        'red works only with red numbers');
    };
  
    Red.prototype.imod = function imod (a) {
      if (this.prime) return this.prime.ireduce(a)._forceRed(this);
      return a.umod(this.m)._forceRed(this);
    };
  
    Red.prototype.neg = function neg (a) {
      if (a.isZero()) {
        return a.clone();
      }
  
      return this.m.sub(a)._forceRed(this);
    };
  
    Red.prototype.add = function add (a, b) {
      this._verify2(a, b);
  
      var res = a.add(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
  
    Red.prototype.iadd = function iadd (a, b) {
      this._verify2(a, b);
  
      var res = a.iadd(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
  
    Red.prototype.sub = function sub (a, b) {
      this._verify2(a, b);
  
      var res = a.sub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
  
    Red.prototype.isub = function isub (a, b) {
      this._verify2(a, b);
  
      var res = a.isub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
  
    Red.prototype.shl = function shl (a, num) {
      this._verify1(a);
      return this.imod(a.ushln(num));
    };
  
    Red.prototype.imul = function imul (a, b) {
      this._verify2(a, b);
      return this.imod(a.imul(b));
    };
  
    Red.prototype.mul = function mul (a, b) {
      this._verify2(a, b);
      return this.imod(a.mul(b));
    };
  
    Red.prototype.isqr = function isqr (a) {
      return this.imul(a, a.clone());
    };
  
    Red.prototype.sqr = function sqr (a) {
      return this.mul(a, a);
    };
  
    Red.prototype.sqrt = function sqrt (a) {
      if (a.isZero()) return a.clone();
  
      var mod3 = this.m.andln(3);
      assert(mod3 % 2 === 1);
  
      // Fast case
      if (mod3 === 3) {
        var pow = this.m.add(new BN(1)).iushrn(2);
        return this.pow(a, pow);
      }
  
      // Tonelli-Shanks algorithm (Totally unoptimized and slow)
      //
      // Find Q and S, that Q * 2 ^ S = (P - 1)
      var q = this.m.subn(1);
      var s = 0;
      while (!q.isZero() && q.andln(1) === 0) {
        s++;
        q.iushrn(1);
      }
      assert(!q.isZero());
  
      var one = new BN(1).toRed(this);
      var nOne = one.redNeg();
  
      // Find quadratic non-residue
      // NOTE: Max is such because of generalized Riemann hypothesis.
      var lpow = this.m.subn(1).iushrn(1);
      var z = this.m.bitLength();
      z = new BN(2 * z * z).toRed(this);
  
      while (this.pow(z, lpow).cmp(nOne) !== 0) {
        z.redIAdd(nOne);
      }
  
      var c = this.pow(z, q);
      var r = this.pow(a, q.addn(1).iushrn(1));
      var t = this.pow(a, q);
      var m = s;
      while (t.cmp(one) !== 0) {
        var tmp = t;
        for (var i = 0; tmp.cmp(one) !== 0; i++) {
          tmp = tmp.redSqr();
        }
        assert(i < m);
        var b = this.pow(c, new BN(1).iushln(m - i - 1));
  
        r = r.redMul(b);
        c = b.redSqr();
        t = t.redMul(c);
        m = i;
      }
  
      return r;
    };
  
    Red.prototype.invm = function invm (a) {
      var inv = a._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
  
    Red.prototype.pow = function pow (a, num) {
      if (num.isZero()) return new BN(1).toRed(this);
      if (num.cmpn(1) === 0) return a.clone();
  
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN(1).toRed(this);
      wnd[1] = a;
      for (var i = 2; i < wnd.length; i++) {
        wnd[i] = this.mul(wnd[i - 1], a);
      }
  
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
  
      for (i = num.length - 1; i >= 0; i--) {
        var word = num.words[i];
        for (var j = start - 1; j >= 0; j--) {
          var bit = (word >> j) & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
  
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
  
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
  
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
  
      return res;
    };
  
    Red.prototype.convertTo = function convertTo (num) {
      var r = num.umod(this.m);
  
      return r === num ? r.clone() : r;
    };
  
    Red.prototype.convertFrom = function convertFrom (num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
  
    //
    // Montgomery method engine
    //
  
    BN.mont = function mont (num) {
      return new Mont(num);
    };
  
    function Mont (m) {
      Red.call(this, m);
  
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - (this.shift % 26);
      }
  
      this.r = new BN(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
  
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits(Mont, Red);
  
    Mont.prototype.convertTo = function convertTo (num) {
      return this.imod(num.ushln(this.shift));
    };
  
    Mont.prototype.convertFrom = function convertFrom (num) {
      var r = this.imod(num.mul(this.rinv));
      r.red = null;
      return r;
    };
  
    Mont.prototype.imul = function imul (a, b) {
      if (a.isZero() || b.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }
  
      var t = a.imul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
  
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
  
      return res._forceRed(this);
    };
  
    Mont.prototype.mul = function mul (a, b) {
      if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
  
      var t = a.mul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
  
      return res._forceRed(this);
    };
  
    Mont.prototype.invm = function invm (a) {
      // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
      var res = this.imod(a._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(typeof module === 'undefined' || module, this);
  
  },{"buffer":2}],188:[function(require,module,exports){
  var r;
  
  module.exports = function rand(len) {
    if (!r)
      r = new Rand(null);
  
    return r.generate(len);
  };
  
  function Rand(rand) {
    this.rand = rand;
  }
  module.exports.Rand = Rand;
  
  Rand.prototype.generate = function generate(len) {
    return this._rand(len);
  };
  
  // Emulate crypto API using randy
  Rand.prototype._rand = function _rand(n) {
    if (this.rand.getBytes)
      return this.rand.getBytes(n);
  
    var res = new Uint8Array(n);
    for (var i = 0; i < res.length; i++)
      res[i] = this.rand.getByte();
    return res;
  };
  
  if (typeof self === 'object') {
    if (self.crypto && self.crypto.getRandomValues) {
      // Modern browsers
      Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        self.crypto.getRandomValues(arr);
        return arr;
      };
    } else if (self.msCrypto && self.msCrypto.getRandomValues) {
      // IE
      Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        self.msCrypto.getRandomValues(arr);
        return arr;
      };
  
    // Safari's WebWorkers do not have `crypto`
    } else if (typeof window === 'object') {
      // Old junk
      Rand.prototype._rand = function() {
        throw new Error('Not implemented yet');
      };
    }
  } else {
    // Node.js or Web worker with no crypto support
    try {
      var crypto = require('crypto');
      if (typeof crypto.randomBytes !== 'function')
        throw new Error('Not supported');
  
      Rand.prototype._rand = function _rand(n) {
        return crypto.randomBytes(n);
      };
    } catch (e) {
    }
  }
  
  },{"crypto":2}],189:[function(require,module,exports){
  var basex = require('base-x')
  var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
  
  module.exports = basex(ALPHABET)
  
  },{"base-x":98}],190:[function(require,module,exports){
  'use strict'
  
  var base58 = require('bs58')
  var Buffer = require('safe-buffer').Buffer
  
  module.exports = function (checksumFn) {
    // Encode a buffer as a base58-check encoded string
    function encode (payload) {
      var checksum = checksumFn(payload)
  
      return base58.encode(Buffer.concat([
        payload,
        checksum
      ], payload.length + 4))
    }
  
    function decodeRaw (buffer) {
      var payload = buffer.slice(0, -4)
      var checksum = buffer.slice(-4)
      var newChecksum = checksumFn(payload)
  
      if (checksum[0] ^ newChecksum[0] |
          checksum[1] ^ newChecksum[1] |
          checksum[2] ^ newChecksum[2] |
          checksum[3] ^ newChecksum[3]) return
  
      return payload
    }
  
    // Decode a base58-check encoded string to a buffer, no result if checksum is wrong
    function decodeUnsafe (string) {
      var buffer = base58.decodeUnsafe(string)
      if (!buffer) return
  
      return decodeRaw(buffer)
    }
  
    function decode (string) {
      var buffer = base58.decode(string)
      var payload = decodeRaw(buffer, checksumFn)
      if (!payload) throw new Error('Invalid checksum')
      return payload
    }
  
    return {
      encode: encode,
      decode: decode,
      decodeUnsafe: decodeUnsafe
    }
  }
  
  },{"bs58":189,"safe-buffer":281}],191:[function(require,module,exports){
  'use strict'
  
  var createHash = require('create-hash')
  var bs58checkBase = require('./base')
  
  // SHA256(SHA256(buffer))
  function sha256x2 (buffer) {
    var tmp = createHash('sha256').update(buffer).digest()
    return createHash('sha256').update(tmp).digest()
  }
  
  module.exports = bs58checkBase(sha256x2)
  
  },{"./base":190,"create-hash":193}],192:[function(require,module,exports){
  var Buffer = require('safe-buffer').Buffer
  var Transform = require('stream').Transform
  var StringDecoder = require('string_decoder').StringDecoder
  var inherits = require('inherits')
  
  function CipherBase (hashMode) {
    Transform.call(this)
    this.hashMode = typeof hashMode === 'string'
    if (this.hashMode) {
      this[hashMode] = this._finalOrDigest
    } else {
      this.final = this._finalOrDigest
    }
    if (this._final) {
      this.__final = this._final
      this._final = null
    }
    this._decoder = null
    this._encoding = null
  }
  inherits(CipherBase, Transform)
  
  CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
    if (typeof data === 'string') {
      data = Buffer.from(data, inputEnc)
    }
  
    var outData = this._update(data)
    if (this.hashMode) return this
  
    if (outputEnc) {
      outData = this._toString(outData, outputEnc)
    }
  
    return outData
  }
  
  CipherBase.prototype.setAutoPadding = function () {}
  CipherBase.prototype.getAuthTag = function () {
    throw new Error('trying to get auth tag in unsupported state')
  }
  
  CipherBase.prototype.setAuthTag = function () {
    throw new Error('trying to set auth tag in unsupported state')
  }
  
  CipherBase.prototype.setAAD = function () {
    throw new Error('trying to set aad in unsupported state')
  }
  
  CipherBase.prototype._transform = function (data, _, next) {
    var err
    try {
      if (this.hashMode) {
        this._update(data)
      } else {
        this.push(this._update(data))
      }
    } catch (e) {
      err = e
    } finally {
      next(err)
    }
  }
  CipherBase.prototype._flush = function (done) {
    var err
    try {
      this.push(this.__final())
    } catch (e) {
      err = e
    }
  
    done(err)
  }
  CipherBase.prototype._finalOrDigest = function (outputEnc) {
    var outData = this.__final() || Buffer.alloc(0)
    if (outputEnc) {
      outData = this._toString(outData, outputEnc, true)
    }
    return outData
  }
  
  CipherBase.prototype._toString = function (value, enc, fin) {
    if (!this._decoder) {
      this._decoder = new StringDecoder(enc)
      this._encoding = enc
    }
  
    if (this._encoding !== enc) throw new Error('can\'t switch encodings')
  
    var out = this._decoder.write(value)
    if (fin) {
      out += this._decoder.end()
    }
  
    return out
  }
  
  module.exports = CipherBase
  
  },{"inherits":280,"safe-buffer":281,"stream":28,"string_decoder":29}],193:[function(require,module,exports){
  'use strict'
  var inherits = require('inherits')
  var MD5 = require('md5.js')
  var RIPEMD160 = require('ripemd160')
  var sha = require('sha.js')
  var Base = require('cipher-base')
  
  function Hash (hash) {
    Base.call(this, 'digest')
  
    this._hash = hash
  }
  
  inherits(Hash, Base)
  
  Hash.prototype._update = function (data) {
    this._hash.update(data)
  }
  
  Hash.prototype._final = function () {
    return this._hash.digest()
  }
  
  module.exports = function createHash (alg) {
    alg = alg.toLowerCase()
    if (alg === 'md5') return new MD5()
    if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160()
  
    return new Hash(sha(alg))
  }
  
  },{"cipher-base":192,"inherits":280,"md5.js":240,"ripemd160":253,"sha.js":257}],194:[function(require,module,exports){
  var MD5 = require('md5.js')
  
  module.exports = function (buffer) {
    return new MD5().update(buffer).digest()
  }
  
  },{"md5.js":240}],195:[function(require,module,exports){
  'use strict'
  var inherits = require('inherits')
  var Legacy = require('./legacy')
  var Base = require('cipher-base')
  var Buffer = require('safe-buffer').Buffer
  var md5 = require('create-hash/md5')
  var RIPEMD160 = require('ripemd160')
  
  var sha = require('sha.js')
  
  var ZEROS = Buffer.alloc(128)
  
  function Hmac (alg, key) {
    Base.call(this, 'digest')
    if (typeof key === 'string') {
      key = Buffer.from(key)
    }
  
    var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64
  
    this._alg = alg
    this._key = key
    if (key.length > blocksize) {
      var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
      key = hash.update(key).digest()
    } else if (key.length < blocksize) {
      key = Buffer.concat([key, ZEROS], blocksize)
    }
  
    var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
    var opad = this._opad = Buffer.allocUnsafe(blocksize)
  
    for (var i = 0; i < blocksize; i++) {
      ipad[i] = key[i] ^ 0x36
      opad[i] = key[i] ^ 0x5C
    }
    this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
    this._hash.update(ipad)
  }
  
  inherits(Hmac, Base)
  
  Hmac.prototype._update = function (data) {
    this._hash.update(data)
  }
  
  Hmac.prototype._final = function () {
    var h = this._hash.digest()
    var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg)
    return hash.update(this._opad).update(h).digest()
  }
  
  module.exports = function createHmac (alg, key) {
    alg = alg.toLowerCase()
    if (alg === 'rmd160' || alg === 'ripemd160') {
      return new Hmac('rmd160', key)
    }
    if (alg === 'md5') {
      return new Legacy(md5, key)
    }
    return new Hmac(alg, key)
  }
  
  },{"./legacy":196,"cipher-base":192,"create-hash/md5":194,"inherits":280,"ripemd160":253,"safe-buffer":281,"sha.js":257}],196:[function(require,module,exports){
  'use strict'
  var inherits = require('inherits')
  var Buffer = require('safe-buffer').Buffer
  
  var Base = require('cipher-base')
  
  var ZEROS = Buffer.alloc(128)
  var blocksize = 64
  
  function Hmac (alg, key) {
    Base.call(this, 'digest')
    if (typeof key === 'string') {
      key = Buffer.from(key)
    }
  
    this._alg = alg
    this._key = key
  
    if (key.length > blocksize) {
      key = alg(key)
    } else if (key.length < blocksize) {
      key = Buffer.concat([key, ZEROS], blocksize)
    }
  
    var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
    var opad = this._opad = Buffer.allocUnsafe(blocksize)
  
    for (var i = 0; i < blocksize; i++) {
      ipad[i] = key[i] ^ 0x36
      opad[i] = key[i] ^ 0x5C
    }
  
    this._hash = [ipad]
  }
  
  inherits(Hmac, Base)
  
  Hmac.prototype._update = function (data) {
    this._hash.push(data)
  }
  
  Hmac.prototype._final = function () {
    var h = this._alg(Buffer.concat(this._hash))
    return this._alg(Buffer.concat([this._opad, h]))
  }
  module.exports = Hmac
  
  },{"cipher-base":192,"inherits":280,"safe-buffer":281}],197:[function(require,module,exports){
  (function(self) {
  
  var irrelevant = (function (exports) {
    var support = {
      searchParams: 'URLSearchParams' in self,
      iterable: 'Symbol' in self && 'iterator' in Symbol,
      blob:
        'FileReader' in self &&
        'Blob' in self &&
        (function() {
          try {
            new Blob();
            return true
          } catch (e) {
            return false
          }
        })(),
      formData: 'FormData' in self,
      arrayBuffer: 'ArrayBuffer' in self
    };
  
    function isDataView(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj)
    }
  
    if (support.arrayBuffer) {
      var viewClasses = [
        '[object Int8Array]',
        '[object Uint8Array]',
        '[object Uint8ClampedArray]',
        '[object Int16Array]',
        '[object Uint16Array]',
        '[object Int32Array]',
        '[object Uint32Array]',
        '[object Float32Array]',
        '[object Float64Array]'
      ];
  
      var isArrayBufferView =
        ArrayBuffer.isView ||
        function(obj) {
          return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
        };
    }
  
    function normalizeName(name) {
      if (typeof name !== 'string') {
        name = String(name);
      }
      if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
        throw new TypeError('Invalid character in header field name')
      }
      return name.toLowerCase()
    }
  
    function normalizeValue(value) {
      if (typeof value !== 'string') {
        value = String(value);
      }
      return value
    }
  
    // Build a destructive iterator for the value list
    function iteratorFor(items) {
      var iterator = {
        next: function() {
          var value = items.shift();
          return {done: value === undefined, value: value}
        }
      };
  
      if (support.iterable) {
        iterator[Symbol.iterator] = function() {
          return iterator
        };
      }
  
      return iterator
    }
  
    function Headers(headers) {
      this.map = {};
  
      if (headers instanceof Headers) {
        headers.forEach(function(value, name) {
          this.append(name, value);
        }, this);
      } else if (Array.isArray(headers)) {
        headers.forEach(function(header) {
          this.append(header[0], header[1]);
        }, this);
      } else if (headers) {
        Object.getOwnPropertyNames(headers).forEach(function(name) {
          this.append(name, headers[name]);
        }, this);
      }
    }
  
    Headers.prototype.append = function(name, value) {
      name = normalizeName(name);
      value = normalizeValue(value);
      var oldValue = this.map[name];
      this.map[name] = oldValue ? oldValue + ', ' + value : value;
    };
  
    Headers.prototype['delete'] = function(name) {
      delete this.map[normalizeName(name)];
    };
  
    Headers.prototype.get = function(name) {
      name = normalizeName(name);
      return this.has(name) ? this.map[name] : null
    };
  
    Headers.prototype.has = function(name) {
      return this.map.hasOwnProperty(normalizeName(name))
    };
  
    Headers.prototype.set = function(name, value) {
      this.map[normalizeName(name)] = normalizeValue(value);
    };
  
    Headers.prototype.forEach = function(callback, thisArg) {
      for (var name in this.map) {
        if (this.map.hasOwnProperty(name)) {
          callback.call(thisArg, this.map[name], name, this);
        }
      }
    };
  
    Headers.prototype.keys = function() {
      var items = [];
      this.forEach(function(value, name) {
        items.push(name);
      });
      return iteratorFor(items)
    };
  
    Headers.prototype.values = function() {
      var items = [];
      this.forEach(function(value) {
        items.push(value);
      });
      return iteratorFor(items)
    };
  
    Headers.prototype.entries = function() {
      var items = [];
      this.forEach(function(value, name) {
        items.push([name, value]);
      });
      return iteratorFor(items)
    };
  
    if (support.iterable) {
      Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    }
  
    function consumed(body) {
      if (body.bodyUsed) {
        return Promise.reject(new TypeError('Already read'))
      }
      body.bodyUsed = true;
    }
  
    function fileReaderReady(reader) {
      return new Promise(function(resolve, reject) {
        reader.onload = function() {
          resolve(reader.result);
        };
        reader.onerror = function() {
          reject(reader.error);
        };
      })
    }
  
    function readBlobAsArrayBuffer(blob) {
      var reader = new FileReader();
      var promise = fileReaderReady(reader);
      reader.readAsArrayBuffer(blob);
      return promise
    }
  
    function readBlobAsText(blob) {
      var reader = new FileReader();
      var promise = fileReaderReady(reader);
      reader.readAsText(blob);
      return promise
    }
  
    function readArrayBufferAsText(buf) {
      var view = new Uint8Array(buf);
      var chars = new Array(view.length);
  
      for (var i = 0; i < view.length; i++) {
        chars[i] = String.fromCharCode(view[i]);
      }
      return chars.join('')
    }
  
    function bufferClone(buf) {
      if (buf.slice) {
        return buf.slice(0)
      } else {
        var view = new Uint8Array(buf.byteLength);
        view.set(new Uint8Array(buf));
        return view.buffer
      }
    }
  
    function Body() {
      this.bodyUsed = false;
  
      this._initBody = function(body) {
        this._bodyInit = body;
        if (!body) {
          this._bodyText = '';
        } else if (typeof body === 'string') {
          this._bodyText = body;
        } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
          this._bodyBlob = body;
        } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
          this._bodyFormData = body;
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this._bodyText = body.toString();
        } else if (support.arrayBuffer && support.blob && isDataView(body)) {
          this._bodyArrayBuffer = bufferClone(body.buffer);
          // IE 10-11 can't handle a DataView body.
          this._bodyInit = new Blob([this._bodyArrayBuffer]);
        } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
          this._bodyArrayBuffer = bufferClone(body);
        } else {
          this._bodyText = body = Object.prototype.toString.call(body);
        }
  
        if (!this.headers.get('content-type')) {
          if (typeof body === 'string') {
            this.headers.set('content-type', 'text/plain;charset=UTF-8');
          } else if (this._bodyBlob && this._bodyBlob.type) {
            this.headers.set('content-type', this._bodyBlob.type);
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
          }
        }
      };
  
      if (support.blob) {
        this.blob = function() {
          var rejected = consumed(this);
          if (rejected) {
            return rejected
          }
  
          if (this._bodyBlob) {
            return Promise.resolve(this._bodyBlob)
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(new Blob([this._bodyArrayBuffer]))
          } else if (this._bodyFormData) {
            throw new Error('could not read FormData body as blob')
          } else {
            return Promise.resolve(new Blob([this._bodyText]))
          }
        };
  
        this.arrayBuffer = function() {
          if (this._bodyArrayBuffer) {
            return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
          } else {
            return this.blob().then(readBlobAsArrayBuffer)
          }
        };
      }
  
      this.text = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }
  
        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as text')
        } else {
          return Promise.resolve(this._bodyText)
        }
      };
  
      if (support.formData) {
        this.formData = function() {
          return this.text().then(decode)
        };
      }
  
      this.json = function() {
        return this.text().then(JSON.parse)
      };
  
      return this
    }
  
    // HTTP methods whose capitalization should be normalized
    var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];
  
    function normalizeMethod(method) {
      var upcased = method.toUpperCase();
      return methods.indexOf(upcased) > -1 ? upcased : method
    }
  
    function Request(input, options) {
      options = options || {};
      var body = options.body;
  
      if (input instanceof Request) {
        if (input.bodyUsed) {
          throw new TypeError('Already read')
        }
        this.url = input.url;
        this.credentials = input.credentials;
        if (!options.headers) {
          this.headers = new Headers(input.headers);
        }
        this.method = input.method;
        this.mode = input.mode;
        this.signal = input.signal;
        if (!body && input._bodyInit != null) {
          body = input._bodyInit;
          input.bodyUsed = true;
        }
      } else {
        this.url = String(input);
      }
  
      this.credentials = options.credentials || this.credentials || 'same-origin';
      if (options.headers || !this.headers) {
        this.headers = new Headers(options.headers);
      }
      this.method = normalizeMethod(options.method || this.method || 'GET');
      this.mode = options.mode || this.mode || null;
      this.signal = options.signal || this.signal;
      this.referrer = null;
  
      if ((this.method === 'GET' || this.method === 'HEAD') && body) {
        throw new TypeError('Body not allowed for GET or HEAD requests')
      }
      this._initBody(body);
    }
  
    Request.prototype.clone = function() {
      return new Request(this, {body: this._bodyInit})
    };
  
    function decode(body) {
      var form = new FormData();
      body
        .trim()
        .split('&')
        .forEach(function(bytes) {
          if (bytes) {
            var split = bytes.split('=');
            var name = split.shift().replace(/\+/g, ' ');
            var value = split.join('=').replace(/\+/g, ' ');
            form.append(decodeURIComponent(name), decodeURIComponent(value));
          }
        });
      return form
    }
  
    function parseHeaders(rawHeaders) {
      var headers = new Headers();
      // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
      // https://tools.ietf.org/html/rfc7230#section-3.2
      var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
      preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
        var parts = line.split(':');
        var key = parts.shift().trim();
        if (key) {
          var value = parts.join(':').trim();
          headers.append(key, value);
        }
      });
      return headers
    }
  
    Body.call(Request.prototype);
  
    function Response(bodyInit, options) {
      if (!options) {
        options = {};
      }
  
      this.type = 'default';
      this.status = options.status === undefined ? 200 : options.status;
      this.ok = this.status >= 200 && this.status < 300;
      this.statusText = 'statusText' in options ? options.statusText : 'OK';
      this.headers = new Headers(options.headers);
      this.url = options.url || '';
      this._initBody(bodyInit);
    }
  
    Body.call(Response.prototype);
  
    Response.prototype.clone = function() {
      return new Response(this._bodyInit, {
        status: this.status,
        statusText: this.statusText,
        headers: new Headers(this.headers),
        url: this.url
      })
    };
  
    Response.error = function() {
      var response = new Response(null, {status: 0, statusText: ''});
      response.type = 'error';
      return response
    };
  
    var redirectStatuses = [301, 302, 303, 307, 308];
  
    Response.redirect = function(url, status) {
      if (redirectStatuses.indexOf(status) === -1) {
        throw new RangeError('Invalid status code')
      }
  
      return new Response(null, {status: status, headers: {location: url}})
    };
  
    exports.DOMException = self.DOMException;
    try {
      new exports.DOMException();
    } catch (err) {
      exports.DOMException = function(message, name) {
        this.message = message;
        this.name = name;
        var error = Error(message);
        this.stack = error.stack;
      };
      exports.DOMException.prototype = Object.create(Error.prototype);
      exports.DOMException.prototype.constructor = exports.DOMException;
    }
  
    function fetch(input, init) {
      return new Promise(function(resolve, reject) {
        var request = new Request(input, init);
  
        if (request.signal && request.signal.aborted) {
          return reject(new exports.DOMException('Aborted', 'AbortError'))
        }
  
        var xhr = new XMLHttpRequest();
  
        function abortXhr() {
          xhr.abort();
        }
  
        xhr.onload = function() {
          var options = {
            status: xhr.status,
            statusText: xhr.statusText,
            headers: parseHeaders(xhr.getAllResponseHeaders() || '')
          };
          options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
          var body = 'response' in xhr ? xhr.response : xhr.responseText;
          resolve(new Response(body, options));
        };
  
        xhr.onerror = function() {
          reject(new TypeError('Network request failed'));
        };
  
        xhr.ontimeout = function() {
          reject(new TypeError('Network request failed'));
        };
  
        xhr.onabort = function() {
          reject(new exports.DOMException('Aborted', 'AbortError'));
        };
  
        xhr.open(request.method, request.url, true);
  
        if (request.credentials === 'include') {
          xhr.withCredentials = true;
        } else if (request.credentials === 'omit') {
          xhr.withCredentials = false;
        }
  
        if ('responseType' in xhr && support.blob) {
          xhr.responseType = 'blob';
        }
  
        request.headers.forEach(function(value, name) {
          xhr.setRequestHeader(name, value);
        });
  
        if (request.signal) {
          request.signal.addEventListener('abort', abortXhr);
  
          xhr.onreadystatechange = function() {
            // DONE (success or failure)
            if (xhr.readyState === 4) {
              request.signal.removeEventListener('abort', abortXhr);
            }
          };
        }
  
        xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
      })
    }
  
    fetch.polyfill = true;
  
    if (!self.fetch) {
      self.fetch = fetch;
      self.Headers = Headers;
      self.Request = Request;
      self.Response = Response;
    }
  
    exports.Headers = Headers;
    exports.Request = Request;
    exports.Response = Response;
    exports.fetch = fetch;
  
    return exports;
  
  }({}));
  })(typeof self !== 'undefined' ? self : this);
  
  },{}],198:[function(require,module,exports){
  'use strict';
  var token = '%[a-f0-9]{2}';
  var singleMatcher = new RegExp(token, 'gi');
  var multiMatcher = new RegExp('(' + token + ')+', 'gi');
  
  function decodeComponents(components, split) {
    try {
      // Try to decode the entire string first
      return decodeURIComponent(components.join(''));
    } catch (err) {
      // Do nothing
    }
  
    if (components.length === 1) {
      return components;
    }
  
    split = split || 1;
  
    // Split the array in 2 parts
    var left = components.slice(0, split);
    var right = components.slice(split);
  
    return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
  }
  
  function decode(input) {
    try {
      return decodeURIComponent(input);
    } catch (err) {
      var tokens = input.match(singleMatcher);
  
      for (var i = 1; i < tokens.length; i++) {
        input = decodeComponents(tokens, i).join('');
  
        tokens = input.match(singleMatcher);
      }
  
      return input;
    }
  }
  
  function customDecodeURIComponent(input) {
    // Keep track of all the replacements and prefill the map with the `BOM`
    var replaceMap = {
      '%FE%FF': '\uFFFD\uFFFD',
      '%FF%FE': '\uFFFD\uFFFD'
    };
  
    var match = multiMatcher.exec(input);
    while (match) {
      try {
        // Decode as big chunks as possible
        replaceMap[match[0]] = decodeURIComponent(match[0]);
      } catch (err) {
        var result = decode(match[0]);
  
        if (result !== match[0]) {
          replaceMap[match[0]] = result;
        }
      }
  
      match = multiMatcher.exec(input);
    }
  
    // Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
    replaceMap['%C2'] = '\uFFFD';
  
    var entries = Object.keys(replaceMap);
  
    for (var i = 0; i < entries.length; i++) {
      // Replace all decoded components
      var key = entries[i];
      input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
    }
  
    return input;
  }
  
  module.exports = function (encodedURI) {
    if (typeof encodedURI !== 'string') {
      throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
    }
  
    try {
      encodedURI = encodedURI.replace(/\+/g, ' ');
  
      // Try the built in decoder first
      return decodeURIComponent(encodedURI);
    } catch (err) {
      // Fallback to a more advanced decoder
      return customDecodeURIComponent(encodedURI);
    }
  };
  
  },{}],199:[function(require,module,exports){
  'use strict';
  
  var Buffer = require('safe-buffer').Buffer;
  
  var getParamBytesForAlg = require('./param-bytes-for-alg');
  
  var MAX_OCTET = 0x80,
    CLASS_UNIVERSAL = 0,
    PRIMITIVE_BIT = 0x20,
    TAG_SEQ = 0x10,
    TAG_INT = 0x02,
    ENCODED_TAG_SEQ = (TAG_SEQ | PRIMITIVE_BIT) | (CLASS_UNIVERSAL << 6),
    ENCODED_TAG_INT = TAG_INT | (CLASS_UNIVERSAL << 6);
  
  function base64Url(base64) {
    return base64
      .replace(/=/g, '')
      .replace(/\+/g, '-')
      .replace(/\//g, '_');
  }
  
  function signatureAsBuffer(signature) {
    if (Buffer.isBuffer(signature)) {
      return signature;
    } else if ('string' === typeof signature) {
      return Buffer.from(signature, 'base64');
    }
  
    throw new TypeError('ECDSA signature must be a Base64 string or a Buffer');
  }
  
  function derToJose(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);
  
    // the DER encoded param should at most be the param size, plus a padding
    // zero, since due to being a signed integer
    var maxEncodedParamLength = paramBytes + 1;
  
    var inputLength = signature.length;
  
    var offset = 0;
    if (signature[offset++] !== ENCODED_TAG_SEQ) {
      throw new Error('Could not find expected "seq"');
    }
  
    var seqLength = signature[offset++];
    if (seqLength === (MAX_OCTET | 1)) {
      seqLength = signature[offset++];
    }
  
    if (inputLength - offset < seqLength) {
      throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
    }
  
    if (signature[offset++] !== ENCODED_TAG_INT) {
      throw new Error('Could not find expected "int" for "r"');
    }
  
    var rLength = signature[offset++];
  
    if (inputLength - offset - 2 < rLength) {
      throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
    }
  
    if (maxEncodedParamLength < rLength) {
      throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
    }
  
    var rOffset = offset;
    offset += rLength;
  
    if (signature[offset++] !== ENCODED_TAG_INT) {
      throw new Error('Could not find expected "int" for "s"');
    }
  
    var sLength = signature[offset++];
  
    if (inputLength - offset !== sLength) {
      throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
    }
  
    if (maxEncodedParamLength < sLength) {
      throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
    }
  
    var sOffset = offset;
    offset += sLength;
  
    if (offset !== inputLength) {
      throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
    }
  
    var rPadding = paramBytes - rLength,
      sPadding = paramBytes - sLength;
  
    var dst = Buffer.allocUnsafe(rPadding + rLength + sPadding + sLength);
  
    for (offset = 0; offset < rPadding; ++offset) {
      dst[offset] = 0;
    }
    signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
  
    offset = paramBytes;
  
    for (var o = offset; offset < o + sPadding; ++offset) {
      dst[offset] = 0;
    }
    signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
  
    dst = dst.toString('base64');
    dst = base64Url(dst);
  
    return dst;
  }
  
  function countPadding(buf, start, stop) {
    var padding = 0;
    while (start + padding < stop && buf[start + padding] === 0) {
      ++padding;
    }
  
    var needsSign = buf[start + padding] >= MAX_OCTET;
    if (needsSign) {
      --padding;
    }
  
    return padding;
  }
  
  function joseToDer(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);
  
    var signatureBytes = signature.length;
    if (signatureBytes !== paramBytes * 2) {
      throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
    }
  
    var rPadding = countPadding(signature, 0, paramBytes);
    var sPadding = countPadding(signature, paramBytes, signature.length);
    var rLength = paramBytes - rPadding;
    var sLength = paramBytes - sPadding;
  
    var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
  
    var shortLength = rsBytes < MAX_OCTET;
  
    var dst = Buffer.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
  
    var offset = 0;
    dst[offset++] = ENCODED_TAG_SEQ;
    if (shortLength) {
      // Bit 8 has value "0"
      // bits 7-1 give the length.
      dst[offset++] = rsBytes;
    } else {
      // Bit 8 of first octet has value "1"
      // bits 7-1 give the number of additional length octets.
      dst[offset++] = MAX_OCTET	| 1;
      // length, base 256
      dst[offset++] = rsBytes & 0xff;
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = rLength;
    if (rPadding < 0) {
      dst[offset++] = 0;
      offset += signature.copy(dst, offset, 0, paramBytes);
    } else {
      offset += signature.copy(dst, offset, rPadding, paramBytes);
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = sLength;
    if (sPadding < 0) {
      dst[offset++] = 0;
      signature.copy(dst, offset, paramBytes);
    } else {
      signature.copy(dst, offset, paramBytes + sPadding);
    }
  
    return dst;
  }
  
  module.exports = {
    derToJose: derToJose,
    joseToDer: joseToDer
  };
  
  },{"./param-bytes-for-alg":200,"safe-buffer":281}],200:[function(require,module,exports){
  'use strict';
  
  function getParamSize(keySize) {
    var result = ((keySize / 8) | 0) + (keySize % 8 === 0 ? 0 : 1);
    return result;
  }
  
  var paramBytesForAlg = {
    ES256: getParamSize(256),
    ES384: getParamSize(384),
    ES512: getParamSize(521)
  };
  
  function getParamBytesForAlg(alg) {
    var paramBytes = paramBytesForAlg[alg];
    if (paramBytes) {
      return paramBytes;
    }
  
    throw new Error('Unknown algorithm "' + alg + '"');
  }
  
  module.exports = getParamBytesForAlg;
  
  },{}],201:[function(require,module,exports){
  'use strict';
  
  var elliptic = exports;
  
  elliptic.version = require('../package.json').version;
  elliptic.utils = require('./elliptic/utils');
  elliptic.rand = require('brorand');
  elliptic.curve = require('./elliptic/curve');
  elliptic.curves = require('./elliptic/curves');
  
  // Protocols
  elliptic.ec = require('./elliptic/ec');
  elliptic.eddsa = require('./elliptic/eddsa');
  
  },{"../package.json":216,"./elliptic/curve":204,"./elliptic/curves":207,"./elliptic/ec":208,"./elliptic/eddsa":211,"./elliptic/utils":215,"brorand":188}],202:[function(require,module,exports){
  'use strict';
  
  var BN = require('bn.js');
  var utils = require('../utils');
  var getNAF = utils.getNAF;
  var getJSF = utils.getJSF;
  var assert = utils.assert;
  
  function BaseCurve(type, conf) {
    this.type = type;
    this.p = new BN(conf.p, 16);
  
    // Use Montgomery, when there is no fast reduction for the prime
    this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
  
    // Useful for many curves
    this.zero = new BN(0).toRed(this.red);
    this.one = new BN(1).toRed(this.red);
    this.two = new BN(2).toRed(this.red);
  
    // Curve configuration, optional
    this.n = conf.n && new BN(conf.n, 16);
    this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  
    // Temporary arrays
    this._wnafT1 = new Array(4);
    this._wnafT2 = new Array(4);
    this._wnafT3 = new Array(4);
    this._wnafT4 = new Array(4);
  
    this._bitLength = this.n ? this.n.bitLength() : 0;
  
    // Generalized Greg Maxwell's trick
    var adjustCount = this.n && this.p.div(this.n);
    if (!adjustCount || adjustCount.cmpn(100) > 0) {
      this.redN = null;
    } else {
      this._maxwellTrick = true;
      this.redN = this.n.toRed(this.red);
    }
  }
  module.exports = BaseCurve;
  
  BaseCurve.prototype.point = function point() {
    throw new Error('Not implemented');
  };
  
  BaseCurve.prototype.validate = function validate() {
    throw new Error('Not implemented');
  };
  
  BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
    assert(p.precomputed);
    var doubles = p._getDoubles();
  
    var naf = getNAF(k, 1, this._bitLength);
    var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
    I /= 3;
  
    // Translate into more windowed form
    var repr = [];
    for (var j = 0; j < naf.length; j += doubles.step) {
      var nafW = 0;
      for (var k = j + doubles.step - 1; k >= j; k--)
        nafW = (nafW << 1) + naf[k];
      repr.push(nafW);
    }
  
    var a = this.jpoint(null, null, null);
    var b = this.jpoint(null, null, null);
    for (var i = I; i > 0; i--) {
      for (var j = 0; j < repr.length; j++) {
        var nafW = repr[j];
        if (nafW === i)
          b = b.mixedAdd(doubles.points[j]);
        else if (nafW === -i)
          b = b.mixedAdd(doubles.points[j].neg());
      }
      a = a.add(b);
    }
    return a.toP();
  };
  
  BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
    var w = 4;
  
    // Precompute window
    var nafPoints = p._getNAFPoints(w);
    w = nafPoints.wnd;
    var wnd = nafPoints.points;
  
    // Get NAF form
    var naf = getNAF(k, w, this._bitLength);
  
    // Add `this`*(N+1) for every w-NAF index
    var acc = this.jpoint(null, null, null);
    for (var i = naf.length - 1; i >= 0; i--) {
      // Count zeroes
      for (var k = 0; i >= 0 && naf[i] === 0; i--)
        k++;
      if (i >= 0)
        k++;
      acc = acc.dblp(k);
  
      if (i < 0)
        break;
      var z = naf[i];
      assert(z !== 0);
      if (p.type === 'affine') {
        // J +- P
        if (z > 0)
          acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
        else
          acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
      } else {
        // J +- J
        if (z > 0)
          acc = acc.add(wnd[(z - 1) >> 1]);
        else
          acc = acc.add(wnd[(-z - 1) >> 1].neg());
      }
    }
    return p.type === 'affine' ? acc.toP() : acc;
  };
  
  BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
                                                         points,
                                                         coeffs,
                                                         len,
                                                         jacobianResult) {
    var wndWidth = this._wnafT1;
    var wnd = this._wnafT2;
    var naf = this._wnafT3;
  
    // Fill all arrays
    var max = 0;
    for (var i = 0; i < len; i++) {
      var p = points[i];
      var nafPoints = p._getNAFPoints(defW);
      wndWidth[i] = nafPoints.wnd;
      wnd[i] = nafPoints.points;
    }
  
    // Comb small window NAFs
    for (var i = len - 1; i >= 1; i -= 2) {
      var a = i - 1;
      var b = i;
      if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
        naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
        naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
        max = Math.max(naf[a].length, max);
        max = Math.max(naf[b].length, max);
        continue;
      }
  
      var comb = [
        points[a], /* 1 */
        null, /* 3 */
        null, /* 5 */
        points[b] /* 7 */
      ];
  
      // Try to avoid Projective points, if possible
      if (points[a].y.cmp(points[b].y) === 0) {
        comb[1] = points[a].add(points[b]);
        comb[2] = points[a].toJ().mixedAdd(points[b].neg());
      } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
        comb[1] = points[a].toJ().mixedAdd(points[b]);
        comb[2] = points[a].add(points[b].neg());
      } else {
        comb[1] = points[a].toJ().mixedAdd(points[b]);
        comb[2] = points[a].toJ().mixedAdd(points[b].neg());
      }
  
      var index = [
        -3, /* -1 -1 */
        -1, /* -1 0 */
        -5, /* -1 1 */
        -7, /* 0 -1 */
        0, /* 0 0 */
        7, /* 0 1 */
        5, /* 1 -1 */
        1, /* 1 0 */
        3  /* 1 1 */
      ];
  
      var jsf = getJSF(coeffs[a], coeffs[b]);
      max = Math.max(jsf[0].length, max);
      naf[a] = new Array(max);
      naf[b] = new Array(max);
      for (var j = 0; j < max; j++) {
        var ja = jsf[0][j] | 0;
        var jb = jsf[1][j] | 0;
  
        naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
        naf[b][j] = 0;
        wnd[a] = comb;
      }
    }
  
    var acc = this.jpoint(null, null, null);
    var tmp = this._wnafT4;
    for (var i = max; i >= 0; i--) {
      var k = 0;
  
      while (i >= 0) {
        var zero = true;
        for (var j = 0; j < len; j++) {
          tmp[j] = naf[j][i] | 0;
          if (tmp[j] !== 0)
            zero = false;
        }
        if (!zero)
          break;
        k++;
        i--;
      }
      if (i >= 0)
        k++;
      acc = acc.dblp(k);
      if (i < 0)
        break;
  
      for (var j = 0; j < len; j++) {
        var z = tmp[j];
        var p;
        if (z === 0)
          continue;
        else if (z > 0)
          p = wnd[j][(z - 1) >> 1];
        else if (z < 0)
          p = wnd[j][(-z - 1) >> 1].neg();
  
        if (p.type === 'affine')
          acc = acc.mixedAdd(p);
        else
          acc = acc.add(p);
      }
    }
    // Zeroify references
    for (var i = 0; i < len; i++)
      wnd[i] = null;
  
    if (jacobianResult)
      return acc;
    else
      return acc.toP();
  };
  
  function BasePoint(curve, type) {
    this.curve = curve;
    this.type = type;
    this.precomputed = null;
  }
  BaseCurve.BasePoint = BasePoint;
  
  BasePoint.prototype.eq = function eq(/*other*/) {
    throw new Error('Not implemented');
  };
  
  BasePoint.prototype.validate = function validate() {
    return this.curve.validate(this);
  };
  
  BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    bytes = utils.toArray(bytes, enc);
  
    var len = this.p.byteLength();
  
    // uncompressed, hybrid-odd, hybrid-even
    if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
        bytes.length - 1 === 2 * len) {
      if (bytes[0] === 0x06)
        assert(bytes[bytes.length - 1] % 2 === 0);
      else if (bytes[0] === 0x07)
        assert(bytes[bytes.length - 1] % 2 === 1);
  
      var res =  this.point(bytes.slice(1, 1 + len),
                            bytes.slice(1 + len, 1 + 2 * len));
  
      return res;
    } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
                bytes.length - 1 === len) {
      return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
    }
    throw new Error('Unknown point format');
  };
  
  BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
    return this.encode(enc, true);
  };
  
  BasePoint.prototype._encode = function _encode(compact) {
    var len = this.curve.p.byteLength();
    var x = this.getX().toArray('be', len);
  
    if (compact)
      return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);
  
    return [ 0x04 ].concat(x, this.getY().toArray('be', len)) ;
  };
  
  BasePoint.prototype.encode = function encode(enc, compact) {
    return utils.encode(this._encode(compact), enc);
  };
  
  BasePoint.prototype.precompute = function precompute(power) {
    if (this.precomputed)
      return this;
  
    var precomputed = {
      doubles: null,
      naf: null,
      beta: null
    };
    precomputed.naf = this._getNAFPoints(8);
    precomputed.doubles = this._getDoubles(4, power);
    precomputed.beta = this._getBeta();
    this.precomputed = precomputed;
  
    return this;
  };
  
  BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
    if (!this.precomputed)
      return false;
  
    var doubles = this.precomputed.doubles;
    if (!doubles)
      return false;
  
    return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
  };
  
  BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
  
    var doubles = [ this ];
    var acc = this;
    for (var i = 0; i < power; i += step) {
      for (var j = 0; j < step; j++)
        acc = acc.dbl();
      doubles.push(acc);
    }
    return {
      step: step,
      points: doubles
    };
  };
  
  BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
  
    var res = [ this ];
    var max = (1 << wnd) - 1;
    var dbl = max === 1 ? null : this.dbl();
    for (var i = 1; i < max; i++)
      res[i] = res[i - 1].add(dbl);
    return {
      wnd: wnd,
      points: res
    };
  };
  
  BasePoint.prototype._getBeta = function _getBeta() {
    return null;
  };
  
  BasePoint.prototype.dblp = function dblp(k) {
    var r = this;
    for (var i = 0; i < k; i++)
      r = r.dbl();
    return r;
  };
  
  },{"../utils":215,"bn.js":187}],203:[function(require,module,exports){
  'use strict';
  
  var utils = require('../utils');
  var BN = require('bn.js');
  var inherits = require('inherits');
  var Base = require('./base');
  
  var assert = utils.assert;
  
  function EdwardsCurve(conf) {
    // NOTE: Important as we are creating point in Base.call()
    this.twisted = (conf.a | 0) !== 1;
    this.mOneA = this.twisted && (conf.a | 0) === -1;
    this.extended = this.mOneA;
  
    Base.call(this, 'edwards', conf);
  
    this.a = new BN(conf.a, 16).umod(this.red.m);
    this.a = this.a.toRed(this.red);
    this.c = new BN(conf.c, 16).toRed(this.red);
    this.c2 = this.c.redSqr();
    this.d = new BN(conf.d, 16).toRed(this.red);
    this.dd = this.d.redAdd(this.d);
  
    assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
    this.oneC = (conf.c | 0) === 1;
  }
  inherits(EdwardsCurve, Base);
  module.exports = EdwardsCurve;
  
  EdwardsCurve.prototype._mulA = function _mulA(num) {
    if (this.mOneA)
      return num.redNeg();
    else
      return this.a.redMul(num);
  };
  
  EdwardsCurve.prototype._mulC = function _mulC(num) {
    if (this.oneC)
      return num;
    else
      return this.c.redMul(num);
  };
  
  // Just for compatibility with Short curve
  EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
    return this.point(x, y, z, t);
  };
  
  EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new BN(x, 16);
    if (!x.red)
      x = x.toRed(this.red);
  
    var x2 = x.redSqr();
    var rhs = this.c2.redSub(this.a.redMul(x2));
    var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
  
    var y2 = rhs.redMul(lhs.redInvm());
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
      throw new Error('invalid point');
  
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd)
      y = y.redNeg();
  
    return this.point(x, y);
  };
  
  EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
    y = new BN(y, 16);
    if (!y.red)
      y = y.toRed(this.red);
  
    // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
    var y2 = y.redSqr();
    var lhs = y2.redSub(this.c2);
    var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
    var x2 = lhs.redMul(rhs.redInvm());
  
    if (x2.cmp(this.zero) === 0) {
      if (odd)
        throw new Error('invalid point');
      else
        return this.point(this.zero, y);
    }
  
    var x = x2.redSqrt();
    if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
      throw new Error('invalid point');
  
    if (x.fromRed().isOdd() !== odd)
      x = x.redNeg();
  
    return this.point(x, y);
  };
  
  EdwardsCurve.prototype.validate = function validate(point) {
    if (point.isInfinity())
      return true;
  
    // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
    point.normalize();
  
    var x2 = point.x.redSqr();
    var y2 = point.y.redSqr();
    var lhs = x2.redMul(this.a).redAdd(y2);
    var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
  
    return lhs.cmp(rhs) === 0;
  };
  
  function Point(curve, x, y, z, t) {
    Base.BasePoint.call(this, curve, 'projective');
    if (x === null && y === null && z === null) {
      this.x = this.curve.zero;
      this.y = this.curve.one;
      this.z = this.curve.one;
      this.t = this.curve.zero;
      this.zOne = true;
    } else {
      this.x = new BN(x, 16);
      this.y = new BN(y, 16);
      this.z = z ? new BN(z, 16) : this.curve.one;
      this.t = t && new BN(t, 16);
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      if (this.t && !this.t.red)
        this.t = this.t.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
  
      // Use extended coordinates
      if (this.curve.extended && !this.t) {
        this.t = this.x.redMul(this.y);
        if (!this.zOne)
          this.t = this.t.redMul(this.z.redInvm());
      }
    }
  }
  inherits(Point, Base.BasePoint);
  
  EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point.fromJSON(this, obj);
  };
  
  EdwardsCurve.prototype.point = function point(x, y, z, t) {
    return new Point(this, x, y, z, t);
  };
  
  Point.fromJSON = function fromJSON(curve, obj) {
    return new Point(curve, obj[0], obj[1], obj[2]);
  };
  
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return '<EC Point Infinity>';
    return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
        ' y: ' + this.y.fromRed().toString(16, 2) +
        ' z: ' + this.z.fromRed().toString(16, 2) + '>';
  };
  
  Point.prototype.isInfinity = function isInfinity() {
    // XXX This code assumes that zero is always zero in red
    return this.x.cmpn(0) === 0 &&
      (this.y.cmp(this.z) === 0 ||
      (this.zOne && this.y.cmp(this.curve.c) === 0));
  };
  
  Point.prototype._extDbl = function _extDbl() {
    // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
    //     #doubling-dbl-2008-hwcd
    // 4M + 4S
  
    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = 2 * Z1^2
    var c = this.z.redSqr();
    c = c.redIAdd(c);
    // D = a * A
    var d = this.curve._mulA(a);
    // E = (X1 + Y1)^2 - A - B
    var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
    // G = D + B
    var g = d.redAdd(b);
    // F = G - C
    var f = g.redSub(c);
    // H = D - B
    var h = d.redSub(b);
    // X3 = E * F
    var nx = e.redMul(f);
    // Y3 = G * H
    var ny = g.redMul(h);
    // T3 = E * H
    var nt = e.redMul(h);
    // Z3 = F * G
    var nz = f.redMul(g);
    return this.curve.point(nx, ny, nz, nt);
  };
  
  Point.prototype._projDbl = function _projDbl() {
    // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
    //     #doubling-dbl-2008-bbjlp
    //     #doubling-dbl-2007-bl
    // and others
    // Generally 3M + 4S or 2M + 4S
  
    // B = (X1 + Y1)^2
    var b = this.x.redAdd(this.y).redSqr();
    // C = X1^2
    var c = this.x.redSqr();
    // D = Y1^2
    var d = this.y.redSqr();
  
    var nx;
    var ny;
    var nz;
    if (this.curve.twisted) {
      // E = a * C
      var e = this.curve._mulA(c);
      // F = E + D
      var f = e.redAdd(d);
      if (this.zOne) {
        // X3 = (B - C - D) * (F - 2)
        nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
        // Y3 = F * (E - D)
        ny = f.redMul(e.redSub(d));
        // Z3 = F^2 - 2 * F
        nz = f.redSqr().redSub(f).redSub(f);
      } else {
        // H = Z1^2
        var h = this.z.redSqr();
        // J = F - 2 * H
        var j = f.redSub(h).redISub(h);
        // X3 = (B-C-D)*J
        nx = b.redSub(c).redISub(d).redMul(j);
        // Y3 = F * (E - D)
        ny = f.redMul(e.redSub(d));
        // Z3 = F * J
        nz = f.redMul(j);
      }
    } else {
      // E = C + D
      var e = c.redAdd(d);
      // H = (c * Z1)^2
      var h = this.curve._mulC(this.z).redSqr();
      // J = E - 2 * H
      var j = e.redSub(h).redSub(h);
      // X3 = c * (B - E) * J
      nx = this.curve._mulC(b.redISub(e)).redMul(j);
      // Y3 = c * E * (C - D)
      ny = this.curve._mulC(e).redMul(c.redISub(d));
      // Z3 = E * J
      nz = e.redMul(j);
    }
    return this.curve.point(nx, ny, nz);
  };
  
  Point.prototype.dbl = function dbl() {
    if (this.isInfinity())
      return this;
  
    // Double in extended coordinates
    if (this.curve.extended)
      return this._extDbl();
    else
      return this._projDbl();
  };
  
  Point.prototype._extAdd = function _extAdd(p) {
    // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
    //     #addition-add-2008-hwcd-3
    // 8M
  
    // A = (Y1 - X1) * (Y2 - X2)
    var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
    // B = (Y1 + X1) * (Y2 + X2)
    var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
    // C = T1 * k * T2
    var c = this.t.redMul(this.curve.dd).redMul(p.t);
    // D = Z1 * 2 * Z2
    var d = this.z.redMul(p.z.redAdd(p.z));
    // E = B - A
    var e = b.redSub(a);
    // F = D - C
    var f = d.redSub(c);
    // G = D + C
    var g = d.redAdd(c);
    // H = B + A
    var h = b.redAdd(a);
    // X3 = E * F
    var nx = e.redMul(f);
    // Y3 = G * H
    var ny = g.redMul(h);
    // T3 = E * H
    var nt = e.redMul(h);
    // Z3 = F * G
    var nz = f.redMul(g);
    return this.curve.point(nx, ny, nz, nt);
  };
  
  Point.prototype._projAdd = function _projAdd(p) {
    // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
    //     #addition-add-2008-bbjlp
    //     #addition-add-2007-bl
    // 10M + 1S
  
    // A = Z1 * Z2
    var a = this.z.redMul(p.z);
    // B = A^2
    var b = a.redSqr();
    // C = X1 * X2
    var c = this.x.redMul(p.x);
    // D = Y1 * Y2
    var d = this.y.redMul(p.y);
    // E = d * C * D
    var e = this.curve.d.redMul(c).redMul(d);
    // F = B - E
    var f = b.redSub(e);
    // G = B + E
    var g = b.redAdd(e);
    // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
    var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
    var nx = a.redMul(f).redMul(tmp);
    var ny;
    var nz;
    if (this.curve.twisted) {
      // Y3 = A * G * (D - a * C)
      ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
      // Z3 = F * G
      nz = f.redMul(g);
    } else {
      // Y3 = A * G * (D - C)
      ny = a.redMul(g).redMul(d.redSub(c));
      // Z3 = c * F * G
      nz = this.curve._mulC(f).redMul(g);
    }
    return this.curve.point(nx, ny, nz);
  };
  
  Point.prototype.add = function add(p) {
    if (this.isInfinity())
      return p;
    if (p.isInfinity())
      return this;
  
    if (this.curve.extended)
      return this._extAdd(p);
    else
      return this._projAdd(p);
  };
  
  Point.prototype.mul = function mul(k) {
    if (this._hasDoubles(k))
      return this.curve._fixedNafMul(this, k);
    else
      return this.curve._wnafMul(this, k);
  };
  
  Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
    return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
  };
  
  Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
    return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
  };
  
  Point.prototype.normalize = function normalize() {
    if (this.zOne)
      return this;
  
    // Normalize coordinates
    var zi = this.z.redInvm();
    this.x = this.x.redMul(zi);
    this.y = this.y.redMul(zi);
    if (this.t)
      this.t = this.t.redMul(zi);
    this.z = this.curve.one;
    this.zOne = true;
    return this;
  };
  
  Point.prototype.neg = function neg() {
    return this.curve.point(this.x.redNeg(),
                            this.y,
                            this.z,
                            this.t && this.t.redNeg());
  };
  
  Point.prototype.getX = function getX() {
    this.normalize();
    return this.x.fromRed();
  };
  
  Point.prototype.getY = function getY() {
    this.normalize();
    return this.y.fromRed();
  };
  
  Point.prototype.eq = function eq(other) {
    return this === other ||
           this.getX().cmp(other.getX()) === 0 &&
           this.getY().cmp(other.getY()) === 0;
  };
  
  Point.prototype.eqXToP = function eqXToP(x) {
    var rx = x.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(rx) === 0)
      return true;
  
    var xc = x.clone();
    var t = this.curve.redN.redMul(this.z);
    for (;;) {
      xc.iadd(this.curve.n);
      if (xc.cmp(this.curve.p) >= 0)
        return false;
  
      rx.redIAdd(t);
      if (this.x.cmp(rx) === 0)
        return true;
    }
  };
  
  // Compatibility with BaseCurve
  Point.prototype.toP = Point.prototype.normalize;
  Point.prototype.mixedAdd = Point.prototype.add;
  
  },{"../utils":215,"./base":202,"bn.js":187,"inherits":280}],204:[function(require,module,exports){
  'use strict';
  
  var curve = exports;
  
  curve.base = require('./base');
  curve.short = require('./short');
  curve.mont = require('./mont');
  curve.edwards = require('./edwards');
  
  },{"./base":202,"./edwards":203,"./mont":205,"./short":206}],205:[function(require,module,exports){
  'use strict';
  
  var BN = require('bn.js');
  var inherits = require('inherits');
  var Base = require('./base');
  
  var utils = require('../utils');
  
  function MontCurve(conf) {
    Base.call(this, 'mont', conf);
  
    this.a = new BN(conf.a, 16).toRed(this.red);
    this.b = new BN(conf.b, 16).toRed(this.red);
    this.i4 = new BN(4).toRed(this.red).redInvm();
    this.two = new BN(2).toRed(this.red);
    this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  inherits(MontCurve, Base);
  module.exports = MontCurve;
  
  MontCurve.prototype.validate = function validate(point) {
    var x = point.normalize().x;
    var x2 = x.redSqr();
    var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
    var y = rhs.redSqrt();
  
    return y.redSqr().cmp(rhs) === 0;
  };
  
  function Point(curve, x, z) {
    Base.BasePoint.call(this, curve, 'projective');
    if (x === null && z === null) {
      this.x = this.curve.one;
      this.z = this.curve.zero;
    } else {
      this.x = new BN(x, 16);
      this.z = new BN(z, 16);
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
    }
  }
  inherits(Point, Base.BasePoint);
  
  MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    return this.point(utils.toArray(bytes, enc), 1);
  };
  
  MontCurve.prototype.point = function point(x, z) {
    return new Point(this, x, z);
  };
  
  MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point.fromJSON(this, obj);
  };
  
  Point.prototype.precompute = function precompute() {
    // No-op
  };
  
  Point.prototype._encode = function _encode() {
    return this.getX().toArray('be', this.curve.p.byteLength());
  };
  
  Point.fromJSON = function fromJSON(curve, obj) {
    return new Point(curve, obj[0], obj[1] || curve.one);
  };
  
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return '<EC Point Infinity>';
    return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
        ' z: ' + this.z.fromRed().toString(16, 2) + '>';
  };
  
  Point.prototype.isInfinity = function isInfinity() {
    // XXX This code assumes that zero is always zero in red
    return this.z.cmpn(0) === 0;
  };
  
  Point.prototype.dbl = function dbl() {
    // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
    // 2M + 2S + 4A
  
    // A = X1 + Z1
    var a = this.x.redAdd(this.z);
    // AA = A^2
    var aa = a.redSqr();
    // B = X1 - Z1
    var b = this.x.redSub(this.z);
    // BB = B^2
    var bb = b.redSqr();
    // C = AA - BB
    var c = aa.redSub(bb);
    // X3 = AA * BB
    var nx = aa.redMul(bb);
    // Z3 = C * (BB + A24 * C)
    var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
    return this.curve.point(nx, nz);
  };
  
  Point.prototype.add = function add() {
    throw new Error('Not supported on Montgomery curve');
  };
  
  Point.prototype.diffAdd = function diffAdd(p, diff) {
    // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
    // 4M + 2S + 6A
  
    // A = X2 + Z2
    var a = this.x.redAdd(this.z);
    // B = X2 - Z2
    var b = this.x.redSub(this.z);
    // C = X3 + Z3
    var c = p.x.redAdd(p.z);
    // D = X3 - Z3
    var d = p.x.redSub(p.z);
    // DA = D * A
    var da = d.redMul(a);
    // CB = C * B
    var cb = c.redMul(b);
    // X5 = Z1 * (DA + CB)^2
    var nx = diff.z.redMul(da.redAdd(cb).redSqr());
    // Z5 = X1 * (DA - CB)^2
    var nz = diff.x.redMul(da.redISub(cb).redSqr());
    return this.curve.point(nx, nz);
  };
  
  Point.prototype.mul = function mul(k) {
    var t = k.clone();
    var a = this; // (N / 2) * Q + Q
    var b = this.curve.point(null, null); // (N / 2) * Q
    var c = this; // Q
  
    for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
      bits.push(t.andln(1));
  
    for (var i = bits.length - 1; i >= 0; i--) {
      if (bits[i] === 0) {
        // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
        a = a.diffAdd(b, c);
        // N * Q = 2 * ((N / 2) * Q + Q))
        b = b.dbl();
      } else {
        // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
        b = a.diffAdd(b, c);
        // N * Q + Q = 2 * ((N / 2) * Q + Q)
        a = a.dbl();
      }
    }
    return b;
  };
  
  Point.prototype.mulAdd = function mulAdd() {
    throw new Error('Not supported on Montgomery curve');
  };
  
  Point.prototype.jumlAdd = function jumlAdd() {
    throw new Error('Not supported on Montgomery curve');
  };
  
  Point.prototype.eq = function eq(other) {
    return this.getX().cmp(other.getX()) === 0;
  };
  
  Point.prototype.normalize = function normalize() {
    this.x = this.x.redMul(this.z.redInvm());
    this.z = this.curve.one;
    return this;
  };
  
  Point.prototype.getX = function getX() {
    // Normalize coordinates
    this.normalize();
  
    return this.x.fromRed();
  };
  
  },{"../utils":215,"./base":202,"bn.js":187,"inherits":280}],206:[function(require,module,exports){
  'use strict';
  
  var utils = require('../utils');
  var BN = require('bn.js');
  var inherits = require('inherits');
  var Base = require('./base');
  
  var assert = utils.assert;
  
  function ShortCurve(conf) {
    Base.call(this, 'short', conf);
  
    this.a = new BN(conf.a, 16).toRed(this.red);
    this.b = new BN(conf.b, 16).toRed(this.red);
    this.tinv = this.two.redInvm();
  
    this.zeroA = this.a.fromRed().cmpn(0) === 0;
    this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  
    // If the curve is endomorphic, precalculate beta and lambda
    this.endo = this._getEndomorphism(conf);
    this._endoWnafT1 = new Array(4);
    this._endoWnafT2 = new Array(4);
  }
  inherits(ShortCurve, Base);
  module.exports = ShortCurve;
  
  ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
    // No efficient endomorphism
    if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
      return;
  
    // Compute beta and lambda, that lambda * P = (beta * Px; Py)
    var beta;
    var lambda;
    if (conf.beta) {
      beta = new BN(conf.beta, 16).toRed(this.red);
    } else {
      var betas = this._getEndoRoots(this.p);
      // Choose the smallest beta
      beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
      beta = beta.toRed(this.red);
    }
    if (conf.lambda) {
      lambda = new BN(conf.lambda, 16);
    } else {
      // Choose the lambda that is matching selected beta
      var lambdas = this._getEndoRoots(this.n);
      if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
        lambda = lambdas[0];
      } else {
        lambda = lambdas[1];
        assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
      }
    }
  
    // Get basis vectors, used for balanced length-two representation
    var basis;
    if (conf.basis) {
      basis = conf.basis.map(function(vec) {
        return {
          a: new BN(vec.a, 16),
          b: new BN(vec.b, 16)
        };
      });
    } else {
      basis = this._getEndoBasis(lambda);
    }
  
    return {
      beta: beta,
      lambda: lambda,
      basis: basis
    };
  };
  
  ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
    // Find roots of for x^2 + x + 1 in F
    // Root = (-1 +- Sqrt(-3)) / 2
    //
    var red = num === this.p ? this.red : BN.mont(num);
    var tinv = new BN(2).toRed(red).redInvm();
    var ntinv = tinv.redNeg();
  
    var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  
    var l1 = ntinv.redAdd(s).fromRed();
    var l2 = ntinv.redSub(s).fromRed();
    return [ l1, l2 ];
  };
  
  ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
    // aprxSqrt >= sqrt(this.n)
    var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  
    // 3.74
    // Run EGCD, until r(L + 1) < aprxSqrt
    var u = lambda;
    var v = this.n.clone();
    var x1 = new BN(1);
    var y1 = new BN(0);
    var x2 = new BN(0);
    var y2 = new BN(1);
  
    // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
    var a0;
    var b0;
    // First vector
    var a1;
    var b1;
    // Second vector
    var a2;
    var b2;
  
    var prevR;
    var i = 0;
    var r;
    var x;
    while (u.cmpn(0) !== 0) {
      var q = v.div(u);
      r = v.sub(q.mul(u));
      x = x2.sub(q.mul(x1));
      var y = y2.sub(q.mul(y1));
  
      if (!a1 && r.cmp(aprxSqrt) < 0) {
        a0 = prevR.neg();
        b0 = x1;
        a1 = r.neg();
        b1 = x;
      } else if (a1 && ++i === 2) {
        break;
      }
      prevR = r;
  
      v = u;
      u = r;
      x2 = x1;
      x1 = x;
      y2 = y1;
      y1 = y;
    }
    a2 = r.neg();
    b2 = x;
  
    var len1 = a1.sqr().add(b1.sqr());
    var len2 = a2.sqr().add(b2.sqr());
    if (len2.cmp(len1) >= 0) {
      a2 = a0;
      b2 = b0;
    }
  
    // Normalize signs
    if (a1.negative) {
      a1 = a1.neg();
      b1 = b1.neg();
    }
    if (a2.negative) {
      a2 = a2.neg();
      b2 = b2.neg();
    }
  
    return [
      { a: a1, b: b1 },
      { a: a2, b: b2 }
    ];
  };
  
  ShortCurve.prototype._endoSplit = function _endoSplit(k) {
    var basis = this.endo.basis;
    var v1 = basis[0];
    var v2 = basis[1];
  
    var c1 = v2.b.mul(k).divRound(this.n);
    var c2 = v1.b.neg().mul(k).divRound(this.n);
  
    var p1 = c1.mul(v1.a);
    var p2 = c2.mul(v2.a);
    var q1 = c1.mul(v1.b);
    var q2 = c2.mul(v2.b);
  
    // Calculate answer
    var k1 = k.sub(p1).sub(p2);
    var k2 = q1.add(q2).neg();
    return { k1: k1, k2: k2 };
  };
  
  ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new BN(x, 16);
    if (!x.red)
      x = x.toRed(this.red);
  
    var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
      throw new Error('invalid point');
  
    // XXX Is there any way to tell if the number is odd without converting it
    // to non-red form?
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd)
      y = y.redNeg();
  
    return this.point(x, y);
  };
  
  ShortCurve.prototype.validate = function validate(point) {
    if (point.inf)
      return true;
  
    var x = point.x;
    var y = point.y;
  
    var ax = this.a.redMul(x);
    var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
    return y.redSqr().redISub(rhs).cmpn(0) === 0;
  };
  
  ShortCurve.prototype._endoWnafMulAdd =
      function _endoWnafMulAdd(points, coeffs, jacobianResult) {
    var npoints = this._endoWnafT1;
    var ncoeffs = this._endoWnafT2;
    for (var i = 0; i < points.length; i++) {
      var split = this._endoSplit(coeffs[i]);
      var p = points[i];
      var beta = p._getBeta();
  
      if (split.k1.negative) {
        split.k1.ineg();
        p = p.neg(true);
      }
      if (split.k2.negative) {
        split.k2.ineg();
        beta = beta.neg(true);
      }
  
      npoints[i * 2] = p;
      npoints[i * 2 + 1] = beta;
      ncoeffs[i * 2] = split.k1;
      ncoeffs[i * 2 + 1] = split.k2;
    }
    var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
  
    // Clean-up references to points and coefficients
    for (var j = 0; j < i * 2; j++) {
      npoints[j] = null;
      ncoeffs[j] = null;
    }
    return res;
  };
  
  function Point(curve, x, y, isRed) {
    Base.BasePoint.call(this, curve, 'affine');
    if (x === null && y === null) {
      this.x = null;
      this.y = null;
      this.inf = true;
    } else {
      this.x = new BN(x, 16);
      this.y = new BN(y, 16);
      // Force redgomery representation when loading from JSON
      if (isRed) {
        this.x.forceRed(this.curve.red);
        this.y.forceRed(this.curve.red);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      this.inf = false;
    }
  }
  inherits(Point, Base.BasePoint);
  
  ShortCurve.prototype.point = function point(x, y, isRed) {
    return new Point(this, x, y, isRed);
  };
  
  ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
    return Point.fromJSON(this, obj, red);
  };
  
  Point.prototype._getBeta = function _getBeta() {
    if (!this.curve.endo)
      return;
  
    var pre = this.precomputed;
    if (pre && pre.beta)
      return pre.beta;
  
    var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (pre) {
      var curve = this.curve;
      var endoMul = function(p) {
        return curve.point(p.x.redMul(curve.endo.beta), p.y);
      };
      pre.beta = beta;
      beta.precomputed = {
        beta: null,
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(endoMul)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(endoMul)
        }
      };
    }
    return beta;
  };
  
  Point.prototype.toJSON = function toJSON() {
    if (!this.precomputed)
      return [ this.x, this.y ];
  
    return [ this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    } ];
  };
  
  Point.fromJSON = function fromJSON(curve, obj, red) {
    if (typeof obj === 'string')
      obj = JSON.parse(obj);
    var res = curve.point(obj[0], obj[1], red);
    if (!obj[2])
      return res;
  
    function obj2point(obj) {
      return curve.point(obj[0], obj[1], red);
    }
  
    var pre = obj[2];
    res.precomputed = {
      beta: null,
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: [ res ].concat(pre.doubles.points.map(obj2point))
      },
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: [ res ].concat(pre.naf.points.map(obj2point))
      }
    };
    return res;
  };
  
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return '<EC Point Infinity>';
    return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
        ' y: ' + this.y.fromRed().toString(16, 2) + '>';
  };
  
  Point.prototype.isInfinity = function isInfinity() {
    return this.inf;
  };
  
  Point.prototype.add = function add(p) {
    // O + P = P
    if (this.inf)
      return p;
  
    // P + O = P
    if (p.inf)
      return this;
  
    // P + P = 2P
    if (this.eq(p))
      return this.dbl();
  
    // P + (-P) = O
    if (this.neg().eq(p))
      return this.curve.point(null, null);
  
    // P + Q = O
    if (this.x.cmp(p.x) === 0)
      return this.curve.point(null, null);
  
    var c = this.y.redSub(p.y);
    if (c.cmpn(0) !== 0)
      c = c.redMul(this.x.redSub(p.x).redInvm());
    var nx = c.redSqr().redISub(this.x).redISub(p.x);
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };
  
  Point.prototype.dbl = function dbl() {
    if (this.inf)
      return this;
  
    // 2P = O
    var ys1 = this.y.redAdd(this.y);
    if (ys1.cmpn(0) === 0)
      return this.curve.point(null, null);
  
    var a = this.curve.a;
  
    var x2 = this.x.redSqr();
    var dyinv = ys1.redInvm();
    var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
  
    var nx = c.redSqr().redISub(this.x.redAdd(this.x));
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };
  
  Point.prototype.getX = function getX() {
    return this.x.fromRed();
  };
  
  Point.prototype.getY = function getY() {
    return this.y.fromRed();
  };
  
  Point.prototype.mul = function mul(k) {
    k = new BN(k, 16);
    if (this.isInfinity())
      return this;
    else if (this._hasDoubles(k))
      return this.curve._fixedNafMul(this, k);
    else if (this.curve.endo)
      return this.curve._endoWnafMulAdd([ this ], [ k ]);
    else
      return this.curve._wnafMul(this, k);
  };
  
  Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
    var points = [ this, p2 ];
    var coeffs = [ k1, k2 ];
    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs);
    else
      return this.curve._wnafMulAdd(1, points, coeffs, 2);
  };
  
  Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
    var points = [ this, p2 ];
    var coeffs = [ k1, k2 ];
    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs, true);
    else
      return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
  };
  
  Point.prototype.eq = function eq(p) {
    return this === p ||
           this.inf === p.inf &&
               (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
  };
  
  Point.prototype.neg = function neg(_precompute) {
    if (this.inf)
      return this;
  
    var res = this.curve.point(this.x, this.y.redNeg());
    if (_precompute && this.precomputed) {
      var pre = this.precomputed;
      var negate = function(p) {
        return p.neg();
      };
      res.precomputed = {
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(negate)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(negate)
        }
      };
    }
    return res;
  };
  
  Point.prototype.toJ = function toJ() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
  
    var res = this.curve.jpoint(this.x, this.y, this.curve.one);
    return res;
  };
  
  function JPoint(curve, x, y, z) {
    Base.BasePoint.call(this, curve, 'jacobian');
    if (x === null && y === null && z === null) {
      this.x = this.curve.one;
      this.y = this.curve.one;
      this.z = new BN(0);
    } else {
      this.x = new BN(x, 16);
      this.y = new BN(y, 16);
      this.z = new BN(z, 16);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  
    this.zOne = this.z === this.curve.one;
  }
  inherits(JPoint, Base.BasePoint);
  
  ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
    return new JPoint(this, x, y, z);
  };
  
  JPoint.prototype.toP = function toP() {
    if (this.isInfinity())
      return this.curve.point(null, null);
  
    var zinv = this.z.redInvm();
    var zinv2 = zinv.redSqr();
    var ax = this.x.redMul(zinv2);
    var ay = this.y.redMul(zinv2).redMul(zinv);
  
    return this.curve.point(ax, ay);
  };
  
  JPoint.prototype.neg = function neg() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  };
  
  JPoint.prototype.add = function add(p) {
    // O + P = P
    if (this.isInfinity())
      return p;
  
    // P + O = P
    if (p.isInfinity())
      return this;
  
    // 12M + 4S + 7A
    var pz2 = p.z.redSqr();
    var z2 = this.z.redSqr();
    var u1 = this.x.redMul(pz2);
    var u2 = p.x.redMul(z2);
    var s1 = this.y.redMul(pz2.redMul(p.z));
    var s2 = p.y.redMul(z2.redMul(this.z));
  
    var h = u1.redSub(u2);
    var r = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
      if (r.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }
  
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
  
    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(p.z).redMul(h);
  
    return this.curve.jpoint(nx, ny, nz);
  };
  
  JPoint.prototype.mixedAdd = function mixedAdd(p) {
    // O + P = P
    if (this.isInfinity())
      return p.toJ();
  
    // P + O = P
    if (p.isInfinity())
      return this;
  
    // 8M + 3S + 7A
    var z2 = this.z.redSqr();
    var u1 = this.x;
    var u2 = p.x.redMul(z2);
    var s1 = this.y;
    var s2 = p.y.redMul(z2).redMul(this.z);
  
    var h = u1.redSub(u2);
    var r = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
      if (r.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }
  
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
  
    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(h);
  
    return this.curve.jpoint(nx, ny, nz);
  };
  
  JPoint.prototype.dblp = function dblp(pow) {
    if (pow === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!pow)
      return this.dbl();
  
    if (this.curve.zeroA || this.curve.threeA) {
      var r = this;
      for (var i = 0; i < pow; i++)
        r = r.dbl();
      return r;
    }
  
    // 1M + 2S + 1A + N * (4S + 5M + 8A)
    // N = 1 => 6M + 6S + 9A
    var a = this.curve.a;
    var tinv = this.curve.tinv;
  
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
  
    // Reuse results
    var jyd = jy.redAdd(jy);
    for (var i = 0; i < pow; i++) {
      var jx2 = jx.redSqr();
      var jyd2 = jyd.redSqr();
      var jyd4 = jyd2.redSqr();
      var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
  
      var t1 = jx.redMul(jyd2);
      var nx = c.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var dny = c.redMul(t2);
      dny = dny.redIAdd(dny).redISub(jyd4);
      var nz = jyd.redMul(jz);
      if (i + 1 < pow)
        jz4 = jz4.redMul(jyd4);
  
      jx = nx;
      jz = nz;
      jyd = dny;
    }
  
    return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
  };
  
  JPoint.prototype.dbl = function dbl() {
    if (this.isInfinity())
      return this;
  
    if (this.curve.zeroA)
      return this._zeroDbl();
    else if (this.curve.threeA)
      return this._threeDbl();
    else
      return this._dbl();
  };
  
  JPoint.prototype._zeroDbl = function _zeroDbl() {
    var nx;
    var ny;
    var nz;
    // Z = 1
    if (this.zOne) {
      // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
      //     #doubling-mdbl-2007-bl
      // 1M + 5S + 14A
  
      // XX = X1^2
      var xx = this.x.redSqr();
      // YY = Y1^2
      var yy = this.y.redSqr();
      // YYYY = YY^2
      var yyyy = yy.redSqr();
      // S = 2 * ((X1 + YY)^2 - XX - YYYY)
      var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s = s.redIAdd(s);
      // M = 3 * XX + a; a = 0
      var m = xx.redAdd(xx).redIAdd(xx);
      // T = M ^ 2 - 2*S
      var t = m.redSqr().redISub(s).redISub(s);
  
      // 8 * YYYY
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
  
      // X3 = T
      nx = t;
      // Y3 = M * (S - T) - 8 * YYYY
      ny = m.redMul(s.redISub(t)).redISub(yyyy8);
      // Z3 = 2*Y1
      nz = this.y.redAdd(this.y);
    } else {
      // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
      //     #doubling-dbl-2009-l
      // 2M + 5S + 13A
  
      // A = X1^2
      var a = this.x.redSqr();
      // B = Y1^2
      var b = this.y.redSqr();
      // C = B^2
      var c = b.redSqr();
      // D = 2 * ((X1 + B)^2 - A - C)
      var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
      d = d.redIAdd(d);
      // E = 3 * A
      var e = a.redAdd(a).redIAdd(a);
      // F = E^2
      var f = e.redSqr();
  
      // 8 * C
      var c8 = c.redIAdd(c);
      c8 = c8.redIAdd(c8);
      c8 = c8.redIAdd(c8);
  
      // X3 = F - 2 * D
      nx = f.redISub(d).redISub(d);
      // Y3 = E * (D - X3) - 8 * C
      ny = e.redMul(d.redISub(nx)).redISub(c8);
      // Z3 = 2 * Y1 * Z1
      nz = this.y.redMul(this.z);
      nz = nz.redIAdd(nz);
    }
  
    return this.curve.jpoint(nx, ny, nz);
  };
  
  JPoint.prototype._threeDbl = function _threeDbl() {
    var nx;
    var ny;
    var nz;
    // Z = 1
    if (this.zOne) {
      // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
      //     #doubling-mdbl-2007-bl
      // 1M + 5S + 15A
  
      // XX = X1^2
      var xx = this.x.redSqr();
      // YY = Y1^2
      var yy = this.y.redSqr();
      // YYYY = YY^2
      var yyyy = yy.redSqr();
      // S = 2 * ((X1 + YY)^2 - XX - YYYY)
      var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s = s.redIAdd(s);
      // M = 3 * XX + a
      var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
      // T = M^2 - 2 * S
      var t = m.redSqr().redISub(s).redISub(s);
      // X3 = T
      nx = t;
      // Y3 = M * (S - T) - 8 * YYYY
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      ny = m.redMul(s.redISub(t)).redISub(yyyy8);
      // Z3 = 2 * Y1
      nz = this.y.redAdd(this.y);
    } else {
      // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
      // 3M + 5S
  
      // delta = Z1^2
      var delta = this.z.redSqr();
      // gamma = Y1^2
      var gamma = this.y.redSqr();
      // beta = X1 * gamma
      var beta = this.x.redMul(gamma);
      // alpha = 3 * (X1 - delta) * (X1 + delta)
      var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
      alpha = alpha.redAdd(alpha).redIAdd(alpha);
      // X3 = alpha^2 - 8 * beta
      var beta4 = beta.redIAdd(beta);
      beta4 = beta4.redIAdd(beta4);
      var beta8 = beta4.redAdd(beta4);
      nx = alpha.redSqr().redISub(beta8);
      // Z3 = (Y1 + Z1)^2 - gamma - delta
      nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
      // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
      var ggamma8 = gamma.redSqr();
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
    }
  
    return this.curve.jpoint(nx, ny, nz);
  };
  
  JPoint.prototype._dbl = function _dbl() {
    var a = this.curve.a;
  
    // 4M + 6S + 10A
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
  
    var jx2 = jx.redSqr();
    var jy2 = jy.redSqr();
  
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
  
    var jxd4 = jx.redAdd(jx);
    jxd4 = jxd4.redIAdd(jxd4);
    var t1 = jxd4.redMul(jy2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
  
    var jyd8 = jy2.redSqr();
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    var ny = c.redMul(t2).redISub(jyd8);
    var nz = jy.redAdd(jy).redMul(jz);
  
    return this.curve.jpoint(nx, ny, nz);
  };
  
  JPoint.prototype.trpl = function trpl() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
  
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
    // 5M + 10S + ...
  
    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // ZZ = Z1^2
    var zz = this.z.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // M = 3 * XX + a * ZZ2; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // MM = M^2
    var mm = m.redSqr();
    // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
    var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    e = e.redIAdd(e);
    e = e.redAdd(e).redIAdd(e);
    e = e.redISub(mm);
    // EE = E^2
    var ee = e.redSqr();
    // T = 16*YYYY
    var t = yyyy.redIAdd(yyyy);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    // U = (M + E)^2 - MM - EE - T
    var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
    // X3 = 4 * (X1 * EE - 4 * YY * U)
    var yyu4 = yy.redMul(u);
    yyu4 = yyu4.redIAdd(yyu4);
    yyu4 = yyu4.redIAdd(yyu4);
    var nx = this.x.redMul(ee).redISub(yyu4);
    nx = nx.redIAdd(nx);
    nx = nx.redIAdd(nx);
    // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
    var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    // Z3 = (Z1 + E)^2 - ZZ - EE
    var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
  
    return this.curve.jpoint(nx, ny, nz);
  };
  
  JPoint.prototype.mul = function mul(k, kbase) {
    k = new BN(k, kbase);
  
    return this.curve._wnafMul(this, k);
  };
  
  JPoint.prototype.eq = function eq(p) {
    if (p.type === 'affine')
      return this.eq(p.toJ());
  
    if (this === p)
      return true;
  
    // x1 * z2^2 == x2 * z1^2
    var z2 = this.z.redSqr();
    var pz2 = p.z.redSqr();
    if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
      return false;
  
    // y1 * z2^3 == y2 * z1^3
    var z3 = z2.redMul(this.z);
    var pz3 = pz2.redMul(p.z);
    return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
  };
  
  JPoint.prototype.eqXToP = function eqXToP(x) {
    var zs = this.z.redSqr();
    var rx = x.toRed(this.curve.red).redMul(zs);
    if (this.x.cmp(rx) === 0)
      return true;
  
    var xc = x.clone();
    var t = this.curve.redN.redMul(zs);
    for (;;) {
      xc.iadd(this.curve.n);
      if (xc.cmp(this.curve.p) >= 0)
        return false;
  
      rx.redIAdd(t);
      if (this.x.cmp(rx) === 0)
        return true;
    }
  };
  
  JPoint.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return '<EC JPoint Infinity>';
    return '<EC JPoint x: ' + this.x.toString(16, 2) +
        ' y: ' + this.y.toString(16, 2) +
        ' z: ' + this.z.toString(16, 2) + '>';
  };
  
  JPoint.prototype.isInfinity = function isInfinity() {
    // XXX This code assumes that zero is always zero in red
    return this.z.cmpn(0) === 0;
  };
  
  },{"../utils":215,"./base":202,"bn.js":187,"inherits":280}],207:[function(require,module,exports){
  'use strict';
  
  var curves = exports;
  
  var hash = require('hash.js');
  var curve = require('./curve');
  var utils = require('./utils');
  
  var assert = utils.assert;
  
  function PresetCurve(options) {
    if (options.type === 'short')
      this.curve = new curve.short(options);
    else if (options.type === 'edwards')
      this.curve = new curve.edwards(options);
    else
      this.curve = new curve.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
  
    assert(this.g.validate(), 'Invalid curve');
    assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
  }
  curves.PresetCurve = PresetCurve;
  
  function defineCurve(name, options) {
    Object.defineProperty(curves, name, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name, {
          configurable: true,
          enumerable: true,
          value: curve
        });
        return curve;
      }
    });
  }
  
  defineCurve('p192', {
    type: 'short',
    prime: 'p192',
    p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
    a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
    b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
    n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
    hash: hash.sha256,
    gRed: false,
    g: [
      '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
      '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
    ]
  });
  
  defineCurve('p224', {
    type: 'short',
    prime: 'p224',
    p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
    a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
    b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
    n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
    hash: hash.sha256,
    gRed: false,
    g: [
      'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
      'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
    ]
  });
  
  defineCurve('p256', {
    type: 'short',
    prime: null,
    p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
    a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
    b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
    n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
    hash: hash.sha256,
    gRed: false,
    g: [
      '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
      '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
    ]
  });
  
  defineCurve('p384', {
    type: 'short',
    prime: null,
    p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
       'fffffffe ffffffff 00000000 00000000 ffffffff',
    a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
       'fffffffe ffffffff 00000000 00000000 fffffffc',
    b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
       '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
    n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
       'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
    hash: hash.sha384,
    gRed: false,
    g: [
      'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
      '5502f25d bf55296c 3a545e38 72760ab7',
      '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
      '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'
    ]
  });
  
  defineCurve('p521', {
    type: 'short',
    prime: null,
    p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
       'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
       'ffffffff ffffffff ffffffff ffffffff ffffffff',
    a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
       'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
       'ffffffff ffffffff ffffffff ffffffff fffffffc',
    b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
       '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
       '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
    n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
       'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
       'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
    hash: hash.sha512,
    gRed: false,
    g: [
      '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
      '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
      'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
      '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
      '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
      '3fad0761 353c7086 a272c240 88be9476 9fd16650'
    ]
  });
  
  defineCurve('curve25519', {
    type: 'mont',
    prime: 'p25519',
    p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
    a: '76d06',
    b: '1',
    n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
    hash: hash.sha256,
    gRed: false,
    g: [
      '9'
    ]
  });
  
  defineCurve('ed25519', {
    type: 'edwards',
    prime: 'p25519',
    p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
    a: '-1',
    c: '1',
    // -121665 * (121666^(-1)) (mod P)
    d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
    n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
    hash: hash.sha256,
    gRed: false,
    g: [
      '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',
  
      // 4/5
      '6666666666666666666666666666666666666666666666666666666666666658'
    ]
  });
  
  var pre;
  try {
    pre = require('./precomputed/secp256k1');
  } catch (e) {
    pre = undefined;
  }
  
  defineCurve('secp256k1', {
    type: 'short',
    prime: 'k256',
    p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
    a: '0',
    b: '7',
    n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
    h: '1',
    hash: hash.sha256,
  
    // Precomputed endomorphism
    beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
    lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
    basis: [
      {
        a: '3086d221a7d46bcde86c90e49284eb15',
        b: '-e4437ed6010e88286f547fa90abfe4c3'
      },
      {
        a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
        b: '3086d221a7d46bcde86c90e49284eb15'
      }
    ],
  
    gRed: false,
    g: [
      '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
      '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
      pre
    ]
  });
  
  },{"./curve":204,"./precomputed/secp256k1":214,"./utils":215,"hash.js":219}],208:[function(require,module,exports){
  'use strict';
  
  var BN = require('bn.js');
  var HmacDRBG = require('hmac-drbg');
  var utils = require('../utils');
  var curves = require('../curves');
  var rand = require('brorand');
  var assert = utils.assert;
  
  var KeyPair = require('./key');
  var Signature = require('./signature');
  
  function EC(options) {
    if (!(this instanceof EC))
      return new EC(options);
  
    // Shortcut `elliptic.ec(curve-name)`
    if (typeof options === 'string') {
      assert(curves.hasOwnProperty(options), 'Unknown curve ' + options);
  
      options = curves[options];
    }
  
    // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
    if (options instanceof curves.PresetCurve)
      options = { curve: options };
  
    this.curve = options.curve.curve;
    this.n = this.curve.n;
    this.nh = this.n.ushrn(1);
    this.g = this.curve.g;
  
    // Point on curve
    this.g = options.curve.g;
    this.g.precompute(options.curve.n.bitLength() + 1);
  
    // Hash for function for DRBG
    this.hash = options.hash || options.curve.hash;
  }
  module.exports = EC;
  
  EC.prototype.keyPair = function keyPair(options) {
    return new KeyPair(this, options);
  };
  
  EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
    return KeyPair.fromPrivate(this, priv, enc);
  };
  
  EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
    return KeyPair.fromPublic(this, pub, enc);
  };
  
  EC.prototype.genKeyPair = function genKeyPair(options) {
    if (!options)
      options = {};
  
    // Instantiate Hmac_DRBG
    var drbg = new HmacDRBG({
      hash: this.hash,
      pers: options.pers,
      persEnc: options.persEnc || 'utf8',
      entropy: options.entropy || rand(this.hash.hmacStrength),
      entropyEnc: options.entropy && options.entropyEnc || 'utf8',
      nonce: this.n.toArray()
    });
  
    var bytes = this.n.byteLength();
    var ns2 = this.n.sub(new BN(2));
    do {
      var priv = new BN(drbg.generate(bytes));
      if (priv.cmp(ns2) > 0)
        continue;
  
      priv.iaddn(1);
      return this.keyFromPrivate(priv);
    } while (true);
  };
  
  EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
    var delta = msg.byteLength() * 8 - this.n.bitLength();
    if (delta > 0)
      msg = msg.ushrn(delta);
    if (!truncOnly && msg.cmp(this.n) >= 0)
      return msg.sub(this.n);
    else
      return msg;
  };
  
  EC.prototype.sign = function sign(msg, key, enc, options) {
    if (typeof enc === 'object') {
      options = enc;
      enc = null;
    }
    if (!options)
      options = {};
  
    key = this.keyFromPrivate(key, enc);
    msg = this._truncateToN(new BN(msg, 16));
  
    // Zero-extend key to provide enough entropy
    var bytes = this.n.byteLength();
    var bkey = key.getPrivate().toArray('be', bytes);
  
    // Zero-extend nonce to have the same byte size as N
    var nonce = msg.toArray('be', bytes);
  
    // Instantiate Hmac_DRBG
    var drbg = new HmacDRBG({
      hash: this.hash,
      entropy: bkey,
      nonce: nonce,
      pers: options.pers,
      persEnc: options.persEnc || 'utf8'
    });
  
    // Number of bytes to generate
    var ns1 = this.n.sub(new BN(1));
  
    for (var iter = 0; true; iter++) {
      var k = options.k ?
          options.k(iter) :
          new BN(drbg.generate(this.n.byteLength()));
      k = this._truncateToN(k, true);
      if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
        continue;
  
      var kp = this.g.mul(k);
      if (kp.isInfinity())
        continue;
  
      var kpX = kp.getX();
      var r = kpX.umod(this.n);
      if (r.cmpn(0) === 0)
        continue;
  
      var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
      s = s.umod(this.n);
      if (s.cmpn(0) === 0)
        continue;
  
      var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                          (kpX.cmp(r) !== 0 ? 2 : 0);
  
      // Use complement of `s`, if it is > `n / 2`
      if (options.canonical && s.cmp(this.nh) > 0) {
        s = this.n.sub(s);
        recoveryParam ^= 1;
      }
  
      return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
    }
  };
  
  EC.prototype.verify = function verify(msg, signature, key, enc) {
    msg = this._truncateToN(new BN(msg, 16));
    key = this.keyFromPublic(key, enc);
    signature = new Signature(signature, 'hex');
  
    // Perform primitive values validation
    var r = signature.r;
    var s = signature.s;
    if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
      return false;
    if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
      return false;
  
    // Validate signature
    var sinv = s.invm(this.n);
    var u1 = sinv.mul(msg).umod(this.n);
    var u2 = sinv.mul(r).umod(this.n);
  
    if (!this.curve._maxwellTrick) {
      var p = this.g.mulAdd(u1, key.getPublic(), u2);
      if (p.isInfinity())
        return false;
  
      return p.getX().umod(this.n).cmp(r) === 0;
    }
  
    // NOTE: Greg Maxwell's trick, inspired by:
    // https://git.io/vad3K
  
    var p = this.g.jmulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;
  
    // Compare `p.x` of Jacobian point with `r`,
    // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
    // inverse of `p.z^2`
    return p.eqXToP(r);
  };
  
  EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
    assert((3 & j) === j, 'The recovery param is more than two bits');
    signature = new Signature(signature, enc);
  
    var n = this.n;
    var e = new BN(msg);
    var r = signature.r;
    var s = signature.s;
  
    // A set LSB signifies that the y-coordinate is odd
    var isYOdd = j & 1;
    var isSecondKey = j >> 1;
    if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
      throw new Error('Unable to find sencond key candinate');
  
    // 1.1. Let x = r + jn.
    if (isSecondKey)
      r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
    else
      r = this.curve.pointFromX(r, isYOdd);
  
    var rInv = signature.r.invm(n);
    var s1 = n.sub(e).mul(rInv).umod(n);
    var s2 = s.mul(rInv).umod(n);
  
    // 1.6.1 Compute Q = r^-1 (sR -  eG)
    //               Q = r^-1 (sR + -eG)
    return this.g.mulAdd(s1, r, s2);
  };
  
  EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
    signature = new Signature(signature, enc);
    if (signature.recoveryParam !== null)
      return signature.recoveryParam;
  
    for (var i = 0; i < 4; i++) {
      var Qprime;
      try {
        Qprime = this.recoverPubKey(e, signature, i);
      } catch (e) {
        continue;
      }
  
      if (Qprime.eq(Q))
        return i;
    }
    throw new Error('Unable to find valid recovery factor');
  };
  
  },{"../curves":207,"../utils":215,"./key":209,"./signature":210,"bn.js":187,"brorand":188,"hmac-drbg":231}],209:[function(require,module,exports){
  'use strict';
  
  var BN = require('bn.js');
  var utils = require('../utils');
  var assert = utils.assert;
  
  function KeyPair(ec, options) {
    this.ec = ec;
    this.priv = null;
    this.pub = null;
  
    // KeyPair(ec, { priv: ..., pub: ... })
    if (options.priv)
      this._importPrivate(options.priv, options.privEnc);
    if (options.pub)
      this._importPublic(options.pub, options.pubEnc);
  }
  module.exports = KeyPair;
  
  KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
    if (pub instanceof KeyPair)
      return pub;
  
    return new KeyPair(ec, {
      pub: pub,
      pubEnc: enc
    });
  };
  
  KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
    if (priv instanceof KeyPair)
      return priv;
  
    return new KeyPair(ec, {
      priv: priv,
      privEnc: enc
    });
  };
  
  KeyPair.prototype.validate = function validate() {
    var pub = this.getPublic();
  
    if (pub.isInfinity())
      return { result: false, reason: 'Invalid public key' };
    if (!pub.validate())
      return { result: false, reason: 'Public key is not a point' };
    if (!pub.mul(this.ec.curve.n).isInfinity())
      return { result: false, reason: 'Public key * N != O' };
  
    return { result: true, reason: null };
  };
  
  KeyPair.prototype.getPublic = function getPublic(compact, enc) {
    // compact is optional argument
    if (typeof compact === 'string') {
      enc = compact;
      compact = null;
    }
  
    if (!this.pub)
      this.pub = this.ec.g.mul(this.priv);
  
    if (!enc)
      return this.pub;
  
    return this.pub.encode(enc, compact);
  };
  
  KeyPair.prototype.getPrivate = function getPrivate(enc) {
    if (enc === 'hex')
      return this.priv.toString(16, 2);
    else
      return this.priv;
  };
  
  KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
    this.priv = new BN(key, enc || 16);
  
    // Ensure that the priv won't be bigger than n, otherwise we may fail
    // in fixed multiplication method
    this.priv = this.priv.umod(this.ec.curve.n);
  };
  
  KeyPair.prototype._importPublic = function _importPublic(key, enc) {
    if (key.x || key.y) {
      // Montgomery points only have an `x` coordinate.
      // Weierstrass/Edwards points on the other hand have both `x` and
      // `y` coordinates.
      if (this.ec.curve.type === 'mont') {
        assert(key.x, 'Need x coordinate');
      } else if (this.ec.curve.type === 'short' ||
                 this.ec.curve.type === 'edwards') {
        assert(key.x && key.y, 'Need both x and y coordinate');
      }
      this.pub = this.ec.curve.point(key.x, key.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(key, enc);
  };
  
  // ECDH
  KeyPair.prototype.derive = function derive(pub) {
    return pub.mul(this.priv).getX();
  };
  
  // ECDSA
  KeyPair.prototype.sign = function sign(msg, enc, options) {
    return this.ec.sign(msg, this, enc, options);
  };
  
  KeyPair.prototype.verify = function verify(msg, signature) {
    return this.ec.verify(msg, signature, this);
  };
  
  KeyPair.prototype.inspect = function inspect() {
    return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
           ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
  };
  
  },{"../utils":215,"bn.js":187}],210:[function(require,module,exports){
  'use strict';
  
  var BN = require('bn.js');
  
  var utils = require('../utils');
  var assert = utils.assert;
  
  function Signature(options, enc) {
    if (options instanceof Signature)
      return options;
  
    if (this._importDER(options, enc))
      return;
  
    assert(options.r && options.s, 'Signature without r or s');
    this.r = new BN(options.r, 16);
    this.s = new BN(options.s, 16);
    if (options.recoveryParam === undefined)
      this.recoveryParam = null;
    else
      this.recoveryParam = options.recoveryParam;
  }
  module.exports = Signature;
  
  function Position() {
    this.place = 0;
  }
  
  function getLength(buf, p) {
    var initial = buf[p.place++];
    if (!(initial & 0x80)) {
      return initial;
    }
    var octetLen = initial & 0xf;
    var val = 0;
    for (var i = 0, off = p.place; i < octetLen; i++, off++) {
      val <<= 8;
      val |= buf[off];
    }
    p.place = off;
    return val;
  }
  
  function rmPadding(buf) {
    var i = 0;
    var len = buf.length - 1;
    while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
      i++;
    }
    if (i === 0) {
      return buf;
    }
    return buf.slice(i);
  }
  
  Signature.prototype._importDER = function _importDER(data, enc) {
    data = utils.toArray(data, enc);
    var p = new Position();
    if (data[p.place++] !== 0x30) {
      return false;
    }
    var len = getLength(data, p);
    if ((len + p.place) !== data.length) {
      return false;
    }
    if (data[p.place++] !== 0x02) {
      return false;
    }
    var rlen = getLength(data, p);
    var r = data.slice(p.place, rlen + p.place);
    p.place += rlen;
    if (data[p.place++] !== 0x02) {
      return false;
    }
    var slen = getLength(data, p);
    if (data.length !== slen + p.place) {
      return false;
    }
    var s = data.slice(p.place, slen + p.place);
    if (r[0] === 0 && (r[1] & 0x80)) {
      r = r.slice(1);
    }
    if (s[0] === 0 && (s[1] & 0x80)) {
      s = s.slice(1);
    }
  
    this.r = new BN(r);
    this.s = new BN(s);
    this.recoveryParam = null;
  
    return true;
  };
  
  function constructLength(arr, len) {
    if (len < 0x80) {
      arr.push(len);
      return;
    }
    var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
    arr.push(octets | 0x80);
    while (--octets) {
      arr.push((len >>> (octets << 3)) & 0xff);
    }
    arr.push(len);
  }
  
  Signature.prototype.toDER = function toDER(enc) {
    var r = this.r.toArray();
    var s = this.s.toArray();
  
    // Pad values
    if (r[0] & 0x80)
      r = [ 0 ].concat(r);
    // Pad values
    if (s[0] & 0x80)
      s = [ 0 ].concat(s);
  
    r = rmPadding(r);
    s = rmPadding(s);
  
    while (!s[0] && !(s[1] & 0x80)) {
      s = s.slice(1);
    }
    var arr = [ 0x02 ];
    constructLength(arr, r.length);
    arr = arr.concat(r);
    arr.push(0x02);
    constructLength(arr, s.length);
    var backHalf = arr.concat(s);
    var res = [ 0x30 ];
    constructLength(res, backHalf.length);
    res = res.concat(backHalf);
    return utils.encode(res, enc);
  };
  
  },{"../utils":215,"bn.js":187}],211:[function(require,module,exports){
  'use strict';
  
  var hash = require('hash.js');
  var curves = require('../curves');
  var utils = require('../utils');
  var assert = utils.assert;
  var parseBytes = utils.parseBytes;
  var KeyPair = require('./key');
  var Signature = require('./signature');
  
  function EDDSA(curve) {
    assert(curve === 'ed25519', 'only tested with ed25519 so far');
  
    if (!(this instanceof EDDSA))
      return new EDDSA(curve);
  
    var curve = curves[curve].curve;
    this.curve = curve;
    this.g = curve.g;
    this.g.precompute(curve.n.bitLength() + 1);
  
    this.pointClass = curve.point().constructor;
    this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
    this.hash = hash.sha512;
  }
  
  module.exports = EDDSA;
  
  /**
  * @param {Array|String} message - message bytes
  * @param {Array|String|KeyPair} secret - secret bytes or a keypair
  * @returns {Signature} - signature
  */
  EDDSA.prototype.sign = function sign(message, secret) {
    message = parseBytes(message);
    var key = this.keyFromSecret(secret);
    var r = this.hashInt(key.messagePrefix(), message);
    var R = this.g.mul(r);
    var Rencoded = this.encodePoint(R);
    var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
                 .mul(key.priv());
    var S = r.add(s_).umod(this.curve.n);
    return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
  };
  
  /**
  * @param {Array} message - message bytes
  * @param {Array|String|Signature} sig - sig bytes
  * @param {Array|String|Point|KeyPair} pub - public key
  * @returns {Boolean} - true if public key matches sig of message
  */
  EDDSA.prototype.verify = function verify(message, sig, pub) {
    message = parseBytes(message);
    sig = this.makeSignature(sig);
    var key = this.keyFromPublic(pub);
    var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
    var SG = this.g.mul(sig.S());
    var RplusAh = sig.R().add(key.pub().mul(h));
    return RplusAh.eq(SG);
  };
  
  EDDSA.prototype.hashInt = function hashInt() {
    var hash = this.hash();
    for (var i = 0; i < arguments.length; i++)
      hash.update(arguments[i]);
    return utils.intFromLE(hash.digest()).umod(this.curve.n);
  };
  
  EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
    return KeyPair.fromPublic(this, pub);
  };
  
  EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
    return KeyPair.fromSecret(this, secret);
  };
  
  EDDSA.prototype.makeSignature = function makeSignature(sig) {
    if (sig instanceof Signature)
      return sig;
    return new Signature(this, sig);
  };
  
  /**
  * * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
  *
  * EDDSA defines methods for encoding and decoding points and integers. These are
  * helper convenience methods, that pass along to utility functions implied
  * parameters.
  *
  */
  EDDSA.prototype.encodePoint = function encodePoint(point) {
    var enc = point.getY().toArray('le', this.encodingLength);
    enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
    return enc;
  };
  
  EDDSA.prototype.decodePoint = function decodePoint(bytes) {
    bytes = utils.parseBytes(bytes);
  
    var lastIx = bytes.length - 1;
    var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
    var xIsOdd = (bytes[lastIx] & 0x80) !== 0;
  
    var y = utils.intFromLE(normed);
    return this.curve.pointFromY(y, xIsOdd);
  };
  
  EDDSA.prototype.encodeInt = function encodeInt(num) {
    return num.toArray('le', this.encodingLength);
  };
  
  EDDSA.prototype.decodeInt = function decodeInt(bytes) {
    return utils.intFromLE(bytes);
  };
  
  EDDSA.prototype.isPoint = function isPoint(val) {
    return val instanceof this.pointClass;
  };
  
  },{"../curves":207,"../utils":215,"./key":212,"./signature":213,"hash.js":219}],212:[function(require,module,exports){
  'use strict';
  
  var utils = require('../utils');
  var assert = utils.assert;
  var parseBytes = utils.parseBytes;
  var cachedProperty = utils.cachedProperty;
  
  /**
  * @param {EDDSA} eddsa - instance
  * @param {Object} params - public/private key parameters
  *
  * @param {Array<Byte>} [params.secret] - secret seed bytes
  * @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
  * @param {Array<Byte>} [params.pub] - public key point encoded as bytes
  *
  */
  function KeyPair(eddsa, params) {
    this.eddsa = eddsa;
    this._secret = parseBytes(params.secret);
    if (eddsa.isPoint(params.pub))
      this._pub = params.pub;
    else
      this._pubBytes = parseBytes(params.pub);
  }
  
  KeyPair.fromPublic = function fromPublic(eddsa, pub) {
    if (pub instanceof KeyPair)
      return pub;
    return new KeyPair(eddsa, { pub: pub });
  };
  
  KeyPair.fromSecret = function fromSecret(eddsa, secret) {
    if (secret instanceof KeyPair)
      return secret;
    return new KeyPair(eddsa, { secret: secret });
  };
  
  KeyPair.prototype.secret = function secret() {
    return this._secret;
  };
  
  cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
    return this.eddsa.encodePoint(this.pub());
  });
  
  cachedProperty(KeyPair, 'pub', function pub() {
    if (this._pubBytes)
      return this.eddsa.decodePoint(this._pubBytes);
    return this.eddsa.g.mul(this.priv());
  });
  
  cachedProperty(KeyPair, 'privBytes', function privBytes() {
    var eddsa = this.eddsa;
    var hash = this.hash();
    var lastIx = eddsa.encodingLength - 1;
  
    var a = hash.slice(0, eddsa.encodingLength);
    a[0] &= 248;
    a[lastIx] &= 127;
    a[lastIx] |= 64;
  
    return a;
  });
  
  cachedProperty(KeyPair, 'priv', function priv() {
    return this.eddsa.decodeInt(this.privBytes());
  });
  
  cachedProperty(KeyPair, 'hash', function hash() {
    return this.eddsa.hash().update(this.secret()).digest();
  });
  
  cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
    return this.hash().slice(this.eddsa.encodingLength);
  });
  
  KeyPair.prototype.sign = function sign(message) {
    assert(this._secret, 'KeyPair can only verify');
    return this.eddsa.sign(message, this);
  };
  
  KeyPair.prototype.verify = function verify(message, sig) {
    return this.eddsa.verify(message, sig, this);
  };
  
  KeyPair.prototype.getSecret = function getSecret(enc) {
    assert(this._secret, 'KeyPair is public only');
    return utils.encode(this.secret(), enc);
  };
  
  KeyPair.prototype.getPublic = function getPublic(enc) {
    return utils.encode(this.pubBytes(), enc);
  };
  
  module.exports = KeyPair;
  
  },{"../utils":215}],213:[function(require,module,exports){
  'use strict';
  
  var BN = require('bn.js');
  var utils = require('../utils');
  var assert = utils.assert;
  var cachedProperty = utils.cachedProperty;
  var parseBytes = utils.parseBytes;
  
  /**
  * @param {EDDSA} eddsa - eddsa instance
  * @param {Array<Bytes>|Object} sig -
  * @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
  * @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
  * @param {Array<Bytes>} [sig.Rencoded] - R point encoded
  * @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
  */
  function Signature(eddsa, sig) {
    this.eddsa = eddsa;
  
    if (typeof sig !== 'object')
      sig = parseBytes(sig);
  
    if (Array.isArray(sig)) {
      sig = {
        R: sig.slice(0, eddsa.encodingLength),
        S: sig.slice(eddsa.encodingLength)
      };
    }
  
    assert(sig.R && sig.S, 'Signature without R or S');
  
    if (eddsa.isPoint(sig.R))
      this._R = sig.R;
    if (sig.S instanceof BN)
      this._S = sig.S;
  
    this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
    this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
  }
  
  cachedProperty(Signature, 'S', function S() {
    return this.eddsa.decodeInt(this.Sencoded());
  });
  
  cachedProperty(Signature, 'R', function R() {
    return this.eddsa.decodePoint(this.Rencoded());
  });
  
  cachedProperty(Signature, 'Rencoded', function Rencoded() {
    return this.eddsa.encodePoint(this.R());
  });
  
  cachedProperty(Signature, 'Sencoded', function Sencoded() {
    return this.eddsa.encodeInt(this.S());
  });
  
  Signature.prototype.toBytes = function toBytes() {
    return this.Rencoded().concat(this.Sencoded());
  };
  
  Signature.prototype.toHex = function toHex() {
    return utils.encode(this.toBytes(), 'hex').toUpperCase();
  };
  
  module.exports = Signature;
  
  },{"../utils":215,"bn.js":187}],214:[function(require,module,exports){
  module.exports = {
    doubles: {
      step: 4,
      points: [
        [
          'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
          'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
        ],
        [
          '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
          '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
        ],
        [
          '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
          'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
        ],
        [
          '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
          '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
        ],
        [
          '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
          '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
        ],
        [
          '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
          '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
        ],
        [
          'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
          '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
        ],
        [
          '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
          'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
        ],
        [
          'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
          '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
        ],
        [
          'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
          'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
        ],
        [
          'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
          '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
        ],
        [
          '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
          '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
        ],
        [
          '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
          '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
        ],
        [
          '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
          '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
        ],
        [
          '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
          '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
        ],
        [
          '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
          '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
        ],
        [
          '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
          '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
        ],
        [
          '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
          '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
        ],
        [
          '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
          'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
        ],
        [
          'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
          '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
        ],
        [
          'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
          '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
        ],
        [
          '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
          '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
        ],
        [
          '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
          '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
        ],
        [
          'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
          '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
        ],
        [
          '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
          'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
        ],
        [
          'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
          '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
        ],
        [
          'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
          'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
        ],
        [
          'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
          '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
        ],
        [
          'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
          'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
        ],
        [
          'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
          '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
        ],
        [
          '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
          'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
        ],
        [
          '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
          '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
        ],
        [
          'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
          '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
        ],
        [
          '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
          'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
        ],
        [
          'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
          '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
        ],
        [
          'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
          '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
        ],
        [
          'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
          'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
        ],
        [
          '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
          '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
        ],
        [
          '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
          '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
        ],
        [
          '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
          'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
        ],
        [
          '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
          '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
        ],
        [
          'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
          '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
        ],
        [
          '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
          '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
        ],
        [
          '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
          'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
        ],
        [
          '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
          '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
        ],
        [
          'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
          '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
        ],
        [
          '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
          'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
        ],
        [
          'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
          'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
        ],
        [
          'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
          '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
        ],
        [
          '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
          'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
        ],
        [
          '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
          'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
        ],
        [
          'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
          '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
        ],
        [
          'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
          '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
        ],
        [
          'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
          '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
        ],
        [
          '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
          'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
        ],
        [
          '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
          '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
        ],
        [
          'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
          'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
        ],
        [
          '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
          'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
        ],
        [
          '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
          '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
        ],
        [
          '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
          '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
        ],
        [
          'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
          'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
        ],
        [
          '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
          '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
        ],
        [
          '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
          '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
        ],
        [
          'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
          '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
        ],
        [
          'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
          'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
          '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
        ],
        [
          '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
          'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
        ],
        [
          '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
          '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
        ],
        [
          'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
          'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
        ],
        [
          '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
          'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
        ],
        [
          'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
          'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
        ],
        [
          'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
          '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
        ],
        [
          'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
          '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
        ],
        [
          '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
          '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
        ],
        [
          '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
          '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
        ],
        [
          '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
          '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
        ],
        [
          '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
          '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
        ],
        [
          'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
          'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
        ],
        [
          'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
          '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
        ],
        [
          '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
          'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
        ],
        [
          '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
          'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
        ],
        [
          '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
          '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
        ],
        [
          '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
          '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
        ],
        [
          '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
          '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
        ],
        [
          '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
          'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
        ],
        [
          'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
          'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
        ],
        [
          '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
          '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
        ],
        [
          '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
          '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
        ],
        [
          'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
          'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
        ],
        [
          '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
          '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
        ],
        [
          'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
          'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
        ],
        [
          'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
          'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
        ],
        [
          '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
          '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
        ],
        [
          '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
          '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
        ],
        [
          '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
          '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
        ],
        [
          'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
          '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
        ],
        [
          '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
          '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
        ],
        [
          'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
          '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
        ],
        [
          '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
          'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
        ],
        [
          '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
          'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
        ],
        [
          'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
          'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
        ],
        [
          '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
          '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
        ],
        [
          '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
          'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
        ],
        [
          'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
          'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
        ],
        [
          '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
          '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
        ],
        [
          '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
          'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
        ],
        [
          '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
          '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
        ],
        [
          '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
          'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
        ],
        [
          'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
          '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
        ],
        [
          '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
          '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
        ],
        [
          '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
          'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
        ],
        [
          '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
          'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
        ],
        [
          'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
          'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
        ],
        [
          'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
          'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
        ],
        [
          '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
          '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
        ],
        [
          '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
          '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
        ],
        [
          'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
          '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
        ],
        [
          'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
          'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
        ],
        [
          '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
          '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
        ],
        [
          '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
          '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
        ],
        [
          'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
          '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
        ],
        [
          '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
          '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
        ],
        [
          'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
          'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
        ],
        [
          '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
          'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
        ],
        [
          '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
          '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
        ],
        [
          'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
          '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
        ],
        [
          'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
          '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
        ],
        [
          '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
          '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
        ],
        [
          '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
          '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
        ],
        [
          '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
          'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
        ],
        [
          '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
          'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
        ],
        [
          '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
          '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
        ],
        [
          '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
          '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
        ],
        [
          '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
          '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
        ],
        [
          '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
          'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
        ],
        [
          'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
          'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
        ],
        [
          '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
          'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
        ],
        [
          'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
          '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
        ],
        [
          'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
          '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
        ],
        [
          'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
          '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
        ],
        [
          'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
          '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
        ],
        [
          '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
          'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
        ],
        [
          '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
          '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
        ],
        [
          '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
          'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
        ],
        [
          'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
          'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
        ],
        [
          'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
          '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
        ],
        [
          'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
          'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
        ],
        [
          'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
          '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
        ],
        [
          '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
          '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
        ],
        [
          'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
          '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
        ],
        [
          'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
          '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
        ],
        [
          '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
          '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
        ],
        [
          '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
          'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
        ],
        [
          'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
          '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
        ],
        [
          'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
          '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
        ],
        [
          'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
          '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
        ],
        [
          '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
          '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
        ],
        [
          'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
          'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
        ],
        [
          '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
          'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
        ],
        [
          'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
          'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
        ],
        [
          'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
          '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
        ],
        [
          '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
          'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
        ],
        [
          'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
          '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
        ],
        [
          'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
          '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
        ],
        [
          'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
          '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
        ],
        [
          '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
          'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
        ],
        [
          '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
          'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
        ],
        [
          'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
          '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
        ],
        [
          '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
          'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
        ],
        [
          '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
          '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
        ],
        [
          '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
          'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
        ],
        [
          'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
          'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
        ],
        [
          '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
          'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
        ],
        [
          '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
          '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
        ],
        [
          '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
          'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
        ],
        [
          '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
          '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
        ],
        [
          'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
          'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
        ],
        [
          '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
          '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
        ],
        [
          'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
          '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
        ],
        [
          '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
          '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
        ],
        [
          'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
          'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
        ],
        [
          'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
          '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
        ],
        [
          'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
          'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
        ],
        [
          '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
          'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
        ],
        [
          '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
          '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
        ],
        [
          '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
          'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
        ],
        [
          '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
          '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
        ],
        [
          '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
          '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
        ],
        [
          '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
          'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
        ],
        [
          '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
          '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
        ],
        [
          '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
          '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
        ],
        [
          '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
          '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
        ]
      ]
    }
  };
  
  },{}],215:[function(require,module,exports){
  'use strict';
  
  var utils = exports;
  var BN = require('bn.js');
  var minAssert = require('minimalistic-assert');
  var minUtils = require('minimalistic-crypto-utils');
  
  utils.assert = minAssert;
  utils.toArray = minUtils.toArray;
  utils.zero2 = minUtils.zero2;
  utils.toHex = minUtils.toHex;
  utils.encode = minUtils.encode;
  
  // Represent num in a w-NAF form
  function getNAF(num, w, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
  
    var ws = 1 << (w + 1);
    var k = num.clone();
  
    for (var i = 0; i < naf.length; i++) {
      var z;
      var mod = k.andln(ws - 1);
      if (k.isOdd()) {
        if (mod > (ws >> 1) - 1)
          z = (ws >> 1) - mod;
        else
          z = mod;
        k.isubn(z);
      } else {
        z = 0;
      }
  
      naf[i] = z;
      k.iushrn(1);
    }
  
    return naf;
  }
  utils.getNAF = getNAF;
  
  // Represent k1, k2 in a Joint Sparse Form
  function getJSF(k1, k2) {
    var jsf = [
      [],
      []
    ];
  
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
  
      // First phase
      var m14 = (k1.andln(3) + d1) & 3;
      var m24 = (k2.andln(3) + d2) & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        var m8 = (k1.andln(7) + d1) & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
  
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        var m8 = (k2.andln(7) + d2) & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
  
      // Second phase
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
  
    return jsf;
  }
  utils.getJSF = getJSF;
  
  function cachedProperty(obj, name, computer) {
    var key = '_' + name;
    obj.prototype[name] = function cachedProperty() {
      return this[key] !== undefined ? this[key] :
             this[key] = computer.call(this);
    };
  }
  utils.cachedProperty = cachedProperty;
  
  function parseBytes(bytes) {
    return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
                                       bytes;
  }
  utils.parseBytes = parseBytes;
  
  function intFromLE(bytes) {
    return new BN(bytes, 'hex', 'le');
  }
  utils.intFromLE = intFromLE;
  
  
  },{"bn.js":187,"minimalistic-assert":242,"minimalistic-crypto-utils":243}],216:[function(require,module,exports){
  module.exports={
    "_from": "elliptic@^6.5.1",
    "_id": "elliptic@6.5.2",
    "_inBundle": false,
    "_integrity": "sha512-f4x70okzZbIQl/NSRLkI/+tteV/9WqL98zx+SQ69KbXxmVrmjwsNUPn/gYJJ0sHvEak24cZgHIPegRePAtA/xw==",
    "_location": "/blockstack/elliptic",
    "_phantomChildren": {},
    "_requested": {
      "type": "range",
      "registry": true,
      "raw": "elliptic@^6.5.1",
      "name": "elliptic",
      "escapedName": "elliptic",
      "rawSpec": "^6.5.1",
      "saveSpec": null,
      "fetchSpec": "^6.5.1"
    },
    "_requiredBy": [
      "/blockstack",
      "/blockstack/jsontokens",
      "/blockstack/tiny-secp256k1"
    ],
    "_resolved": "https://registry.npmjs.org/elliptic/-/elliptic-6.5.2.tgz",
    "_shasum": "05c5678d7173c049d8ca433552224a495d0e3762",
    "_spec": "elliptic@^6.5.1",
    "_where": "D:\\Documents\\GitHub\\gamePartyApp\\node_modules\\blockstack",
    "author": {
      "name": "Fedor Indutny",
      "email": "fedor@indutny.com"
    },
    "bugs": {
      "url": "https://github.com/indutny/elliptic/issues"
    },
    "bundleDependencies": false,
    "dependencies": {
      "bn.js": "^4.4.0",
      "brorand": "^1.0.1",
      "hash.js": "^1.0.0",
      "hmac-drbg": "^1.0.0",
      "inherits": "^2.0.1",
      "minimalistic-assert": "^1.0.0",
      "minimalistic-crypto-utils": "^1.0.0"
    },
    "deprecated": false,
    "description": "EC cryptography",
    "devDependencies": {
      "brfs": "^1.4.3",
      "coveralls": "^3.0.8",
      "grunt": "^1.0.4",
      "grunt-browserify": "^5.0.0",
      "grunt-cli": "^1.2.0",
      "grunt-contrib-connect": "^1.0.0",
      "grunt-contrib-copy": "^1.0.0",
      "grunt-contrib-uglify": "^1.0.1",
      "grunt-mocha-istanbul": "^3.0.1",
      "grunt-saucelabs": "^9.0.1",
      "istanbul": "^0.4.2",
      "jscs": "^3.0.7",
      "jshint": "^2.10.3",
      "mocha": "^6.2.2"
    },
    "files": [
      "lib"
    ],
    "homepage": "https://github.com/indutny/elliptic",
    "keywords": [
      "EC",
      "Elliptic",
      "curve",
      "Cryptography"
    ],
    "license": "MIT",
    "main": "lib/elliptic.js",
    "name": "elliptic",
    "repository": {
      "type": "git",
      "url": "git+ssh://git@github.com/indutny/elliptic.git"
    },
    "scripts": {
      "jscs": "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
      "jshint": "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
      "lint": "npm run jscs && npm run jshint",
      "test": "npm run lint && npm run unit",
      "unit": "istanbul test _mocha --reporter=spec test/index.js",
      "version": "grunt dist && git add dist/"
    },
    "version": "6.5.2"
  }
  
  },{}],217:[function(require,module,exports){
  /* eslint-env browser */
  module.exports = typeof self == 'object' ? self.FormData : window.FormData;
  
  },{}],218:[function(require,module,exports){
  'use strict'
  var Buffer = require('safe-buffer').Buffer
  var Transform = require('stream').Transform
  var inherits = require('inherits')
  
  function throwIfNotStringOrBuffer (val, prefix) {
    if (!Buffer.isBuffer(val) && typeof val !== 'string') {
      throw new TypeError(prefix + ' must be a string or a buffer')
    }
  }
  
  function HashBase (blockSize) {
    Transform.call(this)
  
    this._block = Buffer.allocUnsafe(blockSize)
    this._blockSize = blockSize
    this._blockOffset = 0
    this._length = [0, 0, 0, 0]
  
    this._finalized = false
  }
  
  inherits(HashBase, Transform)
  
  HashBase.prototype._transform = function (chunk, encoding, callback) {
    var error = null
    try {
      this.update(chunk, encoding)
    } catch (err) {
      error = err
    }
  
    callback(error)
  }
  
  HashBase.prototype._flush = function (callback) {
    var error = null
    try {
      this.push(this.digest())
    } catch (err) {
      error = err
    }
  
    callback(error)
  }
  
  HashBase.prototype.update = function (data, encoding) {
    throwIfNotStringOrBuffer(data, 'Data')
    if (this._finalized) throw new Error('Digest already called')
    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)
  
    // consume data
    var block = this._block
    var offset = 0
    while (this._blockOffset + data.length - offset >= this._blockSize) {
      for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]
      this._update()
      this._blockOffset = 0
    }
    while (offset < data.length) block[this._blockOffset++] = data[offset++]
  
    // update length
    for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
      this._length[j] += carry
      carry = (this._length[j] / 0x0100000000) | 0
      if (carry > 0) this._length[j] -= 0x0100000000 * carry
    }
  
    return this
  }
  
  HashBase.prototype._update = function () {
    throw new Error('_update is not implemented')
  }
  
  HashBase.prototype.digest = function (encoding) {
    if (this._finalized) throw new Error('Digest already called')
    this._finalized = true
  
    var digest = this._digest()
    if (encoding !== undefined) digest = digest.toString(encoding)
  
    // reset state
    this._block.fill(0)
    this._blockOffset = 0
    for (var i = 0; i < 4; ++i) this._length[i] = 0
  
    return digest
  }
  
  HashBase.prototype._digest = function () {
    throw new Error('_digest is not implemented')
  }
  
  module.exports = HashBase
  
  },{"inherits":280,"safe-buffer":281,"stream":28}],219:[function(require,module,exports){
  var hash = exports;
  
  hash.utils = require('./hash/utils');
  hash.common = require('./hash/common');
  hash.sha = require('./hash/sha');
  hash.ripemd = require('./hash/ripemd');
  hash.hmac = require('./hash/hmac');
  
  // Proxy hash functions to the main object
  hash.sha1 = hash.sha.sha1;
  hash.sha256 = hash.sha.sha256;
  hash.sha224 = hash.sha.sha224;
  hash.sha384 = hash.sha.sha384;
  hash.sha512 = hash.sha.sha512;
  hash.ripemd160 = hash.ripemd.ripemd160;
  
  },{"./hash/common":220,"./hash/hmac":221,"./hash/ripemd":222,"./hash/sha":223,"./hash/utils":230}],220:[function(require,module,exports){
  'use strict';
  
  var utils = require('./utils');
  var assert = require('minimalistic-assert');
  
  function BlockHash() {
    this.pending = null;
    this.pendingTotal = 0;
    this.blockSize = this.constructor.blockSize;
    this.outSize = this.constructor.outSize;
    this.hmacStrength = this.constructor.hmacStrength;
    this.padLength = this.constructor.padLength / 8;
    this.endian = 'big';
  
    this._delta8 = this.blockSize / 8;
    this._delta32 = this.blockSize / 32;
  }
  exports.BlockHash = BlockHash;
  
  BlockHash.prototype.update = function update(msg, enc) {
    // Convert message to array, pad it, and join into 32bit blocks
    msg = utils.toArray(msg, enc);
    if (!this.pending)
      this.pending = msg;
    else
      this.pending = this.pending.concat(msg);
    this.pendingTotal += msg.length;
  
    // Enough data, try updating
    if (this.pending.length >= this._delta8) {
      msg = this.pending;
  
      // Process pending data in blocks
      var r = msg.length % this._delta8;
      this.pending = msg.slice(msg.length - r, msg.length);
      if (this.pending.length === 0)
        this.pending = null;
  
      msg = utils.join32(msg, 0, msg.length - r, this.endian);
      for (var i = 0; i < msg.length; i += this._delta32)
        this._update(msg, i, i + this._delta32);
    }
  
    return this;
  };
  
  BlockHash.prototype.digest = function digest(enc) {
    this.update(this._pad());
    assert(this.pending === null);
  
    return this._digest(enc);
  };
  
  BlockHash.prototype._pad = function pad() {
    var len = this.pendingTotal;
    var bytes = this._delta8;
    var k = bytes - ((len + this.padLength) % bytes);
    var res = new Array(k + this.padLength);
    res[0] = 0x80;
    for (var i = 1; i < k; i++)
      res[i] = 0;
  
    // Append length
    len <<= 3;
    if (this.endian === 'big') {
      for (var t = 8; t < this.padLength; t++)
        res[i++] = 0;
  
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = (len >>> 24) & 0xff;
      res[i++] = (len >>> 16) & 0xff;
      res[i++] = (len >>> 8) & 0xff;
      res[i++] = len & 0xff;
    } else {
      res[i++] = len & 0xff;
      res[i++] = (len >>> 8) & 0xff;
      res[i++] = (len >>> 16) & 0xff;
      res[i++] = (len >>> 24) & 0xff;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
  
      for (t = 8; t < this.padLength; t++)
        res[i++] = 0;
    }
  
    return res;
  };
  
  },{"./utils":230,"minimalistic-assert":242}],221:[function(require,module,exports){
  'use strict';
  
  var utils = require('./utils');
  var assert = require('minimalistic-assert');
  
  function Hmac(hash, key, enc) {
    if (!(this instanceof Hmac))
      return new Hmac(hash, key, enc);
    this.Hash = hash;
    this.blockSize = hash.blockSize / 8;
    this.outSize = hash.outSize / 8;
    this.inner = null;
    this.outer = null;
  
    this._init(utils.toArray(key, enc));
  }
  module.exports = Hmac;
  
  Hmac.prototype._init = function init(key) {
    // Shorten key, if needed
    if (key.length > this.blockSize)
      key = new this.Hash().update(key).digest();
    assert(key.length <= this.blockSize);
  
    // Add padding to key
    for (var i = key.length; i < this.blockSize; i++)
      key.push(0);
  
    for (i = 0; i < key.length; i++)
      key[i] ^= 0x36;
    this.inner = new this.Hash().update(key);
  
    // 0x36 ^ 0x5c = 0x6a
    for (i = 0; i < key.length; i++)
      key[i] ^= 0x6a;
    this.outer = new this.Hash().update(key);
  };
  
  Hmac.prototype.update = function update(msg, enc) {
    this.inner.update(msg, enc);
    return this;
  };
  
  Hmac.prototype.digest = function digest(enc) {
    this.outer.update(this.inner.digest());
    return this.outer.digest(enc);
  };
  
  },{"./utils":230,"minimalistic-assert":242}],222:[function(require,module,exports){
  'use strict';
  
  var utils = require('./utils');
  var common = require('./common');
  
  var rotl32 = utils.rotl32;
  var sum32 = utils.sum32;
  var sum32_3 = utils.sum32_3;
  var sum32_4 = utils.sum32_4;
  var BlockHash = common.BlockHash;
  
  function RIPEMD160() {
    if (!(this instanceof RIPEMD160))
      return new RIPEMD160();
  
    BlockHash.call(this);
  
    this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
    this.endian = 'little';
  }
  utils.inherits(RIPEMD160, BlockHash);
  exports.ripemd160 = RIPEMD160;
  
  RIPEMD160.blockSize = 512;
  RIPEMD160.outSize = 160;
  RIPEMD160.hmacStrength = 192;
  RIPEMD160.padLength = 64;
  
  RIPEMD160.prototype._update = function update(msg, start) {
    var A = this.h[0];
    var B = this.h[1];
    var C = this.h[2];
    var D = this.h[3];
    var E = this.h[4];
    var Ah = A;
    var Bh = B;
    var Ch = C;
    var Dh = D;
    var Eh = E;
    for (var j = 0; j < 80; j++) {
      var T = sum32(
        rotl32(
          sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
          s[j]),
        E);
      A = E;
      E = D;
      D = rotl32(C, 10);
      C = B;
      B = T;
      T = sum32(
        rotl32(
          sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
          sh[j]),
        Eh);
      Ah = Eh;
      Eh = Dh;
      Dh = rotl32(Ch, 10);
      Ch = Bh;
      Bh = T;
    }
    T = sum32_3(this.h[1], C, Dh);
    this.h[1] = sum32_3(this.h[2], D, Eh);
    this.h[2] = sum32_3(this.h[3], E, Ah);
    this.h[3] = sum32_3(this.h[4], A, Bh);
    this.h[4] = sum32_3(this.h[0], B, Ch);
    this.h[0] = T;
  };
  
  RIPEMD160.prototype._digest = function digest(enc) {
    if (enc === 'hex')
      return utils.toHex32(this.h, 'little');
    else
      return utils.split32(this.h, 'little');
  };
  
  function f(j, x, y, z) {
    if (j <= 15)
      return x ^ y ^ z;
    else if (j <= 31)
      return (x & y) | ((~x) & z);
    else if (j <= 47)
      return (x | (~y)) ^ z;
    else if (j <= 63)
      return (x & z) | (y & (~z));
    else
      return x ^ (y | (~z));
  }
  
  function K(j) {
    if (j <= 15)
      return 0x00000000;
    else if (j <= 31)
      return 0x5a827999;
    else if (j <= 47)
      return 0x6ed9eba1;
    else if (j <= 63)
      return 0x8f1bbcdc;
    else
      return 0xa953fd4e;
  }
  
  function Kh(j) {
    if (j <= 15)
      return 0x50a28be6;
    else if (j <= 31)
      return 0x5c4dd124;
    else if (j <= 47)
      return 0x6d703ef3;
    else if (j <= 63)
      return 0x7a6d76e9;
    else
      return 0x00000000;
  }
  
  var r = [
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
    3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
    1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
    4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
  ];
  
  var rh = [
    5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
    6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
    15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
    8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
    12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
  ];
  
  var s = [
    11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
    7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
    11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
    11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
    9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
  ];
  
  var sh = [
    8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
    9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
    9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
    15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
    8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
  ];
  
  },{"./common":220,"./utils":230}],223:[function(require,module,exports){
  'use strict';
  
  exports.sha1 = require('./sha/1');
  exports.sha224 = require('./sha/224');
  exports.sha256 = require('./sha/256');
  exports.sha384 = require('./sha/384');
  exports.sha512 = require('./sha/512');
  
  },{"./sha/1":224,"./sha/224":225,"./sha/256":226,"./sha/384":227,"./sha/512":228}],224:[function(require,module,exports){
  'use strict';
  
  var utils = require('../utils');
  var common = require('../common');
  var shaCommon = require('./common');
  
  var rotl32 = utils.rotl32;
  var sum32 = utils.sum32;
  var sum32_5 = utils.sum32_5;
  var ft_1 = shaCommon.ft_1;
  var BlockHash = common.BlockHash;
  
  var sha1_K = [
    0x5A827999, 0x6ED9EBA1,
    0x8F1BBCDC, 0xCA62C1D6
  ];
  
  function SHA1() {
    if (!(this instanceof SHA1))
      return new SHA1();
  
    BlockHash.call(this);
    this.h = [
      0x67452301, 0xefcdab89, 0x98badcfe,
      0x10325476, 0xc3d2e1f0 ];
    this.W = new Array(80);
  }
  
  utils.inherits(SHA1, BlockHash);
  module.exports = SHA1;
  
  SHA1.blockSize = 512;
  SHA1.outSize = 160;
  SHA1.hmacStrength = 80;
  SHA1.padLength = 64;
  
  SHA1.prototype._update = function _update(msg, start) {
    var W = this.W;
  
    for (var i = 0; i < 16; i++)
      W[i] = msg[start + i];
  
    for(; i < W.length; i++)
      W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
  
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
  
    for (i = 0; i < W.length; i++) {
      var s = ~~(i / 20);
      var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
      e = d;
      d = c;
      c = rotl32(b, 30);
      b = a;
      a = t;
    }
  
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
  };
  
  SHA1.prototype._digest = function digest(enc) {
    if (enc === 'hex')
      return utils.toHex32(this.h, 'big');
    else
      return utils.split32(this.h, 'big');
  };
  
  },{"../common":220,"../utils":230,"./common":229}],225:[function(require,module,exports){
  'use strict';
  
  var utils = require('../utils');
  var SHA256 = require('./256');
  
  function SHA224() {
    if (!(this instanceof SHA224))
      return new SHA224();
  
    SHA256.call(this);
    this.h = [
      0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
      0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
  }
  utils.inherits(SHA224, SHA256);
  module.exports = SHA224;
  
  SHA224.blockSize = 512;
  SHA224.outSize = 224;
  SHA224.hmacStrength = 192;
  SHA224.padLength = 64;
  
  SHA224.prototype._digest = function digest(enc) {
    // Just truncate output
    if (enc === 'hex')
      return utils.toHex32(this.h.slice(0, 7), 'big');
    else
      return utils.split32(this.h.slice(0, 7), 'big');
  };
  
  
  },{"../utils":230,"./256":226}],226:[function(require,module,exports){
  'use strict';
  
  var utils = require('../utils');
  var common = require('../common');
  var shaCommon = require('./common');
  var assert = require('minimalistic-assert');
  
  var sum32 = utils.sum32;
  var sum32_4 = utils.sum32_4;
  var sum32_5 = utils.sum32_5;
  var ch32 = shaCommon.ch32;
  var maj32 = shaCommon.maj32;
  var s0_256 = shaCommon.s0_256;
  var s1_256 = shaCommon.s1_256;
  var g0_256 = shaCommon.g0_256;
  var g1_256 = shaCommon.g1_256;
  
  var BlockHash = common.BlockHash;
  
  var sha256_K = [
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
  ];
  
  function SHA256() {
    if (!(this instanceof SHA256))
      return new SHA256();
  
    BlockHash.call(this);
    this.h = [
      0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
      0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
    ];
    this.k = sha256_K;
    this.W = new Array(64);
  }
  utils.inherits(SHA256, BlockHash);
  module.exports = SHA256;
  
  SHA256.blockSize = 512;
  SHA256.outSize = 256;
  SHA256.hmacStrength = 192;
  SHA256.padLength = 64;
  
  SHA256.prototype._update = function _update(msg, start) {
    var W = this.W;
  
    for (var i = 0; i < 16; i++)
      W[i] = msg[start + i];
    for (; i < W.length; i++)
      W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
  
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    var f = this.h[5];
    var g = this.h[6];
    var h = this.h[7];
  
    assert(this.k.length === W.length);
    for (i = 0; i < W.length; i++) {
      var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
      var T2 = sum32(s0_256(a), maj32(a, b, c));
      h = g;
      g = f;
      f = e;
      e = sum32(d, T1);
      d = c;
      c = b;
      b = a;
      a = sum32(T1, T2);
    }
  
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
    this.h[5] = sum32(this.h[5], f);
    this.h[6] = sum32(this.h[6], g);
    this.h[7] = sum32(this.h[7], h);
  };
  
  SHA256.prototype._digest = function digest(enc) {
    if (enc === 'hex')
      return utils.toHex32(this.h, 'big');
    else
      return utils.split32(this.h, 'big');
  };
  
  },{"../common":220,"../utils":230,"./common":229,"minimalistic-assert":242}],227:[function(require,module,exports){
  'use strict';
  
  var utils = require('../utils');
  
  var SHA512 = require('./512');
  
  function SHA384() {
    if (!(this instanceof SHA384))
      return new SHA384();
  
    SHA512.call(this);
    this.h = [
      0xcbbb9d5d, 0xc1059ed8,
      0x629a292a, 0x367cd507,
      0x9159015a, 0x3070dd17,
      0x152fecd8, 0xf70e5939,
      0x67332667, 0xffc00b31,
      0x8eb44a87, 0x68581511,
      0xdb0c2e0d, 0x64f98fa7,
      0x47b5481d, 0xbefa4fa4 ];
  }
  utils.inherits(SHA384, SHA512);
  module.exports = SHA384;
  
  SHA384.blockSize = 1024;
  SHA384.outSize = 384;
  SHA384.hmacStrength = 192;
  SHA384.padLength = 128;
  
  SHA384.prototype._digest = function digest(enc) {
    if (enc === 'hex')
      return utils.toHex32(this.h.slice(0, 12), 'big');
    else
      return utils.split32(this.h.slice(0, 12), 'big');
  };
  
  },{"../utils":230,"./512":228}],228:[function(require,module,exports){
  'use strict';
  
  var utils = require('../utils');
  var common = require('../common');
  var assert = require('minimalistic-assert');
  
  var rotr64_hi = utils.rotr64_hi;
  var rotr64_lo = utils.rotr64_lo;
  var shr64_hi = utils.shr64_hi;
  var shr64_lo = utils.shr64_lo;
  var sum64 = utils.sum64;
  var sum64_hi = utils.sum64_hi;
  var sum64_lo = utils.sum64_lo;
  var sum64_4_hi = utils.sum64_4_hi;
  var sum64_4_lo = utils.sum64_4_lo;
  var sum64_5_hi = utils.sum64_5_hi;
  var sum64_5_lo = utils.sum64_5_lo;
  
  var BlockHash = common.BlockHash;
  
  var sha512_K = [
    0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
    0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
    0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
    0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
    0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
    0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
    0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
    0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
    0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
    0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
    0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
    0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
    0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
    0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
    0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
    0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
    0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
    0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
    0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
    0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
    0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
    0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
    0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
    0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
    0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
    0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
    0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
    0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
    0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
    0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
    0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
    0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
    0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
    0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
    0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
    0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
    0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
    0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
    0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
    0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
  ];
  
  function SHA512() {
    if (!(this instanceof SHA512))
      return new SHA512();
  
    BlockHash.call(this);
    this.h = [
      0x6a09e667, 0xf3bcc908,
      0xbb67ae85, 0x84caa73b,
      0x3c6ef372, 0xfe94f82b,
      0xa54ff53a, 0x5f1d36f1,
      0x510e527f, 0xade682d1,
      0x9b05688c, 0x2b3e6c1f,
      0x1f83d9ab, 0xfb41bd6b,
      0x5be0cd19, 0x137e2179 ];
    this.k = sha512_K;
    this.W = new Array(160);
  }
  utils.inherits(SHA512, BlockHash);
  module.exports = SHA512;
  
  SHA512.blockSize = 1024;
  SHA512.outSize = 512;
  SHA512.hmacStrength = 192;
  SHA512.padLength = 128;
  
  SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
    var W = this.W;
  
    // 32 x 32bit words
    for (var i = 0; i < 32; i++)
      W[i] = msg[start + i];
    for (; i < W.length; i += 2) {
      var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
      var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
      var c1_hi = W[i - 14];  // i - 7
      var c1_lo = W[i - 13];
      var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
      var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
      var c3_hi = W[i - 32];  // i - 16
      var c3_lo = W[i - 31];
  
      W[i] = sum64_4_hi(
        c0_hi, c0_lo,
        c1_hi, c1_lo,
        c2_hi, c2_lo,
        c3_hi, c3_lo);
      W[i + 1] = sum64_4_lo(
        c0_hi, c0_lo,
        c1_hi, c1_lo,
        c2_hi, c2_lo,
        c3_hi, c3_lo);
    }
  };
  
  SHA512.prototype._update = function _update(msg, start) {
    this._prepareBlock(msg, start);
  
    var W = this.W;
  
    var ah = this.h[0];
    var al = this.h[1];
    var bh = this.h[2];
    var bl = this.h[3];
    var ch = this.h[4];
    var cl = this.h[5];
    var dh = this.h[6];
    var dl = this.h[7];
    var eh = this.h[8];
    var el = this.h[9];
    var fh = this.h[10];
    var fl = this.h[11];
    var gh = this.h[12];
    var gl = this.h[13];
    var hh = this.h[14];
    var hl = this.h[15];
  
    assert(this.k.length === W.length);
    for (var i = 0; i < W.length; i += 2) {
      var c0_hi = hh;
      var c0_lo = hl;
      var c1_hi = s1_512_hi(eh, el);
      var c1_lo = s1_512_lo(eh, el);
      var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
      var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
      var c3_hi = this.k[i];
      var c3_lo = this.k[i + 1];
      var c4_hi = W[i];
      var c4_lo = W[i + 1];
  
      var T1_hi = sum64_5_hi(
        c0_hi, c0_lo,
        c1_hi, c1_lo,
        c2_hi, c2_lo,
        c3_hi, c3_lo,
        c4_hi, c4_lo);
      var T1_lo = sum64_5_lo(
        c0_hi, c0_lo,
        c1_hi, c1_lo,
        c2_hi, c2_lo,
        c3_hi, c3_lo,
        c4_hi, c4_lo);
  
      c0_hi = s0_512_hi(ah, al);
      c0_lo = s0_512_lo(ah, al);
      c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
      c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
  
      var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
      var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
  
      hh = gh;
      hl = gl;
  
      gh = fh;
      gl = fl;
  
      fh = eh;
      fl = el;
  
      eh = sum64_hi(dh, dl, T1_hi, T1_lo);
      el = sum64_lo(dl, dl, T1_hi, T1_lo);
  
      dh = ch;
      dl = cl;
  
      ch = bh;
      cl = bl;
  
      bh = ah;
      bl = al;
  
      ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
      al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
    }
  
    sum64(this.h, 0, ah, al);
    sum64(this.h, 2, bh, bl);
    sum64(this.h, 4, ch, cl);
    sum64(this.h, 6, dh, dl);
    sum64(this.h, 8, eh, el);
    sum64(this.h, 10, fh, fl);
    sum64(this.h, 12, gh, gl);
    sum64(this.h, 14, hh, hl);
  };
  
  SHA512.prototype._digest = function digest(enc) {
    if (enc === 'hex')
      return utils.toHex32(this.h, 'big');
    else
      return utils.split32(this.h, 'big');
  };
  
  function ch64_hi(xh, xl, yh, yl, zh) {
    var r = (xh & yh) ^ ((~xh) & zh);
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  
  function ch64_lo(xh, xl, yh, yl, zh, zl) {
    var r = (xl & yl) ^ ((~xl) & zl);
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  
  function maj64_hi(xh, xl, yh, yl, zh) {
    var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  
  function maj64_lo(xh, xl, yh, yl, zh, zl) {
    var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  
  function s0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 28);
    var c1_hi = rotr64_hi(xl, xh, 2);  // 34
    var c2_hi = rotr64_hi(xl, xh, 7);  // 39
  
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  
  function s0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 28);
    var c1_lo = rotr64_lo(xl, xh, 2);  // 34
    var c2_lo = rotr64_lo(xl, xh, 7);  // 39
  
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  
  function s1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 14);
    var c1_hi = rotr64_hi(xh, xl, 18);
    var c2_hi = rotr64_hi(xl, xh, 9);  // 41
  
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  
  function s1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 14);
    var c1_lo = rotr64_lo(xh, xl, 18);
    var c2_lo = rotr64_lo(xl, xh, 9);  // 41
  
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  
  function g0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 1);
    var c1_hi = rotr64_hi(xh, xl, 8);
    var c2_hi = shr64_hi(xh, xl, 7);
  
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  
  function g0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 1);
    var c1_lo = rotr64_lo(xh, xl, 8);
    var c2_lo = shr64_lo(xh, xl, 7);
  
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  
  function g1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 19);
    var c1_hi = rotr64_hi(xl, xh, 29);  // 61
    var c2_hi = shr64_hi(xh, xl, 6);
  
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  
  function g1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 19);
    var c1_lo = rotr64_lo(xl, xh, 29);  // 61
    var c2_lo = shr64_lo(xh, xl, 6);
  
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  
  },{"../common":220,"../utils":230,"minimalistic-assert":242}],229:[function(require,module,exports){
  'use strict';
  
  var utils = require('../utils');
  var rotr32 = utils.rotr32;
  
  function ft_1(s, x, y, z) {
    if (s === 0)
      return ch32(x, y, z);
    if (s === 1 || s === 3)
      return p32(x, y, z);
    if (s === 2)
      return maj32(x, y, z);
  }
  exports.ft_1 = ft_1;
  
  function ch32(x, y, z) {
    return (x & y) ^ ((~x) & z);
  }
  exports.ch32 = ch32;
  
  function maj32(x, y, z) {
    return (x & y) ^ (x & z) ^ (y & z);
  }
  exports.maj32 = maj32;
  
  function p32(x, y, z) {
    return x ^ y ^ z;
  }
  exports.p32 = p32;
  
  function s0_256(x) {
    return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
  }
  exports.s0_256 = s0_256;
  
  function s1_256(x) {
    return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
  }
  exports.s1_256 = s1_256;
  
  function g0_256(x) {
    return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
  }
  exports.g0_256 = g0_256;
  
  function g1_256(x) {
    return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
  }
  exports.g1_256 = g1_256;
  
  },{"../utils":230}],230:[function(require,module,exports){
  'use strict';
  
  var assert = require('minimalistic-assert');
  var inherits = require('inherits');
  
  exports.inherits = inherits;
  
  function isSurrogatePair(msg, i) {
    if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
      return false;
    }
    if (i < 0 || i + 1 >= msg.length) {
      return false;
    }
    return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
  }
  
  function toArray(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg === 'string') {
      if (!enc) {
        // Inspired by stringToUtf8ByteArray() in closure-library by Google
        // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
        // Apache License 2.0
        // https://github.com/google/closure-library/blob/master/LICENSE
        var p = 0;
        for (var i = 0; i < msg.length; i++) {
          var c = msg.charCodeAt(i);
          if (c < 128) {
            res[p++] = c;
          } else if (c < 2048) {
            res[p++] = (c >> 6) | 192;
            res[p++] = (c & 63) | 128;
          } else if (isSurrogatePair(msg, i)) {
            c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
            res[p++] = (c >> 18) | 240;
            res[p++] = ((c >> 12) & 63) | 128;
            res[p++] = ((c >> 6) & 63) | 128;
            res[p++] = (c & 63) | 128;
          } else {
            res[p++] = (c >> 12) | 224;
            res[p++] = ((c >> 6) & 63) | 128;
            res[p++] = (c & 63) | 128;
          }
        }
      } else if (enc === 'hex') {
        msg = msg.replace(/[^a-z0-9]+/ig, '');
        if (msg.length % 2 !== 0)
          msg = '0' + msg;
        for (i = 0; i < msg.length; i += 2)
          res.push(parseInt(msg[i] + msg[i + 1], 16));
      }
    } else {
      for (i = 0; i < msg.length; i++)
        res[i] = msg[i] | 0;
    }
    return res;
  }
  exports.toArray = toArray;
  
  function toHex(msg) {
    var res = '';
    for (var i = 0; i < msg.length; i++)
      res += zero2(msg[i].toString(16));
    return res;
  }
  exports.toHex = toHex;
  
  function htonl(w) {
    var res = (w >>> 24) |
              ((w >>> 8) & 0xff00) |
              ((w << 8) & 0xff0000) |
              ((w & 0xff) << 24);
    return res >>> 0;
  }
  exports.htonl = htonl;
  
  function toHex32(msg, endian) {
    var res = '';
    for (var i = 0; i < msg.length; i++) {
      var w = msg[i];
      if (endian === 'little')
        w = htonl(w);
      res += zero8(w.toString(16));
    }
    return res;
  }
  exports.toHex32 = toHex32;
  
  function zero2(word) {
    if (word.length === 1)
      return '0' + word;
    else
      return word;
  }
  exports.zero2 = zero2;
  
  function zero8(word) {
    if (word.length === 7)
      return '0' + word;
    else if (word.length === 6)
      return '00' + word;
    else if (word.length === 5)
      return '000' + word;
    else if (word.length === 4)
      return '0000' + word;
    else if (word.length === 3)
      return '00000' + word;
    else if (word.length === 2)
      return '000000' + word;
    else if (word.length === 1)
      return '0000000' + word;
    else
      return word;
  }
  exports.zero8 = zero8;
  
  function join32(msg, start, end, endian) {
    var len = end - start;
    assert(len % 4 === 0);
    var res = new Array(len / 4);
    for (var i = 0, k = start; i < res.length; i++, k += 4) {
      var w;
      if (endian === 'big')
        w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
      else
        w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
      res[i] = w >>> 0;
    }
    return res;
  }
  exports.join32 = join32;
  
  function split32(msg, endian) {
    var res = new Array(msg.length * 4);
    for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
      var m = msg[i];
      if (endian === 'big') {
        res[k] = m >>> 24;
        res[k + 1] = (m >>> 16) & 0xff;
        res[k + 2] = (m >>> 8) & 0xff;
        res[k + 3] = m & 0xff;
      } else {
        res[k + 3] = m >>> 24;
        res[k + 2] = (m >>> 16) & 0xff;
        res[k + 1] = (m >>> 8) & 0xff;
        res[k] = m & 0xff;
      }
    }
    return res;
  }
  exports.split32 = split32;
  
  function rotr32(w, b) {
    return (w >>> b) | (w << (32 - b));
  }
  exports.rotr32 = rotr32;
  
  function rotl32(w, b) {
    return (w << b) | (w >>> (32 - b));
  }
  exports.rotl32 = rotl32;
  
  function sum32(a, b) {
    return (a + b) >>> 0;
  }
  exports.sum32 = sum32;
  
  function sum32_3(a, b, c) {
    return (a + b + c) >>> 0;
  }
  exports.sum32_3 = sum32_3;
  
  function sum32_4(a, b, c, d) {
    return (a + b + c + d) >>> 0;
  }
  exports.sum32_4 = sum32_4;
  
  function sum32_5(a, b, c, d, e) {
    return (a + b + c + d + e) >>> 0;
  }
  exports.sum32_5 = sum32_5;
  
  function sum64(buf, pos, ah, al) {
    var bh = buf[pos];
    var bl = buf[pos + 1];
  
    var lo = (al + bl) >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    buf[pos] = hi >>> 0;
    buf[pos + 1] = lo;
  }
  exports.sum64 = sum64;
  
  function sum64_hi(ah, al, bh, bl) {
    var lo = (al + bl) >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    return hi >>> 0;
  }
  exports.sum64_hi = sum64_hi;
  
  function sum64_lo(ah, al, bh, bl) {
    var lo = al + bl;
    return lo >>> 0;
  }
  exports.sum64_lo = sum64_lo;
  
  function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
    var carry = 0;
    var lo = al;
    lo = (lo + bl) >>> 0;
    carry += lo < al ? 1 : 0;
    lo = (lo + cl) >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = (lo + dl) >>> 0;
    carry += lo < dl ? 1 : 0;
  
    var hi = ah + bh + ch + dh + carry;
    return hi >>> 0;
  }
  exports.sum64_4_hi = sum64_4_hi;
  
  function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
    var lo = al + bl + cl + dl;
    return lo >>> 0;
  }
  exports.sum64_4_lo = sum64_4_lo;
  
  function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var carry = 0;
    var lo = al;
    lo = (lo + bl) >>> 0;
    carry += lo < al ? 1 : 0;
    lo = (lo + cl) >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = (lo + dl) >>> 0;
    carry += lo < dl ? 1 : 0;
    lo = (lo + el) >>> 0;
    carry += lo < el ? 1 : 0;
  
    var hi = ah + bh + ch + dh + eh + carry;
    return hi >>> 0;
  }
  exports.sum64_5_hi = sum64_5_hi;
  
  function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var lo = al + bl + cl + dl + el;
  
    return lo >>> 0;
  }
  exports.sum64_5_lo = sum64_5_lo;
  
  function rotr64_hi(ah, al, num) {
    var r = (al << (32 - num)) | (ah >>> num);
    return r >>> 0;
  }
  exports.rotr64_hi = rotr64_hi;
  
  function rotr64_lo(ah, al, num) {
    var r = (ah << (32 - num)) | (al >>> num);
    return r >>> 0;
  }
  exports.rotr64_lo = rotr64_lo;
  
  function shr64_hi(ah, al, num) {
    return ah >>> num;
  }
  exports.shr64_hi = shr64_hi;
  
  function shr64_lo(ah, al, num) {
    var r = (ah << (32 - num)) | (al >>> num);
    return r >>> 0;
  }
  exports.shr64_lo = shr64_lo;
  
  },{"inherits":280,"minimalistic-assert":242}],231:[function(require,module,exports){
  'use strict';
  
  var hash = require('hash.js');
  var utils = require('minimalistic-crypto-utils');
  var assert = require('minimalistic-assert');
  
  function HmacDRBG(options) {
    if (!(this instanceof HmacDRBG))
      return new HmacDRBG(options);
    this.hash = options.hash;
    this.predResist = !!options.predResist;
  
    this.outLen = this.hash.outSize;
    this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  
    this._reseed = null;
    this.reseedInterval = null;
    this.K = null;
    this.V = null;
  
    var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
    var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
    var pers = utils.toArray(options.pers, options.persEnc || 'hex');
    assert(entropy.length >= (this.minEntropy / 8),
           'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
    this._init(entropy, nonce, pers);
  }
  module.exports = HmacDRBG;
  
  HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
    var seed = entropy.concat(nonce).concat(pers);
  
    this.K = new Array(this.outLen / 8);
    this.V = new Array(this.outLen / 8);
    for (var i = 0; i < this.V.length; i++) {
      this.K[i] = 0x00;
      this.V[i] = 0x01;
    }
  
    this._update(seed);
    this._reseed = 1;
    this.reseedInterval = 0x1000000000000;  // 2^48
  };
  
  HmacDRBG.prototype._hmac = function hmac() {
    return new hash.hmac(this.hash, this.K);
  };
  
  HmacDRBG.prototype._update = function update(seed) {
    var kmac = this._hmac()
                   .update(this.V)
                   .update([ 0x00 ]);
    if (seed)
      kmac = kmac.update(seed);
    this.K = kmac.digest();
    this.V = this._hmac().update(this.V).digest();
    if (!seed)
      return;
  
    this.K = this._hmac()
                 .update(this.V)
                 .update([ 0x01 ])
                 .update(seed)
                 .digest();
    this.V = this._hmac().update(this.V).digest();
  };
  
  HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
    // Optional entropy enc
    if (typeof entropyEnc !== 'string') {
      addEnc = add;
      add = entropyEnc;
      entropyEnc = null;
    }
  
    entropy = utils.toArray(entropy, entropyEnc);
    add = utils.toArray(add, addEnc);
  
    assert(entropy.length >= (this.minEntropy / 8),
           'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  
    this._update(entropy.concat(add || []));
    this._reseed = 1;
  };
  
  HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
    if (this._reseed > this.reseedInterval)
      throw new Error('Reseed is required');
  
    // Optional encoding
    if (typeof enc !== 'string') {
      addEnc = add;
      add = enc;
      enc = null;
    }
  
    // Optional additional data
    if (add) {
      add = utils.toArray(add, addEnc || 'hex');
      this._update(add);
    }
  
    var temp = [];
    while (temp.length < len) {
      this.V = this._hmac().update(this.V).digest();
      temp = temp.concat(this.V);
    }
  
    var res = temp.slice(0, len);
    this._update(add);
    this._reseed++;
    return utils.encode(res, enc);
  };
  
  },{"hash.js":219,"minimalistic-assert":242,"minimalistic-crypto-utils":243}],232:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const secp256k1_1 = require("./secp256k1");
  exports.SECP256K1Client = secp256k1_1.SECP256K1Client;
  const cryptoClients = {
      ES256K: secp256k1_1.SECP256K1Client
  };
  exports.cryptoClients = cryptoClients;
  
  },{"./secp256k1":233}],233:[function(require,module,exports){
  (function (Buffer){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const elliptic_1 = require("elliptic");
  const ecdsa_sig_formatter_1 = require("ecdsa-sig-formatter");
  const errors_1 = require("../errors");
  class SECP256K1Client {
      constructor() {
      }
      static loadPrivateKey(rawPrivateKey) {
          if (rawPrivateKey.length === 66) {
              rawPrivateKey = rawPrivateKey.slice(0, 64);
          }
          return SECP256K1Client.ec.keyFromPrivate(rawPrivateKey);
      }
      static loadPublicKey(rawPublicKey) {
          return SECP256K1Client.ec.keyFromPublic(rawPublicKey, 'hex');
      }
      static derivePublicKey(privateKey, compressed = true) {
          if (typeof privateKey !== 'string') {
              throw Error('private key must be a string');
          }
          if (!(/^[0-9A-F]+$/i.test(privateKey))) {
              throw Error('private key must be a hex string');
          }
          if (privateKey.length == 66) {
              privateKey = privateKey.slice(0, 64);
          }
          else if (privateKey.length <= 64) {
              // do nothing
          }
          else {
              throw Error('private key must be 66 characters or less');
          }
          const keypair = SECP256K1Client.ec.keyFromPrivate(privateKey);
          return keypair.getPublic(compressed, 'hex');
      }
      static signHash(signingInputHash, rawPrivateKey, format = 'jose') {
          // make sure the required parameters are provided
          if (!(signingInputHash && rawPrivateKey)) {
              throw new errors_1.MissingParametersError('a signing input hash and private key are all required');
          }
          // prepare the private key
          const privateKeyObject = SECP256K1Client.loadPrivateKey(rawPrivateKey);
          // calculate the signature
          const signatureObject = privateKeyObject.sign(signingInputHash);
          const derSignature = Buffer.from(signatureObject.toDER());
          if (format === 'der') {
              return derSignature.toString('hex');
          }
          else if (format === 'jose') {
              // return the JOSE-formatted signature
              return ecdsa_sig_formatter_1.derToJose(derSignature, 'ES256');
          }
          else {
              throw Error('Invalid signature format');
          }
      }
      static loadSignature(joseSignature) {
          // create and return the DER-formatted signature buffer
          return ecdsa_sig_formatter_1.joseToDer(joseSignature, 'ES256');
      }
      static verifyHash(signingInputHash, derSignatureBuffer, rawPublicKey) {
          // make sure the required parameters are provided
          if (!(signingInputHash && derSignatureBuffer && rawPublicKey)) {
              throw new errors_1.MissingParametersError('a signing input hash, der signature, and public key are all required');
          }
          // prepare the public key
          const publicKeyObject = SECP256K1Client.loadPublicKey(rawPublicKey);
          // verify the token
          return publicKeyObject.verify(signingInputHash, derSignatureBuffer);
      }
  }
  exports.SECP256K1Client = SECP256K1Client;
  SECP256K1Client.ec = new elliptic_1.ec('secp256k1');
  SECP256K1Client.algorithmName = 'ES256K';
  
  }).call(this,require("buffer").Buffer)
  },{"../errors":236,"buffer":3,"ecdsa-sig-formatter":199,"elliptic":201}],234:[function(require,module,exports){
  (function (Buffer){
  "use strict";
  var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const sha_js_1 = require("sha.js");
  function hashSha256(input) {
      const hashFunction = new sha_js_1.sha256();
      return hashFunction.update(input).digest();
  }
  exports.hashSha256 = hashSha256;
  function hashSha256Async(input) {
      return __awaiter(this, void 0, void 0, function* () {
          try {
              const isSubtleCryptoAvailable = typeof crypto !== 'undefined' && typeof crypto.subtle !== 'undefined';
              if (isSubtleCryptoAvailable) {
                  // Use the W3C Web Crypto API if available (running in a web browser).
                  const buffer = typeof input === 'string' ? Buffer.from(input) : input;
                  const hash = yield crypto.subtle.digest('SHA-256', buffer);
                  return Buffer.from(hash);
              }
              else {
                  // Otherwise try loading the Node.js `crypto` module (running in Node.js, or an older browser with a polyfill).
                  const nodeCrypto = require('crypto');
                  if (!nodeCrypto.createHash) {
                      throw new Error('`crypto` module does not contain `createHash`');
                  }
                  return Promise.resolve(nodeCrypto.createHash('sha256').update(input).digest());
              }
          }
          catch (error) {
              console.log(error);
              console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, ' +
                  'nor the or the Node.js `require("crypto").createHash` module is available. ' +
                  'Falling back to JS implementation.');
              return Promise.resolve(hashSha256(input));
          }
      });
  }
  exports.hashSha256Async = hashSha256Async;
  
  }).call(this,require("buffer").Buffer)
  },{"buffer":3,"crypto":2,"sha.js":257}],235:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const base64url_1 = require("base64url");
  function decodeToken(token) {
      if (typeof token === 'string') {
          // decompose the token into parts
          const tokenParts = token.split('.');
          const header = JSON.parse(base64url_1.default.decode(tokenParts[0]));
          const payload = JSON.parse(base64url_1.default.decode(tokenParts[1]));
          const signature = tokenParts[2];
          // return the token object
          return {
              header: header,
              payload: payload,
              signature: signature
          };
      }
      else if (typeof token === 'object') {
          if (typeof token.payload !== 'string') {
              throw new Error('Expected token payload to be a base64 or json string');
          }
          let payload = token.payload;
          if (token.payload[0] !== '{') {
              payload = base64url_1.default.decode(payload);
          }
          const allHeaders = [];
          token.header.map((headerValue) => {
              const header = JSON.parse(base64url_1.default.decode(headerValue));
              allHeaders.push(header);
          });
          return {
              header: allHeaders,
              payload: JSON.parse(payload),
              signature: token.signature
          };
      }
  }
  exports.decodeToken = decodeToken;
  
  },{"base64url":101}],236:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  class MissingParametersError extends Error {
      constructor(message) {
          super();
          this.name = 'MissingParametersError';
          this.message = (message || '');
      }
  }
  exports.MissingParametersError = MissingParametersError;
  class InvalidTokenError extends Error {
      constructor(message) {
          super();
          this.name = 'InvalidTokenError';
          this.message = (message || '');
      }
  }
  exports.InvalidTokenError = InvalidTokenError;
  
  },{}],237:[function(require,module,exports){
  "use strict";
  function __export(m) {
      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  __export(require("./signer"));
  __export(require("./verifier"));
  __export(require("./decode"));
  __export(require("./errors"));
  __export(require("./cryptoClients"));
  
  },{"./cryptoClients":232,"./decode":235,"./errors":236,"./signer":238,"./verifier":239}],238:[function(require,module,exports){
  "use strict";
  var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const base64url_1 = require("base64url");
  const cryptoClients_1 = require("./cryptoClients");
  const errors_1 = require("./errors");
  const sha256_1 = require("./cryptoClients/sha256");
  function createSigningInput(payload, header) {
      const tokenParts = [];
      // add in the header
      const encodedHeader = base64url_1.default.encode(JSON.stringify(header));
      tokenParts.push(encodedHeader);
      // add in the payload
      const encodedPayload = base64url_1.default.encode(JSON.stringify(payload));
      tokenParts.push(encodedPayload);
      // prepare the message
      const signingInput = tokenParts.join('.');
      // return the signing input
      return signingInput;
  }
  function createUnsecuredToken(payload) {
      const header = { typ: 'JWT', alg: 'none' };
      return createSigningInput(payload, header) + '.';
  }
  exports.createUnsecuredToken = createUnsecuredToken;
  class TokenSigner {
      constructor(signingAlgorithm, rawPrivateKey) {
          if (!(signingAlgorithm && rawPrivateKey)) {
              throw new errors_1.MissingParametersError('a signing algorithm and private key are required');
          }
          if (typeof signingAlgorithm !== 'string') {
              throw new Error('signing algorithm parameter must be a string');
          }
          signingAlgorithm = signingAlgorithm.toUpperCase();
          if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {
              throw new Error('invalid signing algorithm');
          }
          this.tokenType = 'JWT';
          this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];
          this.rawPrivateKey = rawPrivateKey;
      }
      header(header = {}) {
          const defaultHeader = { typ: this.tokenType,
              alg: this.cryptoClient.algorithmName };
          return Object.assign({}, defaultHeader, header);
      }
      sign(payload, expanded = false, customHeader = {}) {
          // generate the token header
          const header = this.header(customHeader);
          // prepare the message to be signed
          const signingInput = createSigningInput(payload, header);
          const signingInputHash = sha256_1.hashSha256(signingInput);
          return this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash);
      }
      signAsync(payload, expanded = false, customHeader = {}) {
          return __awaiter(this, void 0, void 0, function* () {
              // generate the token header
              const header = this.header(customHeader);
              // prepare the message to be signed
              const signingInput = createSigningInput(payload, header);
              const signingInputHash = yield sha256_1.hashSha256Async(signingInput);
              return this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash);
          });
      }
      createWithSignedHash(payload, expanded, header, signingInput, signingInputHash) {
          // sign the message and add in the signature
          const signature = this.cryptoClient.signHash(signingInputHash, this.rawPrivateKey);
          if (expanded) {
              const signedToken = {
                  'header': [
                      base64url_1.default.encode(JSON.stringify(header))
                  ],
                  'payload': JSON.stringify(payload),
                  'signature': [
                      signature
                  ]
              };
              return signedToken;
          }
          else {
              return [signingInput, signature].join('.');
          }
      }
  }
  exports.TokenSigner = TokenSigner;
  
  },{"./cryptoClients":232,"./cryptoClients/sha256":234,"./errors":236,"base64url":101}],239:[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  const base64url_1 = require("base64url");
  const cryptoClients_1 = require("./cryptoClients");
  const errors_1 = require("./errors");
  const sha256_1 = require("./cryptoClients/sha256");
  class TokenVerifier {
      constructor(signingAlgorithm, rawPublicKey) {
          if (!(signingAlgorithm && rawPublicKey)) {
              throw new errors_1.MissingParametersError('a signing algorithm and public key are required');
          }
          if (typeof signingAlgorithm !== 'string') {
              throw 'signing algorithm parameter must be a string';
          }
          signingAlgorithm = signingAlgorithm.toUpperCase();
          if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {
              throw 'invalid signing algorithm';
          }
          this.tokenType = 'JWT';
          this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];
          this.rawPublicKey = rawPublicKey;
      }
      verify(token) {
          if (typeof token === 'string') {
              return this.verifyCompact(token, false);
          }
          else if (typeof token === 'object') {
              return this.verifyExpanded(token, false);
          }
          else {
              false;
          }
      }
      verifyAsync(token) {
          if (typeof token === 'string') {
              return this.verifyCompact(token, true);
          }
          else if (typeof token === 'object') {
              return this.verifyExpanded(token, true);
          }
          else {
              return Promise.resolve(false);
          }
      }
      verifyCompact(token, async) {
          // decompose the token into parts
          const tokenParts = token.split('.');
          // calculate the signing input hash
          const signingInput = tokenParts[0] + '.' + tokenParts[1];
          const performVerify = (signingInputHash) => {
              // extract the signature as a DER array
              const derSignatureBuffer = this.cryptoClient.loadSignature(tokenParts[2]);
              // verify the signed hash
              return this.cryptoClient.verifyHash(signingInputHash, derSignatureBuffer, this.rawPublicKey);
          };
          if (async) {
              return sha256_1.hashSha256Async(signingInput).then(signingInputHash => performVerify(signingInputHash));
          }
          else {
              const signingInputHash = sha256_1.hashSha256(signingInput);
              return performVerify(signingInputHash);
          }
      }
      verifyExpanded(token, async) {
          const signingInput = [
              token['header'].join('.'),
              base64url_1.default.encode(token['payload'])
          ].join('.');
          let verified = true;
          const performVerify = (signingInputHash) => {
              token['signature'].map((signature) => {
                  const derSignatureBuffer = this.cryptoClient.loadSignature(signature);
                  const signatureVerified = this.cryptoClient.verifyHash(signingInputHash, derSignatureBuffer, this.rawPublicKey);
                  if (!signatureVerified) {
                      verified = false;
                  }
              });
              return verified;
          };
          if (async) {
              return sha256_1.hashSha256Async(signingInput).then(signingInputHash => performVerify(signingInputHash));
          }
          else {
              const signingInputHash = sha256_1.hashSha256(signingInput);
              return performVerify(signingInputHash);
          }
      }
  }
  exports.TokenVerifier = TokenVerifier;
  
  },{"./cryptoClients":232,"./cryptoClients/sha256":234,"./errors":236,"base64url":101}],240:[function(require,module,exports){
  'use strict'
  var inherits = require('inherits')
  var HashBase = require('hash-base')
  var Buffer = require('safe-buffer').Buffer
  
  var ARRAY16 = new Array(16)
  
  function MD5 () {
    HashBase.call(this, 64)
  
    // state
    this._a = 0x67452301
    this._b = 0xefcdab89
    this._c = 0x98badcfe
    this._d = 0x10325476
  }
  
  inherits(MD5, HashBase)
  
  MD5.prototype._update = function () {
    var M = ARRAY16
    for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4)
  
    var a = this._a
    var b = this._b
    var c = this._c
    var d = this._d
  
    a = fnF(a, b, c, d, M[0], 0xd76aa478, 7)
    d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12)
    c = fnF(c, d, a, b, M[2], 0x242070db, 17)
    b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22)
    a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7)
    d = fnF(d, a, b, c, M[5], 0x4787c62a, 12)
    c = fnF(c, d, a, b, M[6], 0xa8304613, 17)
    b = fnF(b, c, d, a, M[7], 0xfd469501, 22)
    a = fnF(a, b, c, d, M[8], 0x698098d8, 7)
    d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12)
    c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17)
    b = fnF(b, c, d, a, M[11], 0x895cd7be, 22)
    a = fnF(a, b, c, d, M[12], 0x6b901122, 7)
    d = fnF(d, a, b, c, M[13], 0xfd987193, 12)
    c = fnF(c, d, a, b, M[14], 0xa679438e, 17)
    b = fnF(b, c, d, a, M[15], 0x49b40821, 22)
  
    a = fnG(a, b, c, d, M[1], 0xf61e2562, 5)
    d = fnG(d, a, b, c, M[6], 0xc040b340, 9)
    c = fnG(c, d, a, b, M[11], 0x265e5a51, 14)
    b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20)
    a = fnG(a, b, c, d, M[5], 0xd62f105d, 5)
    d = fnG(d, a, b, c, M[10], 0x02441453, 9)
    c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14)
    b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20)
    a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5)
    d = fnG(d, a, b, c, M[14], 0xc33707d6, 9)
    c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14)
    b = fnG(b, c, d, a, M[8], 0x455a14ed, 20)
    a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5)
    d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9)
    c = fnG(c, d, a, b, M[7], 0x676f02d9, 14)
    b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20)
  
    a = fnH(a, b, c, d, M[5], 0xfffa3942, 4)
    d = fnH(d, a, b, c, M[8], 0x8771f681, 11)
    c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16)
    b = fnH(b, c, d, a, M[14], 0xfde5380c, 23)
    a = fnH(a, b, c, d, M[1], 0xa4beea44, 4)
    d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11)
    c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16)
    b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23)
    a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4)
    d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11)
    c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16)
    b = fnH(b, c, d, a, M[6], 0x04881d05, 23)
    a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4)
    d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11)
    c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16)
    b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23)
  
    a = fnI(a, b, c, d, M[0], 0xf4292244, 6)
    d = fnI(d, a, b, c, M[7], 0x432aff97, 10)
    c = fnI(c, d, a, b, M[14], 0xab9423a7, 15)
    b = fnI(b, c, d, a, M[5], 0xfc93a039, 21)
    a = fnI(a, b, c, d, M[12], 0x655b59c3, 6)
    d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10)
    c = fnI(c, d, a, b, M[10], 0xffeff47d, 15)
    b = fnI(b, c, d, a, M[1], 0x85845dd1, 21)
    a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6)
    d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10)
    c = fnI(c, d, a, b, M[6], 0xa3014314, 15)
    b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21)
    a = fnI(a, b, c, d, M[4], 0xf7537e82, 6)
    d = fnI(d, a, b, c, M[11], 0xbd3af235, 10)
    c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15)
    b = fnI(b, c, d, a, M[9], 0xeb86d391, 21)
  
    this._a = (this._a + a) | 0
    this._b = (this._b + b) | 0
    this._c = (this._c + c) | 0
    this._d = (this._d + d) | 0
  }
  
  MD5.prototype._digest = function () {
    // create padding and handle blocks
    this._block[this._blockOffset++] = 0x80
    if (this._blockOffset > 56) {
      this._block.fill(0, this._blockOffset, 64)
      this._update()
      this._blockOffset = 0
    }
  
    this._block.fill(0, this._blockOffset, 56)
    this._block.writeUInt32LE(this._length[0], 56)
    this._block.writeUInt32LE(this._length[1], 60)
    this._update()
  
    // produce result
    var buffer = Buffer.allocUnsafe(16)
    buffer.writeInt32LE(this._a, 0)
    buffer.writeInt32LE(this._b, 4)
    buffer.writeInt32LE(this._c, 8)
    buffer.writeInt32LE(this._d, 12)
    return buffer
  }
  
  function rotl (x, n) {
    return (x << n) | (x >>> (32 - n))
  }
  
  function fnF (a, b, c, d, m, k, s) {
    return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0
  }
  
  function fnG (a, b, c, d, m, k, s) {
    return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0
  }
  
  function fnH (a, b, c, d, m, k, s) {
    return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0
  }
  
  function fnI (a, b, c, d, m, k, s) {
    return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0
  }
  
  module.exports = MD5
  
  },{"hash-base":218,"inherits":280,"safe-buffer":281}],241:[function(require,module,exports){
  (function (Buffer){
  // constant-space merkle root calculation algorithm
  module.exports = function fastRoot (values, digestFn) {
    if (!Array.isArray(values)) throw TypeError('Expected values Array')
    if (typeof digestFn !== 'function') throw TypeError('Expected digest Function')
  
    var length = values.length
    var results = values.concat()
  
    while (length > 1) {
      var j = 0
  
      for (var i = 0; i < length; i += 2, ++j) {
        var left = results[i]
        var right = i + 1 === length ? left : results[i + 1]
        var data = Buffer.concat([left, right])
  
        results[j] = digestFn(data)
      }
  
      length = j
    }
  
    return results[0]
  }
  
  }).call(this,require("buffer").Buffer)
  },{"buffer":3}],242:[function(require,module,exports){
  module.exports = assert;
  
  function assert(val, msg) {
    if (!val)
      throw new Error(msg || 'Assertion failed');
  }
  
  assert.equal = function assertEqual(l, r, msg) {
    if (l != r)
      throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
  };
  
  },{}],243:[function(require,module,exports){
  'use strict';
  
  var utils = exports;
  
  function toArray(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== 'string') {
      for (var i = 0; i < msg.length; i++)
        res[i] = msg[i] | 0;
      return res;
    }
    if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (var i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    } else {
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 0xff;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils.toArray = toArray;
  
  function zero2(word) {
    if (word.length === 1)
      return '0' + word;
    else
      return word;
  }
  utils.zero2 = zero2;
  
  function toHex(msg) {
    var res = '';
    for (var i = 0; i < msg.length; i++)
      res += zero2(msg[i].toString(16));
    return res;
  }
  utils.toHex = toHex;
  
  utils.encode = function encode(arr, enc) {
    if (enc === 'hex')
      return toHex(arr);
    else
      return arr;
  };
  
  },{}],244:[function(require,module,exports){
  exports.pbkdf2 = require('./lib/async')
  exports.pbkdf2Sync = require('./lib/sync')
  
  },{"./lib/async":245,"./lib/sync":248}],245:[function(require,module,exports){
  (function (process,global){
  var checkParameters = require('./precondition')
  var defaultEncoding = require('./default-encoding')
  var sync = require('./sync')
  var Buffer = require('safe-buffer').Buffer
  
  var ZERO_BUF
  var subtle = global.crypto && global.crypto.subtle
  var toBrowser = {
    'sha': 'SHA-1',
    'sha-1': 'SHA-1',
    'sha1': 'SHA-1',
    'sha256': 'SHA-256',
    'sha-256': 'SHA-256',
    'sha384': 'SHA-384',
    'sha-384': 'SHA-384',
    'sha-512': 'SHA-512',
    'sha512': 'SHA-512'
  }
  var checks = []
  function checkNative (algo) {
    if (global.process && !global.process.browser) {
      return Promise.resolve(false)
    }
    if (!subtle || !subtle.importKey || !subtle.deriveBits) {
      return Promise.resolve(false)
    }
    if (checks[algo] !== undefined) {
      return checks[algo]
    }
    ZERO_BUF = ZERO_BUF || Buffer.alloc(8)
    var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)
      .then(function () {
        return true
      }).catch(function () {
        return false
      })
    checks[algo] = prom
    return prom
  }
  
  function browserPbkdf2 (password, salt, iterations, length, algo) {
    return subtle.importKey(
      'raw', password, {name: 'PBKDF2'}, false, ['deriveBits']
    ).then(function (key) {
      return subtle.deriveBits({
        name: 'PBKDF2',
        salt: salt,
        iterations: iterations,
        hash: {
          name: algo
        }
      }, key, length << 3)
    }).then(function (res) {
      return Buffer.from(res)
    })
  }
  
  function resolvePromise (promise, callback) {
    promise.then(function (out) {
      process.nextTick(function () {
        callback(null, out)
      })
    }, function (e) {
      process.nextTick(function () {
        callback(e)
      })
    })
  }
  module.exports = function (password, salt, iterations, keylen, digest, callback) {
    if (typeof digest === 'function') {
      callback = digest
      digest = undefined
    }
  
    digest = digest || 'sha1'
    var algo = toBrowser[digest.toLowerCase()]
  
    if (!algo || typeof global.Promise !== 'function') {
      return process.nextTick(function () {
        var out
        try {
          out = sync(password, salt, iterations, keylen, digest)
        } catch (e) {
          return callback(e)
        }
        callback(null, out)
      })
    }
  
    checkParameters(password, salt, iterations, keylen)
    if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2')
    if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding)
    if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding)
  
    resolvePromise(checkNative(algo).then(function (resp) {
      if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo)
  
      return sync(password, salt, iterations, keylen, digest)
    }), callback)
  }
  
  }).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"./default-encoding":246,"./precondition":247,"./sync":248,"_process":11,"safe-buffer":281}],246:[function(require,module,exports){
  (function (process){
  var defaultEncoding
  /* istanbul ignore next */
  if (process.browser) {
    defaultEncoding = 'utf-8'
  } else {
    var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10)
  
    defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary'
  }
  module.exports = defaultEncoding
  
  }).call(this,require('_process'))
  },{"_process":11}],247:[function(require,module,exports){
  (function (Buffer){
  var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs
  
  function checkBuffer (buf, name) {
    if (typeof buf !== 'string' && !Buffer.isBuffer(buf)) {
      throw new TypeError(name + ' must be a buffer or string')
    }
  }
  
  module.exports = function (password, salt, iterations, keylen) {
    checkBuffer(password, 'Password')
    checkBuffer(salt, 'Salt')
  
    if (typeof iterations !== 'number') {
      throw new TypeError('Iterations not a number')
    }
  
    if (iterations < 0) {
      throw new TypeError('Bad iterations')
    }
  
    if (typeof keylen !== 'number') {
      throw new TypeError('Key length not a number')
    }
  
    if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */
      throw new TypeError('Bad key length')
    }
  }
  
  }).call(this,{"isBuffer":require("C:/Users/Johnny/AppData/Roaming/npm/node_modules/browserify/node_modules/is-buffer/index.js")})
  },{"C:/Users/Johnny/AppData/Roaming/npm/node_modules/browserify/node_modules/is-buffer/index.js":8}],248:[function(require,module,exports){
  var md5 = require('create-hash/md5')
  var RIPEMD160 = require('ripemd160')
  var sha = require('sha.js')
  
  var checkParameters = require('./precondition')
  var defaultEncoding = require('./default-encoding')
  var Buffer = require('safe-buffer').Buffer
  var ZEROS = Buffer.alloc(128)
  var sizes = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
  }
  
  function Hmac (alg, key, saltLen) {
    var hash = getDigest(alg)
    var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64
  
    if (key.length > blocksize) {
      key = hash(key)
    } else if (key.length < blocksize) {
      key = Buffer.concat([key, ZEROS], blocksize)
    }
  
    var ipad = Buffer.allocUnsafe(blocksize + sizes[alg])
    var opad = Buffer.allocUnsafe(blocksize + sizes[alg])
    for (var i = 0; i < blocksize; i++) {
      ipad[i] = key[i] ^ 0x36
      opad[i] = key[i] ^ 0x5C
    }
  
    var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4)
    ipad.copy(ipad1, 0, 0, blocksize)
    this.ipad1 = ipad1
    this.ipad2 = ipad
    this.opad = opad
    this.alg = alg
    this.blocksize = blocksize
    this.hash = hash
    this.size = sizes[alg]
  }
  
  Hmac.prototype.run = function (data, ipad) {
    data.copy(ipad, this.blocksize)
    var h = this.hash(ipad)
    h.copy(this.opad, this.blocksize)
    return this.hash(this.opad)
  }
  
  function getDigest (alg) {
    function shaFunc (data) {
      return sha(alg).update(data).digest()
    }
    function rmd160Func (data) {
      return new RIPEMD160().update(data).digest()
    }
  
    if (alg === 'rmd160' || alg === 'ripemd160') return rmd160Func
    if (alg === 'md5') return md5
    return shaFunc
  }
  
  function pbkdf2 (password, salt, iterations, keylen, digest) {
    checkParameters(password, salt, iterations, keylen)
  
    if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding)
    if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding)
  
    digest = digest || 'sha1'
  
    var hmac = new Hmac(digest, password, salt.length)
  
    var DK = Buffer.allocUnsafe(keylen)
    var block1 = Buffer.allocUnsafe(salt.length + 4)
    salt.copy(block1, 0, 0, salt.length)
  
    var destPos = 0
    var hLen = sizes[digest]
    var l = Math.ceil(keylen / hLen)
  
    for (var i = 1; i <= l; i++) {
      block1.writeUInt32BE(i, salt.length)
  
      var T = hmac.run(block1, hmac.ipad1)
      var U = T
  
      for (var j = 1; j < iterations; j++) {
        U = hmac.run(U, hmac.ipad2)
        for (var k = 0; k < hLen; k++) T[k] ^= U[k]
      }
  
      T.copy(DK, destPos)
      destPos += hLen
    }
  
    return DK
  }
  
  module.exports = pbkdf2
  
  },{"./default-encoding":246,"./precondition":247,"create-hash/md5":194,"ripemd160":253,"safe-buffer":281,"sha.js":257}],249:[function(require,module,exports){
  var OPS = require('bitcoin-ops')
  
  function encodingLength (i) {
    return i < OPS.OP_PUSHDATA1 ? 1
    : i <= 0xff ? 2
    : i <= 0xffff ? 3
    : 5
  }
  
  function encode (buffer, number, offset) {
    var size = encodingLength(number)
  
    // ~6 bit
    if (size === 1) {
      buffer.writeUInt8(number, offset)
  
    // 8 bit
    } else if (size === 2) {
      buffer.writeUInt8(OPS.OP_PUSHDATA1, offset)
      buffer.writeUInt8(number, offset + 1)
  
    // 16 bit
    } else if (size === 3) {
      buffer.writeUInt8(OPS.OP_PUSHDATA2, offset)
      buffer.writeUInt16LE(number, offset + 1)
  
    // 32 bit
    } else {
      buffer.writeUInt8(OPS.OP_PUSHDATA4, offset)
      buffer.writeUInt32LE(number, offset + 1)
    }
  
    return size
  }
  
  function decode (buffer, offset) {
    var opcode = buffer.readUInt8(offset)
    var number, size
  
    // ~6 bit
    if (opcode < OPS.OP_PUSHDATA1) {
      number = opcode
      size = 1
  
    // 8 bit
    } else if (opcode === OPS.OP_PUSHDATA1) {
      if (offset + 2 > buffer.length) return null
      number = buffer.readUInt8(offset + 1)
      size = 2
  
    // 16 bit
    } else if (opcode === OPS.OP_PUSHDATA2) {
      if (offset + 3 > buffer.length) return null
      number = buffer.readUInt16LE(offset + 1)
      size = 3
  
    // 32 bit
    } else {
      if (offset + 5 > buffer.length) return null
      if (opcode !== OPS.OP_PUSHDATA4) throw new Error('Unexpected opcode')
  
      number = buffer.readUInt32LE(offset + 1)
      size = 5
    }
  
    return {
      opcode: opcode,
      number: number,
      size: size
    }
  }
  
  module.exports = {
    encodingLength: encodingLength,
    encode: encode,
    decode: decode
  }
  
  },{"bitcoin-ops":140}],250:[function(require,module,exports){
  'use strict';
  const strictUriEncode = require('strict-uri-encode');
  const decodeComponent = require('decode-uri-component');
  const splitOnFirst = require('split-on-first');
  
  function encoderForArrayFormat(options) {
    switch (options.arrayFormat) {
      case 'index':
        return key => (result, value) => {
          const index = result.length;
          if (value === undefined || (options.skipNull && value === null)) {
            return result;
          }
  
          if (value === null) {
            return [...result, [encode(key, options), '[', index, ']'].join('')];
          }
  
          return [
            ...result,
            [encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')
          ];
        };
  
      case 'bracket':
        return key => (result, value) => {
          if (value === undefined || (options.skipNull && value === null)) {
            return result;
          }
  
          if (value === null) {
            return [...result, [encode(key, options), '[]'].join('')];
          }
  
          return [...result, [encode(key, options), '[]=', encode(value, options)].join('')];
        };
  
      case 'comma':
      case 'separator':
        return key => (result, value) => {
          if (value === null || value === undefined || value.length === 0) {
            return result;
          }
  
          if (result.length === 0) {
            return [[encode(key, options), '=', encode(value, options)].join('')];
          }
  
          return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
        };
  
      default:
        return key => (result, value) => {
          if (value === undefined || (options.skipNull && value === null)) {
            return result;
          }
  
          if (value === null) {
            return [...result, encode(key, options)];
          }
  
          return [...result, [encode(key, options), '=', encode(value, options)].join('')];
        };
    }
  }
  
  function parserForArrayFormat(options) {
    let result;
  
    switch (options.arrayFormat) {
      case 'index':
        return (key, value, accumulator) => {
          result = /\[(\d*)\]$/.exec(key);
  
          key = key.replace(/\[\d*\]$/, '');
  
          if (!result) {
            accumulator[key] = value;
            return;
          }
  
          if (accumulator[key] === undefined) {
            accumulator[key] = {};
          }
  
          accumulator[key][result[1]] = value;
        };
  
      case 'bracket':
        return (key, value, accumulator) => {
          result = /(\[\])$/.exec(key);
          key = key.replace(/\[\]$/, '');
  
          if (!result) {
            accumulator[key] = value;
            return;
          }
  
          if (accumulator[key] === undefined) {
            accumulator[key] = [value];
            return;
          }
  
          accumulator[key] = [].concat(accumulator[key], value);
        };
  
      case 'comma':
      case 'separator':
        return (key, value, accumulator) => {
          const isArray = typeof value === 'string' && value.split('').indexOf(options.arrayFormatSeparator) > -1;
          const newValue = isArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);
          accumulator[key] = newValue;
        };
  
      default:
        return (key, value, accumulator) => {
          if (accumulator[key] === undefined) {
            accumulator[key] = value;
            return;
          }
  
          accumulator[key] = [].concat(accumulator[key], value);
        };
    }
  }
  
  function validateArrayFormatSeparator(value) {
    if (typeof value !== 'string' || value.length !== 1) {
      throw new TypeError('arrayFormatSeparator must be single character string');
    }
  }
  
  function encode(value, options) {
    if (options.encode) {
      return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
    }
  
    return value;
  }
  
  function decode(value, options) {
    if (options.decode) {
      return decodeComponent(value);
    }
  
    return value;
  }
  
  function keysSorter(input) {
    if (Array.isArray(input)) {
      return input.sort();
    }
  
    if (typeof input === 'object') {
      return keysSorter(Object.keys(input))
        .sort((a, b) => Number(a) - Number(b))
        .map(key => input[key]);
    }
  
    return input;
  }
  
  function removeHash(input) {
    const hashStart = input.indexOf('#');
    if (hashStart !== -1) {
      input = input.slice(0, hashStart);
    }
  
    return input;
  }
  
  function getHash(url) {
    let hash = '';
    const hashStart = url.indexOf('#');
    if (hashStart !== -1) {
      hash = url.slice(hashStart);
    }
  
    return hash;
  }
  
  function extract(input) {
    input = removeHash(input);
    const queryStart = input.indexOf('?');
    if (queryStart === -1) {
      return '';
    }
  
    return input.slice(queryStart + 1);
  }
  
  function parseValue(value, options) {
    if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {
      value = Number(value);
    } else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
      value = value.toLowerCase() === 'true';
    }
  
    return value;
  }
  
  function parse(input, options) {
    options = Object.assign({
      decode: true,
      sort: true,
      arrayFormat: 'none',
      arrayFormatSeparator: ',',
      parseNumbers: false,
      parseBooleans: false
    }, options);
  
    validateArrayFormatSeparator(options.arrayFormatSeparator);
  
    const formatter = parserForArrayFormat(options);
  
    // Create an object with no prototype
    const ret = Object.create(null);
  
    if (typeof input !== 'string') {
      return ret;
    }
  
    input = input.trim().replace(/^[?#&]/, '');
  
    if (!input) {
      return ret;
    }
  
    for (const param of input.split('&')) {
      let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, ' ') : param, '=');
  
      // Missing `=` should be `null`:
      // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
      value = value === undefined ? null : options.arrayFormat === 'comma' ? value : decode(value, options);
      formatter(decode(key, options), value, ret);
    }
  
    for (const key of Object.keys(ret)) {
      const value = ret[key];
      if (typeof value === 'object' && value !== null) {
        for (const k of Object.keys(value)) {
          value[k] = parseValue(value[k], options);
        }
      } else {
        ret[key] = parseValue(value, options);
      }
    }
  
    if (options.sort === false) {
      return ret;
    }
  
    return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
      const value = ret[key];
      if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
        // Sort object keys, not values
        result[key] = keysSorter(value);
      } else {
        result[key] = value;
      }
  
      return result;
    }, Object.create(null));
  }
  
  exports.extract = extract;
  exports.parse = parse;
  
  exports.stringify = (object, options) => {
    if (!object) {
      return '';
    }
  
    options = Object.assign({
      encode: true,
      strict: true,
      arrayFormat: 'none',
      arrayFormatSeparator: ','
    }, options);
  
    validateArrayFormatSeparator(options.arrayFormatSeparator);
  
    const formatter = encoderForArrayFormat(options);
  
    const objectCopy = Object.assign({}, object);
    if (options.skipNull) {
      for (const key of Object.keys(objectCopy)) {
        if (objectCopy[key] === undefined || objectCopy[key] === null) {
          delete objectCopy[key];
        }
      }
    }
  
    const keys = Object.keys(objectCopy);
  
    if (options.sort !== false) {
      keys.sort(options.sort);
    }
  
    return keys.map(key => {
      const value = object[key];
  
      if (value === undefined) {
        return '';
      }
  
      if (value === null) {
        return encode(key, options);
      }
  
      if (Array.isArray(value)) {
        return value
          .reduce(formatter(key), [])
          .join('&');
      }
  
      return encode(key, options) + '=' + encode(value, options);
    }).filter(x => x.length > 0).join('&');
  };
  
  exports.parseUrl = (input, options) => {
    return {
      url: removeHash(input).split('?')[0] || '',
      query: parse(extract(input), options)
    };
  };
  
  exports.stringifyUrl = (input, options) => {
    const url = removeHash(input.url).split('?')[0] || '';
    const queryFromUrl = exports.extract(input.url);
    const parsedQueryFromUrl = exports.parse(queryFromUrl);
    const hash = getHash(input.url);
    const query = Object.assign(parsedQueryFromUrl, input.query);
    let queryString = exports.stringify(query, options);
    if (queryString) {
      queryString = `?${queryString}`;
    }
  
    return `${url}${queryString}${hash}`;
  };
  
  },{"decode-uri-component":198,"split-on-first":264,"strict-uri-encode":265}],251:[function(require,module,exports){
  (function (process,global){
  'use strict'
  
  // limit of Crypto.getRandomValues()
  // https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
  var MAX_BYTES = 65536
  
  // Node supports requesting up to this number of bytes
  // https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
  var MAX_UINT32 = 4294967295
  
  function oldBrowser () {
    throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
  }
  
  var Buffer = require('safe-buffer').Buffer
  var crypto = global.crypto || global.msCrypto
  
  if (crypto && crypto.getRandomValues) {
    module.exports = randomBytes
  } else {
    module.exports = oldBrowser
  }
  
  function randomBytes (size, cb) {
    // phantomjs needs to throw
    if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')
  
    var bytes = Buffer.allocUnsafe(size)
  
    if (size > 0) {  // getRandomValues fails on IE if size == 0
      if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
        // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
        for (var generated = 0; generated < size; generated += MAX_BYTES) {
          // buffer.slice automatically checks if the end is past the end of
          // the buffer so we don't have to here
          crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
        }
      } else {
        crypto.getRandomValues(bytes)
      }
    }
  
    if (typeof cb === 'function') {
      return process.nextTick(function () {
        cb(null, bytes)
      })
    }
  
    return bytes
  }
  
  }).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"_process":11,"safe-buffer":281}],252:[function(require,module,exports){
  // Extracted from https://github.com/crypto-browserify/ripemd160
  (function (factory) {
      if (typeof module === "object" && typeof module.exports === "object") {
          var v = factory(require, exports);
          if (v !== undefined) module.exports = v;
      }
      else if (typeof define === "function" && define.amd) {
          define(["require", "exports"], factory);
      }
  })(function (require, exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var ARRAY16 = new Array(16);
      var zl = [
          0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
          7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
          3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
          1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
          4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
      ];
      var zr = [
          5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
          6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
          15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
          8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
          12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
      ];
      var sl = [
          11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
          7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
          11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
          11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
          9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
      ];
      var sr = [
          8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
          9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
          9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
          15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
          8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
      ];
      var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e];
      var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000];
      function rotl(x, n) {
          return (x << n) | (x >>> (32 - n));
      }
      function fn1(a, b, c, d, e, m, k, s) {
          return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0;
      }
      function fn2(a, b, c, d, e, m, k, s) {
          return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0;
      }
      function fn3(a, b, c, d, e, m, k, s) {
          return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0;
      }
      function fn4(a, b, c, d, e, m, k, s) {
          return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0;
      }
      function fn5(a, b, c, d, e, m, k, s) {
          return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0;
      }
      function readInt32LE(buffer, offset) {
          offset >>>= 0;
          return (buffer[offset])
              | (buffer[offset + 1] << 8)
              | (buffer[offset + 2] << 16)
              | (buffer[offset + 3] << 24);
      }
      function writeUInt32LE(buffer, value, offset) {
          value = +value;
          offset >>>= 0;
          buffer[offset + 3] = (value >>> 24);
          buffer[offset + 2] = (value >>> 16);
          buffer[offset + 1] = (value >>> 8);
          buffer[offset] = (value & 0xff);
          return offset + 4;
      }
      function writeInt32LE(buffer, value, offset) {
          value = +value;
          offset >>>= 0;
          buffer[offset] = (value & 0xff);
          buffer[offset + 1] = (value >>> 8);
          buffer[offset + 2] = (value >>> 16);
          buffer[offset + 3] = (value >>> 24);
          return offset + 4;
      }
      function createArray(size) {
          if (typeof Uint8Array !== 'undefined') {
              return new Uint8Array(size);
          }
          else {
              return new Array(size);
          }
      }
      var RIPEMD160 = /** @class */ (function () {
          function RIPEMD160() {
              this._block = createArray(64);
              this._blockSize = 64;
              this._blockOffset = 0;
              this._length = [0, 0, 0, 0];
              this._finalized = false;
              this._a = 0x67452301;
              this._b = 0xefcdab89;
              this._c = 0x98badcfe;
              this._d = 0x10325476;
              this._e = 0xc3d2e1f0;
          }
          RIPEMD160.prototype.update = function (data) {
              if (this._finalized)
                  throw new Error('Digest already called');
              // consume data
              var block = this._block;
              var offset = 0;
              while (this._blockOffset + data.length - offset >= this._blockSize) {
                  for (var i = this._blockOffset; i < this._blockSize;)
                      block[i++] = data[offset++];
                  this._update();
                  this._blockOffset = 0;
              }
              while (offset < data.length)
                  block[this._blockOffset++] = data[offset++];
              // update length
              for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
                  this._length[j] += carry;
                  carry = (this._length[j] / 0x0100000000) | 0;
                  if (carry > 0)
                      this._length[j] -= 0x0100000000 * carry;
              }
              return this;
          };
          RIPEMD160.prototype._update = function () {
              var words = ARRAY16;
              for (var j = 0; j < 16; ++j) {
                  words[j] = readInt32LE(this._block, j * 4);
              }
              var al = this._a | 0;
              var bl = this._b | 0;
              var cl = this._c | 0;
              var dl = this._d | 0;
              var el = this._e | 0;
              var ar = this._a | 0;
              var br = this._b | 0;
              var cr = this._c | 0;
              var dr = this._d | 0;
              var er = this._e | 0;
              // computation
              for (var i = 0; i < 80; i += 1) {
                  var tl = void 0;
                  var tr = void 0;
                  if (i < 16) {
                      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
                      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
                  }
                  else if (i < 32) {
                      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
                      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
                  }
                  else if (i < 48) {
                      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
                      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
                  }
                  else if (i < 64) {
                      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
                      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
                  }
                  else { // if (i<80) {
                      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
                      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
                  }
                  al = el;
                  el = dl;
                  dl = rotl(cl, 10);
                  cl = bl;
                  bl = tl;
                  ar = er;
                  er = dr;
                  dr = rotl(cr, 10);
                  cr = br;
                  br = tr;
              }
              // update state
              var t = (this._b + cl + dr) | 0;
              this._b = (this._c + dl + er) | 0;
              this._c = (this._d + el + ar) | 0;
              this._d = (this._e + al + br) | 0;
              this._e = (this._a + bl + cr) | 0;
              this._a = t;
          };
          RIPEMD160.prototype.digest = function () {
              if (this._finalized) {
                  throw new Error('Digest already called');
              }
              this._finalized = true;
              // create padding and handle blocks
              this._block[this._blockOffset++] = 0x80;
              if (this._blockOffset > 56) {
                  this._block.fill(0, this._blockOffset, 64);
                  this._update();
                  this._blockOffset = 0;
              }
              this._block.fill(0, this._blockOffset, 56);
              writeUInt32LE(this._block, this._length[0], 56);
              writeUInt32LE(this._block, this._length[1], 60);
              this._update();
              // produce result
              var buffer = createArray(20);
              writeInt32LE(buffer, this._a, 0);
              writeInt32LE(buffer, this._b, 4);
              writeInt32LE(buffer, this._c, 8);
              writeInt32LE(buffer, this._d, 12);
              writeInt32LE(buffer, this._e, 16);
              // reset state
              this._block.fill(0);
              this._blockOffset = 0;
              for (var i = 0; i < 4; ++i) {
                  this._length[i] = 0;
              }
              return buffer;
          };
          return RIPEMD160;
      }());
      exports.default = RIPEMD160;
  });
  
  },{}],253:[function(require,module,exports){
  'use strict'
  var Buffer = require('buffer').Buffer
  var inherits = require('inherits')
  var HashBase = require('hash-base')
  
  var ARRAY16 = new Array(16)
  
  var zl = [
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
    3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
    1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
    4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
  ]
  
  var zr = [
    5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
    6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
    15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
    8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
    12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
  ]
  
  var sl = [
    11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
    7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
    11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
    11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
    9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
  ]
  
  var sr = [
    8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
    9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
    9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
    15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
    8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
  ]
  
  var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]
  var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]
  
  function RIPEMD160 () {
    HashBase.call(this, 64)
  
    // state
    this._a = 0x67452301
    this._b = 0xefcdab89
    this._c = 0x98badcfe
    this._d = 0x10325476
    this._e = 0xc3d2e1f0
  }
  
  inherits(RIPEMD160, HashBase)
  
  RIPEMD160.prototype._update = function () {
    var words = ARRAY16
    for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4)
  
    var al = this._a | 0
    var bl = this._b | 0
    var cl = this._c | 0
    var dl = this._d | 0
    var el = this._e | 0
  
    var ar = this._a | 0
    var br = this._b | 0
    var cr = this._c | 0
    var dr = this._d | 0
    var er = this._e | 0
  
    // computation
    for (var i = 0; i < 80; i += 1) {
      var tl
      var tr
      if (i < 16) {
        tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])
        tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])
      } else if (i < 32) {
        tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])
        tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])
      } else if (i < 48) {
        tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])
        tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])
      } else if (i < 64) {
        tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])
        tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])
      } else { // if (i<80) {
        tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])
        tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])
      }
  
      al = el
      el = dl
      dl = rotl(cl, 10)
      cl = bl
      bl = tl
  
      ar = er
      er = dr
      dr = rotl(cr, 10)
      cr = br
      br = tr
    }
  
    // update state
    var t = (this._b + cl + dr) | 0
    this._b = (this._c + dl + er) | 0
    this._c = (this._d + el + ar) | 0
    this._d = (this._e + al + br) | 0
    this._e = (this._a + bl + cr) | 0
    this._a = t
  }
  
  RIPEMD160.prototype._digest = function () {
    // create padding and handle blocks
    this._block[this._blockOffset++] = 0x80
    if (this._blockOffset > 56) {
      this._block.fill(0, this._blockOffset, 64)
      this._update()
      this._blockOffset = 0
    }
  
    this._block.fill(0, this._blockOffset, 56)
    this._block.writeUInt32LE(this._length[0], 56)
    this._block.writeUInt32LE(this._length[1], 60)
    this._update()
  
    // produce result
    var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20)
    buffer.writeInt32LE(this._a, 0)
    buffer.writeInt32LE(this._b, 4)
    buffer.writeInt32LE(this._c, 8)
    buffer.writeInt32LE(this._d, 12)
    buffer.writeInt32LE(this._e, 16)
    return buffer
  }
  
  function rotl (x, n) {
    return (x << n) | (x >>> (32 - n))
  }
  
  function fn1 (a, b, c, d, e, m, k, s) {
    return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
  }
  
  function fn2 (a, b, c, d, e, m, k, s) {
    return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
  }
  
  function fn3 (a, b, c, d, e, m, k, s) {
    return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
  }
  
  function fn4 (a, b, c, d, e, m, k, s) {
    return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
  }
  
  function fn5 (a, b, c, d, e, m, k, s) {
    return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
  }
  
  module.exports = RIPEMD160
  
  },{"buffer":3,"hash-base":218,"inherits":280}],254:[function(require,module,exports){
  module.exports = require('./lib/schema-inspector');
  
  },{"./lib/schema-inspector":255}],255:[function(require,module,exports){
  /*
   * This module is intended to be executed both on client side and server side.
   * No error should be thrown. (soft error handling)
   */
  
  (function () {
    var root = {};
    // Dependencies --------------------------------------------------------------
    root.async = (typeof require === 'function') ? require('async') : window.async;
    if (typeof root.async !== 'object') {
      throw new Error('Module async is required (https://github.com/caolan/async)');
    }
    var async = root.async;
  
    function _extend(origin, add) {
      if (!add || typeof add !== 'object') {
        return origin;
      }
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
  
    function _merge() {
      var ret = {};
      var args = Array.prototype.slice.call(arguments);
      var keys = null;
      var i = null;
  
      args.forEach(function (arg) {
        if (arg && arg.constructor === Object) {
          keys = Object.keys(arg);
          i = keys.length;
          while (i--) {
            ret[keys[i]] = arg[keys[i]];
          }
        }
      });
      return ret;
    }
  
    // Customisable class (Base class) -------------------------------------------
    // Use with operation "new" to extend Validation and Sanitization themselves,
    // not their prototype. In other words, constructor shall be call to extend
    // those functions, instead of being in their constructor, like this:
    //		_extend(Validation, new Customisable);
  
    function Customisable() {
      this.custom = {};
  
      this.extend = function (custom) {
        return _extend(this.custom, custom);
      };
  
      this.reset = function () {
        this.custom = {};
      };
  
      this.remove = function (fields) {
        if (!_typeIs.array(fields)) {
          fields = [fields];
        }
        fields.forEach(function (field) {
          delete this.custom[field];
        }, this);
      };
    }
  
    // Inspection class (Base class) ---------------------------------------------
    // Use to extend Validation and Sanitization prototypes. Inspection
    // constructor shall be called in derived class constructor.
  
    function Inspection(schema, custom) {
      var _stack = ['@'];
  
      this._schema = schema;
      this._custom = {};
      if (custom != null) {
        for (var key in custom) {
          if (Object.prototype.hasOwnProperty.call(custom, key)) {
            this._custom['$' + key] = custom[key];
          }
        }
      }
  
      this._getDepth = function () {
        return _stack.length;
      };
  
      this._dumpStack = function () {
        return _stack.map(function (i) {return i.replace(/^\[/g, '\u001b\u001c\u001d\u001e');})
        .join('.').replace(/\.\u001b\u001c\u001d\u001e/g, '[');
      };
  
      this._deeperObject = function (name) {
        _stack.push((/^[a-z$_][a-z0-9$_]*$/i).test(name) ? name : '["' + name + '"]');
        return this;
      };
  
      this._deeperArray = function (i) {
        _stack.push('[' + i + ']');
        return this;
      };
  
      this._back = function () {
        _stack.pop();
        return this;
      };
    }
    // Simple types --------------------------------------------------------------
    // If the property is not defined or is not in this list:
    var _typeIs = {
      "function": function (element) {
        return typeof element === 'function';
      },
      "string": function (element) {
        return typeof element === 'string';
      },
      "number": function (element) {
        return typeof element === 'number' && !isNaN(element);
      },
      "integer": function (element) {
        return typeof element === 'number' && element % 1 === 0;
      },
      "NaN": function (element) {
        return typeof element === 'number' && isNaN(element);
      },
      "boolean": function (element) {
        return typeof element === 'boolean';
      },
      "null": function (element) {
        return element === null;
      },
      "date": function (element) {
        return element != null && element instanceof Date;
      },
      "object": function (element) {
        return element != null && element.constructor === Object;
      },
      "array": function (element) {
        return element != null && element.constructor === Array;
      },
      "any": function (element) {
        return true;
      }
    };
  
    function _simpleType(type, candidate) {
      if (typeof type == 'function') {
        return candidate instanceof type;
      }
      type = type in _typeIs ? type : 'any';
      return _typeIs[type](candidate);
    }
  
    function _realType(candidate) {
      for (var i in _typeIs) {
        if (_simpleType(i, candidate)) {
          if (i !== 'any') { return i; }
          return 'an instance of ' + candidate.constructor.name;
        }
      }
    }
  
    function getIndexes(a, value) {
      var indexes = [];
      var i = a.indexOf(value);
  
      while (i !== -1) {
        indexes.push(i);
        i = a.indexOf(value, i + 1);
      }
      return indexes;
    }
  
    // Available formats ---------------------------------------------------------
    var _formats = {
      'void': /^$/,
      'url': /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)?(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i,
      'date-time': /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?(Z?|(-|\+)\d{2}:\d{2})$/,
      'date': /^\d{4}-\d{2}-\d{2}$/,
      'coolDateTime': /^\d{4}(-|\/)\d{2}(-|\/)\d{2}(T| )\d{2}:\d{2}:\d{2}(\.\d{3})?Z?$/,
      'time': /^\d{2}\:\d{2}\:\d{2}$/,
      'color': /^#([0-9a-f])+$/i,
      'email': /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$/i,
      'numeric': /^[0-9]+$/,
      'integer': /^\-?[0-9]+$/,
      'decimal': /^\-?[0-9]*\.?[0-9]+$/,
      'alpha': /^[a-z]+$/i,
      'alphaNumeric': /^[a-z0-9]+$/i,
      'alphaDash': /^[a-z0-9_-]+$/i,
      'javascript': /^[a-z_\$][a-z0-9_\$]*$/i,
      'upperString': /^[A-Z ]*$/,
      'lowerString': /^[a-z ]*$/
    };
  
  // Validation ------------------------------------------------------------------
    var _validationAttribut = {
      optional: function (schema, candidate) {
        var opt = typeof schema.optional === 'boolean' ? schema.optional : (schema.optional === 'true'); // Default is false
  
        if (opt === true) {
          return;
        }
        if (typeof candidate === 'undefined') {
          this.report('is missing and not optional', null, 'optional');
        }
      },
      type: function (schema, candidate) {
        // return because optional function already handle this case
        if (typeof candidate === 'undefined' || (typeof schema.type !== 'string' && !(schema.type instanceof Array) && typeof schema.type !== 'function')) {
          return;
        }
        var types = _typeIs.array(schema.type) ? schema.type : [schema.type];
        var typeIsValid = types.some(function (type) {
          return _simpleType(type, candidate);
        });
        if (!typeIsValid) {
          types = types.map(function (t) {return typeof t === 'function' ? 'and instance of ' + t.name : t; });
          this.report('must be ' + types.join(' or ') + ', but is ' + _realType(candidate), null, 'type');
        }
      },
      uniqueness: function (schema, candidate) {
        if (typeof schema.uniqueness === 'string') { schema.uniqueness = (schema.uniqueness === 'true'); }
        if (typeof schema.uniqueness !== 'boolean' || schema.uniqueness === false || (!_typeIs.array(candidate) && typeof candidate !== 'string')) {
          return;
        }
        var reported = [];
        for (var i = 0; i < candidate.length; i++) {
          if (reported.indexOf(candidate[i]) >= 0) {
            continue;
          }
          var indexes = getIndexes(candidate, candidate[i]);
          if (indexes.length > 1) {
            reported.push(candidate[i]);
            this.report('has value [' + candidate[i] + '] more than once at indexes [' + indexes.join(', ') + ']', null, 'uniqueness');
          }
        }
      },
      pattern: function (schema, candidate) {
        var self = this;
        var regexs = schema.pattern;
        if (typeof candidate !== 'string') {
          return;
        }
        var matches = false;
        if (!_typeIs.array(regexs)) {
          regexs = [regexs];
        }
        regexs.forEach(function (regex) {
          if (typeof regex === 'string' && regex in _formats) {
            regex = _formats[regex];
          }
          if (regex instanceof RegExp) {
            if (regex.test(candidate)) {
              matches = true;
            }
          }
        });
        if (!matches) {
          self.report('must match [' + regexs.join(' or ') + '], but is equal to "' + candidate + '"', null, 'pattern');
        }
      },
      validDate: function (schema, candidate) {
        if (String(schema.validDate) === 'true' && candidate instanceof Date && isNaN(candidate.getTime())) {
          this.report('must be a valid date', null, 'validDate');
        }
      },
      minLength: function (schema, candidate) {
        if (typeof candidate !== 'string' && !_typeIs.array(candidate)) {
          return;
        }
        var minLength = Number(schema.minLength);
        if (isNaN(minLength)) {
          return;
        }
        if (candidate.length < minLength) {
          this.report('must be longer than ' + minLength + ' elements, but it has ' + candidate.length, null, 'minLength');
        }
      },
      maxLength: function (schema, candidate) {
        if (typeof candidate !== 'string' && !_typeIs.array(candidate)) {
          return;
        }
        var maxLength = Number(schema.maxLength);
        if (isNaN(maxLength)) {
          return;
        }
        if (candidate.length > maxLength) {
          this.report('must be shorter than ' + maxLength + ' elements, but it has ' + candidate.length, null, 'maxLength');
        }
      },
      exactLength: function (schema, candidate) {
        if (typeof candidate !== 'string' && !_typeIs.array(candidate)) {
          return;
        }
        var exactLength = Number(schema.exactLength);
        if (isNaN(exactLength)) {
          return;
        }
        if (candidate.length !== exactLength) {
          this.report('must have exactly ' + exactLength + ' elements, but it have ' + candidate.length, null, 'exactLength');
        }
      },
      lt: function (schema, candidate) {
        var limit = Number(schema.lt);
        if (typeof candidate !== 'number' || isNaN(limit)) {
          return;
        }
        if (candidate >= limit) {
          this.report('must be less than ' + limit + ', but is equal to "' + candidate + '"', null, 'lt');
        }
      },
      lte: function (schema, candidate) {
        var limit = Number(schema.lte);
        if (typeof candidate !== 'number' || isNaN(limit)) {
          return;
        }
        if (candidate > limit) {
          this.report('must be less than or equal to ' + limit + ', but is equal to "' + candidate + '"', null, 'lte');
        }
      },
      gt: function (schema, candidate) {
        var limit = Number(schema.gt);
        if (typeof candidate !== 'number' || isNaN(limit)) {
          return;
        }
        if (candidate <= limit) {
          this.report('must be greater than ' + limit + ', but is equal to "' + candidate + '"', null, 'gt');
        }
      },
      gte: function (schema, candidate) {
        var limit = Number(schema.gte);
        if (typeof candidate !== 'number' || isNaN(limit)) {
          return;
        }
        if (candidate < limit) {
          this.report('must be greater than or equal to ' + limit + ', but is equal to "' + candidate + '"', null, 'gte');
        }
      },
      eq: function (schema, candidate) {
        if (typeof candidate !== 'number' && typeof candidate !== 'string' && typeof candidate !== 'boolean') {
          return;
        }
        var limit = schema.eq;
        if (typeof limit !== 'number' && typeof limit !== 'string' && typeof limit !== 'boolean' && !_typeIs.array(limit)) {
          return;
        }
        if (_typeIs.array(limit)) {
          for (var i = 0; i < limit.length; i++) {
            if (candidate === limit[i]) {
              return;
            }
          }
          this.report('must be equal to [' + limit.map(function (l) {
            return '"' + l + '"';
          }).join(' or ') + '], but is equal to "' + candidate + '"', null, 'eq');
        }
        else {
          if (candidate !== limit) {
            this.report('must be equal to "' + limit + '", but is equal to "' + candidate + '"', null, 'eq');
          }
        }
      },
      ne: function (schema, candidate) {
        if (typeof candidate !== 'number' && typeof candidate !== 'string') {
          return;
        }
        var limit = schema.ne;
        if (typeof limit !== 'number' && typeof limit !== 'string' && !_typeIs.array(limit)) {
          return;
        }
        if (_typeIs.array(limit)) {
          for (var i = 0; i < limit.length; i++) {
            if (candidate === limit[i]) {
              this.report('must not be equal to "' + limit[i] + '"', null, 'ne');
              return;
            }
          }
        }
        else {
          if (candidate === limit) {
            this.report('must not be equal to "' + limit + '"', null, 'ne');
          }
        }
      },
      someKeys: function (schema, candidat) {
        var _keys = schema.someKeys;
        if (!_typeIs.object(candidat)) {
          return;
        }
        var valid = _keys.some(function (action) {
          return (action in candidat);
        });
        if (!valid) {
          this.report('must have at least key ' + _keys.map(function (i) {
            return '"' + i + '"';
          }).join(' or '), null, 'someKeys');
        }
      },
      strict: function (schema, candidate) {
        if (typeof schema.strict === 'string') { schema.strict = (schema.strict === 'true'); }
        if (schema.strict !== true || !_typeIs.object(candidate) || !_typeIs.object(schema.properties)) {
          return;
        }
        var self = this;
        if (typeof schema.properties['*'] === 'undefined') {
          var intruder = Object.keys(candidate).filter(function (key) {
            return (typeof schema.properties[key] === 'undefined');
          });
          if (intruder.length > 0) {
            var msg = 'should not contains ' + (intruder.length > 1 ? 'properties' : 'property') +
              ' [' + intruder.map(function (i) { return '"' + i + '"'; }).join(', ') + ']';
            self.report(msg, null, 'strict');
          }
        }
      },
      exec: function (schema, candidate, callback) {
        var self = this;
  
        if (typeof callback === 'function') {
          return this.asyncExec(schema, candidate, callback);
        }
        (_typeIs.array(schema.exec) ? schema.exec : [schema.exec]).forEach(function (exec) {
          if (typeof exec === 'function') {
            exec.call(self, schema, candidate);
          }
        });
      },
      properties: function (schema, candidate, callback) {
        if (typeof callback === 'function') {
          return this.asyncProperties(schema, candidate, callback);
        }
        if (!(schema.properties instanceof Object) || !(candidate instanceof Object)) {
          return;
        }
        var properties = schema.properties,
            i;
        if (properties['*'] != null) {
          for (i in candidate) {
            if (i in properties) {
              continue;
            }
            this._deeperObject(i);
            this._validate(properties['*'], candidate[i]);
            this._back();
          }
        }
        for (i in properties) {
          if (i === '*') {
            continue;
          }
          this._deeperObject(i);
          this._validate(properties[i], candidate[i]);
          this._back();
        }
      },
      items: function (schema, candidate, callback) {
        if (typeof callback === 'function') {
          return this.asyncItems(schema, candidate, callback);
        }
        if (!(schema.items instanceof Object) || !(candidate instanceof Object)) {
          return;
        }
        var items = schema.items;
        var i, l;
        // If provided schema is an array
        // then call validate for each case
        // else it is an Object
        // then call validate for each key
        if (_typeIs.array(items) && _typeIs.array(candidate)) {
          for (i = 0, l = items.length; i < l; i++) {
            this._deeperArray(i);
            this._validate(items[i], candidate[i]);
            this._back();
          }
        }
        else {
          for (var key in candidate) {
            if (Object.prototype.hasOwnProperty.call(candidate, key)) {
              this._deeperArray(key);
              this._validate(items, candidate[key]);
              this._back();
            }
  
          }
        }
      }
    };
  
    var _asyncValidationAttribut = {
      asyncExec: function (schema, candidate, callback) {
        var self = this;
        async.eachSeries(_typeIs.array(schema.exec) ? schema.exec : [schema.exec], function (exec, done) {
          if (typeof exec === 'function') {
            if (exec.length > 2) {
              return exec.call(self, schema, candidate, done);
            }
            exec.call(self, schema, candidate);
          }
          async.nextTick(done);
        }, callback);
      },
      asyncProperties: function (schema, candidate, callback) {
        if (!(schema.properties instanceof Object) || !_typeIs.object(candidate)) {
          return callback();
        }
        var self = this;
        var properties = schema.properties;
        async.series([
          function (next) {
            if (properties['*'] == null) {
              return next();
            }
            async.eachSeries(Object.keys(candidate), function (i, done) {
              if (i in properties) {
                return async.nextTick(done);
              }
              self._deeperObject(i);
              self._asyncValidate(properties['*'], candidate[i], function (err) {
                self._back();
                done(err);
              });
            }, next);
          },
          function (next) {
            async.eachSeries(Object.keys(properties), function (i, done) {
              if (i === '*') {
                return async.nextTick(done);
              }
              self._deeperObject(i);
              self._asyncValidate(properties[i], candidate[i], function (err) {
                self._back();
                done(err);
              });
            }, next);
          }
        ], callback);
      },
      asyncItems: function (schema, candidate, callback) {
        if (!(schema.items instanceof Object) || !(candidate instanceof Object)) {
          return callback();
        }
        var self = this;
        var items = schema.items;
        var i, l;
  
        if (_typeIs.array(items) && _typeIs.array(candidate)) {
          async.timesSeries(items.length, function (i, done) {
            self._deeperArray(i);
            self._asyncValidate(items[i], candidate[i], function (err, res) {
              self._back();
              done(err, res);
            });
            self._back();
          }, callback);
        }
        else {
          async.eachSeries(Object.keys(candidate), function (key, done) {
            self._deeperArray(key);
            self._asyncValidate(items, candidate[key], function (err, res) {
              self._back();
              done(err, res);
            });
          }, callback);
        }
      }
    };
  
    // Validation Class ----------------------------------------------------------
    // inherits from Inspection class (actually we just call Inspection
    // constructor with the new context, because its prototype is empty
    function Validation(schema, custom) {
      Inspection.prototype.constructor.call(this, schema, _merge(Validation.custom, custom));
      var _error = [];
  
      this._basicFields = Object.keys(_validationAttribut);
      this._customFields = Object.keys(this._custom);
      this.origin = null;
  
      this.report = function (message, code, reason) {
        var newErr = {
          code: code || this.userCode || null,
          reason: reason || 'unknown',
          message: this.userError || message || 'is invalid',
          property: this.userAlias ? (this.userAlias + ' (' + this._dumpStack() + ')') : this._dumpStack()
        };
        _error.push(newErr);
        return this;
      };
  
      this.result = function () {
        return {
          error: _error,
          valid: _error.length === 0,
          format: function () {
            if (this.valid === true) {
              return 'Candidate is valid';
            }
            return this.error.map(function (i) {
              return 'Property ' + i.property + ': ' + i.message;
            }).join('\n');
          }
        };
      };
    }
  
    _extend(Validation.prototype, _validationAttribut);
    _extend(Validation.prototype, _asyncValidationAttribut);
    _extend(Validation, new Customisable());
  
    Validation.prototype.validate = function (candidate, callback) {
      this.origin = candidate;
      if (typeof callback === 'function') {
        var self = this;
        return async.nextTick(function () {
          self._asyncValidate(self._schema, candidate, function (err) {
            self.origin = null;
            callback(err, self.result());
          });
        });
      }
      return this._validate(this._schema, candidate).result();
    };
  
    Validation.prototype._validate = function (schema, candidate, callback) {
      this.userCode = schema.code || null;
      this.userError = schema.error || null;
      this.userAlias = schema.alias || null;
      this._basicFields.forEach(function (i) {
        if ((i in schema || i === 'optional') && typeof this[i] === 'function') {
          this[i](schema, candidate);
        }
      }, this);
      this._customFields.forEach(function (i) {
        if (i in schema && typeof this._custom[i] === 'function') {
          this._custom[i].call(this, schema, candidate);
        }
      }, this);
      return this;
    };
  
    Validation.prototype._asyncValidate = function (schema, candidate, callback) {
      var self = this;
      this.userCode = schema.code || null;
      this.userError = schema.error || null;
      this.userAlias = schema.alias || null;
  
      async.series([
        function (next) {
          async.eachSeries(Object.keys(_validationAttribut), function (i, done) {
            async.nextTick(function () {
              if ((i in schema || i === 'optional') && typeof self[i] === 'function') {
                if (self[i].length > 2) {
                  return self[i](schema, candidate, done);
                }
                self[i](schema, candidate);
              }
              done();
            });
          }, next);
        },
        function (next) {
          async.eachSeries(Object.keys(self._custom), function (i, done) {
            async.nextTick(function () {
              if (i in schema && typeof self._custom[i] === 'function') {
                if (self._custom[i].length > 2) {
                  return self._custom[i].call(self, schema, candidate, done);
                }
                self._custom[i].call(self, schema, candidate);
              }
              done();
            });
          }, next);
        }
      ], callback);
    };
  
  // Sanitization ----------------------------------------------------------------
    // functions called by _sanitization.type method.
    var _forceType = {
      number: function (post, schema) {
        var n;
        if (typeof post === 'number') {
          return post;
        }
        else if (post === '') {
          if (typeof schema.def !== 'undefined')
            return schema.def;
          return null;
        }
        else if (typeof post === 'string') {
          n = parseFloat(post.replace(/,/g, '.').replace(/ /g, ''));
          if (typeof n === 'number') {
            return n;
          }
        }
        else if (post instanceof Date) {
          return +post;
        }
        return null;
      },
      integer: function (post, schema) {
        var n;
        if (typeof post === 'number' && post % 1 === 0) {
          return post;
        }
        else if (post === '') {
          if (typeof schema.def !== 'undefined')
            return schema.def;
          return null;
        }
        else if (typeof post === 'string') {
          n = parseInt(post.replace(/ /g, ''), 10);
          if (typeof n === 'number') {
            return n;
          }
        }
        else if (typeof post === 'number') {
          return parseInt(post, 10);
        }
        else if (typeof post === 'boolean') {
          if (post) { return 1; }
          return 0;
        }
        else if (post instanceof Date) {
          return +post;
        }
        return null;
      },
      string: function (post, schema) {
        if (typeof post === 'boolean' || typeof post === 'number' || post instanceof Date) {
          return post.toString();
        }
        else if (_typeIs.array(post)) {
          // If user authorize array and strings...
          if (schema.items || schema.properties)
            return post;
          return post.join(String(schema.joinWith || ','));
        }
        else if (post instanceof Object) {
          // If user authorize objects ans strings...
          if (schema.items || schema.properties)
            return post;
          return JSON.stringify(post);
        }
        else if (typeof post === 'string' && post.length) {
          return post;
        }
        return null;
      },
      date: function (post, schema) {
        if (post instanceof Date) {
          return post;
        }
        else {
          var d = new Date(post);
          if (!isNaN(d.getTime())) { // if valid date
            return d;
          }
        }
        return null;
      },
      boolean: function (post, schema) {
        if (typeof post === 'undefined') return null;
        if (typeof post === 'string' && post.toLowerCase() === 'false') return false;
        return !!post;
      },
      object: function (post, schema) {
        if (typeof post !== 'string' || _typeIs.object(post)) {
          return post;
        }
        try {
          return JSON.parse(post);
        }
        catch (e) {
          return null;
        }
      },
      array: function (post, schema) {
        if (_typeIs.array(post))
          return post;
        if (typeof post === 'undefined')
          return null;
        if (typeof post === 'string') {
          if (post.substring(0,1) === '[' && post.slice(-1) === ']') {
            try {
              return JSON.parse(post);
            }
            catch (e) {
              return null;
            }
          }
          return post.split(String(schema.splitWith || ','));
  
        }
        if (!_typeIs.array(post))
          return [ post ];
        return null;
      }
    };
  
    var _applyRules = {
      upper: function (post) {
        return post.toUpperCase();
      },
      lower: function (post) {
        return post.toLowerCase();
      },
      title: function (post) {
        // Fix by seb (replace \w\S* by \S* => exemple : coucou a va)
        return post.replace(/\S*/g, function (txt) {
          return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
        });
      },
      capitalize: function (post) {
        return post.charAt(0).toUpperCase() + post.substr(1).toLowerCase();
      },
      ucfirst: function (post) {
        return post.charAt(0).toUpperCase() + post.substr(1);
      },
      trim: function (post) {
        return post.trim();
      }
    };
  
    // Every function return the future value of each property. Therefore you
    // have to return post even if you do not change its value
    var _sanitizationAttribut = {
      strict: function (schema, post) {
        if (typeof schema.strict === 'string') { schema.strict = (schema.strict === 'true'); }
        if (schema.strict !== true)
          return post;
        if (!_typeIs.object(schema.properties))
          return post;
        if (!_typeIs.object(post))
          return post;
        var that = this;
        Object.keys(post).forEach(function (key) {
          if (!(key in schema.properties)) {
            delete post[key];
          }
        });
        return post;
      },
      optional: function (schema, post) {
        var opt = typeof schema.optional === 'boolean' ? schema.optional : (schema.optional !== 'false'); // Default: true
        if (opt === true) {
          return post;
        }
        if (typeof post !== 'undefined') {
          return post;
        }
        this.report();
        if (schema.def === Date) {
          return new Date();
        }
        return schema.def;
      },
      type: function (schema, post) {
        // if (_typeIs['object'](post) || _typeIs.array(post)) {
        // 	return post;
        // }
        if (typeof schema.type !== 'string' || typeof _forceType[schema.type] !== 'function') {
          return post;
        }
        var n;
        var opt = typeof schema.optional === 'boolean' ? schema.optional : true;
        if (typeof _forceType[schema.type] === 'function') {
          n = _forceType[schema.type](post, schema);
          if ((n === null && !opt) || (!n && isNaN(n)) || (n === null && schema.type === 'string')) {
            n = schema.def;
          }
        }
        else if (!opt) {
          n = schema.def;
        }
        if ((n != null || (typeof schema.def !== 'undefined' && schema.def === n)) && n !== post) {
          this.report();
          return n;
        }
        return post;
      },
      rules: function (schema, post) {
        var rules = schema.rules;
        if (typeof post !== 'string' || (typeof rules !== 'string' && !_typeIs.array(rules))) {
          return post;
        }
        var modified = false;
        (_typeIs.array(rules) ? rules : [rules]).forEach(function (rule) {
          if (typeof _applyRules[rule] === 'function') {
            post = _applyRules[rule](post);
            modified = true;
          }
        });
        if (modified) {
          this.report();
        }
        return post;
      },
      min: function (schema, post) {
        var postTest = Number(post);
        if (isNaN(postTest)) {
          return post;
        }
        var min = Number(schema.min);
        if (isNaN(min)) {
          return post;
        }
        if (postTest < min) {
          this.report();
          return min;
        }
        return post;
      },
      max: function (schema, post) {
        var postTest = Number(post);
        if (isNaN(postTest)) {
          return post;
        }
        var max = Number(schema.max);
        if (isNaN(max)) {
          return post;
        }
        if (postTest > max) {
          this.report();
          return max;
        }
        return post;
      },
      minLength: function (schema, post) {
        var limit = Number(schema.minLength);
        if (typeof post !== 'string' || isNaN(limit) || limit < 0) {
          return post;
        }
        var str = '';
        var gap = limit - post.length;
        if (gap > 0) {
          for (var i = 0; i < gap; i++) {
            str += '-';
          }
          this.report();
          return post + str;
        }
        return post;
      },
      maxLength: function (schema, post) {
        var limit = Number(schema.maxLength);
        if (typeof post !== 'string' || isNaN(limit) || limit < 0) {
          return post;
        }
        if (post.length > limit) {
          this.report();
          return post.slice(0, limit);
        }
        return post;
      },
      properties: function (schema, post, callback) {
        if (typeof callback === 'function') {
          return this.asyncProperties(schema, post, callback);
        }
        if (!post || typeof post !== 'object') {
          return post;
        }
        var properties = schema.properties;
        var tmp;
        var i;
        if (typeof properties['*'] !== 'undefined') {
          for (i in post) {
            if (i in properties) {
              continue;
            }
            this._deeperObject(i);
            tmp = this._sanitize(schema.properties['*'], post[i]);
            if (typeof tmp !== 'undefined') {
              post[i]= tmp;
            }
            this._back();
          }
        }
        for (i in schema.properties) {
          if (i !== '*') {
            this._deeperObject(i);
            tmp = this._sanitize(schema.properties[i], post[i]);
            if (typeof tmp !== 'undefined') {
              post[i]= tmp;
            }
            this._back();
          }
        }
        return post;
      },
      items: function (schema, post, callback) {
        if (typeof callback === 'function') {
          return this.asyncItems(schema, post, callback);
        }
        if (!(schema.items instanceof Object) || !(post instanceof Object)) {
          return post;
        }
        var i;
        if (_typeIs.array(schema.items) && _typeIs.array(post)) {
          var minLength = schema.items.length < post.length ? schema.items.length : post.length;
          for (i = 0; i < minLength; i++) {
            this._deeperArray(i);
            post[i] = this._sanitize(schema.items[i], post[i]);
            this._back();
          }
        }
        else {
          for (i in post) {
            if (Object.prototype.hasOwnProperty.call(post, i)) {
              this._deeperArray(i);
              post[i] = this._sanitize(schema.items, post[i]);
              this._back();
            }
          }
        }
        return post;
      },
      exec: function (schema, post, callback) {
        if (typeof callback === 'function') {
          return this.asyncExec(schema, post, callback);
        }
        var execs = _typeIs.array(schema.exec) ? schema.exec : [schema.exec];
  
        execs.forEach(function (exec) {
          if (typeof exec === 'function') {
            post = exec.call(this, schema, post);
          }
        }, this);
        return post;
      }
    };
  
    var _asyncSanitizationAttribut = {
      asyncExec: function (schema, post, callback) {
        var self = this;
        var execs = _typeIs.array(schema.exec) ? schema.exec : [schema.exec];
  
        async.eachSeries(execs, function (exec, done) {
          if (typeof exec === 'function') {
            if (exec.length > 2) {
              return exec.call(self, schema, post, function (err, res) {
                if (err) {
                  return done(err);
                }
                post = res;
                done();
              });
            }
            post = exec.call(self, schema, post);
          }
          done();
        }, function (err) {
          callback(err, post);
        });
      },
      asyncProperties: function (schema, post, callback) {
        if (!post || typeof post !== 'object') {
          return callback(null, post);
        }
        var self = this;
        var properties = schema.properties;
  
        async.series([
          function (next) {
            if (properties['*'] == null) {
              return next();
            }
            var globing = properties['*'];
            async.eachSeries(Object.keys(post), function (i, next) {
              if (i in properties) {
                return next();
              }
              self._deeperObject(i);
              self._asyncSanitize(globing, post[i], function (err, res) {
                if (err) { /* Error can safely be ignored here */ }
                if (typeof res !== 'undefined') {
                  post[i] = res;
                }
                self._back();
                next();
              });
            }, next);
          },
          function (next) {
            async.eachSeries(Object.keys(properties), function (i, next) {
              if (i === '*') {
                return next();
              }
              self._deeperObject(i);
              self._asyncSanitize(properties[i], post[i], function (err, res) {
                if (err) {
                  return next(err);
                }
                if (typeof res !== 'undefined') {
                  post[i] = res;
                }
                self._back();
                next();
              });
            }, next);
          }
        ], function (err) {
          return callback(err, post);
        });
      },
      asyncItems: function (schema, post, callback) {
        if (!(schema.items instanceof Object) || !(post instanceof Object)) {
          return callback(null, post);
        }
        var self = this;
        var items = schema.items;
        if (_typeIs.array(items) && _typeIs.array(post)) {
          var minLength = items.length < post.length ? items.length : post.length;
          async.timesSeries(minLength, function (i, next) {
            self._deeperArray(i);
            self._asyncSanitize(items[i], post[i], function (err, res) {
              if (err) {
                return next(err);
              }
              post[i] = res;
              self._back();
              next();
            });
          }, function (err) {
            callback(err, post);
          });
        }
        else {
          async.eachSeries(Object.keys(post), function (key, next) {
            self._deeperArray(key);
            self._asyncSanitize(items, post[key], function (err, res) {
              if (err) {
                return next();
              }
              post[key] = res;
              self._back();
              next();
            });
          }, function (err) {
            callback(err, post);
          });
        }
        return post;
      }
    };
  
    // Sanitization Class --------------------------------------------------------
    // inherits from Inspection class (actually we just call Inspection
    // constructor with the new context, because its prototype is empty
    function Sanitization(schema, custom) {
      Inspection.prototype.constructor.call(this, schema, _merge(Sanitization.custom, custom));
      var _reporting = [];
  
      this._basicFields = Object.keys(_sanitizationAttribut);
      this._customFields = Object.keys(this._custom);
      this.origin = null;
  
      this.report = function (message) {
        var newNot = {
            message: message || 'was sanitized',
            property: this.userAlias ? (this.userAlias + ' (' + this._dumpStack() + ')') : this._dumpStack()
        };
        if (!_reporting.some(function (e) { return e.property === newNot.property; })) {
          _reporting.push(newNot);
        }
      };
  
      this.result = function (data) {
        return {
          data: data,
          reporting: _reporting,
          format: function () {
            return this.reporting.map(function (i) {
              return 'Property ' + i.property + ' ' + i.message;
            }).join('\n');
          }
        };
      };
    }
  
    _extend(Sanitization.prototype, _sanitizationAttribut);
    _extend(Sanitization.prototype, _asyncSanitizationAttribut);
    _extend(Sanitization, new Customisable());
  
  
    Sanitization.prototype.sanitize = function (post, callback) {
      this.origin = post;
      if (typeof callback === 'function') {
        var self = this;
        return this._asyncSanitize(this._schema, post, function (err, data) {
          self.origin = null;
          callback(err, self.result(data));
        });
      }
      var data = this._sanitize(this._schema, post);
      this.origin = null;
      return this.result(data);
    };
  
    Sanitization.prototype._sanitize = function (schema, post) {
      this.userAlias = schema.alias || null;
      this._basicFields.forEach(function (i) {
        if ((i in schema || i === 'optional') && typeof this[i] === 'function') {
          post = this[i](schema, post);
        }
      }, this);
      this._customFields.forEach(function (i) {
        if (i in schema && typeof this._custom[i] === 'function') {
          post = this._custom[i].call(this, schema, post);
        }
      }, this);
      return post;
    };
  
    Sanitization.prototype._asyncSanitize = function (schema, post, callback) {
      var self = this;
      this.userAlias = schema.alias || null;
  
      async.waterfall([
        function (next) {
          async.reduce(self._basicFields, post, function (value, i, next) {
            async.nextTick(function () {
              if ((i in schema || i === 'optional') && typeof self[i] === 'function') {
                if (self[i].length > 2) {
                  return self[i](schema, value, next);
                }
                value = self[i](schema, value);
              }
              next(null, value);
            });
          }, next);
        },
        function (inter, next) {
          async.reduce(self._customFields, inter, function (value, i, next) {
            async.nextTick(function () {
              if (i in schema && typeof self._custom[i] === 'function') {
                if (self._custom[i].length > 2) {
                  return self._custom[i].call(self, schema, value, next);
                }
                value = self._custom[i].call(self, schema, value);
              }
              next(null, value);
            });
          }, next);
        }
      ], callback);
    };
  
    // ---------------------------------------------------------------------------
  
    var INT_MIN = -2147483648;
    var INT_MAX = 2147483647;
  
    var _rand = {
      int: function (min, max) {
        return min + (0 | Math.random() * (max - min + 1));
      },
      float: function (min, max) {
        return (Math.random() * (max - min) + min);
      },
      bool: function () {
        return (Math.random() > 0.5);
      },
      char: function (min, max) {
        return String.fromCharCode(this.int(min, max));
      },
      fromList: function (list) {
        return list[this.int(0, list.length - 1)];
      }
    };
  
    var _formatSample = {
      'date-time': function () {
        return new Date().toISOString();
      },
      'date': function () {
        return new Date().toISOString().replace(/T.*$/, '');
      },
      'time': function () {
        return new Date().toLocaleTimeString({}, { hour12: false });
      },
      'color': function (min, max) {
        var s = '#';
        if (min < 1) {
          min = 1;
        }
        for (var i = 0, l = _rand.int(min, max); i < l; i++) {
          s += _rand.fromList('0123456789abcdefABCDEF');
        }
        return s;
      },
      'numeric': function () {
        return '' + _rand.int(0, INT_MAX);
      },
      'integer': function () {
        if (_rand.bool() === true) {
          return '-' + this.numeric();
        }
        return this.numeric();
      },
      'decimal': function () {
        return this.integer() + '.' + this.numeric();
      },
      'alpha': function (min, max) {
        var s = '';
        if (min < 1) {
          min = 1;
        }
        for (var i = 0, l = _rand.int(min, max); i < l; i++) {
          s += _rand.fromList('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ');
        }
        return s;
      },
      'alphaNumeric': function (min, max) {
        var s = '';
        if (min < 1) {
          min = 1;
        }
        for (var i = 0, l = _rand.int(min, max); i < l; i++) {
          s += _rand.fromList('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789');
        }
        return s;
      },
      'alphaDash': function (min, max) {
        var s = '';
        if (min < 1) {
          min = 1;
        }
        for (var i = 0, l = _rand.int(min, max); i < l; i++) {
          s += _rand.fromList('_-abcdefghijklmnopqrstuvwxyz_-ABCDEFGHIJKLMNOPQRSTUVWXYZ_-0123456789_-');
        }
        return s;
      },
      'javascript': function (min, max) {
        var s = _rand.fromList('_$abcdefghijklmnopqrstuvwxyz_$ABCDEFGHIJKLMNOPQRSTUVWXYZ_$');
        for (var i = 0, l = _rand.int(min, max - 1); i < l; i++) {
          s += _rand.fromList('_$abcdefghijklmnopqrstuvwxyz_$ABCDEFGHIJKLMNOPQRSTUVWXYZ_$0123456789_$');
        }
        return s;
      }
    };
  
    function _getLimits(schema) {
      var min = INT_MIN;
      var max = INT_MAX;
  
      if (schema.gte != null) {
        min = schema.gte;
      }
      else if (schema.gt != null) {
        min = schema.gt + 1;
      }
      if (schema.lte != null) {
        max = schema.lte;
      }
      else if (schema.lt != null) {
        max = schema.lt - 1;
      }
      return { min: min, max: max };
    }
  
    var _typeGenerator = {
      string: function (schema) {
        if (schema.eq != null) {
          return schema.eq;
        }
        var s = '';
        var minLength = schema.minLength != null ? schema.minLength : 0;
        var maxLength = schema.maxLength != null ? schema.maxLength : 32;
        if (typeof schema.pattern === 'string' && typeof _formatSample[schema.pattern] === 'function') {
          return _formatSample[schema.pattern](minLength, maxLength);
        }
  
        var l = schema.exactLength != null ? schema.exactLength : _rand.int(minLength, maxLength);
        for (var i = 0; i < l; i++) {
          s += _rand.char(32, 126);
        }
        return s;
      },
      number: function (schema) {
        if (schema.eq != null) {
          return schema.eq;
        }
        var limit = _getLimits(schema);
        var n = _rand.float(limit.min, limit.max);
        if (schema.ne != null) {
          var ne = _typeIs.array(schema.ne) ? schema.ne : [schema.ne];
          while (ne.indexOf(n) !== -1) {
            n = _rand.float(limit.min, limit.max);
          }
        }
        return n;
      },
      integer: function (schema) {
        if (schema.eq != null) {
          return schema.eq;
        }
        var limit = _getLimits(schema);
        var n = _rand.int(limit.min, limit.max);
        if (schema.ne != null) {
          var ne = _typeIs.array(schema.ne) ? schema.ne : [schema.ne];
          while (ne.indexOf(n) !== -1) {
            n = _rand.int(limit.min, limit.max);
          }
        }
        return n;
      },
      boolean: function (schema) {
        if (schema.eq != null) {
          return schema.eq;
        }
        return _rand.bool();
      },
      "null": function (schema) {
        return null;
      },
      date: function (schema) {
        if (schema.eq != null) {
          return schema.eq;
        }
        return new Date();
      },
      object: function (schema) {
        var o = {};
        var prop = schema.properties || {};
  
        for (var key in prop) {
          if (Object.prototype.hasOwnProperty.call(prop, key)) {
            if (prop[key].optional === true && _rand.bool() === true) {
              continue;
            }
            if (key !== '*') {
              o[key] = this.generate(prop[key]);
            }
            else {
              var rk = '__random_key_';
              var randomKey = rk + 0;
              var n = _rand.int(1, 9);
              for (var i = 1; i <= n; i++) {
                if (!(randomKey in prop)) {
                  o[randomKey] = this.generate(prop[key]);
                }
                randomKey = rk + i;
              }
            }
          }
        }
        return o;
      },
      array: function (schema) {
        var self = this;
        var items = schema.items || {};
        var minLength = schema.minLength != null ? schema.minLength : 0;
        var maxLength = schema.maxLength != null ? schema.maxLength : 16;
        var type;
        var candidate;
        var size;
        var i;
  
        if (_typeIs.array(items)) {
          size = items.length;
          if (schema.exactLength != null) {
            size = schema.exactLength;
          }
          else if (size < minLength) {
            size = minLength;
          }
          else if (size > maxLength) {
            size = maxLength;
          }
          candidate = new Array(size);
          type = null;
          for (i = 0; i < size; i++) {
            type = items[i].type || 'any';
            if (_typeIs.array(type)) {
              type = type[_rand.int(0, type.length - 1)];
            }
            candidate[i] = self[type](items[i]);
          }
        }
        else {
          size = schema.exactLength != null ? schema.exactLength : _rand.int(minLength, maxLength);
          candidate = new Array(size);
          type = items.type || 'any';
          if (_typeIs.array(type)) {
            type = type[_rand.int(0, type.length - 1)];
          }
          for (i = 0; i < size; i++) {
            candidate[i] = self[type](items);
          }
        }
        return candidate;
      },
      any: function (schema) {
        var fields = Object.keys(_typeGenerator);
        var i = fields[_rand.int(0, fields.length - 2)];
        return this[i](schema);
      }
    };
  
    // CandidateGenerator Class (Singleton) --------------------------------------
    function CandidateGenerator() {
      // Maybe extends Inspection class too ?
    }
  
    _extend(CandidateGenerator.prototype, _typeGenerator);
  
    var _instance = null;
    CandidateGenerator.instance = function () {
      if (!(_instance instanceof CandidateGenerator)) {
        _instance = new CandidateGenerator();
      }
      return _instance;
    };
  
    CandidateGenerator.prototype.generate = function (schema) {
      var type = schema.type || 'any';
      if (_typeIs.array(type)) {
        type = type[_rand.int(0, type.length - 1)];
      }
      return this[type](schema);
    };
  
  // Exports ---------------------------------------------------------------------
    var SchemaInspector = {};
  
    // if server-side (node.js) else client-side
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = SchemaInspector;
    }
    else {
      window.SchemaInspector = SchemaInspector;
    }
  
    SchemaInspector.newSanitization = function (schema, custom) {
      return new Sanitization(schema, custom);
    };
  
    SchemaInspector.newValidation = function (schema, custom) {
      return new Validation(schema, custom);
    };
  
    SchemaInspector.Validation = Validation;
    SchemaInspector.Sanitization = Sanitization;
  
    SchemaInspector.sanitize = function (schema, post, custom, callback) {
      if (arguments.length === 3 && typeof custom === 'function') {
        callback = custom;
        custom = null;
      }
      return new Sanitization(schema, custom).sanitize(post, callback);
    };
  
    SchemaInspector.validate = function (schema, candidate, custom, callback) {
      if (arguments.length === 3 && typeof custom === 'function') {
        callback = custom;
        custom = null;
      }
      return new Validation(schema, custom).validate(candidate, callback);
    };
  
    SchemaInspector.generate = function (schema, n) {
      if (typeof n === 'number') {
        var r = new Array(n);
        for (var i = 0; i < n; i++) {
          r[i] = CandidateGenerator.instance().generate(schema);
        }
        return r;
      }
      return CandidateGenerator.instance().generate(schema);
    };
  })();
  
  },{"async":97}],256:[function(require,module,exports){
  var Buffer = require('safe-buffer').Buffer
  
  // prototype class for hash functions
  function Hash (blockSize, finalSize) {
    this._block = Buffer.alloc(blockSize)
    this._finalSize = finalSize
    this._blockSize = blockSize
    this._len = 0
  }
  
  Hash.prototype.update = function (data, enc) {
    if (typeof data === 'string') {
      enc = enc || 'utf8'
      data = Buffer.from(data, enc)
    }
  
    var block = this._block
    var blockSize = this._blockSize
    var length = data.length
    var accum = this._len
  
    for (var offset = 0; offset < length;) {
      var assigned = accum % blockSize
      var remainder = Math.min(length - offset, blockSize - assigned)
  
      for (var i = 0; i < remainder; i++) {
        block[assigned + i] = data[offset + i]
      }
  
      accum += remainder
      offset += remainder
  
      if ((accum % blockSize) === 0) {
        this._update(block)
      }
    }
  
    this._len += length
    return this
  }
  
  Hash.prototype.digest = function (enc) {
    var rem = this._len % this._blockSize
  
    this._block[rem] = 0x80
  
    // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
    // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
    this._block.fill(0, rem + 1)
  
    if (rem >= this._finalSize) {
      this._update(this._block)
      this._block.fill(0)
    }
  
    var bits = this._len * 8
  
    // uint32
    if (bits <= 0xffffffff) {
      this._block.writeUInt32BE(bits, this._blockSize - 4)
  
    // uint64
    } else {
      var lowBits = (bits & 0xffffffff) >>> 0
      var highBits = (bits - lowBits) / 0x100000000
  
      this._block.writeUInt32BE(highBits, this._blockSize - 8)
      this._block.writeUInt32BE(lowBits, this._blockSize - 4)
    }
  
    this._update(this._block)
    var hash = this._hash()
  
    return enc ? hash.toString(enc) : hash
  }
  
  Hash.prototype._update = function () {
    throw new Error('_update must be implemented by subclass')
  }
  
  module.exports = Hash
  
  },{"safe-buffer":281}],257:[function(require,module,exports){
  var exports = module.exports = function SHA (algorithm) {
    algorithm = algorithm.toLowerCase()
  
    var Algorithm = exports[algorithm]
    if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')
  
    return new Algorithm()
  }
  
  exports.sha = require('./sha')
  exports.sha1 = require('./sha1')
  exports.sha224 = require('./sha224')
  exports.sha256 = require('./sha256')
  exports.sha384 = require('./sha384')
  exports.sha512 = require('./sha512')
  
  },{"./sha":258,"./sha1":259,"./sha224":260,"./sha256":261,"./sha384":262,"./sha512":263}],258:[function(require,module,exports){
  /*
   * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
   * in FIPS PUB 180-1
   * This source code is derived from sha1.js of the same repository.
   * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
   * operation was added.
   */
  
  var inherits = require('inherits')
  var Hash = require('./hash')
  var Buffer = require('safe-buffer').Buffer
  
  var K = [
    0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
  ]
  
  var W = new Array(80)
  
  function Sha () {
    this.init()
    this._w = W
  
    Hash.call(this, 64, 56)
  }
  
  inherits(Sha, Hash)
  
  Sha.prototype.init = function () {
    this._a = 0x67452301
    this._b = 0xefcdab89
    this._c = 0x98badcfe
    this._d = 0x10325476
    this._e = 0xc3d2e1f0
  
    return this
  }
  
  function rotl5 (num) {
    return (num << 5) | (num >>> 27)
  }
  
  function rotl30 (num) {
    return (num << 30) | (num >>> 2)
  }
  
  function ft (s, b, c, d) {
    if (s === 0) return (b & c) | ((~b) & d)
    if (s === 2) return (b & c) | (b & d) | (c & d)
    return b ^ c ^ d
  }
  
  Sha.prototype._update = function (M) {
    var W = this._w
  
    var a = this._a | 0
    var b = this._b | 0
    var c = this._c | 0
    var d = this._d | 0
    var e = this._e | 0
  
    for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
    for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]
  
    for (var j = 0; j < 80; ++j) {
      var s = ~~(j / 20)
      var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0
  
      e = d
      d = c
      c = rotl30(b)
      b = a
      a = t
    }
  
    this._a = (a + this._a) | 0
    this._b = (b + this._b) | 0
    this._c = (c + this._c) | 0
    this._d = (d + this._d) | 0
    this._e = (e + this._e) | 0
  }
  
  Sha.prototype._hash = function () {
    var H = Buffer.allocUnsafe(20)
  
    H.writeInt32BE(this._a | 0, 0)
    H.writeInt32BE(this._b | 0, 4)
    H.writeInt32BE(this._c | 0, 8)
    H.writeInt32BE(this._d | 0, 12)
    H.writeInt32BE(this._e | 0, 16)
  
    return H
  }
  
  module.exports = Sha
  
  },{"./hash":256,"inherits":280,"safe-buffer":281}],259:[function(require,module,exports){
  /*
   * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
   * in FIPS PUB 180-1
   * Version 2.1a Copyright Paul Johnston 2000 - 2002.
   * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
   * Distributed under the BSD License
   * See http://pajhome.org.uk/crypt/md5 for details.
   */
  
  var inherits = require('inherits')
  var Hash = require('./hash')
  var Buffer = require('safe-buffer').Buffer
  
  var K = [
    0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
  ]
  
  var W = new Array(80)
  
  function Sha1 () {
    this.init()
    this._w = W
  
    Hash.call(this, 64, 56)
  }
  
  inherits(Sha1, Hash)
  
  Sha1.prototype.init = function () {
    this._a = 0x67452301
    this._b = 0xefcdab89
    this._c = 0x98badcfe
    this._d = 0x10325476
    this._e = 0xc3d2e1f0
  
    return this
  }
  
  function rotl1 (num) {
    return (num << 1) | (num >>> 31)
  }
  
  function rotl5 (num) {
    return (num << 5) | (num >>> 27)
  }
  
  function rotl30 (num) {
    return (num << 30) | (num >>> 2)
  }
  
  function ft (s, b, c, d) {
    if (s === 0) return (b & c) | ((~b) & d)
    if (s === 2) return (b & c) | (b & d) | (c & d)
    return b ^ c ^ d
  }
  
  Sha1.prototype._update = function (M) {
    var W = this._w
  
    var a = this._a | 0
    var b = this._b | 0
    var c = this._c | 0
    var d = this._d | 0
    var e = this._e | 0
  
    for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
    for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])
  
    for (var j = 0; j < 80; ++j) {
      var s = ~~(j / 20)
      var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0
  
      e = d
      d = c
      c = rotl30(b)
      b = a
      a = t
    }
  
    this._a = (a + this._a) | 0
    this._b = (b + this._b) | 0
    this._c = (c + this._c) | 0
    this._d = (d + this._d) | 0
    this._e = (e + this._e) | 0
  }
  
  Sha1.prototype._hash = function () {
    var H = Buffer.allocUnsafe(20)
  
    H.writeInt32BE(this._a | 0, 0)
    H.writeInt32BE(this._b | 0, 4)
    H.writeInt32BE(this._c | 0, 8)
    H.writeInt32BE(this._d | 0, 12)
    H.writeInt32BE(this._e | 0, 16)
  
    return H
  }
  
  module.exports = Sha1
  
  },{"./hash":256,"inherits":280,"safe-buffer":281}],260:[function(require,module,exports){
  /**
   * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
   * in FIPS 180-2
   * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
   * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
   *
   */
  
  var inherits = require('inherits')
  var Sha256 = require('./sha256')
  var Hash = require('./hash')
  var Buffer = require('safe-buffer').Buffer
  
  var W = new Array(64)
  
  function Sha224 () {
    this.init()
  
    this._w = W // new Array(64)
  
    Hash.call(this, 64, 56)
  }
  
  inherits(Sha224, Sha256)
  
  Sha224.prototype.init = function () {
    this._a = 0xc1059ed8
    this._b = 0x367cd507
    this._c = 0x3070dd17
    this._d = 0xf70e5939
    this._e = 0xffc00b31
    this._f = 0x68581511
    this._g = 0x64f98fa7
    this._h = 0xbefa4fa4
  
    return this
  }
  
  Sha224.prototype._hash = function () {
    var H = Buffer.allocUnsafe(28)
  
    H.writeInt32BE(this._a, 0)
    H.writeInt32BE(this._b, 4)
    H.writeInt32BE(this._c, 8)
    H.writeInt32BE(this._d, 12)
    H.writeInt32BE(this._e, 16)
    H.writeInt32BE(this._f, 20)
    H.writeInt32BE(this._g, 24)
  
    return H
  }
  
  module.exports = Sha224
  
  },{"./hash":256,"./sha256":261,"inherits":280,"safe-buffer":281}],261:[function(require,module,exports){
  /**
   * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
   * in FIPS 180-2
   * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
   * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
   *
   */
  
  var inherits = require('inherits')
  var Hash = require('./hash')
  var Buffer = require('safe-buffer').Buffer
  
  var K = [
    0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
    0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
    0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
    0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
    0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
    0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
    0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
    0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
    0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
    0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
    0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
    0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
    0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
    0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
    0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
    0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
  ]
  
  var W = new Array(64)
  
  function Sha256 () {
    this.init()
  
    this._w = W // new Array(64)
  
    Hash.call(this, 64, 56)
  }
  
  inherits(Sha256, Hash)
  
  Sha256.prototype.init = function () {
    this._a = 0x6a09e667
    this._b = 0xbb67ae85
    this._c = 0x3c6ef372
    this._d = 0xa54ff53a
    this._e = 0x510e527f
    this._f = 0x9b05688c
    this._g = 0x1f83d9ab
    this._h = 0x5be0cd19
  
    return this
  }
  
  function ch (x, y, z) {
    return z ^ (x & (y ^ z))
  }
  
  function maj (x, y, z) {
    return (x & y) | (z & (x | y))
  }
  
  function sigma0 (x) {
    return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
  }
  
  function sigma1 (x) {
    return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
  }
  
  function gamma0 (x) {
    return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
  }
  
  function gamma1 (x) {
    return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
  }
  
  Sha256.prototype._update = function (M) {
    var W = this._w
  
    var a = this._a | 0
    var b = this._b | 0
    var c = this._c | 0
    var d = this._d | 0
    var e = this._e | 0
    var f = this._f | 0
    var g = this._g | 0
    var h = this._h | 0
  
    for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
    for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0
  
    for (var j = 0; j < 64; ++j) {
      var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
      var T2 = (sigma0(a) + maj(a, b, c)) | 0
  
      h = g
      g = f
      f = e
      e = (d + T1) | 0
      d = c
      c = b
      b = a
      a = (T1 + T2) | 0
    }
  
    this._a = (a + this._a) | 0
    this._b = (b + this._b) | 0
    this._c = (c + this._c) | 0
    this._d = (d + this._d) | 0
    this._e = (e + this._e) | 0
    this._f = (f + this._f) | 0
    this._g = (g + this._g) | 0
    this._h = (h + this._h) | 0
  }
  
  Sha256.prototype._hash = function () {
    var H = Buffer.allocUnsafe(32)
  
    H.writeInt32BE(this._a, 0)
    H.writeInt32BE(this._b, 4)
    H.writeInt32BE(this._c, 8)
    H.writeInt32BE(this._d, 12)
    H.writeInt32BE(this._e, 16)
    H.writeInt32BE(this._f, 20)
    H.writeInt32BE(this._g, 24)
    H.writeInt32BE(this._h, 28)
  
    return H
  }
  
  module.exports = Sha256
  
  },{"./hash":256,"inherits":280,"safe-buffer":281}],262:[function(require,module,exports){
  var inherits = require('inherits')
  var SHA512 = require('./sha512')
  var Hash = require('./hash')
  var Buffer = require('safe-buffer').Buffer
  
  var W = new Array(160)
  
  function Sha384 () {
    this.init()
    this._w = W
  
    Hash.call(this, 128, 112)
  }
  
  inherits(Sha384, SHA512)
  
  Sha384.prototype.init = function () {
    this._ah = 0xcbbb9d5d
    this._bh = 0x629a292a
    this._ch = 0x9159015a
    this._dh = 0x152fecd8
    this._eh = 0x67332667
    this._fh = 0x8eb44a87
    this._gh = 0xdb0c2e0d
    this._hh = 0x47b5481d
  
    this._al = 0xc1059ed8
    this._bl = 0x367cd507
    this._cl = 0x3070dd17
    this._dl = 0xf70e5939
    this._el = 0xffc00b31
    this._fl = 0x68581511
    this._gl = 0x64f98fa7
    this._hl = 0xbefa4fa4
  
    return this
  }
  
  Sha384.prototype._hash = function () {
    var H = Buffer.allocUnsafe(48)
  
    function writeInt64BE (h, l, offset) {
      H.writeInt32BE(h, offset)
      H.writeInt32BE(l, offset + 4)
    }
  
    writeInt64BE(this._ah, this._al, 0)
    writeInt64BE(this._bh, this._bl, 8)
    writeInt64BE(this._ch, this._cl, 16)
    writeInt64BE(this._dh, this._dl, 24)
    writeInt64BE(this._eh, this._el, 32)
    writeInt64BE(this._fh, this._fl, 40)
  
    return H
  }
  
  module.exports = Sha384
  
  },{"./hash":256,"./sha512":263,"inherits":280,"safe-buffer":281}],263:[function(require,module,exports){
  var inherits = require('inherits')
  var Hash = require('./hash')
  var Buffer = require('safe-buffer').Buffer
  
  var K = [
    0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
    0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
    0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
    0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
    0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
    0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
    0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
    0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
    0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
    0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
    0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
    0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
    0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
    0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
    0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
    0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
    0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
    0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
    0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
    0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
    0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
    0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
    0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
    0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
    0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
    0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
    0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
    0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
    0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
    0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
    0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
    0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
    0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
    0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
    0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
    0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
    0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
    0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
    0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
    0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
  ]
  
  var W = new Array(160)
  
  function Sha512 () {
    this.init()
    this._w = W
  
    Hash.call(this, 128, 112)
  }
  
  inherits(Sha512, Hash)
  
  Sha512.prototype.init = function () {
    this._ah = 0x6a09e667
    this._bh = 0xbb67ae85
    this._ch = 0x3c6ef372
    this._dh = 0xa54ff53a
    this._eh = 0x510e527f
    this._fh = 0x9b05688c
    this._gh = 0x1f83d9ab
    this._hh = 0x5be0cd19
  
    this._al = 0xf3bcc908
    this._bl = 0x84caa73b
    this._cl = 0xfe94f82b
    this._dl = 0x5f1d36f1
    this._el = 0xade682d1
    this._fl = 0x2b3e6c1f
    this._gl = 0xfb41bd6b
    this._hl = 0x137e2179
  
    return this
  }
  
  function Ch (x, y, z) {
    return z ^ (x & (y ^ z))
  }
  
  function maj (x, y, z) {
    return (x & y) | (z & (x | y))
  }
  
  function sigma0 (x, xl) {
    return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
  }
  
  function sigma1 (x, xl) {
    return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
  }
  
  function Gamma0 (x, xl) {
    return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
  }
  
  function Gamma0l (x, xl) {
    return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
  }
  
  function Gamma1 (x, xl) {
    return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
  }
  
  function Gamma1l (x, xl) {
    return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
  }
  
  function getCarry (a, b) {
    return (a >>> 0) < (b >>> 0) ? 1 : 0
  }
  
  Sha512.prototype._update = function (M) {
    var W = this._w
  
    var ah = this._ah | 0
    var bh = this._bh | 0
    var ch = this._ch | 0
    var dh = this._dh | 0
    var eh = this._eh | 0
    var fh = this._fh | 0
    var gh = this._gh | 0
    var hh = this._hh | 0
  
    var al = this._al | 0
    var bl = this._bl | 0
    var cl = this._cl | 0
    var dl = this._dl | 0
    var el = this._el | 0
    var fl = this._fl | 0
    var gl = this._gl | 0
    var hl = this._hl | 0
  
    for (var i = 0; i < 32; i += 2) {
      W[i] = M.readInt32BE(i * 4)
      W[i + 1] = M.readInt32BE(i * 4 + 4)
    }
    for (; i < 160; i += 2) {
      var xh = W[i - 15 * 2]
      var xl = W[i - 15 * 2 + 1]
      var gamma0 = Gamma0(xh, xl)
      var gamma0l = Gamma0l(xl, xh)
  
      xh = W[i - 2 * 2]
      xl = W[i - 2 * 2 + 1]
      var gamma1 = Gamma1(xh, xl)
      var gamma1l = Gamma1l(xl, xh)
  
      // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
      var Wi7h = W[i - 7 * 2]
      var Wi7l = W[i - 7 * 2 + 1]
  
      var Wi16h = W[i - 16 * 2]
      var Wi16l = W[i - 16 * 2 + 1]
  
      var Wil = (gamma0l + Wi7l) | 0
      var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
      Wil = (Wil + gamma1l) | 0
      Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
      Wil = (Wil + Wi16l) | 0
      Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0
  
      W[i] = Wih
      W[i + 1] = Wil
    }
  
    for (var j = 0; j < 160; j += 2) {
      Wih = W[j]
      Wil = W[j + 1]
  
      var majh = maj(ah, bh, ch)
      var majl = maj(al, bl, cl)
  
      var sigma0h = sigma0(ah, al)
      var sigma0l = sigma0(al, ah)
      var sigma1h = sigma1(eh, el)
      var sigma1l = sigma1(el, eh)
  
      // t1 = h + sigma1 + ch + K[j] + W[j]
      var Kih = K[j]
      var Kil = K[j + 1]
  
      var chh = Ch(eh, fh, gh)
      var chl = Ch(el, fl, gl)
  
      var t1l = (hl + sigma1l) | 0
      var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
      t1l = (t1l + chl) | 0
      t1h = (t1h + chh + getCarry(t1l, chl)) | 0
      t1l = (t1l + Kil) | 0
      t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
      t1l = (t1l + Wil) | 0
      t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0
  
      // t2 = sigma0 + maj
      var t2l = (sigma0l + majl) | 0
      var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0
  
      hh = gh
      hl = gl
      gh = fh
      gl = fl
      fh = eh
      fl = el
      el = (dl + t1l) | 0
      eh = (dh + t1h + getCarry(el, dl)) | 0
      dh = ch
      dl = cl
      ch = bh
      cl = bl
      bh = ah
      bl = al
      al = (t1l + t2l) | 0
      ah = (t1h + t2h + getCarry(al, t1l)) | 0
    }
  
    this._al = (this._al + al) | 0
    this._bl = (this._bl + bl) | 0
    this._cl = (this._cl + cl) | 0
    this._dl = (this._dl + dl) | 0
    this._el = (this._el + el) | 0
    this._fl = (this._fl + fl) | 0
    this._gl = (this._gl + gl) | 0
    this._hl = (this._hl + hl) | 0
  
    this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
    this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
    this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
    this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
    this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
    this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
    this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
    this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
  }
  
  Sha512.prototype._hash = function () {
    var H = Buffer.allocUnsafe(64)
  
    function writeInt64BE (h, l, offset) {
      H.writeInt32BE(h, offset)
      H.writeInt32BE(l, offset + 4)
    }
  
    writeInt64BE(this._ah, this._al, 0)
    writeInt64BE(this._bh, this._bl, 8)
    writeInt64BE(this._ch, this._cl, 16)
    writeInt64BE(this._dh, this._dl, 24)
    writeInt64BE(this._eh, this._el, 32)
    writeInt64BE(this._fh, this._fl, 40)
    writeInt64BE(this._gh, this._gl, 48)
    writeInt64BE(this._hh, this._hl, 56)
  
    return H
  }
  
  module.exports = Sha512
  
  },{"./hash":256,"inherits":280,"safe-buffer":281}],264:[function(require,module,exports){
  'use strict';
  
  module.exports = (string, separator) => {
    if (!(typeof string === 'string' && typeof separator === 'string')) {
      throw new TypeError('Expected the arguments to be of type `string`');
    }
  
    if (separator === '') {
      return [string];
    }
  
    const separatorIndex = string.indexOf(separator);
  
    if (separatorIndex === -1) {
      return [string];
    }
  
    return [
      string.slice(0, separatorIndex),
      string.slice(separatorIndex + separator.length)
    ];
  };
  
  },{}],265:[function(require,module,exports){
  'use strict';
  module.exports = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);
  
  },{}],266:[function(require,module,exports){
  (function (Buffer){
  const BN = require('bn.js')
  const EC = require('elliptic').ec
  const secp256k1 = new EC('secp256k1')
  const deterministicGenerateK = require('./rfc6979')
  
  const ZERO32 = Buffer.alloc(32, 0)
  const EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex')
  const EC_P = Buffer.from('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f', 'hex')
  
  const n = secp256k1.curve.n
  const nDiv2 = n.shrn(1)
  const G = secp256k1.curve.g
  
  const THROW_BAD_PRIVATE = 'Expected Private'
  const THROW_BAD_POINT = 'Expected Point'
  const THROW_BAD_TWEAK = 'Expected Tweak'
  const THROW_BAD_HASH = 'Expected Hash'
  const THROW_BAD_SIGNATURE = 'Expected Signature'
  const THROW_BAD_EXTRA_DATA = 'Expected Extra Data (32 bytes)'
  
  function isScalar (x) {
    return Buffer.isBuffer(x) && x.length === 32
  }
  
  function isOrderScalar (x) {
    if (!isScalar(x)) return false
    return x.compare(EC_GROUP_ORDER) < 0 // < G
  }
  
  function isPoint (p) {
    if (!Buffer.isBuffer(p)) return false
    if (p.length < 33) return false
  
    const t = p[0]
    const x = p.slice(1, 33)
    if (x.compare(ZERO32) === 0) return false
    if (x.compare(EC_P) >= 0) return false
    if ((t === 0x02 || t === 0x03) && p.length === 33) {
      try { decodeFrom(p) } catch (e) { return false } // TODO: temporary
      return true
    }
  
    const y = p.slice(33)
    if (y.compare(ZERO32) === 0) return false
    if (y.compare(EC_P) >= 0) return false
    if (t === 0x04 && p.length === 65) return true
    return false
  }
  
  function __isPointCompressed (p) {
    return p[0] !== 0x04
  }
  
  function isPointCompressed (p) {
    if (!isPoint(p)) return false
    return __isPointCompressed(p)
  }
  
  function isPrivate (x) {
    if (!isScalar(x)) return false
    return x.compare(ZERO32) > 0 && // > 0
      x.compare(EC_GROUP_ORDER) < 0 // < G
  }
  
  function isSignature (value) {
    const r = value.slice(0, 32)
    const s = value.slice(32, 64)
    return Buffer.isBuffer(value) && value.length === 64 &&
      r.compare(EC_GROUP_ORDER) < 0 &&
      s.compare(EC_GROUP_ORDER) < 0
  }
  
  function assumeCompression (value, pubkey) {
    if (value === undefined && pubkey !== undefined) return __isPointCompressed(pubkey)
    if (value === undefined) return true
    return value
  }
  
  function fromBuffer (d) { return new BN(d) }
  function toBuffer (d) { return d.toArrayLike(Buffer, 'be', 32) }
  function decodeFrom (P) { return secp256k1.curve.decodePoint(P) }
  function getEncoded (P, compressed) { return Buffer.from(P._encode(compressed)) }
  
  function pointAdd (pA, pB, __compressed) {
    if (!isPoint(pA)) throw new TypeError(THROW_BAD_POINT)
    if (!isPoint(pB)) throw new TypeError(THROW_BAD_POINT)
  
    const a = decodeFrom(pA)
    const b = decodeFrom(pB)
    const pp = a.add(b)
    if (pp.isInfinity()) return null
  
    const compressed = assumeCompression(__compressed, pA)
    return getEncoded(pp, compressed)
  }
  
  function pointAddScalar (p, tweak, __compressed) {
    if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)
    if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)
  
    const compressed = assumeCompression(__compressed, p)
    const pp = decodeFrom(p)
    if (tweak.compare(ZERO32) === 0) return getEncoded(pp, compressed)
  
    const tt = fromBuffer(tweak)
    const qq = G.mul(tt)
    const uu = pp.add(qq)
    if (uu.isInfinity()) return null
  
    return getEncoded(uu, compressed)
  }
  
  function pointCompress (p, compressed) {
    if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)
  
    const pp = decodeFrom(p)
    if (pp.isInfinity()) throw new TypeError(THROW_BAD_POINT)
  
    return getEncoded(pp, compressed)
  }
  
  function pointFromScalar (d, __compressed) {
    if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)
  
    const dd = fromBuffer(d)
    const pp = G.mul(dd)
    if (pp.isInfinity()) return null
  
    const compressed = assumeCompression(__compressed)
    return getEncoded(pp, compressed)
  }
  
  function pointMultiply (p, tweak, __compressed) {
    if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)
    if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)
  
    const compressed = assumeCompression(__compressed, p)
    const pp = decodeFrom(p)
    const tt = fromBuffer(tweak)
    const qq = pp.mul(tt)
    if (qq.isInfinity()) return null
  
    return getEncoded(qq, compressed)
  }
  
  function privateAdd (d, tweak) {
    if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)
    if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)
  
    const dd = fromBuffer(d)
    const tt = fromBuffer(tweak)
    const dt = toBuffer(dd.add(tt).umod(n))
    if (!isPrivate(dt)) return null
  
    return dt
  }
  
  function privateSub (d, tweak) {
    if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)
    if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)
  
    const dd = fromBuffer(d)
    const tt = fromBuffer(tweak)
    const dt = toBuffer(dd.sub(tt).umod(n))
    if (!isPrivate(dt)) return null
  
    return dt
  }
  
  function sign (hash, x) {
    return __sign(hash, x)
  }
  
  function signWithEntropy (hash, x, addData) {
    return __sign(hash, x, addData)
  }
  
  function __sign (hash, x, addData) {
    if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH)
    if (!isPrivate(x)) throw new TypeError(THROW_BAD_PRIVATE)
    if (addData !== undefined && !isScalar(addData)) throw new TypeError(THROW_BAD_EXTRA_DATA)
  
    const d = fromBuffer(x)
    const e = fromBuffer(hash)
  
    let r, s
    const checkSig = function (k) {
      const kI = fromBuffer(k)
      const Q = G.mul(kI)
  
      if (Q.isInfinity()) return false
  
      r = Q.x.umod(n)
      if (r.isZero() === 0) return false
  
      s = kI
        .invm(n)
        .mul(e.add(d.mul(r)))
        .umod(n)
      if (s.isZero() === 0) return false
  
      return true
    }
  
    deterministicGenerateK(hash, x, checkSig, isPrivate, addData)
  
    // enforce low S values, see bip62: 'low s values in signatures'
    if (s.cmp(nDiv2) > 0) {
      s = n.sub(s)
    }
  
    const buffer = Buffer.allocUnsafe(64)
    toBuffer(r).copy(buffer, 0)
    toBuffer(s).copy(buffer, 32)
    return buffer
  }
  
  function verify (hash, q, signature) {
    if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH)
    if (!isPoint(q)) throw new TypeError(THROW_BAD_POINT)
  
    // 1.4.1 Enforce r and s are both integers in the interval [1, n  1] (1, isSignature enforces '< n - 1')
    if (!isSignature(signature)) throw new TypeError(THROW_BAD_SIGNATURE)
  
    const Q = decodeFrom(q)
    const r = fromBuffer(signature.slice(0, 32))
    const s = fromBuffer(signature.slice(32, 64))
  
    // 1.4.1 Enforce r and s are both integers in the interval [1, n  1] (2, enforces '> 0')
    if (r.gtn(0) <= 0 /* || r.compareTo(n) >= 0 */) return false
    if (s.gtn(0) <= 0 /* || s.compareTo(n) >= 0 */) return false
  
    // 1.4.2 H = Hash(M), already done by the user
    // 1.4.3 e = H
    const e = fromBuffer(hash)
  
    // Compute s^-1
    const sInv = s.invm(n)
  
    // 1.4.4 Compute u1 = es^1 mod n
    //               u2 = rs^1 mod n
    const u1 = e.mul(sInv).umod(n)
    const u2 = r.mul(sInv).umod(n)
  
    // 1.4.5 Compute R = (xR, yR)
    //               R = u1G + u2Q
    const R = G.mulAdd(u1, Q, u2)
  
    // 1.4.5 (cont.) Enforce R is not at infinity
    if (R.isInfinity()) return false
  
    // 1.4.6 Convert the field element R.x to an integer
    const xR = R.x
  
    // 1.4.7 Set v = xR mod n
    const v = xR.umod(n)
  
    // 1.4.8 If v = r, output "valid", and if v != r, output "invalid"
    return v.eq(r)
  }
  
  module.exports = {
    isPoint,
    isPointCompressed,
    isPrivate,
    pointAdd,
    pointAddScalar,
    pointCompress,
    pointFromScalar,
    pointMultiply,
    privateAdd,
    privateSub,
    sign,
    signWithEntropy,
    verify
  }
  
  }).call(this,require("buffer").Buffer)
  },{"./rfc6979":267,"bn.js":187,"buffer":3,"elliptic":201}],267:[function(require,module,exports){
  (function (Buffer){
  const createHmac = require('create-hmac')
  
  const ONE1 = Buffer.alloc(1, 1)
  const ZERO1 = Buffer.alloc(1, 0)
  
  // https://tools.ietf.org/html/rfc6979#section-3.2
  function deterministicGenerateK (hash, x, checkSig, isPrivate, extraEntropy) {
    // Step A, ignored as hash already provided
    // Step B
    // Step C
    let k = Buffer.alloc(32, 0)
    let v = Buffer.alloc(32, 1)
  
    // Step D
    k = createHmac('sha256', k)
      .update(v)
      .update(ZERO1)
      .update(x)
      .update(hash)
      .update(extraEntropy || '')
      .digest()
  
    // Step E
    v = createHmac('sha256', k).update(v).digest()
  
    // Step F
    k = createHmac('sha256', k)
      .update(v)
      .update(ONE1)
      .update(x)
      .update(hash)
      .update(extraEntropy || '')
      .digest()
  
    // Step G
    v = createHmac('sha256', k).update(v).digest()
  
    // Step H1/H2a, ignored as tlen === qlen (256 bit)
    // Step H2b
    v = createHmac('sha256', k).update(v).digest()
  
    let T = v
  
    // Step H3, repeat until T is within the interval [1, n - 1] and is suitable for ECDSA
    while (!isPrivate(T) || !checkSig(T)) {
      k = createHmac('sha256', k)
        .update(v)
        .update(ZERO1)
        .digest()
  
      v = createHmac('sha256', k).update(v).digest()
  
      // Step H1/H2a, again, ignored as tlen === qlen (256 bit)
      // Step H2b again
      v = createHmac('sha256', k).update(v).digest()
      T = v
    }
  
    return T
  }
  
  module.exports = deterministicGenerateK
  
  }).call(this,require("buffer").Buffer)
  },{"buffer":3,"create-hmac":195}],268:[function(require,module,exports){
  (function (global){
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  /* global global, define, System, Reflect, Promise */
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  (function (factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function (exports) { factory(createExporter(root, createExporter(exports))); });
      }
      else if (typeof module === "object" && typeof module.exports === "object") {
          factory(createExporter(root, createExporter(module.exports)));
      }
      else {
          factory(createExporter(root));
      }
      function createExporter(exports, previous) {
          if (exports !== root) {
              if (typeof Object.create === "function") {
                  Object.defineProperty(exports, "__esModule", { value: true });
              }
              else {
                  exports.__esModule = true;
              }
          }
          return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
      }
  })
  (function (exporter) {
      var extendStatics = Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
          function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
  
      __extends = function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  
      __assign = Object.assign || function (t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
      };
  
      __rest = function (s, e) {
          var t = {};
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
              for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                  if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                      t[p[i]] = s[p[i]];
              }
          return t;
      };
  
      __decorate = function (decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
          else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
  
      __param = function (paramIndex, decorator) {
          return function (target, key) { decorator(target, key, paramIndex); }
      };
  
      __metadata = function (metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
      };
  
      __awaiter = function (thisArg, _arguments, P, generator) {
          function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
          return new (P || (P = Promise))(function (resolve, reject) {
              function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
              function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
              function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
              step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
      };
  
      __generator = function (thisArg, body) {
          var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
          function verb(n) { return function (v) { return step([n, v]); }; }
          function step(op) {
              if (f) throw new TypeError("Generator is already executing.");
              while (_) try {
                  if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                  if (y = 0, t) op = [op[0] & 2, t.value];
                  switch (op[0]) {
                      case 0: case 1: t = op; break;
                      case 4: _.label++; return { value: op[1], done: false };
                      case 5: _.label++; y = op[1]; op = [0]; continue;
                      case 7: op = _.ops.pop(); _.trys.pop(); continue;
                      default:
                          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                          if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                          if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                          if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                          if (t[2]) _.ops.pop();
                          _.trys.pop(); continue;
                  }
                  op = body.call(thisArg, _);
              } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
              if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
          }
      };
  
      __exportStar = function (m, exports) {
          for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
      };
  
      __values = function (o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m) return m.call(o);
          if (o && typeof o.length === "number") return {
              next: function () {
                  if (o && i >= o.length) o = void 0;
                  return { value: o && o[i++], done: !o };
              }
          };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
  
      __read = function (o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m) return o;
          var i = m.call(o), r, ar = [], e;
          try {
              while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
          }
          catch (error) { e = { error: error }; }
          finally {
              try {
                  if (r && !r.done && (m = i["return"])) m.call(i);
              }
              finally { if (e) throw e.error; }
          }
          return ar;
      };
  
      __spread = function () {
          for (var ar = [], i = 0; i < arguments.length; i++)
              ar = ar.concat(__read(arguments[i]));
          return ar;
      };
  
      __spreadArrays = function () {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
              for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                  r[k] = a[j];
          return r;
      };
  
      __await = function (v) {
          return this instanceof __await ? (this.v = v, this) : new __await(v);
      };
  
      __asyncGenerator = function (thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
          function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
          function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
          function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
          function fulfill(value) { resume("next", value); }
          function reject(value) { resume("throw", value); }
          function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
      };
  
      __asyncDelegator = function (o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
          function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
      };
  
      __asyncValues = function (o) {
          if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
          function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
          function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
      };
  
      __makeTemplateObject = function (cooked, raw) {
          if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
          return cooked;
      };
  
      __importStar = function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
          result["default"] = mod;
          return result;
      };
  
      __importDefault = function (mod) {
          return (mod && mod.__esModule) ? mod : { "default": mod };
      };
  
      __classPrivateFieldGet = function (receiver, privateMap) {
          if (!privateMap.has(receiver)) {
              throw new TypeError("attempted to get private field on non-instance");
          }
          return privateMap.get(receiver);
      };
  
      __classPrivateFieldSet = function (receiver, privateMap, value) {
          if (!privateMap.has(receiver)) {
              throw new TypeError("attempted to set private field on non-instance");
          }
          privateMap.set(receiver, value);
          return value;
      }
  
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
  });
  
  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{}],269:[function(require,module,exports){
  var native = require('./native')
  
  function getTypeName (fn) {
    return fn.name || fn.toString().match(/function (.*?)\s*\(/)[1]
  }
  
  function getValueTypeName (value) {
    return native.Nil(value) ? '' : getTypeName(value.constructor)
  }
  
  function getValue (value) {
    if (native.Function(value)) return ''
    if (native.String(value)) return JSON.stringify(value)
    if (value && native.Object(value)) return ''
    return value
  }
  
  function captureStackTrace (e, t) {
    if (Error.captureStackTrace) {
      Error.captureStackTrace(e, t)
    }
  }
  
  function tfJSON (type) {
    if (native.Function(type)) return type.toJSON ? type.toJSON() : getTypeName(type)
    if (native.Array(type)) return 'Array'
    if (type && native.Object(type)) return 'Object'
  
    return type !== undefined ? type : ''
  }
  
  function tfErrorString (type, value, valueTypeName) {
    var valueJson = getValue(value)
  
    return 'Expected ' + tfJSON(type) + ', got' +
      (valueTypeName !== '' ? ' ' + valueTypeName : '') +
      (valueJson !== '' ? ' ' + valueJson : '')
  }
  
  function TfTypeError (type, value, valueTypeName) {
    valueTypeName = valueTypeName || getValueTypeName(value)
    this.message = tfErrorString(type, value, valueTypeName)
  
    captureStackTrace(this, TfTypeError)
    this.__type = type
    this.__value = value
    this.__valueTypeName = valueTypeName
  }
  
  TfTypeError.prototype = Object.create(Error.prototype)
  TfTypeError.prototype.constructor = TfTypeError
  
  function tfPropertyErrorString (type, label, name, value, valueTypeName) {
    var description = '" of type '
    if (label === 'key') description = '" with key type '
  
    return tfErrorString('property "' + tfJSON(name) + description + tfJSON(type), value, valueTypeName)
  }
  
  function TfPropertyTypeError (type, property, label, value, valueTypeName) {
    if (type) {
      valueTypeName = valueTypeName || getValueTypeName(value)
      this.message = tfPropertyErrorString(type, label, property, value, valueTypeName)
    } else {
      this.message = 'Unexpected property "' + property + '"'
    }
  
    captureStackTrace(this, TfTypeError)
    this.__label = label
    this.__property = property
    this.__type = type
    this.__value = value
    this.__valueTypeName = valueTypeName
  }
  
  TfPropertyTypeError.prototype = Object.create(Error.prototype)
  TfPropertyTypeError.prototype.constructor = TfTypeError
  
  function tfCustomError (expected, actual) {
    return new TfTypeError(expected, {}, actual)
  }
  
  function tfSubError (e, property, label) {
    // sub child?
    if (e instanceof TfPropertyTypeError) {
      property = property + '.' + e.__property
  
      e = new TfPropertyTypeError(
        e.__type, property, e.__label, e.__value, e.__valueTypeName
      )
  
    // child?
    } else if (e instanceof TfTypeError) {
      e = new TfPropertyTypeError(
        e.__type, property, label, e.__value, e.__valueTypeName
      )
    }
  
    captureStackTrace(e)
    return e
  }
  
  module.exports = {
    TfTypeError: TfTypeError,
    TfPropertyTypeError: TfPropertyTypeError,
    tfCustomError: tfCustomError,
    tfSubError: tfSubError,
    tfJSON: tfJSON,
    getValueTypeName: getValueTypeName
  }
  
  },{"./native":272}],270:[function(require,module,exports){
  (function (Buffer){
  var NATIVE = require('./native')
  var ERRORS = require('./errors')
  
  function _Buffer (value) {
    return Buffer.isBuffer(value)
  }
  
  function Hex (value) {
    return typeof value === 'string' && /^([0-9a-f]{2})+$/i.test(value)
  }
  
  function _LengthN (type, length) {
    var name = type.toJSON()
  
    function Length (value) {
      if (!type(value)) return false
      if (value.length === length) return true
  
      throw ERRORS.tfCustomError(name + '(Length: ' + length + ')', name + '(Length: ' + value.length + ')')
    }
    Length.toJSON = function () { return name }
  
    return Length
  }
  
  var _ArrayN = _LengthN.bind(null, NATIVE.Array)
  var _BufferN = _LengthN.bind(null, _Buffer)
  var _HexN = _LengthN.bind(null, Hex)
  var _StringN = _LengthN.bind(null, NATIVE.String)
  
  function Range (a, b, f) {
    f = f || NATIVE.Number
    function _range (value, strict) {
      return f(value, strict) && (value > a) && (value < b)
    }
    _range.toJSON = function () {
      return `${f.toJSON()} between [${a}, ${b}]`
    }
    return _range
  }
  
  var INT53_MAX = Math.pow(2, 53) - 1
  
  function Finite (value) {
    return typeof value === 'number' && isFinite(value)
  }
  function Int8 (value) { return ((value << 24) >> 24) === value }
  function Int16 (value) { return ((value << 16) >> 16) === value }
  function Int32 (value) { return (value | 0) === value }
  function Int53 (value) {
    return typeof value === 'number' &&
      value >= -INT53_MAX &&
      value <= INT53_MAX &&
      Math.floor(value) === value
  }
  function UInt8 (value) { return (value & 0xff) === value }
  function UInt16 (value) { return (value & 0xffff) === value }
  function UInt32 (value) { return (value >>> 0) === value }
  function UInt53 (value) {
    return typeof value === 'number' &&
      value >= 0 &&
      value <= INT53_MAX &&
      Math.floor(value) === value
  }
  
  var types = {
    ArrayN: _ArrayN,
    Buffer: _Buffer,
    BufferN: _BufferN,
    Finite: Finite,
    Hex: Hex,
    HexN: _HexN,
    Int8: Int8,
    Int16: Int16,
    Int32: Int32,
    Int53: Int53,
    Range: Range,
    StringN: _StringN,
    UInt8: UInt8,
    UInt16: UInt16,
    UInt32: UInt32,
    UInt53: UInt53
  }
  
  for (var typeName in types) {
    types[typeName].toJSON = function (t) {
      return t
    }.bind(null, typeName)
  }
  
  module.exports = types
  
  }).call(this,{"isBuffer":require("C:/Users/Johnny/AppData/Roaming/npm/node_modules/browserify/node_modules/is-buffer/index.js")})
  },{"./errors":269,"./native":272,"C:/Users/Johnny/AppData/Roaming/npm/node_modules/browserify/node_modules/is-buffer/index.js":8}],271:[function(require,module,exports){
  var ERRORS = require('./errors')
  var NATIVE = require('./native')
  
  // short-hand
  var tfJSON = ERRORS.tfJSON
  var TfTypeError = ERRORS.TfTypeError
  var TfPropertyTypeError = ERRORS.TfPropertyTypeError
  var tfSubError = ERRORS.tfSubError
  var getValueTypeName = ERRORS.getValueTypeName
  
  var TYPES = {
    arrayOf: function arrayOf (type, options) {
      type = compile(type)
      options = options || {}
  
      function _arrayOf (array, strict) {
        if (!NATIVE.Array(array)) return false
        if (NATIVE.Nil(array)) return false
        if (options.minLength !== undefined && array.length < options.minLength) return false
        if (options.maxLength !== undefined && array.length > options.maxLength) return false
        if (options.length !== undefined && array.length !== options.length) return false
  
        return array.every(function (value, i) {
          try {
            return typeforce(type, value, strict)
          } catch (e) {
            throw tfSubError(e, i)
          }
        })
      }
      _arrayOf.toJSON = function () {
        var str = '[' + tfJSON(type) + ']'
        if (options.length !== undefined) {
          str += '{' + options.length + '}'
        } else if (options.minLength !== undefined || options.maxLength !== undefined) {
          str += '{' +
            (options.minLength === undefined ? 0 : options.minLength) + ',' +
            (options.maxLength === undefined ? Infinity : options.maxLength) + '}'
        }
        return str
      }
  
      return _arrayOf
    },
  
    maybe: function maybe (type) {
      type = compile(type)
  
      function _maybe (value, strict) {
        return NATIVE.Nil(value) || type(value, strict, maybe)
      }
      _maybe.toJSON = function () { return '?' + tfJSON(type) }
  
      return _maybe
    },
  
    map: function map (propertyType, propertyKeyType) {
      propertyType = compile(propertyType)
      if (propertyKeyType) propertyKeyType = compile(propertyKeyType)
  
      function _map (value, strict) {
        if (!NATIVE.Object(value)) return false
        if (NATIVE.Nil(value)) return false
  
        for (var propertyName in value) {
          try {
            if (propertyKeyType) {
              typeforce(propertyKeyType, propertyName, strict)
            }
          } catch (e) {
            throw tfSubError(e, propertyName, 'key')
          }
  
          try {
            var propertyValue = value[propertyName]
            typeforce(propertyType, propertyValue, strict)
          } catch (e) {
            throw tfSubError(e, propertyName)
          }
        }
  
        return true
      }
  
      if (propertyKeyType) {
        _map.toJSON = function () {
          return '{' + tfJSON(propertyKeyType) + ': ' + tfJSON(propertyType) + '}'
        }
      } else {
        _map.toJSON = function () { return '{' + tfJSON(propertyType) + '}' }
      }
  
      return _map
    },
  
    object: function object (uncompiled) {
      var type = {}
  
      for (var typePropertyName in uncompiled) {
        type[typePropertyName] = compile(uncompiled[typePropertyName])
      }
  
      function _object (value, strict) {
        if (!NATIVE.Object(value)) return false
        if (NATIVE.Nil(value)) return false
  
        var propertyName
  
        try {
          for (propertyName in type) {
            var propertyType = type[propertyName]
            var propertyValue = value[propertyName]
  
            typeforce(propertyType, propertyValue, strict)
          }
        } catch (e) {
          throw tfSubError(e, propertyName)
        }
  
        if (strict) {
          for (propertyName in value) {
            if (type[propertyName]) continue
  
            throw new TfPropertyTypeError(undefined, propertyName)
          }
        }
  
        return true
      }
      _object.toJSON = function () { return tfJSON(type) }
  
      return _object
    },
  
    anyOf: function anyOf () {
      var types = [].slice.call(arguments).map(compile)
  
      function _anyOf (value, strict) {
        return types.some(function (type) {
          try {
            return typeforce(type, value, strict)
          } catch (e) {
            return false
          }
        })
      }
      _anyOf.toJSON = function () { return types.map(tfJSON).join('|') }
  
      return _anyOf
    },
  
    allOf: function allOf () {
      var types = [].slice.call(arguments).map(compile)
  
      function _allOf (value, strict) {
        return types.every(function (type) {
          try {
            return typeforce(type, value, strict)
          } catch (e) {
            return false
          }
        })
      }
      _allOf.toJSON = function () { return types.map(tfJSON).join(' & ') }
  
      return _allOf
    },
  
    quacksLike: function quacksLike (type) {
      function _quacksLike (value) {
        return type === getValueTypeName(value)
      }
      _quacksLike.toJSON = function () { return type }
  
      return _quacksLike
    },
  
    tuple: function tuple () {
      var types = [].slice.call(arguments).map(compile)
  
      function _tuple (values, strict) {
        if (NATIVE.Nil(values)) return false
        if (NATIVE.Nil(values.length)) return false
        if (strict && (values.length !== types.length)) return false
  
        return types.every(function (type, i) {
          try {
            return typeforce(type, values[i], strict)
          } catch (e) {
            throw tfSubError(e, i)
          }
        })
      }
      _tuple.toJSON = function () { return '(' + types.map(tfJSON).join(', ') + ')' }
  
      return _tuple
    },
  
    value: function value (expected) {
      function _value (actual) {
        return actual === expected
      }
      _value.toJSON = function () { return expected }
  
      return _value
    }
  }
  
  // TODO: deprecate
  TYPES.oneOf = TYPES.anyOf
  
  function compile (type) {
    if (NATIVE.String(type)) {
      if (type[0] === '?') return TYPES.maybe(type.slice(1))
  
      return NATIVE[type] || TYPES.quacksLike(type)
    } else if (type && NATIVE.Object(type)) {
      if (NATIVE.Array(type)) {
        if (type.length !== 1) throw new TypeError('Expected compile() parameter of type Array of length 1')
        return TYPES.arrayOf(type[0])
      }
  
      return TYPES.object(type)
    } else if (NATIVE.Function(type)) {
      return type
    }
  
    return TYPES.value(type)
  }
  
  function typeforce (type, value, strict, surrogate) {
    if (NATIVE.Function(type)) {
      if (type(value, strict)) return true
  
      throw new TfTypeError(surrogate || type, value)
    }
  
    // JIT
    return typeforce(compile(type), value, strict)
  }
  
  // assign types to typeforce function
  for (var typeName in NATIVE) {
    typeforce[typeName] = NATIVE[typeName]
  }
  
  for (typeName in TYPES) {
    typeforce[typeName] = TYPES[typeName]
  }
  
  var EXTRA = require('./extra')
  for (typeName in EXTRA) {
    typeforce[typeName] = EXTRA[typeName]
  }
  
  typeforce.compile = compile
  typeforce.TfTypeError = TfTypeError
  typeforce.TfPropertyTypeError = TfPropertyTypeError
  
  module.exports = typeforce
  
  },{"./errors":269,"./extra":270,"./native":272}],272:[function(require,module,exports){
  var types = {
    Array: function (value) { return value !== null && value !== undefined && value.constructor === Array },
    Boolean: function (value) { return typeof value === 'boolean' },
    Function: function (value) { return typeof value === 'function' },
    Nil: function (value) { return value === undefined || value === null },
    Number: function (value) { return typeof value === 'number' },
    Object: function (value) { return typeof value === 'object' },
    String: function (value) { return typeof value === 'string' },
    '': function () { return true }
  }
  
  // TODO: deprecate
  types.Null = types.Nil
  
  for (var typeName in types) {
    types[typeName].toJSON = function (t) {
      return t
    }.bind(null, typeName)
  }
  
  module.exports = types
  
  },{}],273:[function(require,module,exports){
  'use strict'
  var Buffer = require('safe-buffer').Buffer
  
  // Number.MAX_SAFE_INTEGER
  var MAX_SAFE_INTEGER = 9007199254740991
  
  function checkUInt53 (n) {
    if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0) throw new RangeError('value out of range')
  }
  
  function encode (number, buffer, offset) {
    checkUInt53(number)
  
    if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(number))
    if (!Buffer.isBuffer(buffer)) throw new TypeError('buffer must be a Buffer instance')
    if (!offset) offset = 0
  
    // 8 bit
    if (number < 0xfd) {
      buffer.writeUInt8(number, offset)
      encode.bytes = 1
  
    // 16 bit
    } else if (number <= 0xffff) {
      buffer.writeUInt8(0xfd, offset)
      buffer.writeUInt16LE(number, offset + 1)
      encode.bytes = 3
  
    // 32 bit
    } else if (number <= 0xffffffff) {
      buffer.writeUInt8(0xfe, offset)
      buffer.writeUInt32LE(number, offset + 1)
      encode.bytes = 5
  
    // 64 bit
    } else {
      buffer.writeUInt8(0xff, offset)
      buffer.writeUInt32LE(number >>> 0, offset + 1)
      buffer.writeUInt32LE((number / 0x100000000) | 0, offset + 5)
      encode.bytes = 9
    }
  
    return buffer
  }
  
  function decode (buffer, offset) {
    if (!Buffer.isBuffer(buffer)) throw new TypeError('buffer must be a Buffer instance')
    if (!offset) offset = 0
  
    var first = buffer.readUInt8(offset)
  
    // 8 bit
    if (first < 0xfd) {
      decode.bytes = 1
      return first
  
    // 16 bit
    } else if (first === 0xfd) {
      decode.bytes = 3
      return buffer.readUInt16LE(offset + 1)
  
    // 32 bit
    } else if (first === 0xfe) {
      decode.bytes = 5
      return buffer.readUInt32LE(offset + 1)
  
    // 64 bit
    } else {
      decode.bytes = 9
      var lo = buffer.readUInt32LE(offset + 1)
      var hi = buffer.readUInt32LE(offset + 5)
      var number = hi * 0x0100000000 + lo
      checkUInt53(number)
  
      return number
    }
  }
  
  function encodingLength (number) {
    checkUInt53(number)
  
    return (
      number < 0xfd ? 1
        : number <= 0xffff ? 3
          : number <= 0xffffffff ? 5
            : 9
    )
  }
  
  module.exports = { encode: encode, decode: decode, encodingLength: encodingLength }
  
  },{"safe-buffer":281}],274:[function(require,module,exports){
  (function (Buffer){
  var bs58check = require('bs58check')
  
  function decodeRaw (buffer, version) {
    // check version only if defined
    if (version !== undefined && buffer[0] !== version) throw new Error('Invalid network version')
  
    // uncompressed
    if (buffer.length === 33) {
      return {
        version: buffer[0],
        privateKey: buffer.slice(1, 33),
        compressed: false
      }
    }
  
    // invalid length
    if (buffer.length !== 34) throw new Error('Invalid WIF length')
  
    // invalid compression flag
    if (buffer[33] !== 0x01) throw new Error('Invalid compression flag')
  
    return {
      version: buffer[0],
      privateKey: buffer.slice(1, 33),
      compressed: true
    }
  }
  
  function encodeRaw (version, privateKey, compressed) {
    var result = new Buffer(compressed ? 34 : 33)
  
    result.writeUInt8(version, 0)
    privateKey.copy(result, 1)
  
    if (compressed) {
      result[33] = 0x01
    }
  
    return result
  }
  
  function decode (string, version) {
    return decodeRaw(bs58check.decode(string), version)
  }
  
  function encode (version, privateKey, compressed) {
    if (typeof version === 'number') return bs58check.encode(encodeRaw(version, privateKey, compressed))
  
    return bs58check.encode(
      encodeRaw(
        version.version,
        version.privateKey,
        version.compressed
      )
    )
  }
  
  module.exports = {
    decode: decode,
    decodeRaw: decodeRaw,
    encode: encode,
    encodeRaw: encodeRaw
  }
  
  }).call(this,require("buffer").Buffer)
  },{"bs58check":191,"buffer":3}],275:[function(require,module,exports){
  'use strict';
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "makeZoneFile", {
    enumerable: true,
    get: function () {
      return _makeZoneFile.makeZoneFile;
    }
  });
  Object.defineProperty(exports, "parseZoneFile", {
    enumerable: true,
    get: function () {
      return _parseZoneFile.parseZoneFile;
    }
  });
  Object.defineProperty(exports, "ZoneFile", {
    enumerable: true,
    get: function () {
      return _zoneFile.ZoneFile;
    }
  });
  
  var _makeZoneFile = require("./makeZoneFile");
  
  var _parseZoneFile = require("./parseZoneFile");
  
  var _zoneFile = require("./zoneFile");
  },{"./makeZoneFile":276,"./parseZoneFile":277,"./zoneFile":278}],276:[function(require,module,exports){
  'use strict';
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.makeZoneFile = makeZoneFile;
  
  var _zoneFileTemplate = require("./zoneFileTemplate");
  
  function makeZoneFile(jsonZoneFile, template = (0, _zoneFileTemplate.getZoneFileTemplate)()) {
    template = processOrigin(jsonZoneFile['$origin'], template);
    template = processTTL(jsonZoneFile['$ttl'], template);
    template = processSOA(jsonZoneFile['soa'], template);
    template = processNS(jsonZoneFile['ns'], template);
    template = processA(jsonZoneFile['a'], template);
    template = processAAAA(jsonZoneFile['aaaa'], template);
    template = processCNAME(jsonZoneFile['cname'], template);
    template = processMX(jsonZoneFile['mx'], template);
    template = processPTR(jsonZoneFile['ptr'], template);
    template = processTXT(jsonZoneFile['txt'], template);
    template = processSRV(jsonZoneFile['srv'], template);
    template = processSPF(jsonZoneFile['spf'], template);
    template = processURI(jsonZoneFile['uri'], template);
    template = processValues(jsonZoneFile, template);
    return template.replace(/\n{2,}/gim, '\n\n');
  }
  
  ;
  
  function processOrigin(data, template) {
    let ret = '';
  
    if (typeof data !== 'undefined') {
      ret += '$ORIGIN ' + data;
    }
  
    return template.replace('{$origin}', ret);
  }
  
  ;
  
  function processTTL(data, template) {
    let ret = '';
  
    if (typeof data !== 'undefined') {
      ret += '$TTL ' + data;
    }
  
    return template.replace('{$ttl}', ret);
  }
  
  ;
  
  function processSOA(data, template) {
    let ret = template;
  
    if (typeof data !== 'undefined') {
      data.name = data.name || '@';
      data.ttl = data.ttl || '';
  
      for (const key in data) {
        const value = data[key];
        ret = ret.replace('{' + key + '}', value + '\t');
      }
    }
  
    return ret;
  }
  
  ;
  
  function processNS(data, template) {
    let ret = '';
  
    if (data) {
      for (const record of data) {
        ret += (record.name || '@') + '\t';
        if (record.ttl) ret += record.ttl + '\t';
        ret += 'IN\tNS\t' + record.host + '\n';
      }
    }
  
    return template.replace('{ns}', ret);
  }
  
  ;
  
  function processA(data, template) {
    let ret = '';
  
    if (data) {
      for (const record of data) {
        ret += (record.name || '@') + '\t';
        if (record.ttl) ret += record.ttl + '\t';
        ret += 'IN\tA\t' + record.ip + '\n';
      }
    }
  
    return template.replace('{a}', ret);
  }
  
  ;
  
  function processAAAA(data, template) {
    let ret = '';
  
    if (data) {
      for (const record of data) {
        ret += (record.name || '@') + '\t';
        if (record.ttl) ret += record.ttl + '\t';
        ret += 'IN\tAAAA\t' + record.ip + '\n';
      }
    }
  
    return template.replace('{aaaa}', ret);
  }
  
  ;
  
  function processCNAME(data, template) {
    let ret = '';
  
    if (data) {
      for (const record of data) {
        ret += (record.name || '@') + '\t';
        if (record.ttl) ret += record.ttl + '\t';
        ret += 'IN\tCNAME\t' + record.alias + '\n';
      }
    }
  
    return template.replace('{cname}', ret);
  }
  
  ;
  
  function processMX(data, template) {
    let ret = '';
  
    if (data) {
      for (const record of data) {
        ret += (record.name || '@') + '\t';
        if (record.ttl) ret += record.ttl + '\t';
        ret += 'IN\tMX\t' + record.preference + '\t' + record.host + '\n';
      }
    }
  
    return template.replace('{mx}', ret);
  }
  
  ;
  
  function processPTR(data, template) {
    let ret = '';
  
    if (data) {
      for (const record of data) {
        ret += (record.name || '@') + '\t';
        if (record.ttl) ret += record.ttl + '\t';
        ret += 'IN\tPTR\t' + record.host + '\n';
      }
    }
  
    return template.replace('{ptr}', ret);
  }
  
  ;
  
  function processTXT(data, template) {
    let ret = '';
  
    if (data) {
      for (const record of data) {
        ret += (record.name || '@') + '\t';
        if (record.ttl) ret += record.ttl + '\t';
        ret += 'IN\tTXT\t';
        const txtData = record.txt;
  
        if (typeof txtData === 'string') {
          ret += '"' + txtData + '"';
        } else if (txtData instanceof Array) {
          ret += txtData.map(function (datum) {
            return '"' + datum + '"';
          }).join(' ');
        }
  
        ret += '\n';
      }
    }
  
    return template.replace('{txt}', ret);
  }
  
  ;
  
  function processSRV(data, template) {
    let ret = '';
  
    if (data) {
      for (const record of data) {
        ret += (record.name || '@') + '\t';
        if (record.ttl) ret += record.ttl + '\t';
        ret += 'IN\tSRV\t' + record.priority + '\t';
        ret += record.weight + '\t';
        ret += record.port + '\t';
        ret += record.target + '\n';
      }
    }
  
    return template.replace('{srv}', ret);
  }
  
  ;
  
  function processSPF(data, template) {
    let ret = '';
  
    if (data) {
      for (const record of data) {
        ret += (record.name || '@') + '\t';
        if (record.ttl) ret += record.ttl + '\t';
        ret += 'IN\tSPF\t' + record.data + '\n';
      }
    }
  
    return template.replace('{spf}', ret);
  }
  
  ;
  
  function processURI(data, template) {
    let ret = '';
  
    if (data) {
      for (const record of data) {
        ret += (record.name || '@') + '\t';
        if (record.ttl) ret += record.ttl + '\t';
        ret += 'IN\tURI\t' + record.priority + '\t';
        ret += record.weight + '\t';
        ret += '"' + record.target + '"\n';
      }
    }
  
    return template.replace('{uri}', ret);
  }
  
  ;
  
  function processValues(jsonZoneFile, template) {
    template = template.replace('{zone}', jsonZoneFile['$origin'] || (jsonZoneFile['soa'] ? jsonZoneFile['soa']['name'] : false) || '');
    template = template.replace('{datetime}', new Date().toISOString());
    const time = Math.round(Date.now() / 1000);
    return template.replace('{time}', `${time}`);
  }
  
  ;
  },{"./zoneFileTemplate":279}],277:[function(require,module,exports){
  'use strict';
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.parseZoneFile = parseZoneFile;
  
  function parseZoneFile(text) {
    text = removeComments(text);
    text = flatten(text);
    return parseRRs(text);
  }
  
  ;
  
  function removeComments(text) {
    const re = /(^|[^\\]);.*/g;
    return text.replace(re, function (m, g1) {
      return g1 ? g1 : ''; // if g1 is set/matched, re-insert it, else remove
    });
  }
  
  function flatten(text) {
    const captured = [];
    const re = /\([\s\S]*?\)/gim;
    let match = re.exec(text);
  
    while (match !== null) {
      const replacement = match[0].replace(/\s+/gm, ' ');
      captured.push({
        match,
        replacement
      }); // captured Text, index, input
  
      match = re.exec(text);
    }
  
    const arrText = text.split('');
  
    for (const cur of captured) {
      const {
        match,
        replacement
      } = cur;
      arrText.splice(match.index, match[0].length, replacement);
    }
  
    return arrText.join('').replace(/\(|\)/gim, ' ');
  }
  
  function parseRRs(text) {
    const ret = {};
    const rrs = text.split('\n');
  
    for (const rr of rrs) {
      if (!rr || !rr.trim()) {
        continue;
      }
  
      const uRR = rr.toUpperCase();
  
      if (/\s+TXT\s+/.test(uRR)) {
        ret.txt = ret.txt || [];
        ret.txt.push(parseTXT(rr));
      } else if (uRR.indexOf('$ORIGIN') === 0) {
        ret.$origin = rr.split(/\s+/g)[1];
      } else if (uRR.indexOf('$TTL') === 0) {
        ret.$ttl = parseInt(rr.split(/\s+/g)[1], 10);
      } else if (/\s+SOA\s+/.test(uRR)) {
        ret.soa = parseSOA(rr);
      } else if (/\s+NS\s+/.test(uRR)) {
        ret.ns = ret.ns || [];
        ret.ns.push(parseNS(rr));
      } else if (/\s+A\s+/.test(uRR)) {
        ret.a = ret.a || [];
        ret.a.push(parseA(rr, ret.a));
      } else if (/\s+AAAA\s+/.test(uRR)) {
        ret.aaaa = ret.aaaa || [];
        ret.aaaa.push(parseAAAA(rr));
      } else if (/\s+CNAME\s+/.test(uRR)) {
        ret.cname = ret.cname || [];
        ret.cname.push(parseCNAME(rr));
      } else if (/\s+MX\s+/.test(uRR)) {
        ret.mx = ret.mx || [];
        ret.mx.push(parseMX(rr));
      } else if (/\s+PTR\s+/.test(uRR)) {
        ret.ptr = ret.ptr || [];
        ret.ptr.push(parsePTR(rr, ret.ptr, ret.$origin));
      } else if (/\s+SRV\s+/.test(uRR)) {
        ret.srv = ret.srv || [];
        ret.srv.push(parseSRV(rr));
      } else if (/\s+SPF\s+/.test(uRR)) {
        ret.spf = ret.spf || [];
        ret.spf.push(parseSPF(rr));
      } else if (/\s+URI\s+/.test(uRR)) {
        ret.uri = ret.uri || [];
        ret.uri.push(parseURI(rr));
      }
    }
  
    return ret;
  }
  
  function parseSOA(rr) {
    const soa = {};
    const rrTokens = rr.trim().split(/\s+/g);
    const l = rrTokens.length;
    soa.name = rrTokens[0];
    soa.minimum = parseInt(rrTokens[l - 1], 10);
    soa.expire = parseInt(rrTokens[l - 2], 10);
    soa.retry = parseInt(rrTokens[l - 3], 10);
    soa.refresh = parseInt(rrTokens[l - 4], 10);
    soa.serial = parseInt(rrTokens[l - 5], 10);
    soa.rname = rrTokens[l - 6];
    soa.mname = rrTokens[l - 7];
    if (!isNaN(rrTokens[1])) soa.ttl = parseInt(rrTokens[1], 10);
    return soa;
  }
  
  function parseNS(rr) {
    const rrTokens = rr.trim().split(/\s+/g);
    const l = rrTokens.length;
    const result = {
      name: rrTokens[0],
      host: rrTokens[l - 1]
    };
    if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
    return result;
  }
  
  function parseA(rr, recordsSoFar) {
    const rrTokens = rr.trim().split(/\s+/g);
    const urrTokens = rr.trim().toUpperCase().split(/\s+/g);
    const l = rrTokens.length;
    const result = {
      name: rrTokens[0],
      ip: rrTokens[l - 1]
    };
  
    if (urrTokens.lastIndexOf('A') === 0) {
      if (recordsSoFar.length) {
        result.name = recordsSoFar[recordsSoFar.length - 1].name;
      } else {
        result.name = '@';
      }
    }
  
    if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
    return result;
  }
  
  function parseAAAA(rr) {
    const rrTokens = rr.trim().split(/\s+/g);
    const l = rrTokens.length;
    const result = {
      name: rrTokens[0],
      ip: rrTokens[l - 1]
    };
    if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
    return result;
  }
  
  function parseCNAME(rr) {
    const rrTokens = rr.trim().split(/\s+/g);
    const l = rrTokens.length;
    const result = {
      name: rrTokens[0],
      alias: rrTokens[l - 1]
    };
    if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
    return result;
  }
  
  function parseMX(rr) {
    const rrTokens = rr.trim().split(/\s+/g);
    const l = rrTokens.length;
    const result = {
      name: rrTokens[0],
      preference: parseInt(rrTokens[l - 2], 10),
      host: rrTokens[l - 1]
    };
    if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
    return result;
  }
  
  function parseTXT(rr) {
    const rrTokens = rr.trim().match(/[^\s\"']+|\"[^\"]*\"|'[^']*'/g);
    if (!rrTokens) throw new Error('Failure to tokenize TXT record');
    const l = rrTokens.length;
    const indexTXT = rrTokens.indexOf('TXT');
  
    function stripText(txt) {
      if (txt.indexOf('\"') > -1) {
        txt = txt.split('\"')[1];
      }
  
      if (txt.indexOf('"') > -1) {
        txt = txt.split('"')[1];
      }
  
      return txt;
    }
  
    let tokenTxt;
  
    if (l - indexTXT - 1 > 1) {
      tokenTxt = rrTokens.slice(indexTXT + 1).map(stripText);
    } else {
      tokenTxt = stripText(rrTokens[l - 1]);
    }
  
    const result = {
      name: rrTokens[0],
      txt: tokenTxt
    };
    if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
    return result;
  }
  
  function parsePTR(rr, recordsSoFar, currentOrigin) {
    const rrTokens = rr.trim().split(/\s+/g);
    const urrTokens = rr.trim().toUpperCase().split(/\s+/g);
  
    if (urrTokens.lastIndexOf('PTR') === 0 && recordsSoFar[recordsSoFar.length - 1]) {
      rrTokens.unshift(recordsSoFar[recordsSoFar.length - 1].name);
    }
  
    const l = rrTokens.length;
    const result = {
      name: rrTokens[0],
      fullname: rrTokens[0] + '.' + currentOrigin,
      host: rrTokens[l - 1]
    };
    if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
    return result;
  }
  
  function parseSRV(rr) {
    const rrTokens = rr.trim().split(/\s+/g);
    const l = rrTokens.length;
    const result = {
      name: rrTokens[0],
      target: rrTokens[l - 1],
      priority: parseInt(rrTokens[l - 4], 10),
      weight: parseInt(rrTokens[l - 3], 10),
      port: parseInt(rrTokens[l - 2], 10)
    };
    if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
    return result;
  }
  
  function parseSPF(rr) {
    const rrTokens = rr.trim().split(/\s+/g);
    const result = {
      name: rrTokens[0],
      data: ''
    };
    let l = rrTokens.length;
  
    while (l-- > 4) {
      result.data = rrTokens[l] + ' ' + result.data.trim();
    }
  
    if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
    return result;
  }
  
  function parseURI(rr) {
    const rrTokens = rr.trim().split(/\s+/g);
    const l = rrTokens.length;
    const result = {
      name: rrTokens[0],
      target: rrTokens[l - 1].replace(/"/g, ''),
      priority: parseInt(rrTokens[l - 3], 10),
      weight: parseInt(rrTokens[l - 2], 10)
    };
    if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
    return result;
  }
  },{}],278:[function(require,module,exports){
  "use strict";
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ZoneFile = void 0;
  
  var _makeZoneFile = require("./makeZoneFile");
  
  var _parseZoneFile = require("./parseZoneFile");
  
  class ZoneFile {
    constructor(zoneFile) {
      if (typeof zoneFile === 'object') {
        this.jsonZoneFile = JSON.parse(JSON.stringify(zoneFile));
      } else if (typeof zoneFile === 'string') {
        this.jsonZoneFile = (0, _parseZoneFile.parseZoneFile)(zoneFile);
      }
    }
  
    toJSON() {
      return this.jsonZoneFile;
    }
  
    toString() {
      return (0, _makeZoneFile.makeZoneFile)(this.toJSON());
    }
  
  }
  
  exports.ZoneFile = ZoneFile;
  },{"./makeZoneFile":276,"./parseZoneFile":277}],279:[function(require,module,exports){
  'use strict';
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getZoneFileTemplate = getZoneFileTemplate;
  
  function getZoneFileTemplate() {
    return '{$origin}\n\
  {$ttl}\n\
  \n\
  ; SOA Record\n\
  {name} {ttl}    IN  SOA {mname}{rname}(\n\
  {serial} ;serial\n\
  {refresh} ;refresh\n\
  {retry} ;retry\n\
  {expire} ;expire\n\
  {minimum} ;minimum ttl\n\
  )\n\
  \n\
  ; NS Records\n\
  {ns}\n\
  \n\
  ; MX Records\n\
  {mx}\n\
  \n\
  ; A Records\n\
  {a}\n\
  \n\
  ; AAAA Records\n\
  {aaaa}\n\
  \n\
  ; CNAME Records\n\
  {cname}\n\
  \n\
  ; PTR Records\n\
  {ptr}\n\
  \n\
  ; TXT Records\n\
  {txt}\n\
  \n\
  ; SRV Records\n\
  {srv}\n\
  \n\
  ; SPF Records\n\
  {spf}\n\
  \n\
  ; URI Records\n\
  {uri}\n\
  ';
  }
  },{}],280:[function(require,module,exports){
  if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    };
  } else {
    // old school shim for old browsers
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
  
  },{}],281:[function(require,module,exports){
  arguments[4][21][0].apply(exports,arguments)
  },{"buffer":3,"dup":21}]},{},[32]);
  